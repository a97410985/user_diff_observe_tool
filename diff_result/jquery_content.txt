diff --git a/a.js b/b.js
@@ -22,7 +22,6 @@ module.exports = function( grunt ) {
A blob:687b3215c92928c5ca3714822497b490d264af9f
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		nodeV17OrNewer = !/^v1[0246]\./.test( process.version ),
		isCi = process.env.GITHUB_ACTION,
		ciBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
diff --git a/a.js b/b.js
@@ -363,10 +362,6 @@ require( "load-grunt-tasks" )( grunt, {
A blob:687b3215c92928c5ca3714822497b490d264af9f
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt, {
		pattern: oldNode ? [ "grunt-*", "!grunt-eslint" ] : [ "grunt-*" ]
	} );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "print_old_node_message", ( ...args ) => {
		var task = args.join( ":" );
		grunt.log.writeln( "Old Node.js detected, running the task \"" + task + "\" skipped..." );
	} );

	grunt.registerTask( "print_jsdom_message", () => {
		grunt.log.writeln( "Node.js 17 or newer detected, skipping jsdom tests..." );
	} );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
diff --git a/a.js b/b.js
@@ -386,14 +381,10 @@ require( "load-grunt-tasks" )( grunt, {
A blob:687b3215c92928c5ca3714822497b490d264af9f
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt, {
		pattern: oldNode ? [ "grunt-*", "!grunt-eslint" ] : [ "grunt-*" ]
	} );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "print_old_node_message", ( ...args ) => {
		var task = args.join( ":" );
		grunt.log.writeln( "Old Node.js detected, running the task \"" + task + "\" skipped..." );
	} );

	grunt.registerTask( "print_jsdom_message", () => {
		grunt.log.writeln( "Node.js 17 or newer detected, skipping jsdom tests..." );
	} );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		runIfNewNode( "eslint:dev" ),
		runIfNewNode( "eslint:dist" )
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		runIfNewNode( "newer:eslint:dev" ),
		runIfNewNode( "newer:eslint:dist" )
	] );

	grunt.registerTask( "test:fast", runIfNewNode( "node_smoke_tests" ) );
	grunt.registerTask( "test:slow", [
		runIfNewNode( "promises_aplus_tests" ),

		// Support: Node.js 17+
		// jsdom fails to connect to the Karma server in Node 17+.
		// Until we figure out a fix, skip jsdom tests there.
		nodeV17OrNewer ? "print_jsdom_message" : runIfNewNode( "karma:jsdom" )
	] );

	grunt.registerTask( "test:prepare", [
		"npmcopy",
diff --git a/a.js b/b.js
@@ -27,7 +27,7 @@ function schedule() {
A blob:50b1a6ef01ec11c801586d94b6e37c32bed6ed7a
var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
diff --git a/a.js b/b.js
@@ -663,7 +663,6 @@ jQuery.fx.timer = function( timer ) {
A blob:50b1a6ef01ec11c801586d94b6e37c32bed6ed7a
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}
diff --git a/a.js b/b.js
@@ -5,7 +5,8 @@
A blob:4af1f7f983ba58f8e3ab152f42b0aa0413969b84
( function() {

// Can't test what ain't there
if ( !jQuery.fx ) {
	return;
}

var oldRaf = window.requestAnimationFrame,
	defaultPrefilter = jQuery.Animation.prefilters[ 0 ],
	defaultTweener = jQuery.Animation.tweeners[ "*" ][ 0 ],
	startTime = 505877050;

diff --git a/a.js b/b.js
@@ -15,17 +16,14 @@
A blob:4af1f7f983ba58f8e3ab152f42b0aa0413969b84
	startTime = 505877050;

// This module tests jQuery.Animation and the corresponding 1.8+ effects APIs
QUnit.module( "animation", {
	beforeEach: function() {
		this.sandbox = sinon.createSandbox();
		this.clock = this.sandbox.useFakeTimers( startTime );
		this._oldInterval = jQuery.fx.interval;
		window.requestAnimationFrame = null;
		jQuery.fx.step = {};
		jQuery.fx.interval = 10;
		jQuery.Animation.prefilters = [ defaultPrefilter ];
		jQuery.Animation.tweeners = { "*": [ defaultTweener ] };
	},
	afterEach: function() {
		this.sandbox.restore();
		jQuery.fx.stop();
		jQuery.fx.interval = this._oldInterval;
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );
diff --git a/a.js b/b.js
@@ -36,7 +34,7 @@ QUnit.test( "Animation( subject, props, opts ) - shape", function( assert ) {
A blob:4af1f7f983ba58f8e3ab152f42b0aa0413969b84
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );

QUnit.test( "Animation( subject, props, opts ) - shape", function( assert ) {
	assert.expect( 20 );

	var subject = { test: 0 },
		props = { test: 1 },
		opts = { queue: "fx", duration: 100 },
		animation = jQuery.Animation( subject, props, opts );

	assert.equal(
		animation.elem,
diff --git a/a.js b/b.js
@@ -59,14 +57,14 @@ QUnit.test( "Animation( subject, props, opts ) - shape", function( assert ) {
A blob:4af1f7f983ba58f8e3ab152f42b0aa0413969b84
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );

QUnit.test( "Animation( subject, props, opts ) - shape", function( assert ) {
	assert.expect( 20 );

	var subject = { test: 0 },
		props = { test: 1 },
		opts = { queue: "fx", duration: 100 },
		animation = jQuery.Animation( subject, props, opts );

	assert.equal(
		animation.elem,
		subject,
		".elem is set to the exact object passed"
	);
	assert.equal(
		animation.originalOptions,
		opts,
		".originalOptions is set to options passed"
	);
	assert.equal(
		animation.originalProperties,
		props,
		".originalProperties is set to props passed"
	);

	assert.notEqual( animation.props, props, ".props is not the original however" );
	assert.deepEqual( animation.props, props, ".props is a copy of the original" );

	assert.deepEqual( animation.opts, {
		duration: 100,
		queue: "fx",
		specialEasing: { test: undefined },
		easing: jQuery.easing._default
	}, ".options is filled with default easing and specialEasing" );

	assert.equal( animation.startTime, startTime, "startTime was set" );
	assert.equal( animation.duration, 100, ".duration is set" );

	assert.equal( animation.tweens.length, 1, ".tweens has one Tween" );
	assert.equal( typeof animation.tweens[ 0 ].run, "function", "which has a .run function" );

diff --git a/a.js b/b.js
@@ -85,7 +83,7 @@ QUnit.test( "Animation( subject, props, opts ) - shape", function( assert ) {
A blob:4af1f7f983ba58f8e3ab152f42b0aa0413969b84
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );

QUnit.test( "Animation( subject, props, opts ) - shape", function( assert ) {
	assert.expect( 20 );

	var subject = { test: 0 },
		props = { test: 1 },
		opts = { queue: "fx", duration: 100 },
		animation = jQuery.Animation( subject, props, opts );

	assert.equal(
		animation.elem,
		subject,
		".elem is set to the exact object passed"
	);
	assert.equal(
		animation.originalOptions,
		opts,
		".originalOptions is set to options passed"
	);
	assert.equal(
		animation.originalProperties,
		props,
		".originalProperties is set to props passed"
	);

	assert.notEqual( animation.props, props, ".props is not the original however" );
	assert.deepEqual( animation.props, props, ".props is a copy of the original" );

	assert.deepEqual( animation.opts, {
		duration: 100,
		queue: "fx",
		specialEasing: { test: undefined },
		easing: jQuery.easing._default
	}, ".options is filled with default easing and specialEasing" );

	assert.equal( animation.startTime, startTime, "startTime was set" );
	assert.equal( animation.duration, 100, ".duration is set" );

	assert.equal( animation.tweens.length, 1, ".tweens has one Tween" );
	assert.equal( typeof animation.tweens[ 0 ].run, "function", "which has a .run function" );

	assert.equal( typeof animation.createTween, "function", ".createTween is a function" );
	assert.equal( typeof animation.stop, "function", ".stop is a function" );

	assert.equal( typeof animation.done, "function", ".done is a function" );
	assert.equal( typeof animation.fail, "function", ".fail is a function" );
	assert.equal( typeof animation.always, "function", ".always is a function" );
	assert.equal( typeof animation.progress, "function", ".progress is a function" );

	assert.equal( jQuery.timers.length, 1, "Added a timers function" );
	assert.equal( jQuery.timers[ 0 ].elem, subject, "...with .elem as the subject" );
	assert.equal( jQuery.timers[ 0 ].anim, animation, "...with .anim as the animation" );
	assert.equal( jQuery.timers[ 0 ].queue, opts.queue, "...with .queue" );

	// Cleanup after ourselves by ticking to the end
	this.clock.tick( 100 );
} );

QUnit.test( "Animation.prefilter( fn ) - calls prefilter after defaultPrefilter",
	function( assert ) {
diff --git a/a.js b/b.js
@@ -5,7 +5,8 @@
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
( function() {

// Can't test what ain't there
if ( !jQuery.fx ) {
	return;
}

var oldRaf = window.requestAnimationFrame,
	hideOptions = {
		inline: function() { jQuery.style( this, "display", "none" ); },
		cascade: function() { this.className = "hidden"; }
	};
diff --git a/a.js b/b.js
@@ -15,15 +16,12 @@
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		cascade: function() { this.className = "hidden"; }
	};

QUnit.module( "effects", {
	beforeEach: function() {
		this.sandbox = sinon.createSandbox();
		this.clock = this.sandbox.useFakeTimers( 505877050 );
		this._oldInterval = jQuery.fx.interval;
		window.requestAnimationFrame = null;
		jQuery.fx.step = {};
		jQuery.fx.interval = 10;
	},
	afterEach: function() {
		this.sandbox.restore();
		jQuery.fx.stop();
		jQuery.fx.interval = this._oldInterval;
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );
diff --git a/a.js b/b.js
@@ -160,9 +158,9 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See trac-14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
diff --git a/a.js b/b.js
@@ -172,7 +170,7 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See trac-14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
					expected === "inline" ? "inline-block" : expected,
					"Correct display type during animation for " + selector
				);
			} );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal( jQuery( this ).css( "display" ), expected,
					"Correct display type after animation for " + selector );
diff --git a/a.js b/b.js
@@ -203,17 +201,17 @@ QUnit.test( "Persist correct display value - " + type + " hidden", function( ass
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );
} );

// Supports trac-7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='show-tests'><span style='position:absolute;'>foo</span></div>" )
			.appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		var $span = jQuery( "#show-tests span" ),
			displayNone = $span.css( "display" ),
			display = "",
			clock = this.clock;

		$span.show();

		display = $span.css( "display" );

		$span.hide();

		$span.fadeIn( 100, function() {
			assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
			$span.fadeOut( 100, function() {
				assert.equal( $span.css( "display" ), displayNone, "Expecting display: " + displayNone );
				$span.fadeIn( 100, function() {
					assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );

	// Support: IE 11+
	// IE doesn't support Shadow DOM.
diff --git a/a.js b/b.js
@@ -235,17 +233,17 @@ QUnit.test( "Persist correct display value - " + type + " hidden", function( ass
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );
} );

// Supports trac-7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='show-tests'><span style='position:absolute;'>foo</span></div>" )
			.appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		var $span = jQuery( "#show-tests span" ),
			displayNone = $span.css( "display" ),
			display = "",
			clock = this.clock;

		$span.show();

		display = $span.css( "display" );

		$span.hide();

		$span.fadeIn( 100, function() {
			assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
			$span.fadeOut( 100, function() {
				assert.equal( $span.css( "display" ), displayNone, "Expecting display: " + displayNone );
				$span.fadeIn( 100, function() {
					assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );

	// Support: IE 11+
	// IE doesn't support Shadow DOM.
	QUnit.testUnlessIE(
		"Persist correct display value - " + type + " hidden, shadow child", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );

		var shadowHost = document.querySelector( "#shadowHost" );
		var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
		shadowRoot.innerHTML = "<style>.hidden{display: none;}</style>" +
			"<span id='shadowChild' class='hidden'></span>";
		var shadowChild = shadowRoot.querySelector( "#shadowChild" );

		var $shadowChild = jQuery( shadowChild );
		var displayNone = "none";
		var display = "inline";
		var clock = this.clock;

		$shadowChild.fadeIn( 100, function() {
			assert.equal( $shadowChild.css( "display" ), display, "Expecting shadow display: " + display );
			$shadowChild.fadeOut( 100, function() {
				assert.equal( $shadowChild.css( "display" ), displayNone, "Expecting shadow display: " + displayNone );
				$shadowChild.fadeIn( 100, function() {
					assert.equal( $shadowChild.css( "display" ), display, "Expecting shadow display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );
} );

QUnit.test( "animate(Hash, Object, Function)", function( assert ) {
diff --git a/a.js b/b.js
@@ -284,7 +282,7 @@ QUnit.test( "animate relative values", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	jQuery( "#foo" ).animate( hash, 0, function() {
		assert.equal( hash.opacity, hashCopy.opacity, "Check if animate changed the hash parameter" );
	} );
} );

QUnit.test( "animate relative values", function( assert ) {

	var value = 40,
		clock = this.clock,
		bases = [ "%", "px", "em" ],
		adjustments = [ "px", "em" ],
		container = jQuery( "<div></div>" )
			.css( { position: "absolute", height: "50em", width: "50em" } ),
		animations = bases.length * adjustments.length;

	assert.expect( 2 * animations );

	jQuery.each( bases, function( _, baseUnit ) {
		jQuery.each( adjustments, function( _, adjustUnit ) {
			var base = value + baseUnit,
				adjust = { height: "+=2" + adjustUnit, width: "-=2" + adjustUnit },
				elem = jQuery( "<div></div>" )
					.appendTo( container.clone().appendTo( "#qunit-fixture" ) )
					.css( {
						position: "absolute",
						height: base,
						width: value + adjustUnit
					} ),
				baseScale = elem[ 0 ].offsetHeight / value,
				adjustScale = elem[ 0 ].offsetWidth / value;

			elem.css( "width", base ).animate( adjust, 100, function() {
				assert.equal( this.offsetHeight, value * baseScale + 2 * adjustScale,
					baseUnit + "+=" + adjustUnit );
				assert.equal( this.offsetWidth, value * baseScale - 2 * adjustScale,
					baseUnit + "-=" + adjustUnit );
diff --git a/a.js b/b.js
@@ -292,52 +290,52 @@ QUnit.test( "animate relative values", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	jQuery( "#foo" ).animate( hash, 0, function() {
		assert.equal( hash.opacity, hashCopy.opacity, "Check if animate changed the hash parameter" );
	} );
} );

QUnit.test( "animate relative values", function( assert ) {

	var value = 40,
		clock = this.clock,
		bases = [ "%", "px", "em" ],
		adjustments = [ "px", "em" ],
		container = jQuery( "<div></div>" )
			.css( { position: "absolute", height: "50em", width: "50em" } ),
		animations = bases.length * adjustments.length;

	assert.expect( 2 * animations );

	jQuery.each( bases, function( _, baseUnit ) {
		jQuery.each( adjustments, function( _, adjustUnit ) {
			var base = value + baseUnit,
				adjust = { height: "+=2" + adjustUnit, width: "-=2" + adjustUnit },
				elem = jQuery( "<div></div>" )
					.appendTo( container.clone().appendTo( "#qunit-fixture" ) )
					.css( {
						position: "absolute",
						height: base,
						width: value + adjustUnit
					} ),
				baseScale = elem[ 0 ].offsetHeight / value,
				adjustScale = elem[ 0 ].offsetWidth / value;

			elem.css( "width", base ).animate( adjust, 100, function() {
				assert.equal( this.offsetHeight, value * baseScale + 2 * adjustScale,
					baseUnit + "+=" + adjustUnit );
				assert.equal( this.offsetWidth, value * baseScale - 2 * adjustScale,
					baseUnit + "-=" + adjustUnit );

			} );

			clock.tick( 100 );
		} );
	} );
} );

QUnit.test( "animate negative height", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { height: -100 }, 100, function() {
		assert.equal( this.offsetHeight, 0, "Verify height." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative margin", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { "marginTop": -100 }, 100, function() {
		assert.equal( jQuery( this ).css( "marginTop" ), "-100px", "Verify margin." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative margin with px", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { marginTop: "-100px" }, 100, function() {
		assert.equal( jQuery( this ).css( "marginTop" ), "-100px", "Verify margin." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative padding", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { "paddingBottom": -100 }, 100, function() {
		assert.equal( jQuery( this ).css( "paddingBottom" ), "0px", "Verify paddingBottom." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate block as inline width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "#foo" ).css( { display: "inline", width: "", height: "" } ).animate( { width: 42, height: 42 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "inline-block", "inline-block was set on non-floated inline element when animating width/height" );
		assert.equal( this.offsetWidth, 42, "width was animated" );
		assert.equal( this.offsetHeight, 42, "height was animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate native inline width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -346,12 +344,12 @@ QUnit.test( "animate native inline width/height", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( this.offsetHeight, 42, "height was animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate native inline width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "#foo" ).css( { display: "", width: "", height: "" } )
		.append( "<span>text</span>" )
		.children( "span" )
			.animate( { width: 42, height: 42 }, 100, function() {
				assert.equal( jQuery( this ).css( "display" ), "inline-block", "inline-block was set on non-floated inline element when animating width/height" );
				assert.equal( this.offsetWidth, 42, "width was animated" );
				assert.equal( this.offsetHeight, 42, "height was animated" );
			} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -366,7 +364,7 @@ jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
		display: "block",
		width: 20,
		height: 20,
		paddingLeft: 60
	} ).animate( {
		width: 42,
		height: 42
	}, {
		duration: 100,
		step: function() {
			if ( jQuery( this ).width() > 42 ) {
				assert.ok( false, "width was incorrectly augmented during animation" );
			}
diff --git a/a.js b/b.js
@@ -378,16 +376,16 @@ jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
		display: "block",
		width: 20,
		height: 20,
		paddingLeft: 60
	} ).animate( {
		width: 42,
		height: 42
	}, {
		duration: 100,
		step: function() {
			if ( jQuery( this ).width() > 42 ) {
				assert.ok( false, "width was incorrectly augmented during animation" );
			}
		},
		complete: function() {
			assert.equal( jQuery( this ).css( "display" ), "block", "inline-block was not set on block element when animating width/height" );
			assert.equal( jQuery( this ).width(), 42, "width was animated" );
			assert.equal( jQuery( this ).height(), 42, "height was animated" );
		}
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table width/height", function( assert ) {
	assert.expect( 1 );

	jQuery( "#table" ).animate( { width: 42, height: 42 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table", "display mode is correct" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-row width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -397,12 +395,12 @@ QUnit.test( "animate table-row width/height", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( jQuery( this ).css( "display" ), "table", "display mode is correct" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-row width/height", function( assert ) {
	assert.expect( 3 );
	var tr = jQuery( "#table" )
			.attr( { "cellspacing": 0, "cellpadding": 0, "border": 0 } )
			.html( "<tr style='height:42px;'><td style='padding:0;'><div style='width:20px;height:20px;'></div></td></tr>" )
			.find( "tr" );

	tr.animate( { width: 10, height: 10 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table-row", "display mode is correct" );
		assert.equal( this.offsetWidth, 20, "width animated to shrink wrap point" );
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-cell width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -413,12 +411,12 @@ QUnit.test( "animate table-cell width/height", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-cell width/height", function( assert ) {
	assert.expect( 3 );

	var td = jQuery( "#table" )
			.attr( { "cellspacing": 0, "cellpadding": 0, "border": 0 } )
			.html( "<tr><td style='width:42px;height:42px;padding:0;'><div style='width:20px;height:20px;'></div></td></tr>" )
			.find( "td" );

	td.animate( { width: 10, height: 10 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table-cell", "display mode is correct" );
		assert.equal( this.offsetWidth, 20, "width animated to shrink wrap point" );
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate percentage(%) on width/height", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -427,46 +425,25 @@ QUnit.test( "animate percentage(%) on width/height", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate percentage(%) on width/height", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div style='position:absolute;top:-999px;left:-999px;width:60px;height:60px;'><div style='width:50%;height:50%;'></div></div>" )
		.appendTo( "#qunit-fixture" ).children( "div" );

	$div.animate( { width: "25%", height: "25%" }, 13, function() {
		var $this = jQuery( this );
		assert.equal( $this.css( "width" ), "15px", "Width was animated to 15px rather than 25px" );
		assert.equal( $this.css( "height" ), "15px", "Height was animated to 15px rather than 25px" );
	} );
	this.clock.tick( 20 );
} );

QUnit.test( "animate resets overflow-x and overflow-y when finished", function( assert ) {
	assert.expect( 2 );
	jQuery( "#foo" )
		.css( { display: "block", width: 20, height: 20, overflowX: "visible", overflowY: "auto" } )
		.animate( { width: 42, height: 42 }, 100, function() {
			assert.equal( this.style.overflowX, "visible", "overflow-x is visible" );
			assert.equal( this.style.overflowY, "auto", "overflow-y is auto" );
		} );
	this.clock.tick( 100 );
} );

/* // This test ends up being flaky depending upon the CPU load
QUnit.test("animate option (queue === false)", function( assert ) {
	var done = assert.async();
	assert.expect(1);

	var order = [];

	var $foo = jQuery("#foo");
	$foo.animate({width:"100px"}, 3000, function () {
		// should finish after unqueued animation so second
		order.push(2);
		assert.deepEqual( order, [ 1, 2 ], "Animations finished in the correct order" );
		done();
	});
	$foo.animate({fontSize:"2em"}, {queue:false, duration:10, complete:function () {
		// short duration and out of queue so should finish first
		order.push(1);
	}});
});
*/

QUnit.test( "animate option { queue: false }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

diff --git a/a.js b/b.js
@@ -475,12 +452,12 @@ QUnit.test( "animate option { queue: false }", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		order.push(1);
	}});
});
*/

QUnit.test( "animate option { queue: false }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: false,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

diff --git a/a.js b/b.js
@@ -493,7 +470,7 @@ QUnit.test( "animate option { queue: true }", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

QUnit.test( "animate option { queue: true }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: true,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );
diff --git a/a.js b/b.js
@@ -502,7 +479,7 @@ QUnit.test( "animate option { queue: true }", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

QUnit.test( "animate option { queue: true }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: true,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );

	assert.notEqual( foo.queue().length, 0, "Default queue is not empty" );

	//clear out existing timers before next test
	this.clock.tick( 10 );
} );

QUnit.test( "animate option { queue: 'name' }", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -533,7 +510,7 @@ QUnit.test( "animate option { queue: 'name' }", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

	//clear out existing timers before next test
	this.clock.tick( 10 );
} );

QUnit.test( "animate option { queue: 'name' }", function( assert ) {
	assert.expect( 5 );
	var foo = jQuery( "#foo" ),
		origWidth = parseFloat( foo.css( "width" ) ),
		order = [];

	foo.animate( { width: origWidth + 100 }, {
		queue: "name",
		duration: 1,
		complete: function() {

			// second callback function
			order.push( 2 );
			assert.equal( parseFloat( foo.css( "width" ) ), origWidth + 100, "Animation ended" );
			assert.equal( foo.queue( "name" ).length, 1, "Queue length of 'name' queue" );
		}
	} ).queue( "name", function() {

		// last callback function
		assert.deepEqual( order, [ 1, 2 ], "Callbacks in expected order" );
	} );

	// this is the first callback function that should be called
	order.push( 1 );
	assert.equal( parseFloat( foo.css( "width" ) ), origWidth, "Animation does not start on its own." );
	assert.equal( foo.queue( "name" ).length, 2, "Queue length of 'name' queue" );

	foo.dequeue( "name" );
	this.clock.tick( 10 );

} );

QUnit.test( "animate with no properties", function( assert ) {
diff --git a/a.js b/b.js
@@ -553,10 +530,10 @@ QUnit.test( "animate with no properties", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	foo.dequeue( "name" );
	this.clock.tick( 10 );

} );

QUnit.test( "animate with no properties", function( assert ) {
	assert.expect( 2 );

	var foo,
		divs = jQuery( "div" ),
		count = 0;

	divs.animate( {}, function() {
		count++;
	} );

	assert.equal( divs.length, count, "Make sure that callback is called for each element in the set." );

	foo = jQuery( "#foo" );

	foo.animate( {} );
	foo.animate( { top: 10 }, 100, function() {
		assert.ok( true, "Animation was properly dequeued." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate duration 0", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -589,13 +566,13 @@ QUnit.test( "animate duration 0", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.ok( true, "Animation was properly dequeued." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate duration 0", function( assert ) {
	assert.expect( 11 );

	var $elem,
		$elems = jQuery( [ { a:0 }, { a:0 } ] ),
		counter = 0;

	assert.equal( jQuery.timers.length, 0, "Make sure no animation was running from another test" );

	$elems.eq( 0 ).animate( { a:1 }, 0, function() {
		assert.ok( true, "Animate a simple property." );
		counter++;
	} );

	// Failed until [6115]
	assert.equal( jQuery.timers.length, 0, "Make sure synchronic animations are not left on jQuery.timers" );

	assert.equal( counter, 1, "One synchronic animations" );

	$elems.animate( { a:2 }, 0, function() {
		assert.ok( true, "Animate a second simple property." );
		counter++;
	} );

	assert.equal( counter, 3, "Multiple synchronic animations" );

	$elems.eq( 0 ).animate( { a:3 }, 0, function() {
		assert.ok( true, "Animate a third simple property." );
		counter++;
	} );
	$elems.eq( 1 ).animate( { a:3 }, 200, function() {
		counter++;

		// Failed until [6115]
		assert.equal( counter, 5, "One synchronic and one asynchronic" );
	} );
	this.clock.tick( 200 );

	$elem = jQuery( "<div></div>" );
	$elem.show( 0, function() {
		assert.ok( true, "Show callback with no duration" );
diff --git a/a.js b/b.js
@@ -614,12 +591,12 @@ QUnit.test( "animate hyphenated properties", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

	// manually clean up detached elements
	$elem.remove();
} );

QUnit.test( "animate hyphenated properties", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" )
		.css( "font-size", 10 )
		.animate( { "font-size": 20 }, 200, function() {
			assert.equal( this.style.fontSize, "20px", "The font-size property was animated." );
		} );

	// FIXME why is this double only when run with other tests
	this.clock.tick( 400 );

} );

QUnit.test( "animate non-element", function( assert ) {
diff --git a/a.js b/b.js
@@ -628,10 +605,10 @@ QUnit.test( "animate non-element", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	// FIXME why is this double only when run with other tests
	this.clock.tick( 400 );

} );

QUnit.test( "animate non-element", function( assert ) {
	assert.expect( 1 );

	var obj = { test: 0 };

	jQuery( obj ).animate( { test: 200 }, 200, function() {
		assert.equal( obj.test, 200, "The custom property should be modified." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "animate non-element's zIndex without appending \"px\"", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -639,10 +616,10 @@ QUnit.test( "animate non-element's zIndex without appending \"px\"", function( a
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( obj.test, 200, "The custom property should be modified." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "animate non-element's zIndex without appending \"px\"", function( assert ) {
	assert.expect( 1 );

	var obj = { zIndex: 0 };

	jQuery( obj ).animate( { zIndex: 200 }, 200, function() {
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -654,9 +631,9 @@ QUnit.test( "stop()", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

diff --git a/a.js b/b.js
@@ -664,7 +641,7 @@ QUnit.test( "stop()", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	this.clock.tick( 100 );

	$foo.removeData();
	$foo.removeData( undefined, true );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
diff --git a/a.js b/b.js
@@ -672,17 +649,17 @@ QUnit.test( "stop()", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	this.clock.tick( 100 );

	$foo.removeData();
	$foo.removeData( undefined, true );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );

	$one = jQuery( "#fadein" );
	$two = jQuery( "#show" );
	$one.fadeTo( 100, 0, function() {
		$one.stop();
	} );
	this.clock.tick( 100 );
	$two.fadeTo( 100, 0, function() {
		assert.equal( $two.css( "opacity" ), "0", "Stop does not interfere with animations on other elements (trac-6641)" );

		// Reset styles
		$one.add( $two ).css( "opacity", "" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "stop() - several in queue", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -721,12 +698,12 @@ QUnit.test( "stop(clearQueue)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	$foo.stop( true );

	assert.equal( $foo.queue().length, 0, "0 in the queue" );
} );

QUnit.test( "stop(clearQueue)", function( assert ) {
	assert.expect( 4 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { "width": "show" }, 1000 );
	$foo.animate( { "width": "hide" }, 1000 );
	$foo.animate( { "width": "show" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( true );

diff --git a/a.js b/b.js
@@ -735,7 +712,7 @@ QUnit.test( "stop(clearQueue)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	$foo.stop( true );

	assert.equal( $foo.queue().length, 0, "0 in the queue" );
} );

QUnit.test( "stop(clearQueue)", function( assert ) {
	assert.expect( 4 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { "width": "show" }, 1000 );
	$foo.animate( { "width": "hide" }, 1000 );
	$foo.animate( { "width": "show" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( true );

	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
diff --git a/a.js b/b.js
@@ -745,13 +722,13 @@ QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
	assert.expect( 1 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( false, true );

diff --git a/a.js b/b.js
@@ -761,7 +738,7 @@ QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
	assert.expect( 1 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( false, true );

	nw = $foo.css( "width" );

	// Disabled, being flaky
	//equal( nw, 1, "Stop() reset the animation" );

	this.clock.tick( 100 );

	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
diff --git a/a.js b/b.js
@@ -776,7 +753,7 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
diff --git a/a.js b/b.js
@@ -786,7 +763,7 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
	} );

	foo.animate( {
		height: 400
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, true );

	assert.equal( parseFloat( foo.css( "height" ) ), 400, "Height was stopped with gotoEnd" );
diff --git a/a.js b/b.js
@@ -795,11 +772,11 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
	} );

	foo.animate( {
		height: 400
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, true );

	assert.equal( parseFloat( foo.css( "height" ) ), 400, "Height was stopped with gotoEnd" );

	foo.animate( {
		height: 200
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, false );
	saved = parseFloat( foo.css( "height" ) );
        this.clock.tick( 500 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "toggle()", function( assert ) {
	assert.expect( 6 );
diff --git a/a.js b/b.js
@@ -894,7 +871,7 @@ QUnit.test( "Overflow and Display", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	);

	jQuery( div ).remove();
} );

QUnit.test( "Overflow and Display", function( assert ) {
	assert.expect( 4 );

	var
		testClass = jQuery.makeTest( "Overflow and Display" )
			.addClass( "overflow inline" ),
		testStyle = jQuery.makeTest( "Overflow and Display (inline style)" )
			.css( { overflow: "visible", display: "inline" } ),
		done = function() {
			assert.equal( jQuery.css( this, "overflow" ), "visible", "Overflow should be 'visible'" );
			assert.equal( jQuery.css( this, "display" ), "inline", "Display should be 'inline'" );
		};

	testClass.add( testStyle )
		.addClass( "widewidth" )
		.text( "Some sample text." )
		.before( "text before" )
		.after( "text after" )
		.animate( { opacity: 0.5 }, "slow", done );
	this.clock.tick( 600 );
} );

jQuery.each( {
	"CSS Auto": function( elem, prop ) {
diff --git a/a.js b/b.js
@@ -985,7 +962,7 @@ QUnit.test( fn + " to " + tn, function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		"0": function( elem ) {
			jQuery( elem ).addClass( "noback" );
			return 0;
		}
	}, function( tn, t ) {
		QUnit.test( fn + " to " + tn, function( assert ) {
			var num, anim,
				elem = jQuery.makeTest( fn + " to " + tn ),
				t_w = t( elem, "width" ),
				f_w = f( elem, "width" ),
				t_h = t( elem, "height" ),
				f_h = f( elem, "height" ),
				t_o = t( elem, "opacity" ),
				f_o = f( elem, "opacity" );

			if ( f_o === "" ) {
				f_o = 1;
			}

			num = 0;

			// TODO: uncrowd this
			if ( t_h === "show" ) { num++; }
			if ( t_w === "show" ) { num++; }
			if ( t_w === "hide" || t_w === "show" ) { num++; }
			if ( t_h === "hide" || t_h === "show" ) { num++; }
			if ( t_o === "hide" || t_o === "show" ) { num++; }
			if ( t_w === "hide" ) { num++; }
			if ( t_o.constructor === Number ) { num += 2; }
			if ( t_w.constructor === Number ) { num += 2; }
			if ( t_h.constructor === Number ) { num += 2; }

			assert.expect( num );

			anim = { width: t_w, height: t_h, opacity: t_o };

			elem.animate( anim, 50 );

			jQuery.when( elem ).done( function( $elem ) {
				var cur_o, cur_w, cur_h, old_h,
					elem = $elem[ 0 ];
diff --git a/a.js b/b.js
@@ -1055,7 +1032,7 @@ QUnit.test( fn + " to " + tn, function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		"0": function( elem ) {
			jQuery( elem ).addClass( "noback" );
			return 0;
		}
	}, function( tn, t ) {
		QUnit.test( fn + " to " + tn, function( assert ) {
			var num, anim,
				elem = jQuery.makeTest( fn + " to " + tn ),
				t_w = t( elem, "width" ),
				f_w = f( elem, "width" ),
				t_h = t( elem, "height" ),
				f_h = f( elem, "height" ),
				t_o = t( elem, "opacity" ),
				f_o = f( elem, "opacity" );

			if ( f_o === "" ) {
				f_o = 1;
			}

			num = 0;

			// TODO: uncrowd this
			if ( t_h === "show" ) { num++; }
			if ( t_w === "show" ) { num++; }
			if ( t_w === "hide" || t_w === "show" ) { num++; }
			if ( t_h === "hide" || t_h === "show" ) { num++; }
			if ( t_o === "hide" || t_o === "show" ) { num++; }
			if ( t_w === "hide" ) { num++; }
			if ( t_o.constructor === Number ) { num += 2; }
			if ( t_w.constructor === Number ) { num += 2; }
			if ( t_h.constructor === Number ) { num += 2; }

			assert.expect( num );

			anim = { width: t_w, height: t_h, opacity: t_o };

			elem.animate( anim, 50 );

			jQuery.when( elem ).done( function( $elem ) {
				var cur_o, cur_w, cur_h, old_h,
					elem = $elem[ 0 ];

				if ( t_w === "show" ) {
					assert.equal( $elem.css( "display" ), "block",
						"Showing, display should block: " + elem.style.display );
				}

				if ( t_w === "hide" || t_w === "show" ) {
					assert.ok( f_w === "" ? elem.style.width === f_w : elem.style.width.indexOf( f_w ) === 0, "Width must be reset to " + f_w + ": " + elem.style.width );
				}

				if ( t_h === "hide" || t_h === "show" ) {
					assert.ok( f_h === "" ? elem.style.height === f_h : elem.style.height.indexOf( f_h ) === 0, "Height must be reset to " + f_h + ": " + elem.style.height );
				}

				cur_o = jQuery.style( elem, "opacity" );

				if ( f_o !== jQuery.css( elem, "opacity" ) ) {
					f_o = f( elem, "opacity" );
				}

				if ( t_o === "hide" || t_o === "show" ) {
					assert.equal( cur_o, f_o, "Opacity must be reset to " + f_o + ": " + cur_o );
				}

				if ( t_w === "hide" ) {
					assert.equal( elem.style.display, "none", "Hiding, display should be none: " + elem.style.display );
				}

				if ( t_o.constructor === Number ) {
					assert.equal( cur_o, t_o, "Final opacity should be " + t_o + ": " + cur_o );

					assert.ok( jQuery.css( elem, "opacity" ) !== "" || cur_o === t_o, "Opacity should be explicitly set to " + t_o + ", is instead: " + cur_o );
				}

				if ( t_w.constructor === Number ) {
					assert.equal( elem.style.width, t_w + "px", "Final width should be " + t_w + ": " + elem.style.width );

					cur_w = jQuery.css( elem, "width" );

					assert.ok( elem.style.width !== "" || cur_w === t_w, "Width should be explicitly set to " + t_w + ", is instead: " + cur_w );
				}

				if ( t_h.constructor === Number ) {
					assert.equal( elem.style.height, t_h + "px", "Final height should be " + t_h + ": " + elem.style.height );

					cur_h = jQuery.css( elem, "height" );

					assert.ok( elem.style.height !== "" || cur_h === t_h, "Height should be explicitly set to " + t_h + ", is instead: " + cur_h );
				}

				if ( t_h === "show" ) {
					old_h = jQuery.css( elem, "height" );
					jQuery( elem ).append( "<br/>Some more text<br/>and some more..." );

					if ( /Auto/.test( fn ) ) {
						assert.notEqual( jQuery.css( elem, "height" ), old_h, "Make sure height is auto." );
					} else {
						assert.equal( jQuery.css( elem, "height" ), old_h, "Make sure height is not auto." );
					}
				}

				// manually remove generated element
				jQuery( elem ).remove();

			} );
			this.clock.tick( 100 );
		} );
	} );
} );

diff --git a/a.js b/b.js
@@ -1103,7 +1080,7 @@ 		getProps = function( el ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

			assert.deepEqual( getProps( this ), data, name );

			jQuery.removeData( this );
		},
		getProps = function( el ) {
			var obj = {};
			jQuery.each( props, function( i, prop ) {
				obj[ prop ] = prop === "overflow" && el.style[ prop ] || jQuery.css( el, prop );
			} );
			return obj;
		};

	assert.expect( remaining );

	setup( ".fadeOut().fadeIn()", "#fadein div" ).fadeOut( "fast" ).fadeIn( "fast", check );
	setup( ".fadeIn().fadeOut()", "#fadeout div" ).fadeIn( "fast" ).fadeOut( "fast", check );
	setup( ".hide().show()", "#show div" ).hide( "fast" ).show( "fast", check );
	setup( ".show().hide()", "#hide div" ).show( "fast" ).hide( "fast", check );
	setup( ".show().hide(easing)", "#easehide div" ).show( "fast" ).hide( "fast", "linear", check );
	setup( ".toggle().toggle() - in", "#togglein div" ).toggle( "fast" ).toggle( "fast", check );
	setup( ".toggle().toggle() - out", "#toggleout div" ).toggle( "fast" ).toggle( "fast", check );
	setup( ".toggle().toggle(easing) - out", "#easetoggleout div" ).toggle( "fast" ).toggle( "fast", "linear", check );
	setup( ".slideDown().slideUp()", "#slidedown div" ).slideDown( "fast" ).slideUp( "fast", check );
	setup( ".slideUp().slideDown()", "#slideup div" ).slideUp( "fast" ).slideDown( "fast", check );
	setup( ".slideUp().slideDown(easing)", "#easeslideup div" ).slideUp( "fast" ).slideDown( "fast", "linear", check );
	setup( ".slideToggle().slideToggle() - in", "#slidetogglein div" ).slideToggle( "fast" ).slideToggle( "fast", check );
	setup( ".slideToggle().slideToggle() - out", "#slidetoggleout div" ).slideToggle( "fast" ).slideToggle( "fast", check );
	setup( ".fadeToggle().fadeToggle() - in", "#fadetogglein div" ).fadeToggle( "fast" ).fadeToggle( "fast", check );
	setup( ".fadeToggle().fadeToggle() - out", "#fadetoggleout div" ).fadeToggle( "fast" ).fadeToggle( "fast", check );
	setup( ".fadeTo(0.5).fadeTo(1.0, easing)", "#fadeto div" ).fadeTo( "fast", 0.5 ).fadeTo( "fast", 1.0, "linear", check );

    this.clock.tick( 400 );
} );

jQuery.makeTest = function( text ) {
        var elem = jQuery( "<div></div>" )
diff --git a/a.js b/b.js
@@ -1131,15 +1108,14 @@ QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug trac-1095)", f
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
        return elem;
};

jQuery.makeTest.id = 1;

QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug trac-1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	$checkedtest.hide().show( "fast", function() {
		assert.ok( jQuery( "input[type='radio']", $checkedtest ).first().attr( "checked" ), "Check first radio still checked." );
		assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
		assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
		assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "interrupt toggle", function( assert ) {
	assert.expect( 24 );

	var env = this,
		longDuration = 2000,
		shortDuration = 500,
		remaining = 0,
		$elems = jQuery( ".chain-test" ),
		clock = this.clock,
		finish = function() {
diff --git a/a.js b/b.js
@@ -1222,7 +1198,7 @@ 	jQuery.easing._defaultTest = function( p ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	jQuery.easing._test2 = function( p ) {
		test2Called = true;
		return p;
	};

	jQuery.easing._defaultTest = function( p ) {
		defaultTestCalled = true;
		return p;
	};

	jQuery( data ).animate( props, 400, "_defaultTest", function() {
		assert.ok( test1Called, "Easing function (_test1) called" );
		assert.ok( test2Called, "Easing function (_test2) called" );
		assert.ok( defaultTestCalled, "Easing function (_default) called" );
		assert.equal( props.a[ 1 ], "_test1", "animate does not change original props (per-property easing would be lost)" );
diff --git a/a.js b/b.js
@@ -1230,7 +1206,7 @@ jQuery( data ).animate( props, 400, "_defaultTest", function() {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	jQuery.easing._defaultTest = function( p ) {
		defaultTestCalled = true;
		return p;
	};

	jQuery( data ).animate( props, 400, "_defaultTest", function() {
		assert.ok( test1Called, "Easing function (_test1) called" );
		assert.ok( test2Called, "Easing function (_test2) called" );
		assert.ok( defaultTestCalled, "Easing function (_default) called" );
		assert.equal( props.a[ 1 ], "_test1", "animate does not change original props (per-property easing would be lost)" );
		assert.equal( props.b[ 1 ], "_test2", "animate does not change original props (per-property easing would be lost)" );
	} );

	this.clock.tick( 400 );
} );

QUnit.test( "animate with CSS shorthand properties", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -1256,7 +1232,8 @@ 	jQuery.easing.propertyScope = function( p ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
			easeAnimation_count++;
		}
		return p;
	};

	jQuery.easing.propertyScope = function( p ) {
		if ( p >= 1 ) {
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
diff --git a/a.js b/b.js
@@ -1264,7 +1241,8 @@ jQuery( "#foo" )
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
			assert.equal( easeAnimation_count, 4, "per-animation default easing called for each property" );
			easeAnimation_count = 0;
		} )
		.animate( propsSpecial, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "1px", "padding-top was animated again" );
			assert.equal( this.style.paddingLeft, "2px", "padding-left was animated again" );
			assert.equal( this.style.paddingRight, "2px", "padding-right was animated again" );
			assert.equal( this.style.paddingBottom, "3px", "padding-bottom was animated again" );
diff --git a/a.js b/b.js
@@ -1276,7 +1254,7 @@ jQuery( "#foo" )
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
			assert.equal( easeAnimation_count, 4, "per-animation default easing called for each property" );
			easeAnimation_count = 0;
		} )
		.animate( propsSpecial, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "1px", "padding-top was animated again" );
			assert.equal( this.style.paddingLeft, "2px", "padding-left was animated again" );
			assert.equal( this.style.paddingRight, "2px", "padding-right was animated again" );
			assert.equal( this.style.paddingBottom, "3px", "padding-bottom was animated again" );
			assert.equal( easeAnimation_count, 0, "per-animation default easing not called" );
			assert.equal( easeProperty_count, 4, "special easing called for each property" );

			jQuery( this ).css( "padding", "0" );
			delete jQuery.easing.animationScope;
			delete jQuery.easing.propertyScope;
		} );
		this.clock.tick( 400 );
} );

QUnit.test( "hide hidden elements, with animation (bug trac-7141)", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -1302,7 +1280,7 @@ QUnit.test( "animate unit-less properties (trac-4966)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );
	this.clock.tick( 50 );
	assert.equal( div.css( "display" ), "block", "Element is visible after animations" );
} );

QUnit.test( "animate unit-less properties (trac-4966)", function( assert ) {
	assert.expect( 2 );

	var div = jQuery( "<div style='z-index: 0; position: absolute;'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "z-index" ), "0", "z-index is 0" );
	div.animate( { zIndex: 2 }, function() {
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (trac-9074)", function( assert ) {
	assert.expect( 6 );
diff --git a/a.js b/b.js
@@ -1320,9 +1298,9 @@ QUnit.test( "animate properties missing px w/ opacity as last (trac-9074)", func
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (trac-9074)", function( assert ) {
	assert.expect( 6 );

	var ml, l,
		div = jQuery( "<div style='position: absolute; margin-left: 0; left: 0px;'></div>" )
		.appendTo( "#qunit-fixture" );
	function cssInt( prop ) {
		return parseInt( div.css( prop ), 10 );
	}
	assert.equal( cssInt( "marginLeft" ), 0, "Margin left is 0" );
	assert.equal( cssInt( "left" ), 0, "Left is 0" );
	div.animate( {
		left: 200,
		marginLeft: 200,
		opacity: 0
	}, 2000 );

	this.clock.tick( 500 );

	ml = cssInt( "marginLeft" );
	l = cssInt( "left" );
	assert.notEqual( ml, 0, "Margin left is not 0 after partial animate" );
diff --git a/a.js b/b.js
@@ -1342,14 +1320,14 @@ QUnit.test( "callbacks should fire in correct order (trac-9100)", function( asse
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	assert.notEqual( l, 0, "Left is not 0 after partial animate" );
	assert.notEqual( l, 200, "Left is not 200 after partial animate" );
	div.stop().remove();
} );

QUnit.test( "callbacks should fire in correct order (trac-9100)", function( assert ) {
	assert.expect( 1 );

	var a = 1,
		cb = 0;

	jQuery( "<p data-operation='*2'></p><p data-operation='^2'></p>" ).appendTo( "#qunit-fixture" )

		// The test will always pass if no properties are animated or if the duration is 0
		.animate( { fontSize: 12 }, 13, function() {
			a *= jQuery( this ).data( "operation" ) === "*2" ? 2 : a;
			cb++;
			if ( cb === 2 ) {
				assert.equal( a, 4, "test value has been *2 and _then_ ^2" );
			}
		} );
	this.clock.tick( 20 );
} );

QUnit.test( "callbacks that throw exceptions will be removed (trac-5684)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1421,8 +1399,8 @@ QUnit.test( "line-height animates correctly (trac-13855)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( jQuery( this ).css( "fill-opacity" ), 1, "Do not append px to 'fill-opacity'" );
		$div.remove();
	} );
} );

QUnit.test( "line-height animates correctly (trac-13855)", function( assert ) {
	assert.expect( 12 );

	var t0,
		clock = this.clock,
		longDuration = 2000,
		shortDuration = 500,
		animated = jQuery(
			"<p style='line-height: 100;'>unitless</p>" +
			"<p style='line-height: 5000px;'>px</p>" +
			"<p style='line-height: 5000%;'>percent</p>" +
diff --git a/a.js b/b.js
@@ -1472,11 +1450,11 @@ setTimeout( function() {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

			t0 = +( new Date() );
			animated.stop( true, true ).hide()
					.animate( { "line-height": "show" }, longDuration, "linear" );

			setTimeout( function() {
				var progress = ( ( new Date() ) - t0 ) / longDuration;

				animated.each( function( i ) {
					var label = jQuery.text( this ),
						initial = initialHeight[ i ],
						height = jQuery( this ).height(),
						upper = initial * progress * tolerance;
					assert.ok( height < upper, "show " + label + ": upper bound; " +
						height + " < " + upper + " @ " + ( progress * 100 ) + "%" );
				} );

				animated.stop( true, true );
			}, shortDuration );
clock.tick( shortDuration );
		}, shortDuration );
clock.tick( shortDuration );
	}, 50 );
clock.tick( 50 );
} );

// Start 1.8 Animation tests
QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
diff --git a/a.js b/b.js
@@ -1504,7 +1482,7 @@ QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	}, 50 );
clock.tick( 50 );
} );

// Start 1.8 Animation tests
QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
	assert.expect( 4 );

	var animation,
		testObject = {
			"foo": 0,
			"bar": 1,
			"width": 100
		},
		testDest = {
			"foo": 1,
			"bar": 0,
			"width": 200
		};

	animation = jQuery.Animation( testObject, testDest, { "duration": 1 } );
	animation.done( function() {
		for ( var prop in testDest ) {
			assert.equal( testObject[ prop ], testDest[ prop ], "Animated: " + prop );
		}
		animation.done( function() {
			assert.deepEqual( testObject, testDest, "No unexpected properties" );
		} );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate Option: step: function( percent, tween )", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1532,7 +1510,7 @@ jQuery( "#foo" ).animate( {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

QUnit.test( "Animate Option: step: function( percent, tween )", function( assert ) {
	assert.expect( 1 );

	var counter = {};
	jQuery( "#foo" ).animate( {
		prop1: 1,
		prop2: 2,
		prop3: 3
	}, {
		duration: 1,
		step: function( value, tween ) {
			var calls = counter[ tween.prop ] = counter[ tween.prop ] || [];

			// in case this is called multiple times for either, lets store it in
			// 0 or 1 in the array
			calls[ value === 0 ? 0 : 1 ] = value;
		}
	} ).queue( function( next ) {
		assert.deepEqual( counter, {
			prop1: [ 0, 1 ],
			prop2: [ 0, 2 ],
			prop3: [ 0, 3 ]
		}, "Step function was called once at 0% and once at 100% for each property" );
		next();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate callbacks have correct context", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1541,15 +1519,15 @@ QUnit.test( "Animate callbacks have correct context", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		next();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate callbacks have correct context", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	foo.animate( {
		height: 10
	}, 10, function() {
		assert.equal( foo[ 0 ], this, "Complete callback after stop(true) `this` is element" );
	} ).stop( true, true );
	foo.animate( {
		height: 100
	}, 10, function() {
		assert.equal( foo[ 0 ], this, "Complete callback `this` is element" );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "User supplied callback called after show when fx off (trac-8892)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1571,8 +1549,7 @@ QUnit.test( "User supplied callback called after show when fx off (trac-8892)",
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.equal( foo[ 0 ], this, "Complete callback `this` is element" );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "User supplied callback called after show when fx off (trac-8892)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	jQuery.fx.off = true;
	foo.hide();
	foo.fadeIn( 500, function() {
		assert.ok( supportjQuery( this ).is( ":visible" ), "Element is visible in callback" );
		foo.fadeOut( 500, function() {
			assert.ok( supportjQuery( this ).is( ":hidden" ), "Element is hidden in callback" );
			jQuery.fx.off = false;
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
diff --git a/a.js b/b.js
@@ -1625,7 +1602,7 @@ QUnit.test( "animate should set display for disconnected nodes", function( asser
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
			animate: [ { width: "show" } ]
		},
		toggleMethods = {
			toggle: [ 1 ],
			slideToggle: []
		},
		$divEmpty = jQuery( "<div></div>" ),
		$divTest = jQuery( "<div>test</div>" ),
		$divNone = jQuery( "<div style='display: none;'></div>" ),
		$divInline = jQuery( "<div style='display: inline;'></div>" ),
		nullParentDisplay = $divEmpty.css( "display" ),
		underFragmentDisplay = $divTest.css( "display" ),
		clock = this.clock;

	assert.strictEqual( $divEmpty[ 0 ].parentNode, null, "Setup: element with null parentNode" );
	assert.strictEqual( ( $divTest[ 0 ].parentNode || {} ).nodeType, 11, "Setup: element under fragment" );

	assert.strictEqual( $divEmpty.show()[ 0 ].style.display, "",
		"set display with show() for element with null parentNode" );
	assert.strictEqual( $divTest.show()[ 0 ].style.display, "",
		"set display with show() for element under fragment" );
	assert.strictEqual( $divNone.show()[ 0 ].style.display, "",
		"show() should change display if it already set to none" );
	assert.strictEqual( $divInline.show()[ 0 ].style.display, "inline",
		"show() should not change display if it already set" );

	jQuery.each( showMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), nullParentDisplay,
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), underFragmentDisplay,
				"." + name + " block under fragment" );
		} ] ) );
	} );
	jQuery.each( toggleMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block under fragment" );
		} ] ) );
	} );
	clock.tick( 400 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Animation callback should not show animated element as :animated (trac-7157)", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1635,10 +1612,10 @@ QUnit.test( "animate should set display for disconnected nodes", function( asser
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
			animate: [ { width: "show" } ]
		},
		toggleMethods = {
			toggle: [ 1 ],
			slideToggle: []
		},
		$divEmpty = jQuery( "<div></div>" ),
		$divTest = jQuery( "<div>test</div>" ),
		$divNone = jQuery( "<div style='display: none;'></div>" ),
		$divInline = jQuery( "<div style='display: inline;'></div>" ),
		nullParentDisplay = $divEmpty.css( "display" ),
		underFragmentDisplay = $divTest.css( "display" ),
		clock = this.clock;

	assert.strictEqual( $divEmpty[ 0 ].parentNode, null, "Setup: element with null parentNode" );
	assert.strictEqual( ( $divTest[ 0 ].parentNode || {} ).nodeType, 11, "Setup: element under fragment" );

	assert.strictEqual( $divEmpty.show()[ 0 ].style.display, "",
		"set display with show() for element with null parentNode" );
	assert.strictEqual( $divTest.show()[ 0 ].style.display, "",
		"set display with show() for element under fragment" );
	assert.strictEqual( $divNone.show()[ 0 ].style.display, "",
		"show() should change display if it already set to none" );
	assert.strictEqual( $divInline.show()[ 0 ].style.display, "inline",
		"show() should not change display if it already set" );

	jQuery.each( showMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), nullParentDisplay,
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), underFragmentDisplay,
				"." + name + " block under fragment" );
		} ] ) );
	} );
	jQuery.each( toggleMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block under fragment" );
		} ] ) );
	} );
	clock.tick( 400 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Animation callback should not show animated element as :animated (trac-7157)", function( assert ) {
	assert.expect( 1 );

	var foo = jQuery( "#foo" );

	foo.animate( {
		opacity: 0
	}, 100, function() {
		assert.ok( !foo.is( ":animated" ), "The element is not animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Initial step callback should show element as :animated (trac-14623)", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1677,7 +1654,7 @@ QUnit.test( "hide called on element within hidden parent should set display to n
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );
	this.clock.tick( 1 );
	foo.stop();
} );

QUnit.test( "hide called on element within hidden parent should set display to none (trac-10045)", function( assert ) {
	assert.expect( 3 );

	var hidden = jQuery( ".hidden" ),
		elems = jQuery( "<div>hide</div><div>hide0</div><div>hide1</div>" );

	hidden.append( elems );

	jQuery.when(
		elems.eq( 0 ).hide(),
		elems.eq( 1 ).hide( 0 ),
		elems.eq( 2 ).hide( 1 )
	).done( function() {
		assert.strictEqual( elems.get( 0 ).style.display, "none", "hide() called on element within hidden parent should set display to none" );
		assert.strictEqual( elems.get( 1 ).style.display, "none", "hide( 0 ) called on element within hidden parent should set display to none" );
		assert.strictEqual( elems.get( 2 ).style.display, "none", "hide( 1 ) called on element within hidden parent should set display to none" );

		elems.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "hide, fadeOut and slideUp called on element width height and width = 0 should set display to none", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -1708,7 +1685,7 @@ QUnit.test( "hide, fadeOut and slideUp called on element width height and width
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		elems.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "hide, fadeOut and slideUp called on element width height and width = 0 should set display to none", function( assert ) {
	assert.expect( 5 );

	var foo = jQuery( "#foo" ),
		i = 0,
		elems = jQuery();

	for ( ; i < 5; i++ ) {
		elems = elems.add( "<div style='width:0;height:0;'></div>" );
	}

	foo.append( elems );

	jQuery.when(
		elems.eq( 0 ).hide(),
		elems.eq( 1 ).hide( jQuery.noop ),
		elems.eq( 2 ).hide( 1 ),
		elems.eq( 3 ).fadeOut(),
		elems.eq( 4 ).slideUp()
	).done( function() {
		assert.strictEqual( elems.get( 0 ).style.display, "none", "hide() called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 1 ).style.display, "none",
												"hide( jQuery.noop ) called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 2 ).style.display, "none", "hide( 1 ) called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 3 ).style.display, "none", "fadeOut() called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 4 ).style.display, "none", "slideUp() called on element width height and width = 0 should set display to none" );

	} );
	this.clock.tick( 400 );
} );

QUnit.test( "hide should not leave hidden inline elements visible (trac-14848)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1735,7 +1712,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
diff --git a/a.js b/b.js
@@ -1743,21 +1720,21 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
diff --git a/a.js b/b.js
@@ -1765,7 +1742,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
		} ).animate( {
			bottom: 10
		}, {
			duration: 10,
			queue: false,
			complete: function() {
				assert.ok( step > 7 && step < 10, "Step eight or nine" );
				step++;
diff --git a/a.js b/b.js
@@ -1776,7 +1753,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
		} ).animate( {
			bottom: 10
		}, {
			duration: 10,
			queue: false,
			complete: function() {
				assert.ok( step > 7 && step < 10, "Step eight or nine" );
				step++;
			}
		} ).promise().done( function() {
			assert.equal( step++, 10, "steps 6-10: queue:fx then queue:false" );
		} );

	} );
	this.clock.tick( 10 );
} );

QUnit.test( "multiple unqueued and promise", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -1811,7 +1788,7 @@ QUnit.test( "multiple unqueued and promise", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

	} );
	this.clock.tick( 10 );
} );

QUnit.test( "multiple unqueued and promise", function( assert ) {
	assert.expect( 4 );

	var foo = jQuery( "#foo" ),
		step = 1;
	foo.animate( {
		marginLeft: 300
	}, {
		duration: 500,
		queue: false,
		complete: function() {
			assert.strictEqual( step++, 2, "Step 2" );
		}
	} ).animate( {
		top: 100
	}, {
		duration: 1000,
		queue: false,
		complete: function() {
			assert.strictEqual( step++, 3, "Step 3" );
		}
	} ).animate( {}, {
		duration: 2000,
		queue: false,
		complete: function() {

			// no properties is a non-op and finishes immediately
			assert.strictEqual( step++, 1, "Step 1" );
		}
	} ).promise().done( function() {
		assert.strictEqual( step++, 4, "Step 4" );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate does not change start value for non-px animation (trac-7109)", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1834,7 +1811,7 @@ QUnit.test( "animate does not change start value for non-px animation (trac-7109
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.strictEqual( step++, 4, "Step 4" );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate does not change start value for non-px animation (trac-7109)", function( assert ) {
	assert.expect( 1 );

	var parent = jQuery( "<div><div></div></div>" ).css( { width: 284, height: 1 } ).appendTo( "#qunit-fixture" ),
		child = parent.children().css( { fontSize: "98.6in", width: "0.01em", height: 1 } ),
		actual = parseFloat( child.css( "width" ) ),
		computed = [];

	child.animate( { width: "0%" }, {
		duration: 1,
		step: function() {
			computed.push( parseFloat( child.css( "width" ) ) );
		}
	} ).queue( function( next ) {
		var ratio = computed[ 0 ] / actual;
		assert.ok( ratio > 0.9 && ratio < 1.1,
			"Starting width was close enough (" + computed[ 0 ] + " approximates " + actual + ")" );
		next();
		parent.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "non-px animation handles non-numeric start (trac-11971)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1866,7 +1843,7 @@ QUnit.test( "non-px animation handles non-numeric start (trac-11971)", function(
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		parent.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "non-px animation handles non-numeric start (trac-11971)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" ),
		initial = foo.css( "backgroundPositionX" );

	if ( !initial ) {
		assert.expect( 1 );
		assert.ok( true, "Style property not understood" );
		return;
	}

	foo.animate( { backgroundPositionX: "42%" }, {
		duration: 1,
		progress: function( anim, percent ) {
			if ( percent ) {
				return;
			}

			if ( parseFloat( initial ) ) {
				assert.equal( jQuery.style( this, "backgroundPositionX" ), initial, "Numeric start preserved" );
			} else {
				assert.equal( jQuery.style( this, "backgroundPositionX" ), "0%", "Non-numeric start zeroed" );
			}
		},
		done: function() {
			assert.equal( jQuery.style( this, "backgroundPositionX" ), "42%", "End reached" );
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks (trac-11797)", function( assert ) {
	assert.expect( 15 );
diff --git a/a.js b/b.js
@@ -1946,7 +1923,7 @@ QUnit.test( "Animation callbacks (trac-11797)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks (trac-11797)", function( assert ) {
	assert.expect( 15 );

	var prog = 0,
		targets = jQuery( "#foo" ).children(),
		done = false,
		expectedProgress = 1;

	targets.eq( 0 ).animate( {}, {
		duration: 1,
		start: function() {
			assert.ok( true, "empty: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, prog, "empty: progress " + prog );
			prog = 1;
		},
		done: function() {
			assert.ok( true, "empty: done" );
		},
		fail: function() {
			assert.ok( false, "empty: fail" );
		},
		always: function() {
			assert.ok( true, "empty: always" );
			done = true;
		}
	} );

	assert.ok( done, "empty: done immediately" );

	done = false;
	targets.eq( 1 ).animate( {
		opacity: 0
	}, {
		duration: 1,
		start: function() {
			assert.ok( true, "stopped: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, 0, "stopped: progress 0" );
		},
		done: function() {
			assert.ok( false, "stopped: done" );
		},
		fail: function() {
			assert.ok( true, "stopped: fail" );
		},
		always: function() {
			assert.ok( true, "stopped: always" );
			done = true;
		}
	} ).stop();

	assert.ok( done, "stopped: stopped immediately" );

	targets.eq( 2 ).animate( {
		opacity: 0
	}, {
		duration: 1,
		start: function() {
			assert.ok( true, "async: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, expectedProgress, "async: progress " + expectedProgress );
			expectedProgress++;
		},
		done: function() {
			assert.ok( true, "async: done" );
		},
		fail: function() {
			assert.ok( false, "async: fail" );
		},
		always: function() {
			assert.ok( true, "async: always" );
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks in order (gh-2283)", function( assert ) {
	assert.expect( 9 );
diff --git a/a.js b/b.js
@@ -1986,7 +1963,7 @@ jQuery( "#foo" ).animate( {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

	var done = assert.async(),
		step = 0,
		dur = 50;

	jQuery( "#foo" ).animate( {
		width: "5px"
	}, {
		duration: dur,
		start: function() {
			assert.step( "start" );
		},
		progress: function( anim, p, ms ) {
			if ( !( step++ ) ) {
				assert.step( "progress" );
				assert.strictEqual( p, 0, "first progress callback: progress ratio" );
				assert.strictEqual( ms, dur, "first progress callback: remaining ms" );
			} else {
				assert.step( "last progress" );
				assert.strictEqual( p, 1, "last progress callback: progress ratio" );
				assert.strictEqual( ms, 0, "last progress callback: remaining ms" );
			}
		},
		done: function() {
			assert.step( "done" );
		},
		fail: function() {
			assert.ok( false, "Animation failed" );
		},
		always: function() {
			assert.verifySteps( [ "start", "progress", "last progress", "done" ] );
			done();
		}
	} ).finish();

	this.clock.tick( dur + 10 );
} );

QUnit.test( "Animate properly sets overflow hidden when animating width/height (trac-12117)", function( assert ) {
	assert.expect( 8 );
diff --git a/a.js b/b.js
@@ -2096,8 +2073,8 @@ QUnit.test( "toggle state tests: " + method + " (trac-8685)", function( assert )
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
jQuery.map( [ "toggle", "slideToggle", "fadeToggle" ], function( method ) {

	// this test would look a lot better if we were using something to override
	// the default timers
	var duration = 1500;
	QUnit.test( "toggle state tests: " + method + " (trac-8685)", function( assert ) {
		function secondToggle() {
			var stopped = parseFloat( element.css( check ) );
			tested = false;
			element[ method ]( {
				duration: duration,
				step: function( p, fx ) {
					if ( fx.pos > 0.1 && fx.prop === check && !tested ) {
						tested = true;
						assert.equal( fx.start, stopped, check + " starts at " + stopped + " where it stopped" );
						assert.equal( fx.end, original, check + " ending value is " + original );
						element.stop();
					}
				}
			} );
		}

		var tested,
			original,
			check = method === "slideToggle" ? "height" : "opacity",
			element = jQuery( "#foo" ).height( 200 );

		assert.expect( 4 );

		element[ method ]( {
			duration: duration,
			easing: "linear",
			step: function( p, fx ) {
				if ( fx.pos > 0.1 && fx.prop === check && !tested ) {
					tested = true;
					original = fx.start;
					assert.ok( fx.start !== 0, check + " is starting at " + original + " on first toggle (non-zero)" );
					assert.equal( fx.end, 0, check + " is ending at 0 on first toggle" );
					element.stop();
				}
			},
			always: secondToggle
		} );

                //FIXME figure out why 470
		this.clock.tick( 470 );
	} );
} );

QUnit.test( "jQuery.fx.start & jQuery.fx.stop hook points", function( assert ) {
diff --git a/a.js b/b.js
@@ -2291,7 +2268,10 @@ QUnit.test( ".finish() is applied correctly when multiple elements were animated
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	assert.equal( outside, 2, "2 finish callbacks" );

	div.remove();
} );

QUnit.test( ".finish() is applied correctly when multiple elements were animated (trac-13937)", function( assert ) {
	assert.expect( 3 );

	var elems = jQuery( "<a>0</a><a>1</a><a>2</a>" );

	elems.animate( { opacity: 0 }, 1500 ).animate( { opacity: 1 }, 1500 );
	setTimeout( function() {
		elems.eq( 1 ).finish();
		assert.ok( !elems.eq( 1 ).queue().length, "empty queue for .finish()ed element" );
		assert.ok( elems.eq( 0 ).queue().length, "non-empty queue for preceding element" );
diff --git a/a.js b/b.js
@@ -2300,7 +2280,7 @@ setTimeout( function() {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	assert.expect( 3 );

	var elems = jQuery( "<a>0</a><a>1</a><a>2</a>" );

	elems.animate( { opacity: 0 }, 1500 ).animate( { opacity: 1 }, 1500 );
	setTimeout( function() {
		elems.eq( 1 ).finish();
		assert.ok( !elems.eq( 1 ).queue().length, "empty queue for .finish()ed element" );
		assert.ok( elems.eq( 0 ).queue().length, "non-empty queue for preceding element" );
		assert.ok( elems.eq( 2 ).queue().length, "non-empty queue for following element" );
		elems.stop( true );

	}, 100 );
	this.clock.tick( 1500 );
} );

QUnit.test( "slideDown() after stop() (trac-13483)", function( assert ) {
		assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2312,28 +2292,28 @@ QUnit.test( "slideDown() after stop() (trac-13483)", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd

	}, 100 );
	this.clock.tick( 1500 );
} );

QUnit.test( "slideDown() after stop() (trac-13483)", function( assert ) {
		assert.expect( 2 );

		var ul = jQuery( "<ul style='height: 100px; display: block;'></ul>" )
				.appendTo( "#qunit-fixture" ),
			origHeight = ul.height(),
			clock = this.clock;

        // First test. slideUp() -> stop() in the middle -> slideDown() until the end
		ul.slideUp( 1000 );
		clock.tick( 500 );
		ul.stop( true );
		ul.slideDown( 1, function() {
				assert.equal( ul.height(), origHeight, "slideDown() after interrupting slideUp() with stop(). Height must be in original value" );

				// Second test. slideDown() -> stop() in the middle -> slideDown() until the end
				ul.slideUp( 1 );
				clock.tick( 10 );
				ul.slideDown( 1000 );
				clock.tick( 500 );
				ul.stop( true );
				ul.slideDown( 1 );
				assert.equal( ul.height(), origHeight, "slideDown() after interrupting slideDown() with stop(). Height must be in original value" );

				// Cleanup
				ul.remove();
				clock.tick( 10 );

		} );

		clock.tick( 10 );
} );

QUnit.test( "Respect display value on inline elements (trac-14824)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2359,7 +2339,7 @@ QUnit.test( "Respect display value on inline elements (trac-14824)", function( a
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		} );

		clock.tick( 10 );
} );

QUnit.test( "Respect display value on inline elements (trac-14824)", function( assert ) {
	assert.expect( 2 );

	var clock = this.clock,
		fromStyleSheet = jQuery( "<span id='span-14824'></span>" ),
		fromStyleAttr = jQuery( "<span style='display: block;'></span>" );

	jQuery( "#qunit-fixture" ).append( fromStyleSheet, fromStyleAttr );

	fromStyleSheet.slideUp( function() {
		jQuery( this ).slideDown( function() {
			assert.equal( jQuery( this ).css( "display" ), "block",
				"Respect previous display value (from stylesheet) on span element" );
		} );
	} );

	fromStyleAttr.slideUp( function() {
		jQuery( this ).slideDown( function() {
			assert.equal( jQuery( this ).css( "display" ), "block",
				"Respect previous display value (from style attribute) on span element" );
		} );
	} );

	clock.tick( 800 );
} );

QUnit.test( "jQuery.easing._default (gh-2218)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2383,7 +2363,7 @@ jQuery( "#foo" )
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
} );

QUnit.test( "jQuery.easing._default (gh-2218)", function( assert ) {
	assert.expect( 2 );

	jQuery( "#foo" )
		.animate( { width: "5px" }, {
			duration: 5,
			start: function( anim ) {
				assert.equal( anim.opts.easing, jQuery.easing._default,
					"anim.opts.easing should be equal to jQuery.easing._default when the easing argument is not given" );
			}
		} )
		.animate( { height: "5px" }, {
			duration: 5,
			easing: "linear",
			start: function( anim ) {
				assert.equal( anim.opts.easing, "linear",
					"anim.opts.easing should be equal to the easing argument" );
			}
		} )
		.stop();

	this.clock.tick( 25 );
} );

QUnit.test( "jQuery.easing._default in Animation (gh-2218", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -2411,7 +2391,7 @@ 	jQuery.easing.custom = function( p ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		defaultEasing = jQuery.easing._default,
		called = false,
		testObject = { "width": 100 },
		testDest = { "width": 200 };

	jQuery.easing.custom = function( p ) {
		called = true;
		return p;
	};
	jQuery.easing._default = "custom";

	animation = jQuery.Animation( testObject, testDest, { "duration": 1 } );
	animation.done( function() {
		assert.equal( testObject.width, testDest.width, "Animated width" );
		assert.ok( called, "Custom jQuery.easing._default called" );
		assert.strictEqual( animation.opts.easing, "custom",
			"Animation used custom jQuery.easing._default" );
		jQuery.easing._default = defaultEasing;
		delete jQuery.easing.custom;
	} );

	this.clock.tick( 10 );
} );

QUnit.test( "jQuery.easing._default in Tween (gh-2218)", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -2464,7 +2444,7 @@ QUnit.test( "Show/hide/toggle and display: inline", function( assert ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		div.remove();
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "Show/hide/toggle and display: inline", function( assert ) {
	assert.expect( 40 );

	var clock = this.clock;

	jQuery( "<span></span><div style='display:inline' title='inline div'></div>" ).each( function() {
		var completed, interrupted,
			N = 100,
			fixture = jQuery( "#qunit-fixture" ),
			$el = jQuery( this ),
			kind = this.title || this.nodeName.toLowerCase();

diff --git a/a.js b/b.js
@@ -2530,7 +2510,7 @@ function testEasing( assert, speed, easing, complete ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
				kind + " display is not inline-block after " + call + "+toggle" );
		} );
	} );
} );

function testEasing( assert, speed, easing, complete ) {
	assert.expect( 4 );
	var options = jQuery.speed( speed, easing, complete );

	assert.equal( options.duration, 10, "Duration set properly" );
	assert.equal(
		typeof options.easing === "function" ? options.easing() : options.easing,
		"linear",
		"Easing set properly"
diff --git a/a.js b/b.js
@@ -2541,7 +2521,7 @@ function testEasing( assert, speed, easing, complete ) {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
				kind + " display is not inline-block after " + call + "+toggle" );
		} );
	} );
} );

function testEasing( assert, speed, easing, complete ) {
	assert.expect( 4 );
	var options = jQuery.speed( speed, easing, complete );

	assert.equal( options.duration, 10, "Duration set properly" );
	assert.equal(
		typeof options.easing === "function" ? options.easing() : options.easing,
		"linear",
		"Easing set properly"
	);
	assert.equal( options.queue, "fx", "Queue defaults to fx" );
	options.complete();
}

QUnit.test( "jQuery.speed( speed, easing, complete )", function( assert ) {
	testEasing( assert, 10, "linear", function() {
		assert.ok( true, "Complete called" );
	} );
} );

diff --git a/a.js b/b.js
@@ -2549,7 +2529,7 @@ testEasing( assert, 10, "linear", function() {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
	assert.equal( options.queue, "fx", "Queue defaults to fx" );
	options.complete();
}

QUnit.test( "jQuery.speed( speed, easing, complete )", function( assert ) {
	testEasing( assert, 10, "linear", function() {
		assert.ok( true, "Complete called" );
	} );
} );

QUnit.test( "jQuery.speed( speed, easing, complete ) - with easing function", function( assert ) {
	testEasing(
		assert,
		10,
		function() {
			return "linear";
		},
		function() {
diff --git a/a.js b/b.js
@@ -2561,7 +2541,7 @@ testEasing(
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		assert.ok( true, "Complete called" );
	} );
} );

QUnit.test( "jQuery.speed( speed, easing, complete ) - with easing function", function( assert ) {
	testEasing(
		assert,
		10,
		function() {
			return "linear";
		},
		function() {
			assert.ok( true, "Complete called" );
		}
	);
} );

QUnit.test( "jQuery.speed( options )", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: "linear",
		complete: function() {
			assert.ok( true, "Complete called" );
		}
diff --git a/a.js b/b.js
@@ -2571,7 +2551,7 @@ testEasing( assert, {
A blob:f75ff481addc448debaaffcb942a55bcb669c1fd
		}
	);
} );

QUnit.test( "jQuery.speed( options )", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: "linear",
		complete: function() {
			assert.ok( true, "Complete called" );
		}
	} );
} );

QUnit.test( "jQuery.speed( options ) - with easing function", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: function() {
			return "linear";
		},
		complete: function() {
diff --git a/a.js b/b.js
@@ -11,15 +11,12 @@
A blob:9367978774d2cfaf6f94527e10a7926de94237d0

var oldRaf = window.requestAnimationFrame;

QUnit.module( "tween", {
	beforeEach: function() {
		this.sandbox = sinon.createSandbox();
		this.clock = this.sandbox.useFakeTimers( 505877050 );
		this._oldInterval = jQuery.fx.interval;
		window.requestAnimationFrame = null;
		jQuery.fx.step = {};
		jQuery.fx.interval = 10;
	},
	afterEach: function() {
		this.sandbox.restore();
		jQuery.fx.stop();
		jQuery.fx.interval = this._oldInterval;
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );
diff --git a/a.js b/b.js
@@ -1456,7 +1456,13 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:115d3117da5b02d0181d573ff4a445a323074b5d
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid XML not detected" );
	} catch ( e ) {
		assert.ok( e.message.indexOf( "Invalid XML:" ) === 0, "invalid XML detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
		xml = jQuery.parseXML();
		assert.strictEqual( xml, null, "undefined string => null document" );
		xml = jQuery.parseXML( null );
		assert.strictEqual( xml, null, "null string => null document" );
		xml = jQuery.parseXML( true );
		assert.strictEqual( xml, null, "non-string => null document" );
	} catch ( e ) {
		assert.ok( false, "empty input throws exception" );
	}
} );

// Support: IE 11+
// IE throws an error when parsing invalid XML instead of reporting the error
// in a `parsererror` element, skip the test there.
QUnit.testUnlessIE( "jQuery.parseXML - error reporting", function( assert ) {
	assert.expect( 2 );

	var errorArg, lineMatch, line, columnMatch, column;

	sinon.stub( jQuery, "error" );

	jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
	errorArg = jQuery.error.firstCall.lastArg.toLowerCase();
	console.log( "errorArg", errorArg );

	lineMatch = errorArg.match( /line\s*(?:number)?\s*(\d+)/ );
	line = lineMatch && lineMatch[ 1 ];
	columnMatch = errorArg.match( /column\s*(\d+)/ );
	column = columnMatch && columnMatch[ 1 ];

	assert.strictEqual( line, "1", "reports error line" );
	assert.strictEqual( column, "11", "reports error column" );
} );

testIframe(
	"document ready when jQuery loaded asynchronously (trac-13655)",
diff --git a/a.js b/b.js
@@ -20,8 +20,7 @@ function classesToArray( value ) {
A blob:796fbcc808ca15bbe771f8c9c1a7bab3388f6128

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( typeof value === "function" ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
diff --git a/a.js b/b.js
@@ -29,36 +28,35 @@ addClass: function( value ) {
A blob:796fbcc808ca15bbe771f8c9c1a7bab3388f6128
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( typeof value === "function" ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( typeof value === "function" ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
diff --git a/a.js b/b.js
@@ -70,38 +68,40 @@ removeClass: function( value ) {
A blob:796fbcc808ca15bbe771f8c9c1a7bab3388f6128
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( typeof value === "function" ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		if ( typeof value === "function" ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
diff --git a/a.js b/b.js
@@ -115,24 +115,28 @@ toggleClass: function( value, stateVal ) {
A blob:796fbcc808ca15bbe771f8c9c1a7bab3388f6128
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		if ( typeof value === "function" ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		return this.each( function() {
			var className, i, self, classNames;

			// Toggle individual class names
			i = 0;
			self = jQuery( this );
			classNames = classesToArray( value );

			while ( ( className = classNames[ i++ ] ) ) {

				// Check each className given, space separated list
				if ( self.hasClass( className ) ) {
					self.removeClass( className );
				} else {
					self.addClass( className );
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
diff --git a/a.js b/b.js
@@ -1644,6 +1644,44 @@ QUnit.test( "addClass, removeClass, hasClass on elements with classes with non-H
A blob:98fae06c7efb8a056becb75e3d47033462996a2e
	assert.equal( elem[ 2 ].className, "hi", "Check removal of two classes" );

	assert.ok( elem.hasClass( "hi" ), "Check has1" );
} );

QUnit.test( "addClass, removeClass, hasClass on elements with classes with non-HTML whitespace (gh-3072, gh-3003)", function( assert ) {
	assert.expect( 9 );

	var $elem = jQuery( "<div class='&#xA0;test'></div>" );

	function testMatches() {
		assert.ok( $elem.is( ".\\A0 test" ), "Element matches with collapsed space" );
		assert.ok( $elem.is( ".\\A0test" ), "Element matches with non-breaking space" );
		assert.ok( $elem.hasClass( "\xA0test" ), "Element has class with non-breaking space" );
	}

	testMatches();
	$elem.addClass( "foo" );
	testMatches();
	$elem.removeClass( "foo" );
	testMatches();
} );

QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div><span class='foo'></span><!-- comment -->text</div>" ),
diff --git a/a.js b/b.js
@@ -1,6 +1,7 @@
A blob:127cc70683fc62ce96fb8f15176e8f64fe4bb3ff
import jQuery from "../core.js";
import document from "../var/document.js";
import sort from "../var/sort.js";

var hasDuplicate;

// Document order sorting
diff --git a/a.js b/b.js
@@ -80,7 +81,7 @@ jQuery.uniqueSort = function( results ) {
A blob:127cc70683fc62ce96fb8f15176e8f64fe4bb3ff

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	hasDuplicate = false;

	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
diff --git a/a.js b/b.js
@@ -1895,9 +1895,7 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:6cf288c19b8eb17de0b3819d37fc5dd4cc141768
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
diff --git a/a.js b/b.js
@@ -1959,8 +1957,12 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:6cf288c19b8eb17de0b3819d37fc5dd4cc141768
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
		body = document.body,
		fixture = document.getElementById( "qunit-fixture" ),
		detached1 = document.createElement( "p" ),
		detached2 = document.createElement( "ul" ),
		detachedChild = detached1.appendChild( document.createElement( "a" ) ),
		detachedGrandchild = detachedChild.appendChild( document.createElement( "b" ) );

	for ( i = 0; i < 12; i++ ) {
		detached.push( document.createElement( "li" ) );
		detached[ i ].id = "detached" + i;
		detached2.appendChild( document.createElement( "li" ) ).id = "detachedChild" + i;
	}

	tests = {
		"Empty": {
			input: [],
			expected: []
		},
		"Single-element": {
			input: [ fixture ],
			expected: [ fixture ]
		},
		"No duplicates": {
			input: [ fixture, body ],
			expected: [ body, fixture ]
		},
		"Duplicates": {
			input: [ body, fixture, fixture, body ],
			expected: [ body, fixture ]
		},
		"Detached": {
			input: detached.slice( 0 ),
			expected: detached.slice( 0 )
		},
		"Detached children": {
			input: [
				detached2.childNodes[ 3 ],
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 1 ]
			],
			expected: [
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 1 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 3 ]
			]
		},
		"Attached/detached mixture": {
			input: [ detached1, fixture, detached2, document, detachedChild, body, detachedGrandchild ],
			expected: [ document, body, fixture ],
			length: 3
		}
	};

	jQuery.each( tests, function( label, test ) {
		var length = test.length || test.input.length;
		assert.deepEqual( jQuery.uniqueSort( test.input ).slice( 0, length ), test.expected, label + " (array)" );
		assert.deepEqual( jQuery.uniqueSort( new Arrayish( test.input ) ).slice( 0, length ), test.expected, label + " (quasi-array)" );
	} );
} );

testIframe(
diff --git a/a.js b/b.js
@@ -2770,8 +2770,8 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
A blob:39fb95be0ddf5c8da2ceb90f9657fcde8e36d9e6
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (trac-14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (trac-14773)
	// Selector should include any valid non-HTML whitespace (trac-3003)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with non-HTML whitespace(trac-3003) )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #whitespace\\\\xA0 ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
diff --git a/a.js b/b.js
@@ -817,7 +817,7 @@ 	callback = function( v, k ) {
A blob:fc40dd9520516f69c3629058c60d7b152547cd19
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (trac-2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
	assert.equal( result.length, 3, "Array flatten only one level down" );
	assert.ok( Array.isArray( result[ 0 ] ), "Array flatten only one level down" );

	// Support: IE 11+
	// IE doesn't have Array#flat so it'd fail the test.
	if ( !QUnit.isIE ) {
		result = jQuery.map( Array( 300000 ), function( v, k ) {
			return k;
		} );
		assert.equal( result.length, 300000, "Able to map 300000 records without any problems (trac-4320)" );
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );
diff --git a/a.js b/b.js
@@ -1456,7 +1456,13 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:fc40dd9520516f69c3629058c60d7b152547cd19
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid XML not detected" );
	} catch ( e ) {
		assert.ok( e.message.indexOf( "Invalid XML:" ) === 0, "invalid XML detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
		xml = jQuery.parseXML();
		assert.strictEqual( xml, null, "undefined string => null document" );
		xml = jQuery.parseXML( null );
		assert.strictEqual( xml, null, "null string => null document" );
		xml = jQuery.parseXML( true );
		assert.strictEqual( xml, null, "non-string => null document" );
	} catch ( e ) {
		assert.ok( false, "empty input throws exception" );
	}
} );

// Support: IE 11+
// IE throws an error when parsing invalid XML instead of reporting the error
// in a `parsererror` element, skip the test there.
QUnit.testUnlessIE( "jQuery.parseXML - error reporting", function( assert ) {
	assert.expect( 2 );

	var errorArg, lineMatch, line, columnMatch, column;

	sinon.stub( jQuery, "error" );

	jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
	errorArg = jQuery.error.firstCall.lastArg.toLowerCase();
	console.log( "errorArg", errorArg );

	lineMatch = errorArg.match( /line\s*(?:number)?\s*(\d+)/ );
	line = lineMatch && lineMatch[ 1 ];
	columnMatch = errorArg.match( /column\s*(\d+)/ );
	column = columnMatch && columnMatch[ 1 ];

	assert.strictEqual( line, "1", "reports error line" );
	assert.strictEqual( column, "11", "reports error column" );
} );

testIframe(
	"document ready when jQuery loaded asynchronously (trac-13655)",
diff --git a/a.js b/b.js
@@ -1182,7 +1182,7 @@ QUnit.test( "percentage properties for left and top should be transformed to pix
A blob:0c1e43dec7fd82c9cb388e34566aa82ad0df3242
		assert.ok( div.css( "background-position" ), "can't get background-position in IE<9, see trac-10796" );
	}
} );

if ( jQuery.fn.offset ) {
	QUnit.test( "percentage properties for left and top should be transformed to pixels, see trac-9505", function( assert ) {
		assert.expect( 2 );
		var parent = jQuery( "<div style='position:relative;width:200px;height:200px;margin:0;padding:0;border-width:0'></div>" ).appendTo( "#qunit-fixture" ),
			div = jQuery( "<div style='position: absolute; width: 20px; height: 20px; top:50%; left:50%'></div>" ).appendTo( parent );

		assert.equal( div.css( "top" ), "100px", "position properties not transformed to pixels, see trac-9505" );
		assert.equal( div.css( "left" ), "100px", "position properties not transformed to pixels, see trac-9505" );
	} );
}

QUnit.test( "Do not append px (trac-9548, trac-12990, trac-2792)", function( assert ) {
	assert.expect( 4 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -290,7 +290,7 @@ QUnit.test( "data-* attributes", function( assert ) {
A blob:49a3500ac330ed6fddf24652c22eaee858ee4f0b

	assert.equal( $divs.eq( 0 ).data( "type" ), "bar", "Correct updated value" );
	assert.equal( $divs.eq( 1 ).data( "type" ), "foo", "Original value retained" );
} );

QUnit.test( "data-* attributes", function( assert ) {
	assert.expect( 46 );

	var prop, i, l, metadata, elem,
		obj, obj2, check, num, num2,
		parseJSON = JSON.parse,
		div = jQuery( "<div>" ),
		child = jQuery( "<div data-myobj='old data' data-ignored=\"DOM\" data-other='test' data-foo-42='boosh'></div>" ),
		dummy = jQuery( "<div data-myobj='old data' data-ignored=\"DOM\" data-other='test' data-foo-42='boosh'></div>" );

	assert.equal( div.data( "attr" ), undefined, "Check for non-existing data-attr attribute" );

	div.attr( "data-attr", "exists" );
	assert.equal( div.data( "attr" ), "exists", "Check for existing data-attr attribute" );

	div.attr( "data-attr", "exists2" );
	assert.equal( div.data( "attr" ), "exists", "Check that updates to data- don't update .data()" );

	div.data( "attr", "internal" ).attr( "data-attr", "external" );
	assert.equal( div.data( "attr" ), "internal", "Check for .data('attr') precedence (internal > external data-* attribute)" );

	div.remove();

	child.appendTo( "#qunit-fixture" );
	assert.equal( child.data( "myobj" ), "old data", "Value accessed from data-* attribute" );
	assert.equal( child.data( "foo-42" ), "boosh", "camelCasing does not affect numbers (trac-1751)" );

	child.data( "myobj", "replaced" );
	assert.equal( child.data( "myobj" ), "replaced", "Original data overwritten" );

diff --git a/a.js b/b.js
@@ -5,7 +5,8 @@
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
( function() {

// Can't test what ain't there
if ( !jQuery.fx ) {
	return;
}

var oldRaf = window.requestAnimationFrame,
	hideOptions = {
		inline: function() { jQuery.style( this, "display", "none" ); },
		cascade: function() { this.className = "hidden"; }
	};
diff --git a/a.js b/b.js
@@ -15,15 +16,12 @@
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		cascade: function() { this.className = "hidden"; }
	};

QUnit.module( "effects", {
	beforeEach: function() {
		this.sandbox = sinon.createSandbox();
		this.clock = this.sandbox.useFakeTimers( 505877050 );
		this._oldInterval = jQuery.fx.interval;
		window.requestAnimationFrame = null;
		jQuery.fx.step = {};
		jQuery.fx.interval = 10;
	},
	afterEach: function() {
		this.sandbox.restore();
		jQuery.fx.stop();
		jQuery.fx.interval = this._oldInterval;
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );
diff --git a/a.js b/b.js
@@ -160,9 +158,9 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See trac-14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
diff --git a/a.js b/b.js
@@ -172,7 +170,7 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See trac-14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
					expected === "inline" ? "inline-block" : expected,
					"Correct display type during animation for " + selector
				);
			} );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal( jQuery( this ).css( "display" ), expected,
					"Correct display type after animation for " + selector );
diff --git a/a.js b/b.js
@@ -203,17 +201,17 @@ QUnit.test( "Persist correct display value - " + type + " hidden", function( ass
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );
} );

// Supports trac-7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='show-tests'><span style='position:absolute;'>foo</span></div>" )
			.appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		var $span = jQuery( "#show-tests span" ),
			displayNone = $span.css( "display" ),
			display = "",
			clock = this.clock;

		$span.show();

		display = $span.css( "display" );

		$span.hide();

		$span.fadeIn( 100, function() {
			assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
			$span.fadeOut( 100, function() {
				assert.equal( $span.css( "display" ), displayNone, "Expecting display: " + displayNone );
				$span.fadeIn( 100, function() {
					assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );

	// Support: IE 11+
	// IE doesn't support Shadow DOM.
diff --git a/a.js b/b.js
@@ -235,17 +233,17 @@ QUnit.test( "Persist correct display value - " + type + " hidden", function( ass
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );
} );

// Supports trac-7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='show-tests'><span style='position:absolute;'>foo</span></div>" )
			.appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		var $span = jQuery( "#show-tests span" ),
			displayNone = $span.css( "display" ),
			display = "",
			clock = this.clock;

		$span.show();

		display = $span.css( "display" );

		$span.hide();

		$span.fadeIn( 100, function() {
			assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
			$span.fadeOut( 100, function() {
				assert.equal( $span.css( "display" ), displayNone, "Expecting display: " + displayNone );
				$span.fadeIn( 100, function() {
					assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );

	// Support: IE 11+
	// IE doesn't support Shadow DOM.
	QUnit.testUnlessIE(
		"Persist correct display value - " + type + " hidden, shadow child", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );

		var shadowHost = document.querySelector( "#shadowHost" );
		var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
		shadowRoot.innerHTML = "<style>.hidden{display: none;}</style>" +
			"<span id='shadowChild' class='hidden'></span>";
		var shadowChild = shadowRoot.querySelector( "#shadowChild" );

		var $shadowChild = jQuery( shadowChild );
		var displayNone = "none";
		var display = "inline";
		var clock = this.clock;

		$shadowChild.fadeIn( 100, function() {
			assert.equal( $shadowChild.css( "display" ), display, "Expecting shadow display: " + display );
			$shadowChild.fadeOut( 100, function() {
				assert.equal( $shadowChild.css( "display" ), displayNone, "Expecting shadow display: " + displayNone );
				$shadowChild.fadeIn( 100, function() {
					assert.equal( $shadowChild.css( "display" ), display, "Expecting shadow display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );
} );

QUnit.test( "animate(Hash, Object, Function)", function( assert ) {
diff --git a/a.js b/b.js
@@ -284,7 +282,7 @@ QUnit.test( "animate relative values", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	jQuery( "#foo" ).animate( hash, 0, function() {
		assert.equal( hash.opacity, hashCopy.opacity, "Check if animate changed the hash parameter" );
	} );
} );

QUnit.test( "animate relative values", function( assert ) {

	var value = 40,
		clock = this.clock,
		bases = [ "%", "px", "em" ],
		adjustments = [ "px", "em" ],
		container = jQuery( "<div></div>" )
			.css( { position: "absolute", height: "50em", width: "50em" } ),
		animations = bases.length * adjustments.length;

	assert.expect( 2 * animations );

	jQuery.each( bases, function( _, baseUnit ) {
		jQuery.each( adjustments, function( _, adjustUnit ) {
			var base = value + baseUnit,
				adjust = { height: "+=2" + adjustUnit, width: "-=2" + adjustUnit },
				elem = jQuery( "<div></div>" )
					.appendTo( container.clone().appendTo( "#qunit-fixture" ) )
					.css( {
						position: "absolute",
						height: base,
						width: value + adjustUnit
					} ),
				baseScale = elem[ 0 ].offsetHeight / value,
				adjustScale = elem[ 0 ].offsetWidth / value;

			elem.css( "width", base ).animate( adjust, 100, function() {
				assert.equal( this.offsetHeight, value * baseScale + 2 * adjustScale,
					baseUnit + "+=" + adjustUnit );
				assert.equal( this.offsetWidth, value * baseScale - 2 * adjustScale,
					baseUnit + "-=" + adjustUnit );
diff --git a/a.js b/b.js
@@ -292,52 +290,52 @@ QUnit.test( "animate relative values", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	jQuery( "#foo" ).animate( hash, 0, function() {
		assert.equal( hash.opacity, hashCopy.opacity, "Check if animate changed the hash parameter" );
	} );
} );

QUnit.test( "animate relative values", function( assert ) {

	var value = 40,
		clock = this.clock,
		bases = [ "%", "px", "em" ],
		adjustments = [ "px", "em" ],
		container = jQuery( "<div></div>" )
			.css( { position: "absolute", height: "50em", width: "50em" } ),
		animations = bases.length * adjustments.length;

	assert.expect( 2 * animations );

	jQuery.each( bases, function( _, baseUnit ) {
		jQuery.each( adjustments, function( _, adjustUnit ) {
			var base = value + baseUnit,
				adjust = { height: "+=2" + adjustUnit, width: "-=2" + adjustUnit },
				elem = jQuery( "<div></div>" )
					.appendTo( container.clone().appendTo( "#qunit-fixture" ) )
					.css( {
						position: "absolute",
						height: base,
						width: value + adjustUnit
					} ),
				baseScale = elem[ 0 ].offsetHeight / value,
				adjustScale = elem[ 0 ].offsetWidth / value;

			elem.css( "width", base ).animate( adjust, 100, function() {
				assert.equal( this.offsetHeight, value * baseScale + 2 * adjustScale,
					baseUnit + "+=" + adjustUnit );
				assert.equal( this.offsetWidth, value * baseScale - 2 * adjustScale,
					baseUnit + "-=" + adjustUnit );

			} );

			clock.tick( 100 );
		} );
	} );
} );

QUnit.test( "animate negative height", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { height: -100 }, 100, function() {
		assert.equal( this.offsetHeight, 0, "Verify height." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative margin", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { "marginTop": -100 }, 100, function() {
		assert.equal( jQuery( this ).css( "marginTop" ), "-100px", "Verify margin." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative margin with px", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { marginTop: "-100px" }, 100, function() {
		assert.equal( jQuery( this ).css( "marginTop" ), "-100px", "Verify margin." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative padding", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { "paddingBottom": -100 }, 100, function() {
		assert.equal( jQuery( this ).css( "paddingBottom" ), "0px", "Verify paddingBottom." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate block as inline width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "#foo" ).css( { display: "inline", width: "", height: "" } ).animate( { width: 42, height: 42 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "inline-block", "inline-block was set on non-floated inline element when animating width/height" );
		assert.equal( this.offsetWidth, 42, "width was animated" );
		assert.equal( this.offsetHeight, 42, "height was animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate native inline width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -346,12 +344,12 @@ QUnit.test( "animate native inline width/height", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( this.offsetHeight, 42, "height was animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate native inline width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "#foo" ).css( { display: "", width: "", height: "" } )
		.append( "<span>text</span>" )
		.children( "span" )
			.animate( { width: 42, height: 42 }, 100, function() {
				assert.equal( jQuery( this ).css( "display" ), "inline-block", "inline-block was set on non-floated inline element when animating width/height" );
				assert.equal( this.offsetWidth, 42, "width was animated" );
				assert.equal( this.offsetHeight, 42, "height was animated" );
			} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -366,7 +364,7 @@ jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
		display: "block",
		width: 20,
		height: 20,
		paddingLeft: 60
	} ).animate( {
		width: 42,
		height: 42
	}, {
		duration: 100,
		step: function() {
			if ( jQuery( this ).width() > 42 ) {
				assert.ok( false, "width was incorrectly augmented during animation" );
			}
diff --git a/a.js b/b.js
@@ -378,16 +376,16 @@ jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
		display: "block",
		width: 20,
		height: 20,
		paddingLeft: 60
	} ).animate( {
		width: 42,
		height: 42
	}, {
		duration: 100,
		step: function() {
			if ( jQuery( this ).width() > 42 ) {
				assert.ok( false, "width was incorrectly augmented during animation" );
			}
		},
		complete: function() {
			assert.equal( jQuery( this ).css( "display" ), "block", "inline-block was not set on block element when animating width/height" );
			assert.equal( jQuery( this ).width(), 42, "width was animated" );
			assert.equal( jQuery( this ).height(), 42, "height was animated" );
		}
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table width/height", function( assert ) {
	assert.expect( 1 );

	jQuery( "#table" ).animate( { width: 42, height: 42 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table", "display mode is correct" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-row width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -397,12 +395,12 @@ QUnit.test( "animate table-row width/height", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( jQuery( this ).css( "display" ), "table", "display mode is correct" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-row width/height", function( assert ) {
	assert.expect( 3 );
	var tr = jQuery( "#table" )
			.attr( { "cellspacing": 0, "cellpadding": 0, "border": 0 } )
			.html( "<tr style='height:42px;'><td style='padding:0;'><div style='width:20px;height:20px;'></div></td></tr>" )
			.find( "tr" );

	tr.animate( { width: 10, height: 10 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table-row", "display mode is correct" );
		assert.equal( this.offsetWidth, 20, "width animated to shrink wrap point" );
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-cell width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -413,12 +411,12 @@ QUnit.test( "animate table-cell width/height", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-cell width/height", function( assert ) {
	assert.expect( 3 );

	var td = jQuery( "#table" )
			.attr( { "cellspacing": 0, "cellpadding": 0, "border": 0 } )
			.html( "<tr><td style='width:42px;height:42px;padding:0;'><div style='width:20px;height:20px;'></div></td></tr>" )
			.find( "td" );

	td.animate( { width: 10, height: 10 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table-cell", "display mode is correct" );
		assert.equal( this.offsetWidth, 20, "width animated to shrink wrap point" );
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate percentage(%) on width/height", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -427,46 +425,25 @@ QUnit.test( "animate percentage(%) on width/height", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate percentage(%) on width/height", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div style='position:absolute;top:-999px;left:-999px;width:60px;height:60px;'><div style='width:50%;height:50%;'></div></div>" )
		.appendTo( "#qunit-fixture" ).children( "div" );

	$div.animate( { width: "25%", height: "25%" }, 13, function() {
		var $this = jQuery( this );
		assert.equal( $this.css( "width" ), "15px", "Width was animated to 15px rather than 25px" );
		assert.equal( $this.css( "height" ), "15px", "Height was animated to 15px rather than 25px" );
	} );
	this.clock.tick( 20 );
} );

QUnit.test( "animate resets overflow-x and overflow-y when finished", function( assert ) {
	assert.expect( 2 );
	jQuery( "#foo" )
		.css( { display: "block", width: 20, height: 20, overflowX: "visible", overflowY: "auto" } )
		.animate( { width: 42, height: 42 }, 100, function() {
			assert.equal( this.style.overflowX, "visible", "overflow-x is visible" );
			assert.equal( this.style.overflowY, "auto", "overflow-y is auto" );
		} );
	this.clock.tick( 100 );
} );

/* // This test ends up being flaky depending upon the CPU load
QUnit.test("animate option (queue === false)", function( assert ) {
	var done = assert.async();
	assert.expect(1);

	var order = [];

	var $foo = jQuery("#foo");
	$foo.animate({width:"100px"}, 3000, function () {
		// should finish after unqueued animation so second
		order.push(2);
		assert.deepEqual( order, [ 1, 2 ], "Animations finished in the correct order" );
		done();
	});
	$foo.animate({fontSize:"2em"}, {queue:false, duration:10, complete:function () {
		// short duration and out of queue so should finish first
		order.push(1);
	}});
});
*/

QUnit.test( "animate option { queue: false }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

diff --git a/a.js b/b.js
@@ -475,12 +452,12 @@ QUnit.test( "animate option { queue: false }", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		order.push(1);
	}});
});
*/

QUnit.test( "animate option { queue: false }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: false,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

diff --git a/a.js b/b.js
@@ -493,7 +470,7 @@ QUnit.test( "animate option { queue: true }", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

QUnit.test( "animate option { queue: true }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: true,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );
diff --git a/a.js b/b.js
@@ -502,7 +479,7 @@ QUnit.test( "animate option { queue: true }", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

QUnit.test( "animate option { queue: true }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: true,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );

	assert.notEqual( foo.queue().length, 0, "Default queue is not empty" );

	//clear out existing timers before next test
	this.clock.tick( 10 );
} );

QUnit.test( "animate option { queue: 'name' }", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -533,7 +510,7 @@ QUnit.test( "animate option { queue: 'name' }", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

	//clear out existing timers before next test
	this.clock.tick( 10 );
} );

QUnit.test( "animate option { queue: 'name' }", function( assert ) {
	assert.expect( 5 );
	var foo = jQuery( "#foo" ),
		origWidth = parseFloat( foo.css( "width" ) ),
		order = [];

	foo.animate( { width: origWidth + 100 }, {
		queue: "name",
		duration: 1,
		complete: function() {

			// second callback function
			order.push( 2 );
			assert.equal( parseFloat( foo.css( "width" ) ), origWidth + 100, "Animation ended" );
			assert.equal( foo.queue( "name" ).length, 1, "Queue length of 'name' queue" );
		}
	} ).queue( "name", function() {

		// last callback function
		assert.deepEqual( order, [ 1, 2 ], "Callbacks in expected order" );
	} );

	// this is the first callback function that should be called
	order.push( 1 );
	assert.equal( parseFloat( foo.css( "width" ) ), origWidth, "Animation does not start on its own." );
	assert.equal( foo.queue( "name" ).length, 2, "Queue length of 'name' queue" );

	foo.dequeue( "name" );
	this.clock.tick( 10 );

} );

QUnit.test( "animate with no properties", function( assert ) {
diff --git a/a.js b/b.js
@@ -553,10 +530,10 @@ QUnit.test( "animate with no properties", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	foo.dequeue( "name" );
	this.clock.tick( 10 );

} );

QUnit.test( "animate with no properties", function( assert ) {
	assert.expect( 2 );

	var foo,
		divs = jQuery( "div" ),
		count = 0;

	divs.animate( {}, function() {
		count++;
	} );

	assert.equal( divs.length, count, "Make sure that callback is called for each element in the set." );

	foo = jQuery( "#foo" );

	foo.animate( {} );
	foo.animate( { top: 10 }, 100, function() {
		assert.ok( true, "Animation was properly dequeued." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate duration 0", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -589,13 +566,13 @@ QUnit.test( "animate duration 0", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.ok( true, "Animation was properly dequeued." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate duration 0", function( assert ) {
	assert.expect( 11 );

	var $elem,
		$elems = jQuery( [ { a:0 }, { a:0 } ] ),
		counter = 0;

	assert.equal( jQuery.timers.length, 0, "Make sure no animation was running from another test" );

	$elems.eq( 0 ).animate( { a:1 }, 0, function() {
		assert.ok( true, "Animate a simple property." );
		counter++;
	} );

	// Failed until [6115]
	assert.equal( jQuery.timers.length, 0, "Make sure synchronic animations are not left on jQuery.timers" );

	assert.equal( counter, 1, "One synchronic animations" );

	$elems.animate( { a:2 }, 0, function() {
		assert.ok( true, "Animate a second simple property." );
		counter++;
	} );

	assert.equal( counter, 3, "Multiple synchronic animations" );

	$elems.eq( 0 ).animate( { a:3 }, 0, function() {
		assert.ok( true, "Animate a third simple property." );
		counter++;
	} );
	$elems.eq( 1 ).animate( { a:3 }, 200, function() {
		counter++;

		// Failed until [6115]
		assert.equal( counter, 5, "One synchronic and one asynchronic" );
	} );
	this.clock.tick( 200 );

	$elem = jQuery( "<div></div>" );
	$elem.show( 0, function() {
		assert.ok( true, "Show callback with no duration" );
diff --git a/a.js b/b.js
@@ -614,12 +591,12 @@ QUnit.test( "animate hyphenated properties", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

	// manually clean up detached elements
	$elem.remove();
} );

QUnit.test( "animate hyphenated properties", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" )
		.css( "font-size", 10 )
		.animate( { "font-size": 20 }, 200, function() {
			assert.equal( this.style.fontSize, "20px", "The font-size property was animated." );
		} );

	// FIXME why is this double only when run with other tests
	this.clock.tick( 400 );

} );

QUnit.test( "animate non-element", function( assert ) {
diff --git a/a.js b/b.js
@@ -628,10 +605,10 @@ QUnit.test( "animate non-element", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	// FIXME why is this double only when run with other tests
	this.clock.tick( 400 );

} );

QUnit.test( "animate non-element", function( assert ) {
	assert.expect( 1 );

	var obj = { test: 0 };

	jQuery( obj ).animate( { test: 200 }, 200, function() {
		assert.equal( obj.test, 200, "The custom property should be modified." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "animate non-element's zIndex without appending \"px\"", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -639,10 +616,10 @@ QUnit.test( "animate non-element's zIndex without appending \"px\"", function( a
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( obj.test, 200, "The custom property should be modified." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "animate non-element's zIndex without appending \"px\"", function( assert ) {
	assert.expect( 1 );

	var obj = { zIndex: 0 };

	jQuery( obj ).animate( { zIndex: 200 }, 200, function() {
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -654,9 +631,9 @@ QUnit.test( "stop()", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

diff --git a/a.js b/b.js
@@ -664,7 +641,7 @@ QUnit.test( "stop()", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	this.clock.tick( 100 );

	$foo.removeData();
	$foo.removeData( undefined, true );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
diff --git a/a.js b/b.js
@@ -672,17 +649,17 @@ QUnit.test( "stop()", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	this.clock.tick( 100 );

	$foo.removeData();
	$foo.removeData( undefined, true );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );

	$one = jQuery( "#fadein" );
	$two = jQuery( "#show" );
	$one.fadeTo( 100, 0, function() {
		$one.stop();
	} );
	this.clock.tick( 100 );
	$two.fadeTo( 100, 0, function() {
		assert.equal( $two.css( "opacity" ), "0", "Stop does not interfere with animations on other elements (trac-6641)" );

		// Reset styles
		$one.add( $two ).css( "opacity", "" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "stop() - several in queue", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -721,12 +698,12 @@ QUnit.test( "stop(clearQueue)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	$foo.stop( true );

	assert.equal( $foo.queue().length, 0, "0 in the queue" );
} );

QUnit.test( "stop(clearQueue)", function( assert ) {
	assert.expect( 4 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { "width": "show" }, 1000 );
	$foo.animate( { "width": "hide" }, 1000 );
	$foo.animate( { "width": "show" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( true );

diff --git a/a.js b/b.js
@@ -735,7 +712,7 @@ QUnit.test( "stop(clearQueue)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	$foo.stop( true );

	assert.equal( $foo.queue().length, 0, "0 in the queue" );
} );

QUnit.test( "stop(clearQueue)", function( assert ) {
	assert.expect( 4 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { "width": "show" }, 1000 );
	$foo.animate( { "width": "hide" }, 1000 );
	$foo.animate( { "width": "show" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( true );

	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
diff --git a/a.js b/b.js
@@ -745,13 +722,13 @@ QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
	assert.expect( 1 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( false, true );

diff --git a/a.js b/b.js
@@ -761,7 +738,7 @@ QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
	assert.expect( 1 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( false, true );

	nw = $foo.css( "width" );

	// Disabled, being flaky
	//equal( nw, 1, "Stop() reset the animation" );

	this.clock.tick( 100 );

	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
diff --git a/a.js b/b.js
@@ -776,7 +753,7 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
diff --git a/a.js b/b.js
@@ -786,7 +763,7 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
	} );

	foo.animate( {
		height: 400
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, true );

	assert.equal( parseFloat( foo.css( "height" ) ), 400, "Height was stopped with gotoEnd" );
diff --git a/a.js b/b.js
@@ -795,11 +772,11 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
	} );

	foo.animate( {
		height: 400
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, true );

	assert.equal( parseFloat( foo.css( "height" ) ), 400, "Height was stopped with gotoEnd" );

	foo.animate( {
		height: 200
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, false );
	saved = parseFloat( foo.css( "height" ) );
        this.clock.tick( 500 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "toggle()", function( assert ) {
	assert.expect( 6 );
diff --git a/a.js b/b.js
@@ -894,7 +871,7 @@ QUnit.test( "Overflow and Display", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	);

	jQuery( div ).remove();
} );

QUnit.test( "Overflow and Display", function( assert ) {
	assert.expect( 4 );

	var
		testClass = jQuery.makeTest( "Overflow and Display" )
			.addClass( "overflow inline" ),
		testStyle = jQuery.makeTest( "Overflow and Display (inline style)" )
			.css( { overflow: "visible", display: "inline" } ),
		done = function() {
			assert.equal( jQuery.css( this, "overflow" ), "visible", "Overflow should be 'visible'" );
			assert.equal( jQuery.css( this, "display" ), "inline", "Display should be 'inline'" );
		};

	testClass.add( testStyle )
		.addClass( "widewidth" )
		.text( "Some sample text." )
		.before( "text before" )
		.after( "text after" )
		.animate( { opacity: 0.5 }, "slow", done );
	this.clock.tick( 600 );
} );

jQuery.each( {
	"CSS Auto": function( elem, prop ) {
diff --git a/a.js b/b.js
@@ -985,7 +962,7 @@ QUnit.test( fn + " to " + tn, function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		"0": function( elem ) {
			jQuery( elem ).addClass( "noback" );
			return 0;
		}
	}, function( tn, t ) {
		QUnit.test( fn + " to " + tn, function( assert ) {
			var num, anim,
				elem = jQuery.makeTest( fn + " to " + tn ),
				t_w = t( elem, "width" ),
				f_w = f( elem, "width" ),
				t_h = t( elem, "height" ),
				f_h = f( elem, "height" ),
				t_o = t( elem, "opacity" ),
				f_o = f( elem, "opacity" );

			if ( f_o === "" ) {
				f_o = 1;
			}

			num = 0;

			// TODO: uncrowd this
			if ( t_h === "show" ) { num++; }
			if ( t_w === "show" ) { num++; }
			if ( t_w === "hide" || t_w === "show" ) { num++; }
			if ( t_h === "hide" || t_h === "show" ) { num++; }
			if ( t_o === "hide" || t_o === "show" ) { num++; }
			if ( t_w === "hide" ) { num++; }
			if ( t_o.constructor === Number ) { num += 2; }
			if ( t_w.constructor === Number ) { num += 2; }
			if ( t_h.constructor === Number ) { num += 2; }

			assert.expect( num );

			anim = { width: t_w, height: t_h, opacity: t_o };

			elem.animate( anim, 50 );

			jQuery.when( elem ).done( function( $elem ) {
				var cur_o, cur_w, cur_h, old_h,
					elem = $elem[ 0 ];
diff --git a/a.js b/b.js
@@ -1055,7 +1032,7 @@ QUnit.test( fn + " to " + tn, function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		"0": function( elem ) {
			jQuery( elem ).addClass( "noback" );
			return 0;
		}
	}, function( tn, t ) {
		QUnit.test( fn + " to " + tn, function( assert ) {
			var num, anim,
				elem = jQuery.makeTest( fn + " to " + tn ),
				t_w = t( elem, "width" ),
				f_w = f( elem, "width" ),
				t_h = t( elem, "height" ),
				f_h = f( elem, "height" ),
				t_o = t( elem, "opacity" ),
				f_o = f( elem, "opacity" );

			if ( f_o === "" ) {
				f_o = 1;
			}

			num = 0;

			// TODO: uncrowd this
			if ( t_h === "show" ) { num++; }
			if ( t_w === "show" ) { num++; }
			if ( t_w === "hide" || t_w === "show" ) { num++; }
			if ( t_h === "hide" || t_h === "show" ) { num++; }
			if ( t_o === "hide" || t_o === "show" ) { num++; }
			if ( t_w === "hide" ) { num++; }
			if ( t_o.constructor === Number ) { num += 2; }
			if ( t_w.constructor === Number ) { num += 2; }
			if ( t_h.constructor === Number ) { num += 2; }

			assert.expect( num );

			anim = { width: t_w, height: t_h, opacity: t_o };

			elem.animate( anim, 50 );

			jQuery.when( elem ).done( function( $elem ) {
				var cur_o, cur_w, cur_h, old_h,
					elem = $elem[ 0 ];

				if ( t_w === "show" ) {
					assert.equal( $elem.css( "display" ), "block",
						"Showing, display should block: " + elem.style.display );
				}

				if ( t_w === "hide" || t_w === "show" ) {
					assert.ok( f_w === "" ? elem.style.width === f_w : elem.style.width.indexOf( f_w ) === 0, "Width must be reset to " + f_w + ": " + elem.style.width );
				}

				if ( t_h === "hide" || t_h === "show" ) {
					assert.ok( f_h === "" ? elem.style.height === f_h : elem.style.height.indexOf( f_h ) === 0, "Height must be reset to " + f_h + ": " + elem.style.height );
				}

				cur_o = jQuery.style( elem, "opacity" );

				if ( f_o !== jQuery.css( elem, "opacity" ) ) {
					f_o = f( elem, "opacity" );
				}

				if ( t_o === "hide" || t_o === "show" ) {
					assert.equal( cur_o, f_o, "Opacity must be reset to " + f_o + ": " + cur_o );
				}

				if ( t_w === "hide" ) {
					assert.equal( elem.style.display, "none", "Hiding, display should be none: " + elem.style.display );
				}

				if ( t_o.constructor === Number ) {
					assert.equal( cur_o, t_o, "Final opacity should be " + t_o + ": " + cur_o );

					assert.ok( jQuery.css( elem, "opacity" ) !== "" || cur_o === t_o, "Opacity should be explicitly set to " + t_o + ", is instead: " + cur_o );
				}

				if ( t_w.constructor === Number ) {
					assert.equal( elem.style.width, t_w + "px", "Final width should be " + t_w + ": " + elem.style.width );

					cur_w = jQuery.css( elem, "width" );

					assert.ok( elem.style.width !== "" || cur_w === t_w, "Width should be explicitly set to " + t_w + ", is instead: " + cur_w );
				}

				if ( t_h.constructor === Number ) {
					assert.equal( elem.style.height, t_h + "px", "Final height should be " + t_h + ": " + elem.style.height );

					cur_h = jQuery.css( elem, "height" );

					assert.ok( elem.style.height !== "" || cur_h === t_h, "Height should be explicitly set to " + t_h + ", is instead: " + cur_h );
				}

				if ( t_h === "show" ) {
					old_h = jQuery.css( elem, "height" );
					jQuery( elem ).append( "<br/>Some more text<br/>and some more..." );

					if ( /Auto/.test( fn ) ) {
						assert.notEqual( jQuery.css( elem, "height" ), old_h, "Make sure height is auto." );
					} else {
						assert.equal( jQuery.css( elem, "height" ), old_h, "Make sure height is not auto." );
					}
				}

				// manually remove generated element
				jQuery( elem ).remove();

			} );
			this.clock.tick( 100 );
		} );
	} );
} );

diff --git a/a.js b/b.js
@@ -1103,7 +1080,7 @@ 		getProps = function( el ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

			assert.deepEqual( getProps( this ), data, name );

			jQuery.removeData( this );
		},
		getProps = function( el ) {
			var obj = {};
			jQuery.each( props, function( i, prop ) {
				obj[ prop ] = prop === "overflow" && el.style[ prop ] || jQuery.css( el, prop );
			} );
			return obj;
		};

	assert.expect( remaining );

	setup( ".fadeOut().fadeIn()", "#fadein div" ).fadeOut( "fast" ).fadeIn( "fast", check );
	setup( ".fadeIn().fadeOut()", "#fadeout div" ).fadeIn( "fast" ).fadeOut( "fast", check );
	setup( ".hide().show()", "#show div" ).hide( "fast" ).show( "fast", check );
	setup( ".show().hide()", "#hide div" ).show( "fast" ).hide( "fast", check );
	setup( ".show().hide(easing)", "#easehide div" ).show( "fast" ).hide( "fast", "linear", check );
	setup( ".toggle().toggle() - in", "#togglein div" ).toggle( "fast" ).toggle( "fast", check );
	setup( ".toggle().toggle() - out", "#toggleout div" ).toggle( "fast" ).toggle( "fast", check );
	setup( ".toggle().toggle(easing) - out", "#easetoggleout div" ).toggle( "fast" ).toggle( "fast", "linear", check );
	setup( ".slideDown().slideUp()", "#slidedown div" ).slideDown( "fast" ).slideUp( "fast", check );
	setup( ".slideUp().slideDown()", "#slideup div" ).slideUp( "fast" ).slideDown( "fast", check );
	setup( ".slideUp().slideDown(easing)", "#easeslideup div" ).slideUp( "fast" ).slideDown( "fast", "linear", check );
	setup( ".slideToggle().slideToggle() - in", "#slidetogglein div" ).slideToggle( "fast" ).slideToggle( "fast", check );
	setup( ".slideToggle().slideToggle() - out", "#slidetoggleout div" ).slideToggle( "fast" ).slideToggle( "fast", check );
	setup( ".fadeToggle().fadeToggle() - in", "#fadetogglein div" ).fadeToggle( "fast" ).fadeToggle( "fast", check );
	setup( ".fadeToggle().fadeToggle() - out", "#fadetoggleout div" ).fadeToggle( "fast" ).fadeToggle( "fast", check );
	setup( ".fadeTo(0.5).fadeTo(1.0, easing)", "#fadeto div" ).fadeTo( "fast", 0.5 ).fadeTo( "fast", 1.0, "linear", check );

    this.clock.tick( 400 );
} );

jQuery.makeTest = function( text ) {
        var elem = jQuery( "<div></div>" )
diff --git a/a.js b/b.js
@@ -1131,15 +1108,14 @@ QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug trac-1095)", f
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
        return elem;
};

jQuery.makeTest.id = 1;

QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug trac-1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	$checkedtest.hide().show( "fast", function() {
		assert.ok( jQuery( "input[type='radio']", $checkedtest ).first().attr( "checked" ), "Check first radio still checked." );
		assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
		assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
		assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "interrupt toggle", function( assert ) {
	assert.expect( 24 );

	var env = this,
		longDuration = 2000,
		shortDuration = 500,
		remaining = 0,
		$elems = jQuery( ".chain-test" ),
		clock = this.clock,
		finish = function() {
diff --git a/a.js b/b.js
@@ -1222,7 +1198,7 @@ 	jQuery.easing._defaultTest = function( p ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	jQuery.easing._test2 = function( p ) {
		test2Called = true;
		return p;
	};

	jQuery.easing._defaultTest = function( p ) {
		defaultTestCalled = true;
		return p;
	};

	jQuery( data ).animate( props, 400, "_defaultTest", function() {
		assert.ok( test1Called, "Easing function (_test1) called" );
		assert.ok( test2Called, "Easing function (_test2) called" );
		assert.ok( defaultTestCalled, "Easing function (_default) called" );
		assert.equal( props.a[ 1 ], "_test1", "animate does not change original props (per-property easing would be lost)" );
diff --git a/a.js b/b.js
@@ -1230,7 +1206,7 @@ jQuery( data ).animate( props, 400, "_defaultTest", function() {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	jQuery.easing._defaultTest = function( p ) {
		defaultTestCalled = true;
		return p;
	};

	jQuery( data ).animate( props, 400, "_defaultTest", function() {
		assert.ok( test1Called, "Easing function (_test1) called" );
		assert.ok( test2Called, "Easing function (_test2) called" );
		assert.ok( defaultTestCalled, "Easing function (_default) called" );
		assert.equal( props.a[ 1 ], "_test1", "animate does not change original props (per-property easing would be lost)" );
		assert.equal( props.b[ 1 ], "_test2", "animate does not change original props (per-property easing would be lost)" );
	} );

	this.clock.tick( 400 );
} );

QUnit.test( "animate with CSS shorthand properties", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -1256,7 +1232,8 @@ 	jQuery.easing.propertyScope = function( p ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
			easeAnimation_count++;
		}
		return p;
	};

	jQuery.easing.propertyScope = function( p ) {
		if ( p >= 1 ) {
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
diff --git a/a.js b/b.js
@@ -1264,7 +1241,8 @@ jQuery( "#foo" )
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
			assert.equal( easeAnimation_count, 4, "per-animation default easing called for each property" );
			easeAnimation_count = 0;
		} )
		.animate( propsSpecial, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "1px", "padding-top was animated again" );
			assert.equal( this.style.paddingLeft, "2px", "padding-left was animated again" );
			assert.equal( this.style.paddingRight, "2px", "padding-right was animated again" );
			assert.equal( this.style.paddingBottom, "3px", "padding-bottom was animated again" );
diff --git a/a.js b/b.js
@@ -1276,7 +1254,7 @@ jQuery( "#foo" )
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
			assert.equal( easeAnimation_count, 4, "per-animation default easing called for each property" );
			easeAnimation_count = 0;
		} )
		.animate( propsSpecial, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "1px", "padding-top was animated again" );
			assert.equal( this.style.paddingLeft, "2px", "padding-left was animated again" );
			assert.equal( this.style.paddingRight, "2px", "padding-right was animated again" );
			assert.equal( this.style.paddingBottom, "3px", "padding-bottom was animated again" );
			assert.equal( easeAnimation_count, 0, "per-animation default easing not called" );
			assert.equal( easeProperty_count, 4, "special easing called for each property" );

			jQuery( this ).css( "padding", "0" );
			delete jQuery.easing.animationScope;
			delete jQuery.easing.propertyScope;
		} );
		this.clock.tick( 400 );
} );

QUnit.test( "hide hidden elements, with animation (bug trac-7141)", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -1302,7 +1280,7 @@ QUnit.test( "animate unit-less properties (trac-4966)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );
	this.clock.tick( 50 );
	assert.equal( div.css( "display" ), "block", "Element is visible after animations" );
} );

QUnit.test( "animate unit-less properties (trac-4966)", function( assert ) {
	assert.expect( 2 );

	var div = jQuery( "<div style='z-index: 0; position: absolute;'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "z-index" ), "0", "z-index is 0" );
	div.animate( { zIndex: 2 }, function() {
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (trac-9074)", function( assert ) {
	assert.expect( 6 );
diff --git a/a.js b/b.js
@@ -1320,9 +1298,9 @@ QUnit.test( "animate properties missing px w/ opacity as last (trac-9074)", func
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (trac-9074)", function( assert ) {
	assert.expect( 6 );

	var ml, l,
		div = jQuery( "<div style='position: absolute; margin-left: 0; left: 0px;'></div>" )
		.appendTo( "#qunit-fixture" );
	function cssInt( prop ) {
		return parseInt( div.css( prop ), 10 );
	}
	assert.equal( cssInt( "marginLeft" ), 0, "Margin left is 0" );
	assert.equal( cssInt( "left" ), 0, "Left is 0" );
	div.animate( {
		left: 200,
		marginLeft: 200,
		opacity: 0
	}, 2000 );

	this.clock.tick( 500 );

	ml = cssInt( "marginLeft" );
	l = cssInt( "left" );
	assert.notEqual( ml, 0, "Margin left is not 0 after partial animate" );
diff --git a/a.js b/b.js
@@ -1342,14 +1320,14 @@ QUnit.test( "callbacks should fire in correct order (trac-9100)", function( asse
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	assert.notEqual( l, 0, "Left is not 0 after partial animate" );
	assert.notEqual( l, 200, "Left is not 200 after partial animate" );
	div.stop().remove();
} );

QUnit.test( "callbacks should fire in correct order (trac-9100)", function( assert ) {
	assert.expect( 1 );

	var a = 1,
		cb = 0;

	jQuery( "<p data-operation='*2'></p><p data-operation='^2'></p>" ).appendTo( "#qunit-fixture" )

		// The test will always pass if no properties are animated or if the duration is 0
		.animate( { fontSize: 12 }, 13, function() {
			a *= jQuery( this ).data( "operation" ) === "*2" ? 2 : a;
			cb++;
			if ( cb === 2 ) {
				assert.equal( a, 4, "test value has been *2 and _then_ ^2" );
			}
		} );
	this.clock.tick( 20 );
} );

QUnit.test( "callbacks that throw exceptions will be removed (trac-5684)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1421,8 +1399,8 @@ QUnit.test( "line-height animates correctly (trac-13855)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( jQuery( this ).css( "fill-opacity" ), 1, "Do not append px to 'fill-opacity'" );
		$div.remove();
	} );
} );

QUnit.test( "line-height animates correctly (trac-13855)", function( assert ) {
	assert.expect( 12 );

	var t0,
		clock = this.clock,
		longDuration = 2000,
		shortDuration = 500,
		animated = jQuery(
			"<p style='line-height: 100;'>unitless</p>" +
			"<p style='line-height: 5000px;'>px</p>" +
			"<p style='line-height: 5000%;'>percent</p>" +
diff --git a/a.js b/b.js
@@ -1472,11 +1450,11 @@ setTimeout( function() {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

			t0 = +( new Date() );
			animated.stop( true, true ).hide()
					.animate( { "line-height": "show" }, longDuration, "linear" );

			setTimeout( function() {
				var progress = ( ( new Date() ) - t0 ) / longDuration;

				animated.each( function( i ) {
					var label = jQuery.text( this ),
						initial = initialHeight[ i ],
						height = jQuery( this ).height(),
						upper = initial * progress * tolerance;
					assert.ok( height < upper, "show " + label + ": upper bound; " +
						height + " < " + upper + " @ " + ( progress * 100 ) + "%" );
				} );

				animated.stop( true, true );
			}, shortDuration );
clock.tick( shortDuration );
		}, shortDuration );
clock.tick( shortDuration );
	}, 50 );
clock.tick( 50 );
} );

// Start 1.8 Animation tests
QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
diff --git a/a.js b/b.js
@@ -1504,7 +1482,7 @@ QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	}, 50 );
clock.tick( 50 );
} );

// Start 1.8 Animation tests
QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
	assert.expect( 4 );

	var animation,
		testObject = {
			"foo": 0,
			"bar": 1,
			"width": 100
		},
		testDest = {
			"foo": 1,
			"bar": 0,
			"width": 200
		};

	animation = jQuery.Animation( testObject, testDest, { "duration": 1 } );
	animation.done( function() {
		for ( var prop in testDest ) {
			assert.equal( testObject[ prop ], testDest[ prop ], "Animated: " + prop );
		}
		animation.done( function() {
			assert.deepEqual( testObject, testDest, "No unexpected properties" );
		} );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate Option: step: function( percent, tween )", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1532,7 +1510,7 @@ jQuery( "#foo" ).animate( {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

QUnit.test( "Animate Option: step: function( percent, tween )", function( assert ) {
	assert.expect( 1 );

	var counter = {};
	jQuery( "#foo" ).animate( {
		prop1: 1,
		prop2: 2,
		prop3: 3
	}, {
		duration: 1,
		step: function( value, tween ) {
			var calls = counter[ tween.prop ] = counter[ tween.prop ] || [];

			// in case this is called multiple times for either, lets store it in
			// 0 or 1 in the array
			calls[ value === 0 ? 0 : 1 ] = value;
		}
	} ).queue( function( next ) {
		assert.deepEqual( counter, {
			prop1: [ 0, 1 ],
			prop2: [ 0, 2 ],
			prop3: [ 0, 3 ]
		}, "Step function was called once at 0% and once at 100% for each property" );
		next();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate callbacks have correct context", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1541,15 +1519,15 @@ QUnit.test( "Animate callbacks have correct context", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		next();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate callbacks have correct context", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	foo.animate( {
		height: 10
	}, 10, function() {
		assert.equal( foo[ 0 ], this, "Complete callback after stop(true) `this` is element" );
	} ).stop( true, true );
	foo.animate( {
		height: 100
	}, 10, function() {
		assert.equal( foo[ 0 ], this, "Complete callback `this` is element" );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "User supplied callback called after show when fx off (trac-8892)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1571,8 +1549,7 @@ QUnit.test( "User supplied callback called after show when fx off (trac-8892)",
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.equal( foo[ 0 ], this, "Complete callback `this` is element" );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "User supplied callback called after show when fx off (trac-8892)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	jQuery.fx.off = true;
	foo.hide();
	foo.fadeIn( 500, function() {
		assert.ok( supportjQuery( this ).is( ":visible" ), "Element is visible in callback" );
		foo.fadeOut( 500, function() {
			assert.ok( supportjQuery( this ).is( ":hidden" ), "Element is hidden in callback" );
			jQuery.fx.off = false;
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
diff --git a/a.js b/b.js
@@ -1625,7 +1602,7 @@ QUnit.test( "animate should set display for disconnected nodes", function( asser
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
			animate: [ { width: "show" } ]
		},
		toggleMethods = {
			toggle: [ 1 ],
			slideToggle: []
		},
		$divEmpty = jQuery( "<div></div>" ),
		$divTest = jQuery( "<div>test</div>" ),
		$divNone = jQuery( "<div style='display: none;'></div>" ),
		$divInline = jQuery( "<div style='display: inline;'></div>" ),
		nullParentDisplay = $divEmpty.css( "display" ),
		underFragmentDisplay = $divTest.css( "display" ),
		clock = this.clock;

	assert.strictEqual( $divEmpty[ 0 ].parentNode, null, "Setup: element with null parentNode" );
	assert.strictEqual( ( $divTest[ 0 ].parentNode || {} ).nodeType, 11, "Setup: element under fragment" );

	assert.strictEqual( $divEmpty.show()[ 0 ].style.display, "",
		"set display with show() for element with null parentNode" );
	assert.strictEqual( $divTest.show()[ 0 ].style.display, "",
		"set display with show() for element under fragment" );
	assert.strictEqual( $divNone.show()[ 0 ].style.display, "",
		"show() should change display if it already set to none" );
	assert.strictEqual( $divInline.show()[ 0 ].style.display, "inline",
		"show() should not change display if it already set" );

	jQuery.each( showMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), nullParentDisplay,
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), underFragmentDisplay,
				"." + name + " block under fragment" );
		} ] ) );
	} );
	jQuery.each( toggleMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block under fragment" );
		} ] ) );
	} );
	clock.tick( 400 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Animation callback should not show animated element as :animated (trac-7157)", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1635,10 +1612,10 @@ QUnit.test( "animate should set display for disconnected nodes", function( asser
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
			animate: [ { width: "show" } ]
		},
		toggleMethods = {
			toggle: [ 1 ],
			slideToggle: []
		},
		$divEmpty = jQuery( "<div></div>" ),
		$divTest = jQuery( "<div>test</div>" ),
		$divNone = jQuery( "<div style='display: none;'></div>" ),
		$divInline = jQuery( "<div style='display: inline;'></div>" ),
		nullParentDisplay = $divEmpty.css( "display" ),
		underFragmentDisplay = $divTest.css( "display" ),
		clock = this.clock;

	assert.strictEqual( $divEmpty[ 0 ].parentNode, null, "Setup: element with null parentNode" );
	assert.strictEqual( ( $divTest[ 0 ].parentNode || {} ).nodeType, 11, "Setup: element under fragment" );

	assert.strictEqual( $divEmpty.show()[ 0 ].style.display, "",
		"set display with show() for element with null parentNode" );
	assert.strictEqual( $divTest.show()[ 0 ].style.display, "",
		"set display with show() for element under fragment" );
	assert.strictEqual( $divNone.show()[ 0 ].style.display, "",
		"show() should change display if it already set to none" );
	assert.strictEqual( $divInline.show()[ 0 ].style.display, "inline",
		"show() should not change display if it already set" );

	jQuery.each( showMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), nullParentDisplay,
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), underFragmentDisplay,
				"." + name + " block under fragment" );
		} ] ) );
	} );
	jQuery.each( toggleMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block under fragment" );
		} ] ) );
	} );
	clock.tick( 400 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Animation callback should not show animated element as :animated (trac-7157)", function( assert ) {
	assert.expect( 1 );

	var foo = jQuery( "#foo" );

	foo.animate( {
		opacity: 0
	}, 100, function() {
		assert.ok( !foo.is( ":animated" ), "The element is not animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Initial step callback should show element as :animated (trac-14623)", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1677,7 +1654,7 @@ QUnit.test( "hide called on element within hidden parent should set display to n
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );
	this.clock.tick( 1 );
	foo.stop();
} );

QUnit.test( "hide called on element within hidden parent should set display to none (trac-10045)", function( assert ) {
	assert.expect( 3 );

	var hidden = jQuery( ".hidden" ),
		elems = jQuery( "<div>hide</div><div>hide0</div><div>hide1</div>" );

	hidden.append( elems );

	jQuery.when(
		elems.eq( 0 ).hide(),
		elems.eq( 1 ).hide( 0 ),
		elems.eq( 2 ).hide( 1 )
	).done( function() {
		assert.strictEqual( elems.get( 0 ).style.display, "none", "hide() called on element within hidden parent should set display to none" );
		assert.strictEqual( elems.get( 1 ).style.display, "none", "hide( 0 ) called on element within hidden parent should set display to none" );
		assert.strictEqual( elems.get( 2 ).style.display, "none", "hide( 1 ) called on element within hidden parent should set display to none" );

		elems.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "hide, fadeOut and slideUp called on element width height and width = 0 should set display to none", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -1708,7 +1685,7 @@ QUnit.test( "hide, fadeOut and slideUp called on element width height and width
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		elems.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "hide, fadeOut and slideUp called on element width height and width = 0 should set display to none", function( assert ) {
	assert.expect( 5 );

	var foo = jQuery( "#foo" ),
		i = 0,
		elems = jQuery();

	for ( ; i < 5; i++ ) {
		elems = elems.add( "<div style='width:0;height:0;'></div>" );
	}

	foo.append( elems );

	jQuery.when(
		elems.eq( 0 ).hide(),
		elems.eq( 1 ).hide( jQuery.noop ),
		elems.eq( 2 ).hide( 1 ),
		elems.eq( 3 ).fadeOut(),
		elems.eq( 4 ).slideUp()
	).done( function() {
		assert.strictEqual( elems.get( 0 ).style.display, "none", "hide() called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 1 ).style.display, "none",
												"hide( jQuery.noop ) called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 2 ).style.display, "none", "hide( 1 ) called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 3 ).style.display, "none", "fadeOut() called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 4 ).style.display, "none", "slideUp() called on element width height and width = 0 should set display to none" );

	} );
	this.clock.tick( 400 );
} );

QUnit.test( "hide should not leave hidden inline elements visible (trac-14848)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1735,7 +1712,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
diff --git a/a.js b/b.js
@@ -1743,21 +1720,21 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
diff --git a/a.js b/b.js
@@ -1765,7 +1742,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
		} ).animate( {
			bottom: 10
		}, {
			duration: 10,
			queue: false,
			complete: function() {
				assert.ok( step > 7 && step < 10, "Step eight or nine" );
				step++;
diff --git a/a.js b/b.js
@@ -1776,7 +1753,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
		} ).animate( {
			bottom: 10
		}, {
			duration: 10,
			queue: false,
			complete: function() {
				assert.ok( step > 7 && step < 10, "Step eight or nine" );
				step++;
			}
		} ).promise().done( function() {
			assert.equal( step++, 10, "steps 6-10: queue:fx then queue:false" );
		} );

	} );
	this.clock.tick( 10 );
} );

QUnit.test( "multiple unqueued and promise", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -1811,7 +1788,7 @@ QUnit.test( "multiple unqueued and promise", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

	} );
	this.clock.tick( 10 );
} );

QUnit.test( "multiple unqueued and promise", function( assert ) {
	assert.expect( 4 );

	var foo = jQuery( "#foo" ),
		step = 1;
	foo.animate( {
		marginLeft: 300
	}, {
		duration: 500,
		queue: false,
		complete: function() {
			assert.strictEqual( step++, 2, "Step 2" );
		}
	} ).animate( {
		top: 100
	}, {
		duration: 1000,
		queue: false,
		complete: function() {
			assert.strictEqual( step++, 3, "Step 3" );
		}
	} ).animate( {}, {
		duration: 2000,
		queue: false,
		complete: function() {

			// no properties is a non-op and finishes immediately
			assert.strictEqual( step++, 1, "Step 1" );
		}
	} ).promise().done( function() {
		assert.strictEqual( step++, 4, "Step 4" );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate does not change start value for non-px animation (trac-7109)", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1834,7 +1811,7 @@ QUnit.test( "animate does not change start value for non-px animation (trac-7109
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.strictEqual( step++, 4, "Step 4" );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate does not change start value for non-px animation (trac-7109)", function( assert ) {
	assert.expect( 1 );

	var parent = jQuery( "<div><div></div></div>" ).css( { width: 284, height: 1 } ).appendTo( "#qunit-fixture" ),
		child = parent.children().css( { fontSize: "98.6in", width: "0.01em", height: 1 } ),
		actual = parseFloat( child.css( "width" ) ),
		computed = [];

	child.animate( { width: "0%" }, {
		duration: 1,
		step: function() {
			computed.push( parseFloat( child.css( "width" ) ) );
		}
	} ).queue( function( next ) {
		var ratio = computed[ 0 ] / actual;
		assert.ok( ratio > 0.9 && ratio < 1.1,
			"Starting width was close enough (" + computed[ 0 ] + " approximates " + actual + ")" );
		next();
		parent.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "non-px animation handles non-numeric start (trac-11971)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1866,7 +1843,7 @@ QUnit.test( "non-px animation handles non-numeric start (trac-11971)", function(
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		parent.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "non-px animation handles non-numeric start (trac-11971)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" ),
		initial = foo.css( "backgroundPositionX" );

	if ( !initial ) {
		assert.expect( 1 );
		assert.ok( true, "Style property not understood" );
		return;
	}

	foo.animate( { backgroundPositionX: "42%" }, {
		duration: 1,
		progress: function( anim, percent ) {
			if ( percent ) {
				return;
			}

			if ( parseFloat( initial ) ) {
				assert.equal( jQuery.style( this, "backgroundPositionX" ), initial, "Numeric start preserved" );
			} else {
				assert.equal( jQuery.style( this, "backgroundPositionX" ), "0%", "Non-numeric start zeroed" );
			}
		},
		done: function() {
			assert.equal( jQuery.style( this, "backgroundPositionX" ), "42%", "End reached" );
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks (trac-11797)", function( assert ) {
	assert.expect( 15 );
diff --git a/a.js b/b.js
@@ -1946,10 +1923,10 @@ QUnit.test( "Animation callbacks (trac-11797)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks (trac-11797)", function( assert ) {
	assert.expect( 15 );

	var prog = 0,
		targets = jQuery( "#foo" ).children(),
		done = false,
		expectedProgress = 1;

	targets.eq( 0 ).animate( {}, {
		duration: 1,
		start: function() {
			assert.ok( true, "empty: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, prog, "empty: progress " + prog );
			prog = 1;
		},
		done: function() {
			assert.ok( true, "empty: done" );
		},
		fail: function() {
			assert.ok( false, "empty: fail" );
		},
		always: function() {
			assert.ok( true, "empty: always" );
			done = true;
		}
	} );

	assert.ok( done, "empty: done immediately" );

	done = false;
	targets.eq( 1 ).animate( {
		opacity: 0
	}, {
		duration: 1,
		start: function() {
			assert.ok( true, "stopped: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, 0, "stopped: progress 0" );
		},
		done: function() {
			assert.ok( false, "stopped: done" );
		},
		fail: function() {
			assert.ok( true, "stopped: fail" );
		},
		always: function() {
			assert.ok( true, "stopped: always" );
			done = true;
		}
	} ).stop();

	assert.ok( done, "stopped: stopped immediately" );

	targets.eq( 2 ).animate( {
		opacity: 0
	}, {
		duration: 1,
		start: function() {
			assert.ok( true, "async: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, expectedProgress, "async: progress " + expectedProgress );
			expectedProgress++;
		},
		done: function() {
			assert.ok( true, "async: done" );
		},
		fail: function() {
			assert.ok( false, "async: fail" );
		},
		always: function() {
			assert.ok( true, "async: always" );
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks in order (trac-2292)", function( assert ) {
	assert.expect( 9 );

	var done = assert.async(),
		step = 0,
diff --git a/a.js b/b.js
@@ -1986,7 +1963,7 @@ jQuery( "#foo" ).animate( {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

	var done = assert.async(),
		step = 0,
		dur = 50;

	jQuery( "#foo" ).animate( {
		width: "5px"
	}, {
		duration: dur,
		start: function() {
			assert.step( "start" );
		},
		progress: function( anim, p, ms ) {
			if ( !( step++ ) ) {
				assert.step( "progress" );
				assert.strictEqual( p, 0, "first progress callback: progress ratio" );
				assert.strictEqual( ms, dur, "first progress callback: remaining ms" );
			} else {
				assert.step( "last progress" );
				assert.strictEqual( p, 1, "last progress callback: progress ratio" );
				assert.strictEqual( ms, 0, "last progress callback: remaining ms" );
			}
		},
		done: function() {
			assert.step( "done" );
		},
		fail: function() {
			assert.ok( false, "Animation failed" );
		},
		always: function() {
			assert.verifySteps( [ "start", "progress", "last progress", "done" ] );
			done();
		}
	} ).finish();

	this.clock.tick( dur + 10 );
} );

QUnit.test( "Animate properly sets overflow hidden when animating width/height (trac-12117)", function( assert ) {
	assert.expect( 8 );
diff --git a/a.js b/b.js
@@ -2096,8 +2073,8 @@ QUnit.test( "toggle state tests: " + method + " (trac-8685)", function( assert )
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
jQuery.map( [ "toggle", "slideToggle", "fadeToggle" ], function( method ) {

	// this test would look a lot better if we were using something to override
	// the default timers
	var duration = 1500;
	QUnit.test( "toggle state tests: " + method + " (trac-8685)", function( assert ) {
		function secondToggle() {
			var stopped = parseFloat( element.css( check ) );
			tested = false;
			element[ method ]( {
				duration: duration,
				step: function( p, fx ) {
					if ( fx.pos > 0.1 && fx.prop === check && !tested ) {
						tested = true;
						assert.equal( fx.start, stopped, check + " starts at " + stopped + " where it stopped" );
						assert.equal( fx.end, original, check + " ending value is " + original );
						element.stop();
					}
				}
			} );
		}

		var tested,
			original,
			check = method === "slideToggle" ? "height" : "opacity",
			element = jQuery( "#foo" ).height( 200 );

		assert.expect( 4 );

		element[ method ]( {
			duration: duration,
			easing: "linear",
			step: function( p, fx ) {
				if ( fx.pos > 0.1 && fx.prop === check && !tested ) {
					tested = true;
					original = fx.start;
					assert.ok( fx.start !== 0, check + " is starting at " + original + " on first toggle (non-zero)" );
					assert.equal( fx.end, 0, check + " is ending at 0 on first toggle" );
					element.stop();
				}
			},
			always: secondToggle
		} );

                //FIXME figure out why 470
		this.clock.tick( 470 );
	} );
} );

QUnit.test( "jQuery.fx.start & jQuery.fx.stop hook points", function( assert ) {
diff --git a/a.js b/b.js
@@ -2291,7 +2268,10 @@ QUnit.test( ".finish() is applied correctly when multiple elements were animated
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	assert.equal( outside, 2, "2 finish callbacks" );

	div.remove();
} );

QUnit.test( ".finish() is applied correctly when multiple elements were animated (trac-13937)", function( assert ) {
	assert.expect( 3 );

	var elems = jQuery( "<a>0</a><a>1</a><a>2</a>" );

	elems.animate( { opacity: 0 }, 1500 ).animate( { opacity: 1 }, 1500 );
	setTimeout( function() {
		elems.eq( 1 ).finish();
		assert.ok( !elems.eq( 1 ).queue().length, "empty queue for .finish()ed element" );
		assert.ok( elems.eq( 0 ).queue().length, "non-empty queue for preceding element" );
diff --git a/a.js b/b.js
@@ -2300,7 +2280,7 @@ setTimeout( function() {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	assert.expect( 3 );

	var elems = jQuery( "<a>0</a><a>1</a><a>2</a>" );

	elems.animate( { opacity: 0 }, 1500 ).animate( { opacity: 1 }, 1500 );
	setTimeout( function() {
		elems.eq( 1 ).finish();
		assert.ok( !elems.eq( 1 ).queue().length, "empty queue for .finish()ed element" );
		assert.ok( elems.eq( 0 ).queue().length, "non-empty queue for preceding element" );
		assert.ok( elems.eq( 2 ).queue().length, "non-empty queue for following element" );
		elems.stop( true );

	}, 100 );
	this.clock.tick( 1500 );
} );

QUnit.test( "slideDown() after stop() (trac-13483)", function( assert ) {
		assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2312,28 +2292,28 @@ QUnit.test( "slideDown() after stop() (trac-13483)", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111

	}, 100 );
	this.clock.tick( 1500 );
} );

QUnit.test( "slideDown() after stop() (trac-13483)", function( assert ) {
		assert.expect( 2 );

		var ul = jQuery( "<ul style='height: 100px; display: block;'></ul>" )
				.appendTo( "#qunit-fixture" ),
			origHeight = ul.height(),
			clock = this.clock;

        // First test. slideUp() -> stop() in the middle -> slideDown() until the end
		ul.slideUp( 1000 );
		clock.tick( 500 );
		ul.stop( true );
		ul.slideDown( 1, function() {
				assert.equal( ul.height(), origHeight, "slideDown() after interrupting slideUp() with stop(). Height must be in original value" );

				// Second test. slideDown() -> stop() in the middle -> slideDown() until the end
				ul.slideUp( 1 );
				clock.tick( 10 );
				ul.slideDown( 1000 );
				clock.tick( 500 );
				ul.stop( true );
				ul.slideDown( 1 );
				assert.equal( ul.height(), origHeight, "slideDown() after interrupting slideDown() with stop(). Height must be in original value" );

				// Cleanup
				ul.remove();
				clock.tick( 10 );

		} );

		clock.tick( 10 );
} );

QUnit.test( "Respect display value on inline elements (trac-14824)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2359,7 +2339,7 @@ QUnit.test( "Respect display value on inline elements (trac-14824)", function( a
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		} );

		clock.tick( 10 );
} );

QUnit.test( "Respect display value on inline elements (trac-14824)", function( assert ) {
	assert.expect( 2 );

	var clock = this.clock,
		fromStyleSheet = jQuery( "<span id='span-14824'></span>" ),
		fromStyleAttr = jQuery( "<span style='display: block;'></span>" );

	jQuery( "#qunit-fixture" ).append( fromStyleSheet, fromStyleAttr );

	fromStyleSheet.slideUp( function() {
		jQuery( this ).slideDown( function() {
			assert.equal( jQuery( this ).css( "display" ), "block",
				"Respect previous display value (from stylesheet) on span element" );
		} );
	} );

	fromStyleAttr.slideUp( function() {
		jQuery( this ).slideDown( function() {
			assert.equal( jQuery( this ).css( "display" ), "block",
				"Respect previous display value (from style attribute) on span element" );
		} );
	} );

	clock.tick( 800 );
} );

QUnit.test( "jQuery.easing._default (gh-2218)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2383,7 +2363,7 @@ jQuery( "#foo" )
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
} );

QUnit.test( "jQuery.easing._default (gh-2218)", function( assert ) {
	assert.expect( 2 );

	jQuery( "#foo" )
		.animate( { width: "5px" }, {
			duration: 5,
			start: function( anim ) {
				assert.equal( anim.opts.easing, jQuery.easing._default,
					"anim.opts.easing should be equal to jQuery.easing._default when the easing argument is not given" );
			}
		} )
		.animate( { height: "5px" }, {
			duration: 5,
			easing: "linear",
			start: function( anim ) {
				assert.equal( anim.opts.easing, "linear",
					"anim.opts.easing should be equal to the easing argument" );
			}
		} )
		.stop();

	this.clock.tick( 25 );
} );

QUnit.test( "jQuery.easing._default in Animation (gh-2218", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -2411,7 +2391,7 @@ 	jQuery.easing.custom = function( p ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		defaultEasing = jQuery.easing._default,
		called = false,
		testObject = { "width": 100 },
		testDest = { "width": 200 };

	jQuery.easing.custom = function( p ) {
		called = true;
		return p;
	};
	jQuery.easing._default = "custom";

	animation = jQuery.Animation( testObject, testDest, { "duration": 1 } );
	animation.done( function() {
		assert.equal( testObject.width, testDest.width, "Animated width" );
		assert.ok( called, "Custom jQuery.easing._default called" );
		assert.strictEqual( animation.opts.easing, "custom",
			"Animation used custom jQuery.easing._default" );
		jQuery.easing._default = defaultEasing;
		delete jQuery.easing.custom;
	} );

	this.clock.tick( 10 );
} );

QUnit.test( "jQuery.easing._default in Tween (gh-2218)", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -2464,7 +2444,7 @@ QUnit.test( "Show/hide/toggle and display: inline", function( assert ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		div.remove();
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "Show/hide/toggle and display: inline", function( assert ) {
	assert.expect( 40 );

	var clock = this.clock;

	jQuery( "<span></span><div style='display:inline' title='inline div'></div>" ).each( function() {
		var completed, interrupted,
			N = 100,
			fixture = jQuery( "#qunit-fixture" ),
			$el = jQuery( this ),
			kind = this.title || this.nodeName.toLowerCase();

diff --git a/a.js b/b.js
@@ -2530,7 +2510,7 @@ function testEasing( assert, speed, easing, complete ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
				kind + " display is not inline-block after " + call + "+toggle" );
		} );
	} );
} );

function testEasing( assert, speed, easing, complete ) {
	assert.expect( 4 );
	var options = jQuery.speed( speed, easing, complete );

	assert.equal( options.duration, 10, "Duration set properly" );
	assert.equal(
		typeof options.easing === "function" ? options.easing() : options.easing,
		"linear",
		"Easing set properly"
diff --git a/a.js b/b.js
@@ -2541,7 +2521,7 @@ function testEasing( assert, speed, easing, complete ) {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
				kind + " display is not inline-block after " + call + "+toggle" );
		} );
	} );
} );

function testEasing( assert, speed, easing, complete ) {
	assert.expect( 4 );
	var options = jQuery.speed( speed, easing, complete );

	assert.equal( options.duration, 10, "Duration set properly" );
	assert.equal(
		typeof options.easing === "function" ? options.easing() : options.easing,
		"linear",
		"Easing set properly"
	);
	assert.equal( options.queue, "fx", "Queue defaults to fx" );
	options.complete();
}

QUnit.test( "jQuery.speed( speed, easing, complete )", function( assert ) {
	testEasing( assert, 10, "linear", function() {
		assert.ok( true, "Complete called" );
	} );
} );

diff --git a/a.js b/b.js
@@ -2549,7 +2529,7 @@ testEasing( assert, 10, "linear", function() {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
	assert.equal( options.queue, "fx", "Queue defaults to fx" );
	options.complete();
}

QUnit.test( "jQuery.speed( speed, easing, complete )", function( assert ) {
	testEasing( assert, 10, "linear", function() {
		assert.ok( true, "Complete called" );
	} );
} );

QUnit.test( "jQuery.speed( speed, easing, complete ) - with easing function", function( assert ) {
	testEasing(
		assert,
		10,
		function() {
			return "linear";
		},
		function() {
diff --git a/a.js b/b.js
@@ -2561,7 +2541,7 @@ testEasing(
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		assert.ok( true, "Complete called" );
	} );
} );

QUnit.test( "jQuery.speed( speed, easing, complete ) - with easing function", function( assert ) {
	testEasing(
		assert,
		10,
		function() {
			return "linear";
		},
		function() {
			assert.ok( true, "Complete called" );
		}
	);
} );

QUnit.test( "jQuery.speed( options )", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: "linear",
		complete: function() {
			assert.ok( true, "Complete called" );
		}
diff --git a/a.js b/b.js
@@ -2571,7 +2551,7 @@ testEasing( assert, {
A blob:a4c91b331b2b8ee5af9036e7293f79869cbcf111
		}
	);
} );

QUnit.test( "jQuery.speed( options )", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: "linear",
		complete: function() {
			assert.ok( true, "Complete called" );
		}
	} );
} );

QUnit.test( "jQuery.speed( options ) - with easing function", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: function() {
			return "linear";
		},
		complete: function() {
diff --git a/a.js b/b.js
@@ -465,7 +465,7 @@ QUnit.test( "html(String) with HTML5 (Bug trac-6485)", function( assert ) {
A blob:a6633ec451560461e640aeb5580bca01d17bba9e

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug trac-6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().length, 1, "Make sure HTML5 article elements can hold children. innerHTML shortcut path" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().children().length, 1, "Make sure nested HTML5 elements can hold children." );
} );

QUnit.test( "html(String) tag-hyphenated elements (Bug trac-1987)", function( assert ) {

	assert.expect( 27 );

	jQuery.each( "thead tbody tfoot colgroup caption tr th td".split( " " ), function( i, name ) {
diff --git a/a.js b/b.js
@@ -643,7 +643,7 @@ QUnit.test( "attributes - special characters", function( assert ) {
A blob:0c81e48625d3adab315174c80460dbe67e41423d
		"#names-group span[id|='name-is']",
		[ "name-is-example", "name-is-div" ] );
	assert.t( "string ending with hyphen", "#names-group span[id|='name-is-']", [] );
} );

QUnit.test( "attributes - special characters", function( assert ) {
	assert.expect( 16 );

	var attrbad;
	var div = document.createElement( "div" );

	// trac-3279
	div.innerHTML = "<div id='foo' xml:test='something'></div>";
	assert.deepEqual( jQuery( "[xml\\:test]", div ).get(),
		[ div.firstChild ],
		"attribute name containing colon" );
diff --git a/a.js b/b.js
@@ -1895,9 +1895,7 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:0c81e48625d3adab315174c80460dbe67e41423d
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
diff --git a/a.js b/b.js
@@ -1959,8 +1957,12 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:0c81e48625d3adab315174c80460dbe67e41423d
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
		body = document.body,
		fixture = document.getElementById( "qunit-fixture" ),
		detached1 = document.createElement( "p" ),
		detached2 = document.createElement( "ul" ),
		detachedChild = detached1.appendChild( document.createElement( "a" ) ),
		detachedGrandchild = detachedChild.appendChild( document.createElement( "b" ) );

	for ( i = 0; i < 12; i++ ) {
		detached.push( document.createElement( "li" ) );
		detached[ i ].id = "detached" + i;
		detached2.appendChild( document.createElement( "li" ) ).id = "detachedChild" + i;
	}

	tests = {
		"Empty": {
			input: [],
			expected: []
		},
		"Single-element": {
			input: [ fixture ],
			expected: [ fixture ]
		},
		"No duplicates": {
			input: [ fixture, body ],
			expected: [ body, fixture ]
		},
		"Duplicates": {
			input: [ body, fixture, fixture, body ],
			expected: [ body, fixture ]
		},
		"Detached": {
			input: detached.slice( 0 ),
			expected: detached.slice( 0 )
		},
		"Detached children": {
			input: [
				detached2.childNodes[ 3 ],
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 1 ]
			],
			expected: [
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 1 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 3 ]
			]
		},
		"Attached/detached mixture": {
			input: [ detached1, fixture, detached2, document, detachedChild, body, detachedGrandchild ],
			expected: [ document, body, fixture ],
			length: 3
		}
	};

	jQuery.each( tests, function( label, test ) {
		var length = test.length || test.input.length;
		assert.deepEqual( jQuery.uniqueSort( test.input ).slice( 0, length ), test.expected, label + " (array)" );
		assert.deepEqual( jQuery.uniqueSort( new Arrayish( test.input ) ).slice( 0, length ), test.expected, label + " (quasi-array)" );
	} );
} );

testIframe(
diff --git a/a.js b/b.js
@@ -2051,7 +2051,6 @@ dequeue: function( type ) {
A blob:80c97a226a9833674b06d341ca9f8e93389e9d33
				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},

	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

diff --git a/a.js b/b.js
@@ -2559,7 +2558,6 @@ prop: function( elem, name, value ) {
A blob:80c97a226a9833674b06d341ca9f8e93389e9d33
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode( "tabindex" );

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
diff --git a/a.js b/b.js
@@ -59,7 +59,6 @@ prop: function( elem, name, value ) {
A blob:e80532eb6f22a724a054a345398b036d77aaef0a
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11+
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval (trac-12072)
				var tabindex = elem.getAttribute( "tabindex" );

				if ( tabindex ) {
diff --git a/a.js b/b.js
@@ -4,7 +4,6 @@
A blob:fe3a6f6b77b64b1720a2886927674bc37b12f153
import jQuery from "../core.js";

import "../queue.js";
import "../effects.js"; // Delay is optional because of this dependency

// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

diff --git a/a.js b/b.js
@@ -17,7 +17,7 @@
A blob:3921de6b5222d714e0b7d10d2fec7067a598cb30

var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

diff --git a/a.js b/b.js
@@ -40,7 +40,7 @@
A blob:3921de6b5222d714e0b7d10d2fec7067a598cb30
	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
diff --git a/a.js b/b.js
@@ -111,7 +111,7 @@ function inspectPrefiltersOrTransports( structure, options, originalOptions, jqX
A blob:3921de6b5222d714e0b7d10d2fec7067a598cb30
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

diff --git a/a.js b/b.js
@@ -528,12 +528,12 @@ ajax: function( url, options ) {
A blob:3921de6b5222d714e0b7d10d2fec7067a598cb30

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {

								// Support: IE 11+
								// `getResponseHeader( key )` in IE doesn't combine all header
								// values for the provided key into a single result with values
								// joined by commas as other browsers do. Instead, it returns
								// them on separate lines.
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
diff --git a/a.js b/b.js
@@ -605,7 +605,7 @@ ajax: function( url, options ) {
A blob:3921de6b5222d714e0b7d10d2fec7067a598cb30

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {

								// Support: IE 11+
								// `getResponseHeader( key )` in IE doesn't combine all header
								// values for the provided key into a single result with values
								// joined by commas as other browsers do. Instead, it returns
								// them on separate lines.
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11+
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an ESM-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
diff --git a/a.js b/b.js
@@ -66,7 +66,7 @@ 			callback = function( type ) {
A blob:2c9bc81258866e1625d16532d66082ca48deebd9
			for ( i in headers ) {
				xhr.setRequestHeader( i, headers[ i ] );
			}

			// Callback
			callback = function( type ) {
				return function() {
					if ( callback ) {
						callback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = null;

						if ( type === "abort" ) {
							xhr.abort();
						} else if ( type === "error" ) {
							complete(

								// File: protocol always yields status 0; see #8605, #14207
								xhr.status,
								xhr.statusText
							);
						} else {
diff --git a/a.js b/b.js
@@ -99,7 +99,7 @@ 			callback = function( type ) {
A blob:2c9bc81258866e1625d16532d66082ca48deebd9
			for ( i in headers ) {
				xhr.setRequestHeader( i, headers[ i ] );
			}

			// Callback
			callback = function( type ) {
				return function() {
					if ( callback ) {
						callback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = null;

						if ( type === "abort" ) {
							xhr.abort();
						} else if ( type === "error" ) {
							complete(

								// File: protocol always yields status 0; see #8605, #14207
								xhr.status,
								xhr.statusText
							);
						} else {
							complete(
								xhrSuccessStatus[ xhr.status ] || xhr.status,
								xhr.statusText,

								// For XHR2 non-text, let the caller handle it (gh-2498)
								( xhr.responseType || "text" ) === "text" ?
									{ text: xhr.responseText } :
									{ binary: xhr.response },
								xhr.getAllResponseHeaders()
							);
						}
					}
				};
			};

			// Listen to events
			xhr.onload = callback();
			xhr.onabort = xhr.onerror = xhr.ontimeout = callback( "error" );

			// Create the abort callback
			callback = callback( "abort" );

			try {

				// Do send the request (this may raise an exception)
				xhr.send( options.hasContent && options.data || null );
			} catch ( e ) {

				// #14683: Only rethrow if this hasn't been notified as an error yet
				if ( callback ) {
					throw e;
				}
			}
diff --git a/a.js b/b.js
@@ -59,8 +59,7 @@ prop: function( elem, name, value ) {
A blob:453d4c7cd0a09fa765b0791749ec671a5bd73e39
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11+
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = elem.getAttribute( "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
diff --git a/a.js b/b.js
@@ -149,7 +149,7 @@ val: function( value ) {
A blob:f200f97eedabfcd55c2b822c514c2b9789569c24
import nodeName from "../core/nodeName.js";

import "../core/init.js";

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = typeof value === "function";

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					if ( option.selected &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( ( option.selected =
						jQuery.inArray( jQuery( option ).val(), values ) > -1
					) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

if ( isIE ) {
	jQuery.valHooks.option = {
		get: function( elem ) {

			var val = elem.getAttribute( "value" );
			return val != null ?
				val :

				// Support: IE <=10 - 11+
				// option.text throws exceptions (#14686, #14858)
				// Strip and collapse whitespace
				// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
				stripAndCollapse( jQuery.text( elem ) );
		}
diff --git a/a.js b/b.js
@@ -10,8 +10,8 @@
A blob:8fc24d8dd6b54aae34e626dfe72d5a7ebdffe6fc

import "../traversing/findFilter.js";

// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
diff --git a/a.js b/b.js
@@ -25,7 +25,7 @@ jQuery.fn.ready = function( fn ) {
A blob:51f6d7f6b71718e96247a5ab1024dd3583c69371
		window.setTimeout( function() {
			fn.call( document, jQuery );
		} );
	};

jQuery.fn.ready = function( fn ) {
	whenReady( fn );
	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	ready: function( wait ) {

diff --git a/a.js b/b.js
@@ -28,7 +28,7 @@ jQuery.fn.ready = function( fn ) {
A blob:d6c507e41c1aa1dfa98e60b1d4b14e5127536ce5
import "../deferred.js";

// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {
diff --git a/a.js b/b.js
@@ -220,15 +220,15 @@ style: function( elem, name, value, extra ) {
A blob:b50aa3d91aa3e2a3a75374c99eff4a9a95e2c1f0
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = cssCamelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

diff --git a/a.js b/b.js
@@ -239,7 +239,7 @@ style: function( elem, name, value, extra ) {
A blob:b50aa3d91aa3e2a3a75374c99eff4a9a95e2c1f0
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = cssCamelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If the value is a number, add `px` for certain CSS properties
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( isAutoPx( origName ) ? "px" : "" );
			}

			// Support: IE <=9 - 11+
			// background-* props of a cloned element affect the source element (#8908)
			if ( isIE && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

diff --git a/a.js b/b.js
@@ -6,7 +6,7 @@
A blob:a3d5fe6286b56048acb2945f429c047325737b25

// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/;

// Convert dashed to camelCase, handle vendor prefixes.
// Used by the css & effects modules.
// Support: IE <=9 - 11+
// Microsoft forgot to hump their vendor prefix (#9572)
function cssCamelCase( string ) {
	return camelCase( string.replace( rmsPrefix, "ms-" ) );
}

diff --git a/a.js b/b.js
@@ -105,7 +105,7 @@ data: function( key, value ) {
A blob:cd658b386c9c167c645643d7ef542d21b009c6ea
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
diff --git a/a.js b/b.js
@@ -21,7 +21,7 @@ cache: function( owner ) {
A blob:a5eb090895dc4b9df9e4b051f76f7f2d608642e2

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = Object.create( null );

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
diff --git a/a.js b/b.js
@@ -369,15 +369,15 @@ handlers: function( event, handlers ) {
A blob:4b6eb00e4fde107fcba89a1883c95bd81f3fffd8
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: Firefox <=42 - 66+
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11+
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
diff --git a/a.js b/b.js
@@ -71,8 +71,8 @@ trigger: function( event, data, elem, onlyHandlers ) {
A blob:7919a50136098e64f2eb63e16fb9ad00199bcd36
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
diff --git a/a.js b/b.js
@@ -124,7 +124,7 @@ trigger: function( event, data, elem, onlyHandlers ) {
A blob:7919a50136098e64f2eb63e16fb9ad00199bcd36
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && typeof elem[ type ] === "function" && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];
diff --git a/a.js b/b.js
@@ -21,8 +21,8 @@ jQuery.noConflict = function( deep ) {
A blob:b49496fbb0a4f2d830b165935025c68e75b53128
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}

diff --git a/a.js b/b.js
@@ -120,7 +120,7 @@ function domManip( collection, args, callback, ignored ) {
A blob:19c60fcbcc60b7e37b9dac8d40b1dfe527eef1c3

		dataUser.set( dest, udataCur );
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = typeof value === "function";

	if ( valueIsFunction ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			args[ 0 ] = value.call( this, index, self.html() );
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
diff --git a/a.js b/b.js
@@ -4,7 +4,7 @@ jQuery._evalUrl = function( url, options, doc ) {
A blob:8a8d63d9d404e87ac259529efb36ec5ecda75adf
import jQuery from "../ajax.js";

jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
diff --git a/a.js b/b.js
@@ -52,7 +52,7 @@ function buildFragment( elems, context, scripts, selection, ignored ) {
A blob:d6f8e57832ac4079eefd2ffb344465eede527d23
import setGlobalEval from "./setGlobalEval.js";
import isArrayLike from "../core/isArrayLike.js";

var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" && ( elem.nodeType || isArrayLike( elem ) ) ) {
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || arr;

				// Create wrappers & descend into them.
				j = wrap.length;
				while ( --j > -1 ) {
					tmp = tmp.appendChild( context.createElement( wrap[ j ] ) );
				}

				tmp.innerHTML = jQuery.htmlPrefilter( elem );

				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}
diff --git a/a.js b/b.js
@@ -4,7 +4,7 @@
A blob:995d22c0cd810901e07d8f85d8441fd95239d362
import jQuery from "../core.js";
import nodeName from "../core/nodeName.js";

function getAll( context, tag ) {

	// Support: IE <=9 - 11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );
diff --git a/a.js b/b.js
@@ -282,7 +282,8 @@ function createCache() {
A blob:4b9c8b6ed7c66c60840c897ee246643368675803
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
diff --git a/a.js b/b.js
@@ -432,7 +433,7 @@ function setDocument( node ) {
A blob:4b9c8b6ed7c66c60840c897ee246643368675803

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+
	// IE sometimes throws a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 ) {
		return;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: IE 9 - 11+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+
	// IE sometimes throws a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
diff --git a/a.js b/b.js
@@ -843,7 +844,8 @@ find.matchesSelector = function( elem, expr ) {
A blob:4b9c8b6ed7c66c60840c897ee246643368675803

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			return matches.call( elem, expr );
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	find: {
		ID: function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		},

		TAG: function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
			} else {
				return context.querySelectorAll( tag );
			}
		},

		CLASS: function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					selectorError( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				selectorError( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		ID: function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		},

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?

				function() {
					return true;
				} :

				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = jQuery.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					selectorError( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),
diff --git a/a.js b/b.js
@@ -1348,7 +1350,8 @@ function matcherFromTokens( tokens ) {
A blob:4b9c8b6ed7c66c60840c897ee246643368675803
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

diff --git a/a.js b/b.js
@@ -20,7 +20,7 @@
A blob:8a0b2a1ca03a1886542fbaa089f489cc9efbcbe7

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
diff --git a/a.js b/b.js
@@ -613,7 +613,7 @@ ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				complete: callback( "complete" )
			} ]
		};
	} );

	ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
		function nocallback( msg ) {
			return function() {
				assert.equal( typeof this.url, "string", "context is settings on callback " + msg );
			};
		}
		return {
			url: url( "404.txt" ),
			beforeSend: nocallback( "beforeSend" ),
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
diff --git a/a.js b/b.js
@@ -629,7 +629,7 @@ ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function(
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
				holder = jQuery.event;
				delete jQuery.event;
			},
			complete: function() {
				assert.ok( true, "Call can be made without jQuery.event" );
				jQuery.event = holder;
			},
			success: true
		};
	} );

	ajaxTest( "#15160 - jQuery.ajax() - request manually aborted in ajaxSend", 3, function( assert ) {
		return {
			setup: function() {
				jQuery( document ).on( "ajaxSend", function( e, jqXHR ) {
					jqXHR.abort();
diff --git a/a.js b/b.js
@@ -1895,7 +1895,7 @@ ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				}
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success callback.", 1, function( assert ) {
		return {
			url: url( "mock.php?action=echoData" ),
			error: function( _, __, error ) {
				assert.equal( typeof error === "object", true,  "Didn't get back error object for empty json response" );
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
diff --git a/a.js b/b.js
@@ -1921,7 +1921,7 @@ ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( ass
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
					beforeSend: function() {
						assert.ok( true, "beforeSend got called, canceling" );
						return false;
					},
					success: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					complete: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					error: function() {
						assert.ok( false, "request didn't get canceled" );
					}
				} );
			},
			fail: function( _, reason ) {
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
diff --git a/a.js b/b.js
@@ -1935,7 +1935,7 @@ ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, f
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
					return "value";
				}
			},
			success: function( result ) {
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
diff --git a/a.js b/b.js
@@ -1953,7 +1953,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -1967,7 +1967,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function() {
					assert.strictEqual( this.cache, false, "cache must be false on JSON request" );
					return false;
				},
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
diff --git a/a.js b/b.js
@@ -2006,7 +2006,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -2044,7 +2044,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function( jqXHR, s ) {
					s.callback = s.jsonpCallback;

					assert.ok( this.callback in window, "JSONP callback name is in the window" );
				},
				success: function() {
					var previous = this;

					assert.strictEqual(
						previous.jsonpCallback,
						undefined,
						"jsonpCallback option is set back to default in callbacks"
					);

					assert.ok(
						!( this.callback in window ),
						"JSONP callback name was removed from the window"
					);

					jQuery.ajax( {
						url: baseURL + "mock.php?action=jsonp",
						dataType: "jsonp",
						crossDomain: crossDomain,
						beforeSend: function() {
							assert.strictEqual( this.jsonpCallback, previous.callback, "JSONP callback name is re-used" );
							return false;
						}
					} );
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
diff --git a/a.js b/b.js
@@ -2078,7 +2078,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
diff --git a/a.js b/b.js
@@ -2088,7 +2088,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
diff --git a/a.js b/b.js
@@ -2102,7 +2102,7 @@ ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
				return string;
			},
			error: function( jqXHR ) {
				assert.strictEqual( jqXHR.responseText, "{ \"code\": 40, \"message\": \"Bad Request\" }", "Error body properly set" );
				assert.deepEqual( jqXHR.responseJSON, { code: 40, message: "Bad Request" }, "Error body properly parsed" );
			}
		};
	} );

	ajaxTest( "#11426 - jQuery.ajax() - loading binary data shouldn't throw an exception in IE", 1, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			success: function( data ) {
				assert.ok( data === undefined || /JFIF/.test( data ), "success callback reached" );
diff --git a/a.js b/b.js
@@ -2135,7 +2135,7 @@ ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception",
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
		s.xhrFields = { responseType: "arraybuffer" };
		s.responseFields.arraybuffer = "response";
		s.converters[ "binary arraybuffer" ] = true;
	} );

	ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception", 2, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			dataType: "arraybuffer",
			success: function( data, s, jqxhr ) {
				assert.ok( data instanceof window.ArrayBuffer, "correct data type" );
				assert.ok( jqxhr.response instanceof window.ArrayBuffer, "data in jQXHR" );
			}
		};
	} );
}

	QUnit.test( "#11743 - jQuery.ajax() - script, throws exception", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		var onerror = window.onerror;
		window.onerror = function() {
diff --git a/a.js b/b.js
@@ -2170,7 +2170,7 @@ 				options.success = function( msg ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
diff --git a/a.js b/b.js
@@ -2189,7 +2189,7 @@ 				options.success = function( msg ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
						var options = {};
						options[ globalOption ] = "POST";
						jQuery.ajaxSetup( options );
					},
					requests: [
						request( assert, "type" ),
						request( assert, "method" ),
						request( assert )
					]
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
diff --git a/a.js b/b.js
@@ -2207,7 +2207,7 @@ ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from aja
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
				var parsedXML = jQuery( jQuery.parseXML( "<tab title=\"Added\">blibli</tab>" ) ).find( "tab" );
				ajaxXML = jQuery( ajaxXML );
				try {
					ajaxXML.find( "infowindowtab" ).append( parsedXML );
				} catch ( e ) {
					assert.strictEqual( e, undefined, "error" );
					return;
				}
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
diff --git a/a.js b/b.js
@@ -2229,7 +2229,7 @@ ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3,
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
				"* testing": function() {
					throw "converter was called";
				}
			},
			success: function( data, status, jqXHR ) {
				assert.strictEqual( jqXHR.status, 204, "status code is 204" );
				assert.strictEqual( status, "nocontent", "status text is 'nocontent'" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
diff --git a/a.js b/b.js
@@ -2241,7 +2241,7 @@ ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
				assert.notStrictEqual( resp, undefined, "XML document exists" );
				assert.ok( "responseXML" in jqXHR, "jqXHR.responseXML exists" );
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
diff --git a/a.js b/b.js
@@ -2272,7 +2272,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
diff --git a/a.js b/b.js
@@ -2281,7 +2281,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
			}
		);
	}

	ajaxTest( "#14683 - jQuery.ajax() - Exceptions thrown synchronously by xhr.send should be caught", 4, function( assert ) {
		return [ {
			url: baseURL + "mock.php?action=echoData",
			method: "POST",
			data: {
diff --git a/a.js b/b.js
@@ -2504,7 +2504,7 @@ QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function(
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
			error: pass,
			success: fail
		} );
	} );

	QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			timeout: 50
		} );
		jQuery.ajax( {
			type: "GET",
			timeout: 15000,
			url: url( "mock.php?action=wait&wait=1" ),
			error: function() {
				assert.ok( false, "Check for local timeout failed" );
				done();
			},
			success: function() {
				assert.ok( true, "Check for local timeout" );
				done();
			}
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
diff --git a/a.js b/b.js
@@ -2521,7 +2521,7 @@ QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
		} );

		jQuery( document ).on( "ajaxStart ajaxStop", function() {
			assert.ok( false, "Global event triggered" );
		} );

		jQuery( "#qunit-fixture" ).append( "<script src='" + baseURL + "mock.php?action=script'></script>" );

		jQuery( document ).off( "ajaxStart ajaxStop" );
	} );

	QUnit.test(
		"jQuery#load() - always use GET method even if it overrided through ajaxSetup (#11264)",
		function( assert ) {
			assert.expect( 1 );
			var done = assert.async();

diff --git a/a.js b/b.js
@@ -2558,7 +2558,7 @@ QUnit.test(
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				done();
			} );
		}
	);

	QUnit.test(
		"jQuery#load() - should resolve with correct context",
		function( assert ) {
			assert.expect( 2 );
			var done = assert.async();
			var ps = jQuery( "<p></p><p></p>" );
			var i = 0;

			ps.appendTo( "#qunit-fixture" );

			ps.load( baseURL + "mock.php?action=echoMethod", function() {
				assert.strictEqual( this, ps[ i++ ] );

				if ( i === 2 ) {
					done();
				}
			} );
		}
	);

	QUnit.test(
		"#11402 - jQuery.domManip() - script in comments are properly evaluated",
		function( assert ) {
			assert.expect( 2 );
			jQuery( "#qunit-fixture" ).load( baseURL + "cleanScript.html", assert.async() );
		}
diff --git a/a.js b/b.js
@@ -2581,7 +2581,7 @@ QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
		}
	);

//----------- jQuery.get()

	QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on nodes", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();
		jQuery.get( url( "dashboard.xml" ), function( xml ) {
			var content = [];
			jQuery( "tab", xml ).each( function() {
				content.push( jQuery( this ).text() );
			} );
			assert.strictEqual( content[ 0 ], "blabla", "Check first tab" );
			assert.strictEqual( content[ 1 ], "blublu", "Check second tab" );
			done();
		} );
	} );

	QUnit.test( "#8277 - jQuery.get( String, Function ) - data in ajaxSettings", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			data: "helloworld"
diff --git a/a.js b/b.js
@@ -2672,7 +2672,7 @@ QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( asse
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				done();
			} );
		}
	);

	QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( assert ) {
		assert.expect( 1 );
		Globals.register( "testBar" );
		jQuery.getScript( url( "mock.php?action=testbar" ) ).done( assert.async() );
	} );

	QUnit.test( "#8082 - jQuery.getScript( String, Function ) - source as responseText", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();

		Globals.register( "testBar" );
diff --git a/a.js b/b.js
@@ -2759,7 +2759,7 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
		} );
		jQuery( "#first" ).load( baseURL + "name.html", undefined, assert.async() );
	} );

	// check if load can be called with only url
	QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html div.user", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 2, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
diff --git a/a.js b/b.js
@@ -2769,9 +2769,9 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	// Selector should include any valid non-HTML whitespace (#3003)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with non-HTML whitespace(#3003) )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #whitespace\\\\xA0 ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
diff --git a/a.js b/b.js
@@ -2902,7 +2902,7 @@ QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function(
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
			assert.ok( $node.find( "#query" ).text().match( /foo=3&bar=ok/ ), "Check if a string of data is passed correctly" );
			done();
		} );
	} );

	QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function( assert ) {
		assert.expect( 8 );
		var completeArgs = {},
			done = assert.async();

		jQuery.ajaxSetup( {
			success: function( _, status, jqXHR ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			},
			error: function( jqXHR, status ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			}
		} );

		jQuery.when.apply(
			jQuery,
			jQuery.map( [
				{
					type: "success",
					url: baseURL + "mock.php?action=echoQuery&arg=pop"
				},
				{
					type: "error",
					url: baseURL + "404.txt"
				}
			],
			function( options ) {
				return jQuery.Deferred( function( defer ) {
					jQuery( "#foo" ).load( options.url, function() {
						var args = arguments;
						assert.strictEqual( completeArgs[ options.url ].length, args.length, "same number of arguments (" + options.type + ")" );
						jQuery.each( completeArgs[ options.url ], function( i, value ) {
							assert.strictEqual( args[ i ], value, "argument #" + i + " is the same (" + options.type + ")" );
						} );
						defer.resolve();
					} );
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
diff --git a/a.js b/b.js
@@ -2917,7 +2917,7 @@ QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataTy
A blob:445f88aa3de8c4816679c110d41255bd13a8213d
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
			dataType: "json"
		} );
		jQuery( document ).on( "ajaxComplete", function( e, xml, s ) {
			assert.strictEqual( s.dataType, "html", "Verify the load() dataType was html" );
			jQuery( document ).off( "ajaxComplete" );
			done();
		} );
		jQuery( "#first" ).load( baseURL + "test3.html" );
	} );

	QUnit.test( "#10524 - jQuery.fn.load() - data specified in ajaxSettings is merged in", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		var data = {
diff --git a/a.js b/b.js
@@ -82,9 +82,9 @@ QUnit.test( "attr(String)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	};

	assert.deepEqual( props, jQuery.propFix, "jQuery.propFix passes integrity check" );
} );

QUnit.test( "attr(String)", function( assert ) {
	assert.expect( 50 );

	var extras, body, $body,
		select, optgroup, option, $img, styleElem,
		$button, $form, $a;

	assert.equal( jQuery( "#text1" ).attr( "type" ), "text", "Check for type attribute" );
	assert.equal( jQuery( "#radio1" ).attr( "type" ), "radio", "Check for type attribute" );
	assert.equal( jQuery( "#check1" ).attr( "type" ), "checkbox", "Check for type attribute" );
	assert.equal( jQuery( "#simon1" ).attr( "rel" ), "bookmark", "Check for rel attribute" );
	assert.equal( jQuery( "#google" ).attr( "title" ), "Google!", "Check for title attribute" );
	assert.equal( jQuery( "#mark" ).attr( "hreflang" ), "en", "Check for hreflang attribute" );
	assert.equal( jQuery( "#en" ).attr( "lang" ), "en", "Check for lang attribute" );
	assert.equal( jQuery( "#simon" ).attr( "class" ), "blog link", "Check for class attribute" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "name", "Check for name attribute" );
	assert.equal( jQuery( "#text1" ).attr( "name" ), "action", "Check for name attribute" );
	assert.ok( jQuery( "#form" ).attr( "action" ).indexOf( "formaction" ) >= 0, "Check for action attribute" );
	assert.equal( jQuery( "#text1" ).attr( "value", "t" ).attr( "value" ), "t", "Check setting the value attribute" );
	assert.equal( jQuery( "#text1" ).attr( "value", "" ).attr( "value" ), "", "Check setting the value attribute to empty string" );
	assert.equal( jQuery( "<div value='t'></div>" ).attr( "value" ), "t", "Check setting custom attr named 'value' on a div" );
	assert.equal( jQuery( "#form" ).attr( "blah", "blah" ).attr( "blah" ), "blah", "Set non-existent attribute on a form" );
	assert.equal( jQuery( "#foo" ).attr( "height" ), undefined, "Non existent height attribute should return undefined" );

	// [7472] & [3113] (form contains an input with name="action" or name="id")
	extras = jQuery( "<input id='id' name='id' /><input id='name' name='name' /><input id='target' name='target' />" ).appendTo( "#testForm" );
	assert.equal( jQuery( "#form" ).attr( "action", "newformaction" ).attr( "action" ), "newformaction", "Check that action attribute was changed" );
	assert.equal( jQuery( "#testForm" ).attr( "target" ), undefined, "Retrieving target does not equal the input with name=target" );
	assert.equal( jQuery( "#testForm" ).attr( "target", "newTarget" ).attr( "target" ), "newTarget", "Set target successfully on a form" );
	assert.equal( jQuery( "#testForm" ).removeAttr( "id" ).attr( "id" ), undefined, "Retrieving id does not equal the input with name=id after id is removed [#7472]" );

	// Bug #3685 (form contains input with name="name")
	assert.equal( jQuery( "#testForm" ).attr( "name" ), undefined, "Retrieving name does not retrieve input with name=name" );
	extras.remove();

	assert.equal( jQuery( "#text1" ).attr( "maxlength" ), "30", "Check for maxlength attribute" );
diff --git a/a.js b/b.js
@@ -142,13 +142,13 @@ jQuery( "<a></a>" ).attr( {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	assert.equal( jQuery( "#text1" ).attr( "maxlength" ), "30", "Check for maxlength attribute" );
	assert.equal( jQuery( "#text1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );
	assert.equal( jQuery( "#area1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );

	// using innerHTML in IE causes href attribute to be serialized to the full path
	jQuery( "<a></a>" ).attr( {
		"id": "tAnchor5",
		"href": "#5"
	} ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).attr( "href" ), "#5", "Check for non-absolute href (an anchor)" );
	jQuery( "<a id='tAnchor6' href='#5'></a>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#tAnchor6" ).prop( "href" ), "Check for absolute href prop on an anchor" );

	jQuery( "<script type='jquery/test' src='#5' id='scriptSrc'></script>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#scriptSrc" ).prop( "src" ), "Check for absolute src prop on a script" );

	// list attribute is readonly by default in browsers that support it
	jQuery( "#list-test" ).attr( "list", "datalist" );
	assert.equal( jQuery( "#list-test" ).attr( "list" ), "datalist", "Check setting list attribute" );

	// Related to [5574] and [5683]
	body = document.body;
	$body = jQuery( body );

	assert.strictEqual( $body.attr( "foo" ), undefined, "Make sure that a non existent attribute returns undefined" );

	body.setAttribute( "foo", "baz" );
	assert.equal( $body.attr( "foo" ), "baz", "Make sure the dom attribute is retrieved when no expando is found" );

	$body.attr( "foo", "cool" );
	assert.equal( $body.attr( "foo" ), "cool", "Make sure that setting works well when both expando and dom attribute are available" );

	body.removeAttribute( "foo" ); // Cleanup

	select = document.createElement( "select" );
	optgroup = document.createElement( "optgroup" );
	option = document.createElement( "option" );

	optgroup.appendChild( option );
	select.appendChild( optgroup );

	assert.equal( jQuery( option ).prop( "selected" ), true, "Make sure that a single option is selected, even when in an optgroup." );

	$img = jQuery( "<img style='display:none' width='215' height='53' src='" + baseURL + "1x1.jpg'/>" ).appendTo( "body" );
	assert.equal( $img.attr( "width" ), "215", "Retrieve width attribute on an element with display:none." );
	assert.equal( $img.attr( "height" ), "53", "Retrieve height attribute on an element with display:none." );

	// Check for style support
	styleElem = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).css( {
		background: "url(UPPERlower.gif)"
	} );
	assert.ok( !!~styleElem.attr( "style" ).indexOf( "UPPERlower.gif" ), "Check style attribute getter" );
	assert.ok( !!~styleElem.attr( "style", "position:absolute;" ).attr( "style" ).indexOf( "absolute" ), "Check style setter" );

	// Check value on button element (#1954)
	$button = jQuery( "<button>text</button>" ).insertAfter( "#button" );
	assert.strictEqual( $button.attr( "value" ), undefined, "Absence of value attribute on a button" );
	assert.equal( $button.attr( "value", "foobar" ).attr( "value" ), "foobar", "Value attribute on a button does not return innerHTML" );
	assert.equal( $button.attr( "value", "baz" ).html(), "text", "Setting the value attribute does not change innerHTML" );

	// Attributes with a colon on a table element (#1591)
	assert.equal( jQuery( "#table" ).attr( "test:attrib" ), undefined, "Retrieving a non-existent attribute on a table with a colon does not throw an error." );
	assert.equal( jQuery( "#table" ).attr( "test:attrib", "foobar" ).attr( "test:attrib" ), "foobar", "Setting an attribute on a table with a colon does not throw an error." );

	$form = jQuery( "<form class='something'></form>" ).appendTo( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -166,11 +166,11 @@ jQuery( "<a></a>" ).attr( {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	assert.equal( jQuery( "#text1" ).attr( "maxlength" ), "30", "Check for maxlength attribute" );
	assert.equal( jQuery( "#text1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );
	assert.equal( jQuery( "#area1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );

	// using innerHTML in IE causes href attribute to be serialized to the full path
	jQuery( "<a></a>" ).attr( {
		"id": "tAnchor5",
		"href": "#5"
	} ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).attr( "href" ), "#5", "Check for non-absolute href (an anchor)" );
	jQuery( "<a id='tAnchor6' href='#5'></a>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#tAnchor6" ).prop( "href" ), "Check for absolute href prop on an anchor" );

	jQuery( "<script type='jquery/test' src='#5' id='scriptSrc'></script>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#scriptSrc" ).prop( "src" ), "Check for absolute src prop on a script" );

	// list attribute is readonly by default in browsers that support it
	jQuery( "#list-test" ).attr( "list", "datalist" );
	assert.equal( jQuery( "#list-test" ).attr( "list" ), "datalist", "Check setting list attribute" );

	// Related to [5574] and [5683]
	body = document.body;
	$body = jQuery( body );

	assert.strictEqual( $body.attr( "foo" ), undefined, "Make sure that a non existent attribute returns undefined" );

	body.setAttribute( "foo", "baz" );
	assert.equal( $body.attr( "foo" ), "baz", "Make sure the dom attribute is retrieved when no expando is found" );

	$body.attr( "foo", "cool" );
	assert.equal( $body.attr( "foo" ), "cool", "Make sure that setting works well when both expando and dom attribute are available" );

	body.removeAttribute( "foo" ); // Cleanup

	select = document.createElement( "select" );
	optgroup = document.createElement( "optgroup" );
	option = document.createElement( "option" );

	optgroup.appendChild( option );
	select.appendChild( optgroup );

	assert.equal( jQuery( option ).prop( "selected" ), true, "Make sure that a single option is selected, even when in an optgroup." );

	$img = jQuery( "<img style='display:none' width='215' height='53' src='" + baseURL + "1x1.jpg'/>" ).appendTo( "body" );
	assert.equal( $img.attr( "width" ), "215", "Retrieve width attribute on an element with display:none." );
	assert.equal( $img.attr( "height" ), "53", "Retrieve height attribute on an element with display:none." );

	// Check for style support
	styleElem = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).css( {
		background: "url(UPPERlower.gif)"
	} );
	assert.ok( !!~styleElem.attr( "style" ).indexOf( "UPPERlower.gif" ), "Check style attribute getter" );
	assert.ok( !!~styleElem.attr( "style", "position:absolute;" ).attr( "style" ).indexOf( "absolute" ), "Check style setter" );

	// Check value on button element (#1954)
	$button = jQuery( "<button>text</button>" ).insertAfter( "#button" );
	assert.strictEqual( $button.attr( "value" ), undefined, "Absence of value attribute on a button" );
	assert.equal( $button.attr( "value", "foobar" ).attr( "value" ), "foobar", "Value attribute on a button does not return innerHTML" );
	assert.equal( $button.attr( "value", "baz" ).html(), "text", "Setting the value attribute does not change innerHTML" );

	// Attributes with a colon on a table element (#1591)
	assert.equal( jQuery( "#table" ).attr( "test:attrib" ), undefined, "Retrieving a non-existent attribute on a table with a colon does not throw an error." );
	assert.equal( jQuery( "#table" ).attr( "test:attrib", "foobar" ).attr( "test:attrib" ), "foobar", "Setting an attribute on a table with a colon does not throw an error." );

	$form = jQuery( "<form class='something'></form>" ).appendTo( "#qunit-fixture" );
	assert.equal( $form.attr( "class" ), "something", "Retrieve the class attribute on a form." );

	$a = jQuery( "<a href='#' onclick='something()'>Click</a>" ).appendTo( "#qunit-fixture" );
	assert.equal( $a.attr( "onclick" ), "something()", "Retrieve ^on attribute without anonymous function wrapper." );

	assert.ok( jQuery( "<div></div>" ).attr( "doesntexist" ) === undefined, "Make sure undefined is returned when no attribute is found." );
	assert.ok( jQuery( "<div></div>" ).attr( "title" ) === undefined, "Make sure undefined is returned when no attribute is found." );
	assert.equal( jQuery( "<div></div>" ).attr( "title", "something" ).attr( "title" ), "something", "Set the title attribute." );
	assert.ok( jQuery().attr( "doesntexist" ) === undefined, "Make sure undefined is returned when no element is there." );
	assert.equal( jQuery( "<div></div>" ).attr( "value" ), undefined, "An unset value on a div returns undefined." );
	assert.strictEqual( jQuery( "<select><option value='property'></option></select>" ).attr( "value" ), undefined, "An unset value on a select returns undefined." );

	$form = jQuery( "#form" ).attr( "enctype", "multipart/form-data" );
	assert.equal( $form.prop( "enctype" ), "multipart/form-data", "Set the enctype of a form (encoding in IE6/7 #6743)" );

} );

QUnit.test( "attr(String) on cloned elements, #9646", function( assert ) {
	assert.expect( 4 );

	var div,
		input = jQuery( "<input name='tester' />" );
diff --git a/a.js b/b.js
@@ -295,7 +295,7 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
diff --git a/a.js b/b.js
@@ -377,13 +377,13 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

diff --git a/a.js b/b.js
@@ -402,7 +402,7 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

	// Register the property on the window for the previous assertion so it will be clean up
	Globals.register( "nonexisting" );

	table = jQuery( "#table" ).append( "<tr><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr>" );
	td = table.find( "td" ).eq( 0 );
	td.attr( "rowspan", "2" );
	assert.equal( td[ 0 ][ "rowSpan" ], 2, "Check rowspan is correctly set" );
	td.attr( "colspan", "2" );
	assert.equal( td[ 0 ][ "colSpan" ], 2, "Check colspan is correctly set" );
	table.attr( "cellspacing", "2" );
	assert.equal( table[ 0 ][ "cellSpacing" ], "2", "Check cellspacing is correctly set" );

	assert.equal( jQuery( "#area1" ).attr( "value" ), undefined, "Value attribute is distinct from value property." );

	// for #1070
	jQuery( "#name" ).attr( "someAttr", "0" );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to a string of '0'" );
	jQuery( "#name" ).attr( "someAttr", 0 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to the number 0" );
diff --git a/a.js b/b.js
@@ -462,7 +462,7 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

	// Register the property on the window for the previous assertion so it will be clean up
	Globals.register( "nonexisting" );

	table = jQuery( "#table" ).append( "<tr><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr>" );
	td = table.find( "td" ).eq( 0 );
	td.attr( "rowspan", "2" );
	assert.equal( td[ 0 ][ "rowSpan" ], 2, "Check rowspan is correctly set" );
	td.attr( "colspan", "2" );
	assert.equal( td[ 0 ][ "colSpan" ], 2, "Check colspan is correctly set" );
	table.attr( "cellspacing", "2" );
	assert.equal( table[ 0 ][ "cellSpacing" ], "2", "Check cellspacing is correctly set" );

	assert.equal( jQuery( "#area1" ).attr( "value" ), undefined, "Value attribute is distinct from value property." );

	// for #1070
	jQuery( "#name" ).attr( "someAttr", "0" );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to a string of '0'" );
	jQuery( "#name" ).attr( "someAttr", 0 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to the number 0" );
	jQuery( "#name" ).attr( "someAttr", 1 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "1", "Set attribute to the number 1" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();

	j.attr( "name", "attrvalue" );
	assert.equal( j.attr( "name" ), "attrvalue", "Check node,textnode,comment for attr" );
	j.removeAttr( "name" );

	// Type
	type = jQuery( "#check2" ).attr( "type" );
	try {
		jQuery( "#check2" ).attr( "type", "hidden" );
		assert.ok( true, "No exception thrown on input type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on input type change: " + e );
	}

	check = document.createElement( "input" );
	thrown = true;
	try {
		jQuery( check ).attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", jQuery( check ).attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	check = jQuery( "<input />" );
	thrown = true;
	try {
		check.attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", check.attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	button = jQuery( "#button" );
	try {
		button.attr( "type", "submit" );
		assert.ok( true, "No exception thrown on button type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on button type change: " + e );
	}

	$radio = jQuery( "<input>", {
		"value": "sup",
		// Use uppercase here to ensure the type
		// attrHook is still used
		"TYPE": "radio"
	} ).appendTo( "#testForm" );
	assert.equal( $radio.val(), "sup", "Value is not reset when type is set after value on a radio" );

	// Setting attributes on svg elements (bug #3116)
	$svg = jQuery(
		"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1' baseProfile='full' width='200' height='200'>" +

			"<circle cx='200' cy='200' r='150' />" +
diff --git a/a.js b/b.js
@@ -474,9 +474,9 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

	// Register the property on the window for the previous assertion so it will be clean up
	Globals.register( "nonexisting" );

	table = jQuery( "#table" ).append( "<tr><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr>" );
	td = table.find( "td" ).eq( 0 );
	td.attr( "rowspan", "2" );
	assert.equal( td[ 0 ][ "rowSpan" ], 2, "Check rowspan is correctly set" );
	td.attr( "colspan", "2" );
	assert.equal( td[ 0 ][ "colSpan" ], 2, "Check colspan is correctly set" );
	table.attr( "cellspacing", "2" );
	assert.equal( table[ 0 ][ "cellSpacing" ], "2", "Check cellspacing is correctly set" );

	assert.equal( jQuery( "#area1" ).attr( "value" ), undefined, "Value attribute is distinct from value property." );

	// for #1070
	jQuery( "#name" ).attr( "someAttr", "0" );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to a string of '0'" );
	jQuery( "#name" ).attr( "someAttr", 0 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to the number 0" );
	jQuery( "#name" ).attr( "someAttr", 1 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "1", "Set attribute to the number 1" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();

	j.attr( "name", "attrvalue" );
	assert.equal( j.attr( "name" ), "attrvalue", "Check node,textnode,comment for attr" );
	j.removeAttr( "name" );

	// Type
	type = jQuery( "#check2" ).attr( "type" );
	try {
		jQuery( "#check2" ).attr( "type", "hidden" );
		assert.ok( true, "No exception thrown on input type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on input type change: " + e );
	}

	check = document.createElement( "input" );
	thrown = true;
	try {
		jQuery( check ).attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", jQuery( check ).attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	check = jQuery( "<input />" );
	thrown = true;
	try {
		check.attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", check.attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	button = jQuery( "#button" );
	try {
		button.attr( "type", "submit" );
		assert.ok( true, "No exception thrown on button type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on button type change: " + e );
	}

	$radio = jQuery( "<input>", {
		"value": "sup",
		// Use uppercase here to ensure the type
		// attrHook is still used
		"TYPE": "radio"
	} ).appendTo( "#testForm" );
	assert.equal( $radio.val(), "sup", "Value is not reset when type is set after value on a radio" );

	// Setting attributes on svg elements (bug #3116)
	$svg = jQuery(
		"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1' baseProfile='full' width='200' height='200'>" +

			"<circle cx='200' cy='200' r='150' />" +
			"</svg>"
		).appendTo( "body" );
	assert.equal( $svg.attr( "cx", 100 ).attr( "cx" ), "100", "Set attribute on svg element" );
	$svg.remove();

	// undefined values are chainable
	jQuery( "#name" ).attr( "maxlength", "5" ).removeAttr( "nonexisting" );
	assert.equal( typeof jQuery( "#name" ).attr( "maxlength", undefined ), "object", ".attr('attribute', undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#name" ).attr( "maxlength", undefined ).attr( "maxlength" ), "5", ".attr('attribute', undefined) does not change value (#5571)" );
	assert.equal( jQuery( "#name" ).attr( "nonexisting", undefined ).attr( "nonexisting" ), undefined, ".attr('attribute', undefined) does not create attribute (#5571)" );
} );

QUnit.test( "attr(non-ASCII)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -573,7 +573,7 @@ QUnit.test( "removeAttr(String)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	element.attr( "tabindex", -1 );
	assert.equal( element.attr( "tabindex" ), "-1", "set negative tabindex" );
} );

QUnit.test( "removeAttr(String)", function( assert ) {
	assert.expect( 12 );
	var $first;

	assert.equal( jQuery( "<div class='hello'></div>" ).removeAttr( "class" ).attr( "class" ), undefined, "remove class" );
	assert.equal( jQuery( "#form" ).removeAttr( "id" ).attr( "id" ), undefined, "Remove id" );
	assert.equal( jQuery( "#foo" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute" );
	assert.equal( jQuery( "#form" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute on a form" );
	assert.equal( jQuery( "<div style='position: absolute'></div>" ).appendTo( "#foo" ).removeAttr( "style" ).prop( "style" ).cssText, "", "Check removing style attribute (#9699 Webkit)" );
	assert.equal( jQuery( "#fx-test-group" ).attr( "height", "3px" ).removeAttr( "height" ).get( 0 ).style.height, "1px", "Removing height attribute has no effect on height set with style attribute" );

	jQuery( "#check1" ).removeAttr( "checked" ).prop( "checked", true ).removeAttr( "checked" );
	assert.equal( document.getElementById( "check1" ).checked, true, "removeAttr should not set checked to false, since the checked attribute does NOT mirror the checked property" );
diff --git a/a.js b/b.js
@@ -582,13 +582,13 @@ QUnit.test( "removeAttr(String)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	element.attr( "tabindex", -1 );
	assert.equal( element.attr( "tabindex" ), "-1", "set negative tabindex" );
} );

QUnit.test( "removeAttr(String)", function( assert ) {
	assert.expect( 12 );
	var $first;

	assert.equal( jQuery( "<div class='hello'></div>" ).removeAttr( "class" ).attr( "class" ), undefined, "remove class" );
	assert.equal( jQuery( "#form" ).removeAttr( "id" ).attr( "id" ), undefined, "Remove id" );
	assert.equal( jQuery( "#foo" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute" );
	assert.equal( jQuery( "#form" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute on a form" );
	assert.equal( jQuery( "<div style='position: absolute'></div>" ).appendTo( "#foo" ).removeAttr( "style" ).prop( "style" ).cssText, "", "Check removing style attribute (#9699 Webkit)" );
	assert.equal( jQuery( "#fx-test-group" ).attr( "height", "3px" ).removeAttr( "height" ).get( 0 ).style.height, "1px", "Removing height attribute has no effect on height set with style attribute" );

	jQuery( "#check1" ).removeAttr( "checked" ).prop( "checked", true ).removeAttr( "checked" );
	assert.equal( document.getElementById( "check1" ).checked, true, "removeAttr should not set checked to false, since the checked attribute does NOT mirror the checked property" );
	jQuery( "#text1" ).prop( "readOnly", true ).removeAttr( "readonly" );
	assert.equal( document.getElementById( "text1" ).readOnly, false, "removeAttr sets boolean properties to false" );

	jQuery( "#option2c" ).removeAttr( "selected" );
	assert.equal( jQuery( "#option2d" ).attr( "selected" ), "selected", "Removing `selected` from an option that is not selected does not remove selected from the currently selected option (#10870)" );

	try {
		$first = jQuery( "#first" ).attr( "contenteditable", "true" ).removeAttr( "contenteditable" );
		assert.equal( $first.attr( "contenteditable" ), undefined, "Remove the contenteditable attribute" );
	} catch ( e ) {
		assert.ok( false, "Removing contenteditable threw an error (#10429)" );
	}

	$first = jQuery( "<div Case='mixed'></div>" );
	assert.equal( $first.attr( "Case" ), "mixed", "case of attribute doesn't matter" );
diff --git a/a.js b/b.js
@@ -714,26 +714,26 @@ QUnit.test( "prop(String, Object) on null/undefined", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	assert.equal( jQuery( "#table" ).prop( "useMap" ), 1, "Check setting and retrieving useMap" );
	jQuery( "#table" ).prop( "frameborder", 1 );
	assert.equal( jQuery( "#table" ).prop( "frameBorder" ), 1, "Check setting and retrieving frameBorder" );
} );

QUnit.test( "prop(String, Object) on null/undefined", function( assert ) {

  assert.expect( 14 );

	var select, optgroup, option, attributeNode, commentNode, textNode, obj, $form,
		body = document.body,
		$body = jQuery( body );

	assert.ok( $body.prop( "nextSibling" ) === null, "Make sure a null expando returns null" );
	body[ "foo" ] = "bar";
	assert.equal( $body.prop( "foo" ), "bar", "Make sure the expando is preferred over the dom attribute" );
	body[ "foo" ] = undefined;
	assert.ok( $body.prop( "foo" ) === undefined, "Make sure the expando is preferred over the dom attribute, even if undefined" );

	select = document.createElement( "select" );
	optgroup = document.createElement( "optgroup" );
	option = document.createElement( "option" );

	optgroup.appendChild( option );
	select.appendChild( optgroup );

	assert.equal( jQuery( option ).prop( "selected" ), true, "Make sure that a single option is selected, even when in an optgroup." );
	assert.equal( jQuery( document ).prop( "nodeName" ), "#document", "prop works correctly on document nodes (bug #7451)." );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};
	jQuery.each( [ document, attributeNode, commentNode, textNode, obj, "#firstp" ], function( i, ele ) {
		assert.strictEqual( jQuery( ele ).prop( "nonexisting" ), undefined, "prop works correctly for non existing attributes (bug #7500)." );
	} );

	obj = {};
	jQuery.each( [ document, obj ], function( i, ele ) {
		var $ele = jQuery( ele );
		$ele.prop( "nonexisting", "foo" );
		assert.equal( $ele.prop( "nonexisting" ), "foo", "prop(name, value) works correctly for non existing attributes (bug #7500)." );
	} );
	jQuery( document ).removeProp( "nonexisting" );

	$form = jQuery( "#form" ).prop( "enctype", "multipart/form-data" );
	assert.equal( $form.prop( "enctype" ), "multipart/form-data", "Set the enctype of a form (encoding in IE6/7 #6743)" );
} );

QUnit.test( "prop('tabindex')", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -856,12 +856,12 @@ QUnit.test( "removeProp(String)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	$select.find( "[value=b]" ).prop( "selected", true );

	assert.equal( $select[ 0 ].selectedIndex, 1, "Setting option in optgroup selected affects selectedIndex" );
} );

QUnit.test( "removeProp(String)", function( assert ) {
	assert.expect( 6 );
	var attributeNode = document.createAttribute( "irrelevant" ),
		commentNode = document.createComment( "some comment" ),
		textNode = document.createTextNode( "some text" ),
		obj = {};

	assert.strictEqual(
		jQuery( "#firstp" ).prop( "nonexisting", "foo" ).removeProp( "nonexisting" )[ 0 ][ "nonexisting" ],
		undefined,
		"removeprop works correctly on DOM element nodes"
	);

	jQuery.each( [ document, obj ], function( i, ele ) {
		var $ele = jQuery( ele );
		$ele.prop( "nonexisting", "foo" ).removeProp( "nonexisting" );
		assert.strictEqual( ele[ "nonexisting" ], undefined, "removeProp works correctly on non DOM element nodes (bug #7500)." );
	} );
	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, ele ) {
		var $ele = jQuery( ele );
		$ele.prop( "nonexisting", "foo" ).removeProp( "nonexisting" );
		assert.strictEqual( ele[ "nonexisting" ], undefined, "removeProp works correctly on non DOM element nodes (bug #7500)." );
	} );
} );

QUnit.test( "val() after modification", function( assert ) {
diff --git a/a.js b/b.js
@@ -880,7 +880,7 @@ QUnit.test( "val()", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	document.getElementById( "text1" ).value = "bla";
	assert.equal( jQuery( "#text1" ).val(), "bla", "Check for modified value of input element" );
} );

QUnit.test( "val()", function( assert ) {

	assert.expect( 20 + ( jQuery.fn.serialize ? 6 : 0 ) );

	var checks, $button;
	assert.equal( jQuery( "#text1" ).val(), "Test", "Check for value of input element" );

	// ticket #1714 this caused a JS error in IE
	assert.equal( jQuery( "#first" ).val(), "", "Check a paragraph element to see if it has a value" );
	assert.ok( jQuery( [] ).val() === undefined, "Check an empty jQuery object will return undefined from val" );

	assert.equal( jQuery( "#select2" ).val(), "3", "Call val() on a single='single' select" );
diff --git a/a.js b/b.js
@@ -918,7 +918,7 @@ QUnit.test( "val()", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	document.getElementById( "text1" ).value = "bla";
	assert.equal( jQuery( "#text1" ).val(), "bla", "Check for modified value of input element" );
} );

QUnit.test( "val()", function( assert ) {

	assert.expect( 20 + ( jQuery.fn.serialize ? 6 : 0 ) );

	var checks, $button;
	assert.equal( jQuery( "#text1" ).val(), "Test", "Check for value of input element" );

	// ticket #1714 this caused a JS error in IE
	assert.equal( jQuery( "#first" ).val(), "", "Check a paragraph element to see if it has a value" );
	assert.ok( jQuery( [] ).val() === undefined, "Check an empty jQuery object will return undefined from val" );

	assert.equal( jQuery( "#select2" ).val(), "3", "Call val() on a single='single' select" );

	assert.deepEqual( jQuery( "#select3" ).val(), [ "1", "2" ], "Call val() on a multiple='multiple' select" );

	assert.equal( jQuery( "#option3c" ).val(), "2", "Call val() on a option element with value" );

	assert.equal( jQuery( "#option3a" ).val(), "", "Call val() on a option element with empty value" );

	assert.equal( jQuery( "#option3e" ).val(), "no value", "Call val() on a option element with no value attribute" );

	assert.equal( jQuery( "#option3a" ).val(), "", "Call val() on a option element with no value attribute" );

	jQuery( "#select3" ).val( "" );
	assert.deepEqual( jQuery( "#select3" ).val(), [ "" ], "Call val() on a multiple='multiple' select" );

	assert.deepEqual( jQuery( "#select4" ).val(), [], "Call val() on multiple='multiple' select with all disabled options" );

	jQuery( "#select4 optgroup" ).add( "#select4 > [disabled]" ).attr( "disabled", false );
	assert.deepEqual( jQuery( "#select4" ).val(), [ "2", "3" ], "Call val() on multiple='multiple' select with some disabled options" );

	jQuery( "#select4" ).attr( "disabled", true );
	assert.deepEqual( jQuery( "#select4" ).val(), [ "2", "3" ], "Call val() on disabled multiple='multiple' select" );

	assert.equal( jQuery( "#select5" ).val(), "3", "Check value on ambiguous select." );

	jQuery( "#select5" ).val( 1 );
	assert.equal( jQuery( "#select5" ).val(), "1", "Check value on ambiguous select." );

	jQuery( "#select5" ).val( 3 );
	assert.equal( jQuery( "#select5" ).val(), "3", "Check value on ambiguous select." );

	assert.strictEqual(
		jQuery( "<select name='select12584' id='select12584'><option value='1' disabled='disabled'>1</option></select>" ).val(),
		null,
		"Select-one with only option disabled (#12584)"
	);

	if ( jQuery.fn.serialize ) {
		checks = jQuery( "<input type='checkbox' name='test' value='1'/><input type='checkbox' name='test' value='2'/><input type='checkbox' name='test' value=''/><input type='checkbox' name='test'/>" ).appendTo( "#form" );
diff --git a/a.js b/b.js
@@ -966,7 +966,7 @@ QUnit.test( "val() with non-matching values on dropdown list", function( assert
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	assert.equal( $button.val( "baz" ).html(), "text", "Setting the value does not change innerHTML" );

	assert.equal( jQuery( "<option></option>" ).val( "test" ).attr( "value" ), "test", "Setting value sets the value attribute" );
} );

QUnit.test( "val() with non-matching values on dropdown list", function( assert ) {
	assert.expect( 3 );

	jQuery( "#select5" ).val( "" );
	assert.equal( jQuery( "#select5" ).val(), null, "Non-matching set on select-one" );

	var select6 = jQuery( "<select multiple id=\"select6\"><option value=\"1\">A</option><option value=\"2\">B</option></select>" ).appendTo( "#form" );
	jQuery( select6 ).val( "nothing" );
	assert.deepEqual( jQuery( select6 ).val(), [], "Non-matching set (single value) on select-multiple" );

	jQuery( select6 ).val( [ "nothing1", "nothing2" ] );
	assert.deepEqual( jQuery( select6 ).val(), [], "Non-matching set (array of values) on select-multiple" );

	select6.remove();
} );

QUnit.test( "val() respects numbers without exception (Bug #9319) - progress",
	function( assert ) {

	assert.expect( 2 );

diff --git a/a.js b/b.js
@@ -983,7 +983,7 @@ function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	select6.remove();
} );

QUnit.test( "val() respects numbers without exception (Bug #9319) - progress",
	function( assert ) {

	assert.expect( 2 );

	var $progress = jQuery( "<progress max='10' value='1.5'></progress>" );

	try {
		assert.equal( typeof $progress.val(), "number", "progress, returns a number and does not throw exception" );
		assert.equal( $progress.val(), $progress[ 0 ].value, "progress, api matches host and does not throw exception" );

	} catch ( e ) {}

	$progress.remove();
} );

// IE doesn't support <meter>
QUnit.testUnlessIE( "val() respects numbers without exception (Bug #9319) - meter",
	function( assert ) {

	assert.expect( 2 );

diff --git a/a.js b/b.js
@@ -1045,7 +1045,7 @@ QUnit.test( "val(Function)", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

QUnit.test( "val(String/Number)", function( assert ) {
	testVal( bareObj, assert );
} );

QUnit.test( "val(Function)", function( assert ) {
	testVal( functionReturningObj, assert );
} );

QUnit.test( "val(Array of Numbers) (Bug #7123)", function( assert ) {
	assert.expect( 4 );
	jQuery( "#form" ).append( "<input type='checkbox' name='arrayTest' value='1' /><input type='checkbox' name='arrayTest' value='2' /><input type='checkbox' name='arrayTest' value='3' checked='checked' /><input type='checkbox' name='arrayTest' value='4' />" );
	var elements = jQuery( "#form input[name=arrayTest]" ).val( [ 1, 2 ] );
	assert.ok( elements[ 0 ].checked, "First element was checked" );
diff --git a/a.js b/b.js
@@ -1109,7 +1109,7 @@ jQuery( "#select1" ).val( function( i, val ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	jQuery( "#select1" ).append( "<option value='4'>four</option>" );

	oldVal = jQuery( "#select1" ).val();

	jQuery( "#select1" ).val( function( i, val ) {
		assert.equal( val, oldVal, "Make sure the incoming value is correct." );
		return 4;
	} );

	assert.equal( jQuery( "#select1" ).val(), "4", "Should be possible to set the val() to a newly created option" );
} );

// testing if a form.reset() breaks a subsequent call to a select element's .val() (in IE only)
QUnit.test( "val(select) after form.reset() (Bug #2551)", function( assert ) {
	assert.expect( 3 );

	jQuery( "<form id='kk' name='kk'><select id='kkk'><option value='cf'>cf</option><option value='gf'>gf</option></select></form>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -1644,6 +1644,44 @@ QUnit.test( "addClass, removeClass, hasClass on elements with classes with non-H
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	assert.equal( elem[ 2 ].className, "hi", "Check removal of two classes" );

	assert.ok( elem.hasClass( "hi" ), "Check has1" );
} );

QUnit.test( "addClass, removeClass, hasClass on elements with classes with non-HTML whitespace (gh-3072, gh-3003)", function( assert ) {
	assert.expect( 9 );

	var $elem = jQuery( "<div class='&#xA0;test'></div>" );

	function testMatches() {
		assert.ok( $elem.is( ".\\A0 test" ), "Element matches with collapsed space" );
		assert.ok( $elem.is( ".\\A0test" ), "Element matches with non-breaking space" );
		assert.ok( $elem.hasClass( "\xA0test" ), "Element has class with non-breaking space" );
	}

	testMatches();
	$elem.addClass( "foo" );
	testMatches();
	$elem.removeClass( "foo" );
	testMatches();
} );

QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div><span class='foo'></span><!-- comment -->text</div>" ),
diff --git a/a.js b/b.js
@@ -1654,7 +1692,7 @@ QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	testMatches();
	$elem.removeClass( "foo" );
	testMatches();
} );

QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div><span class='foo'></span><!-- comment -->text</div>" ),
	$contents = $div.contents();

	assert.ok( $contents.hasClass( "foo" ), "Found 'foo' in $contents" );
	assert.ok( !$contents.hasClass( "undefined" ), "Did not find 'undefined' in $contents (correctly)" );
} );

QUnit.test( "hasClass correctly interprets non-space separators (#13835)", function( assert ) {
	assert.expect( 4 );

	var
		map = {
diff --git a/a.js b/b.js
@@ -1674,7 +1712,7 @@ QUnit.test( "hasClass correctly interprets non-space separators (#13835)", funct
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7

	assert.ok( $contents.hasClass( "foo" ), "Found 'foo' in $contents" );
	assert.ok( !$contents.hasClass( "undefined" ), "Did not find 'undefined' in $contents (correctly)" );
} );

QUnit.test( "hasClass correctly interprets non-space separators (#13835)", function( assert ) {
	assert.expect( 4 );

	var
		map = {
			tab: "&#9;",
			"line-feed": "&#10;",
			"form-feed": "&#12;",
			"carriage-return": "&#13;"
		},
		classes = jQuery.map( map, function( separator, label ) {
			return " " + separator + label + separator + " ";
		} ),
		$div = jQuery( "<div class='" + classes + "'></div>" );

	jQuery.each( map, function( label ) {
		assert.ok( $div.hasClass( label ), label.replace( "-", " " ) );
	} );
} );

QUnit.test( "coords returns correct values in IE6/IE7, see #10828", function( assert ) {
	assert.expect( 1 );

	var area,
		map = jQuery( "<map></map>" );
diff --git a/a.js b/b.js
@@ -1684,7 +1722,7 @@ QUnit.test( "coords returns correct values in IE6/IE7, see #10828", function( as
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	jQuery.each( map, function( label ) {
		assert.ok( $div.hasClass( label ), label.replace( "-", " " ) );
	} );
} );

QUnit.test( "coords returns correct values in IE6/IE7, see #10828", function( assert ) {
	assert.expect( 1 );

	var area,
		map = jQuery( "<map></map>" );

	area = map.html( "<area shape='rect' coords='0,0,0,0' href='#' alt='a'></area>" ).find( "area" );
	assert.equal( area.attr( "coords" ), "0,0,0,0", "did not retrieve coords correctly" );
} );

QUnit.test( "should not throw at $(option).val() (#14686)", function( assert ) {
	assert.expect( 1 );

	try {
		jQuery( "<option></option>" ).val();
diff --git a/a.js b/b.js
@@ -1700,7 +1738,7 @@ QUnit.test( "option value not trimmed when setting via parent select", function(
A blob:2658495ae372a3ed46ce9cc6be9ccbd4652be9f7
	} catch ( _ ) {
		assert.ok( false );
	}
} );

QUnit.test( "option value not trimmed when setting via parent select", function( assert ) {
	assert.expect( 1 );
	assert.equal( jQuery( "<select><option> 2</option></select>" ).val( "2" ).val(), "2" );
} );

QUnit.test( "Insignificant white space returned for $(option).val() (#14858, gh-2978)", function( assert ) {
	assert.expect( 16 );

	var val = jQuery( "<option></option>" ).val();
	assert.equal( val.length, 0, "Empty option should have no value" );
diff --git a/a.js b/b.js
@@ -100,7 +100,7 @@ QUnit.test( "jQuery.Callbacks( " + showFlags( flags ) + " ) - " + filterLabel, f
A blob:c1a6eacf6c0a2befc09824e17db6e4f4bbed4b63
			jQuery.each( {
				"string": strFlags,
				"object": objectFlags
			}, function( flagsTypes, flags ) {

				QUnit.test( "jQuery.Callbacks( " + showFlags( flags ) + " ) - " + filterLabel, function( assert ) {

					assert.expect( 29 );

					var cblist,
						results = resultString.split( /\s+/ );

					// Basic binding and firing
					output = "X";
					cblist = jQuery.Callbacks( flags );
					assert.strictEqual( cblist.locked(), false, ".locked() initially false" );
					assert.strictEqual( cblist.disabled(), false, ".disabled() initially false" );
					assert.strictEqual( cblist.fired(), false, ".fired() initially false" );
					cblist.add( function( str ) {
						output += str;
					} );
					assert.strictEqual( cblist.fired(), false, ".fired() still false after .add" );
					cblist.fire( "A" );
					assert.strictEqual( output, "XA", "Basic binding and firing" );
					assert.strictEqual( cblist.fired(), true, ".fired() detects firing" );
					output = "X";
					cblist.disable();
					cblist.add( function( str ) {
						output += str;
					} );
					assert.strictEqual( output, "X", "Adding a callback after disabling" );
					cblist.fire( "A" );
					assert.strictEqual( output, "X", "Firing after disabling" );
					assert.strictEqual( cblist.disabled(), true, ".disabled() becomes true" );
					assert.strictEqual( cblist.locked(), true, "disabling locks" );

					// Emptying while firing (#13517)
					cblist = jQuery.Callbacks( flags );
					cblist.add( cblist.empty );
					cblist.add( function() {
						assert.ok( false, "not emptied" );
diff --git a/a.js b/b.js
@@ -92,7 +92,7 @@ QUnit.test( "jQuery()", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
	assert.ok( RegExp, "RegExp" );
	assert.ok( jQuery, "jQuery" );
	assert.ok( $, "$" );
} );

QUnit.test( "jQuery()", function( assert ) {

	var elem, i,
		obj = jQuery( "div" ),
		code = jQuery( "<code></code>" ),
		img = jQuery( "<img/>" ),
		div = jQuery( "<div></div><hr/><code></code><b/>" ),
		exec = false,
		expected = 23,
		attrObj = {
			"text": "test",
			"class": "test2",
			"id": "test3"
		};

	// The $(html, props) signature can stealth-call any $.fn method, check for a
	// few here but beware of modular builds where these methods may be excluded.
	if ( jQuery.fn.click ) {
		expected++;
		attrObj[ "click" ] = function() { assert.ok( exec, "Click executed." ); };
	}
	if ( jQuery.fn.width ) {
		expected++;
		attrObj[ "width" ] = 10;
	}
	if ( jQuery.fn.offset ) {
		expected++;
		attrObj[ "offset" ] = { "top": 1, "left": 1 };
	}
	if ( jQuery.fn.css ) {
		expected += 2;
		attrObj[ "css" ] = { "paddingLeft": 1, "paddingRight": 1 };
	}
	if ( jQuery.fn.attr ) {
		expected++;
		attrObj.attr = { "desired": "very" };
	}

	assert.expect( expected );

	// Basic constructor's behavior
	assert.equal( jQuery().length, 0, "jQuery() === jQuery([])" );
	assert.equal( jQuery( undefined ).length, 0, "jQuery(undefined) === jQuery([])" );
	assert.equal( jQuery( null ).length, 0, "jQuery(null) === jQuery([])" );
	assert.equal( jQuery( "" ).length, 0, "jQuery('') === jQuery([])" );
	assert.deepEqual( jQuery( obj ).get(), obj.get(), "jQuery(jQueryObj) == jQueryObj" );

	// Invalid #id will throw an error (gh-1682)
	try {
		jQuery( "#" );
	} catch ( e ) {
		assert.ok( true, "Threw an error on #id with no id" );
	}

	// can actually yield more than one, when iframes are included, the window is an array as well
	assert.equal( jQuery( window ).length, 1, "Correct number of elements generated for jQuery(window)" );

/*
	// disabled since this test was doing nothing. i tried to fix it but i'm not sure
	// what the expected behavior should even be. FF returns "\n" for the text node
	// make sure this is handled
	var crlfContainer = jQuery('<p>\r\n</p>');
	var x = crlfContainer.contents().get(0).nodeValue;
	assert.equal( x, what???, "Check for \\r and \\n in jQuery()" );
*/

	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		jQuery("<div>Testing</div>").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	assert.ok( pass, "jQuery('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	assert.equal( code.length, 1, "Correct number of elements generated for code" );
	assert.equal( code.parent().length, 0, "Make sure that the generated HTML has no parent." );

diff --git a/a.js b/b.js
@@ -146,7 +146,7 @@ QUnit.test( "jQuery()", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
	assert.ok( RegExp, "RegExp" );
	assert.ok( jQuery, "jQuery" );
	assert.ok( $, "$" );
} );

QUnit.test( "jQuery()", function( assert ) {

	var elem, i,
		obj = jQuery( "div" ),
		code = jQuery( "<code></code>" ),
		img = jQuery( "<img/>" ),
		div = jQuery( "<div></div><hr/><code></code><b/>" ),
		exec = false,
		expected = 23,
		attrObj = {
			"text": "test",
			"class": "test2",
			"id": "test3"
		};

	// The $(html, props) signature can stealth-call any $.fn method, check for a
	// few here but beware of modular builds where these methods may be excluded.
	if ( jQuery.fn.click ) {
		expected++;
		attrObj[ "click" ] = function() { assert.ok( exec, "Click executed." ); };
	}
	if ( jQuery.fn.width ) {
		expected++;
		attrObj[ "width" ] = 10;
	}
	if ( jQuery.fn.offset ) {
		expected++;
		attrObj[ "offset" ] = { "top": 1, "left": 1 };
	}
	if ( jQuery.fn.css ) {
		expected += 2;
		attrObj[ "css" ] = { "paddingLeft": 1, "paddingRight": 1 };
	}
	if ( jQuery.fn.attr ) {
		expected++;
		attrObj.attr = { "desired": "very" };
	}

	assert.expect( expected );

	// Basic constructor's behavior
	assert.equal( jQuery().length, 0, "jQuery() === jQuery([])" );
	assert.equal( jQuery( undefined ).length, 0, "jQuery(undefined) === jQuery([])" );
	assert.equal( jQuery( null ).length, 0, "jQuery(null) === jQuery([])" );
	assert.equal( jQuery( "" ).length, 0, "jQuery('') === jQuery([])" );
	assert.deepEqual( jQuery( obj ).get(), obj.get(), "jQuery(jQueryObj) == jQueryObj" );

	// Invalid #id will throw an error (gh-1682)
	try {
		jQuery( "#" );
	} catch ( e ) {
		assert.ok( true, "Threw an error on #id with no id" );
	}

	// can actually yield more than one, when iframes are included, the window is an array as well
	assert.equal( jQuery( window ).length, 1, "Correct number of elements generated for jQuery(window)" );

/*
	// disabled since this test was doing nothing. i tried to fix it but i'm not sure
	// what the expected behavior should even be. FF returns "\n" for the text node
	// make sure this is handled
	var crlfContainer = jQuery('<p>\r\n</p>');
	var x = crlfContainer.contents().get(0).nodeValue;
	assert.equal( x, what???, "Check for \\r and \\n in jQuery()" );
*/

	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		jQuery("<div>Testing</div>").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	assert.ok( pass, "jQuery('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	assert.equal( code.length, 1, "Correct number of elements generated for code" );
	assert.equal( code.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( img.length, 1, "Correct number of elements generated for img" );
	assert.equal( img.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( div.length, 4, "Correct number of elements generated for div hr code b" );
	assert.equal( div.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( jQuery( [ 1, 2, 3 ] ).get( 1 ), 2, "Test passing an array to the factory" );

	assert.equal( jQuery( document.body ).get( 0 ), jQuery( "body" ).get( 0 ), "Test passing an html node to the factory" );

	elem = jQuery( "  <em>hello</em>" )[ 0 ];
	assert.equal( elem.nodeName.toLowerCase(), "em", "leading space" );

	elem = jQuery( "\n\n<em>world</em>" )[ 0 ];
	assert.equal( elem.nodeName.toLowerCase(), "em", "leading newlines" );

	elem = jQuery( "<div></div>", attrObj );

	if ( jQuery.fn.width ) {
		assert.equal( elem[ 0 ].style.width, "10px", "jQuery() quick setter width" );
	}

	if ( jQuery.fn.offset ) {
		assert.equal( elem[ 0 ].style.top, "1px", "jQuery() quick setter offset" );
	}

	if ( jQuery.fn.css ) {
		assert.equal( elem[ 0 ].style.paddingLeft, "1px", "jQuery quick setter css" );
		assert.equal( elem[ 0 ].style.paddingRight, "1px", "jQuery quick setter css" );
	}

	if ( jQuery.fn.attr ) {
		assert.equal( elem[ 0 ].getAttribute( "desired" ), "very", "jQuery quick setter attr" );
	}

	assert.equal( elem[ 0 ].childNodes.length, 1, "jQuery quick setter text" );
	assert.equal( elem[ 0 ].firstChild.nodeValue, "test", "jQuery quick setter text" );
	assert.equal( elem[ 0 ].className, "test2", "jQuery() quick setter class" );
	assert.equal( elem[ 0 ].id, "test3", "jQuery() quick setter id" );

	exec = true;
	elem.trigger( "click" );

	// manually clean up detached elements
	elem.remove();

	for ( i = 0; i < 3; ++i ) {
		elem = jQuery( "<input type='text' value='TEST' />" );
	}
	assert.equal( elem[ 0 ].defaultValue, "TEST", "Ensure cached nodes are cloned properly (Bug #6655)" );

	elem = jQuery( "<input type='hidden'>", {} );
	assert.strictEqual( elem[ 0 ].ownerDocument, document,
		"Empty attributes object is not interpreted as a document (trac-8950)" );
diff --git a/a.js b/b.js
@@ -182,7 +182,7 @@ QUnit.test( "globalEval with 'use strict'", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef

	jQuery.globalEval( "this.globalEvalTest = 3;" );
	assert.equal( window.globalEvalTest, 3, "Test context (this) is the window object" );
} );

QUnit.test( "globalEval with 'use strict'", function( assert ) {
	assert.expect( 1 );
	Globals.register( "strictEvalTest" );

	jQuery.globalEval( "'use strict'; var strictEvalTest = 1;" );
	assert.equal( window.strictEvalTest, 1, "Test variable declarations are global (strict mode)" );
} );

QUnit.test( "globalEval execution after script injection (#7862)", function( assert ) {
	assert.expect( 1 );

	var now,
		script = document.createElement( "script" );
diff --git a/a.js b/b.js
@@ -475,7 +475,7 @@ QUnit.test( "jQuery('html')", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
	} catch ( err ) {
		jQuery[ "_check9521" ]( true );
	}
} );

QUnit.test( "jQuery('html')", function( assert ) {
	assert.expect( 18 );

	var s, div, j;

	jQuery[ "foo" ] = false;
	s = jQuery( "<script>jQuery.foo='test';</script>" )[ 0 ];
	assert.ok( s, "Creating a script" );
	assert.ok( !jQuery[ "foo" ], "Make sure the script wasn't executed prematurely" );
	jQuery( "body" ).append( "<script>jQuery.foo='test';</script>" );
	assert.ok( jQuery[ "foo" ], "Executing a script's contents in the right context" );

	// Test multi-line HTML
	div = jQuery( "<div>\r\nsome text\n<p>some p</p>\nmore text\r\n</div>" )[ 0 ];
	assert.equal( div.nodeName.toUpperCase(), "DIV", "Make sure we're getting a div." );
	assert.equal( div.firstChild.nodeType, 3, "Text node." );
	assert.equal( div.lastChild.nodeType, 3, "Text node." );
	assert.equal( div.childNodes[ 1 ].nodeType, 1, "Paragraph." );
	assert.equal( div.childNodes[ 1 ].firstChild.nodeType, 3, "Paragraph text." );

	assert.ok( jQuery( "<link rel='stylesheet'/>" )[ 0 ], "Creating a link" );

	assert.ok( !jQuery( "<script></script>" )[ 0 ].parentNode, "Create a script" );

	assert.ok( jQuery( "<input/>" ).attr( "type", "hidden" ), "Create an input and set the type." );

	j = jQuery( "<span>hi</span> there <!-- mon ami -->" );
	assert.ok( j.length >= 2, "Check node,textnode,comment creation (some browsers delete comments)" );

	assert.ok( !jQuery( "<option>test</option>" )[ 0 ].selected, "Make sure that options are auto-selected #2050" );

	assert.ok( jQuery( "<div></div>" )[ 0 ], "Create a div with closing tag." );
	assert.ok( jQuery( "<table></table>" )[ 0 ], "Create a table with closing tag." );

diff --git a/a.js b/b.js
@@ -516,7 +516,7 @@ QUnit.test( "jQuery(element with non-alphanumeric name)", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
		assert.ok( "skip", "Complex :not not supported in selector-native" );
	}
	assert.equal( jQuery( "\\<div\\>" ).length, 0, "Ignore escaped html characters" );
} );

QUnit.test( "jQuery(element with non-alphanumeric name)", function( assert ) {
	assert.expect( 36 );

	jQuery.each( [ "-", ":" ], function( i, symbol ) {
		jQuery.each( [ "thead", "tbody", "tfoot", "colgroup", "caption", "tr", "th", "td" ],
			function( j, tag ) {
				var tagName = tag + symbol + "test";
				var el = jQuery( "<" + tagName + "></" + tagName + ">" );
				assert.ok( el[ 0 ], "Create a " + tagName + " element" );
				assert.ok( el[ 0 ].nodeName === tagName.toUpperCase(),
					tagName + " element has expected node name" );
			}
		);

		var tagName = [ "tr", "multiple", "symbol" ].join( symbol );
		var el = jQuery( "<" + tagName + "></" + tagName + ">" );
		assert.ok( el[ 0 ], "Create a " + tagName + " element" );
		assert.ok( el[ 0 ].nodeName === tagName.toUpperCase(),
			tagName + " element has expected node name" );
	} );
} );

QUnit.test( "jQuery('massive html #7990')", function( assert ) {
	assert.expect( 3 );

	var i,
		li = "<li>very very very very large html string</li>",
diff --git a/a.js b/b.js
@@ -538,7 +538,7 @@ QUnit.test( "jQuery('html', context)", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
	assert.equal( html.nodeName.toLowerCase(), "ul" );
	assert.equal( html.firstChild.nodeName.toLowerCase(), "li" );
	assert.equal( html.childNodes.length, 30000 );
} );

QUnit.test( "jQuery('html', context)", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div></div>" )[ 0 ],
		$span = jQuery( "<span></span>", $div );
	assert.equal( $span.length, 1, "verify a span created with a div context works, #1763" );
} );

QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -546,7 +546,7 @@ QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", functio
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
	var $div = jQuery( "<div></div>" )[ 0 ],
		$span = jQuery( "<span></span>", $div );
	assert.equal( $span.length, 1, "verify a span created with a div context works, #1763" );
} );

QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", function( assert ) {
	assert.expect( 2 );

	var xml = createDashboardXML(),

	// tests for #1419 where ie was a problem
		tab = jQuery( "tab", xml ).eq( 0 );
	assert.equal( tab.text(), "blabla", "verify initial text correct" );
	tab.text( "newtext" );
	assert.equal( tab.text(), "newtext", "verify new text correct" );
diff --git a/a.js b/b.js
@@ -803,7 +803,7 @@ 	callback = function( v, k ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (#2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
diff --git a/a.js b/b.js
@@ -817,7 +817,7 @@ 	callback = function( v, k ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (#2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
	assert.equal( result.length, 3, "Array flatten only one level down" );
	assert.ok( Array.isArray( result[ 0 ] ), "Array flatten only one level down" );

	// Support: IE 11+
	// IE doesn't have Array#flat so it'd fail the test.
	if ( !QUnit.isIE ) {
		result = jQuery.map( Array( 300000 ), function( v, k ) {
			return k;
		} );
		assert.equal( result.length, 300000, "Able to map 300000 records without any problems (#4320)" );
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );
diff --git a/a.js b/b.js
@@ -854,14 +854,14 @@ QUnit.test( "jQuery.merge()", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );

QUnit.test( "jQuery.merge()", function( assert ) {
	assert.expect( 10 );

	assert.deepEqual(
		jQuery.merge( [], [] ),
		[],
		"Empty arrays"
	);

	assert.deepEqual(
		jQuery.merge( [ 1 ], [ 2 ] ),
		[ 1, 2 ],
		"Basic (single-element)"
	);
	assert.deepEqual(
		jQuery.merge( [ 1, 2 ], [ 3, 4 ] ),
		[ 1, 2, 3, 4 ],
		"Basic (multiple-element)"
	);

	assert.deepEqual(
		jQuery.merge( [ 1, 2 ], [] ),
		[ 1, 2 ],
		"Second empty"
	);
	assert.deepEqual(
		jQuery.merge( [], [ 1, 2 ] ),
		[ 1, 2 ],
		"First empty"
	);

	// Fixed at [5998], #3641
	assert.deepEqual(
		jQuery.merge( [ -2, -1 ], [ 0, 1, 2 ] ),
		[ -2, -1, 0, 1, 2 ],
		"Second array including a zero (falsy)"
	);

	// After fixing #5527
	assert.deepEqual(
		jQuery.merge( [], [ null, undefined ] ),
		[ null, undefined ],
		"Second array including null and undefined values"
diff --git a/a.js b/b.js
@@ -1005,7 +1005,7 @@ QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
		[],
		"Satisfying elements absent, Array-like object used, and grep explicitly uninverted"
	);
} );

QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
	assert.expect( 28 );

	var empty, optionsWithLength, optionsWithDate, myKlass,
		customObject, optionsWithCustomObject, MyNumber, ret,
		nullUndef, target, recursive, obj,
		defaults, defaultsCopy, options1, options1Copy, options2, options2Copy, merged2,
		settings = { "xnumber1": 5, "xnumber2": 7, "xstring1": "peter", "xstring2": "pan" },
		options = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		optionsCopy = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		merged = { "xnumber1": 5, "xnumber2": 1, "xstring1": "peter", "xstring2": "x", "xxx": "newstring" },
		deep1 = { "foo": { "bar": true } },
		deep2 = { "foo": { "baz": true }, "foo2": document },
		deep2copy = { "foo": { "baz": true }, "foo2": document },
		deepmerged = { "foo": { "bar": true, "baz": true }, "foo2": document },
		arr = [ 1, 2, 3 ],
		nestedarray = { "arr": arr };

	jQuery.extend( settings, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( settings, null, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( true, deep1, deep2 );
	assert.deepEqual( deep1[ "foo" ], deepmerged[ "foo" ], "Check if foo: settings must be extended" );
	assert.deepEqual( deep2[ "foo" ], deep2copy[ "foo" ], "Check if not deep2: options must not be modified" );
	assert.equal( deep1[ "foo2" ], document, "Make sure that a deep clone was not attempted on the document" );

	assert.ok( jQuery.extend( true, {}, nestedarray )[ "arr" ] !== arr, "Deep extend of object must clone child array" );

	// #5991
	assert.ok( Array.isArray( jQuery.extend( true, { "arr": {} }, nestedarray )[ "arr" ] ), "Cloned array have to be an Array" );
	assert.ok( jQuery.isPlainObject( jQuery.extend( true, { "arr": arr }, { "arr": {} } )[ "arr" ] ), "Cloned object have to be an plain object" );

	empty = {};
diff --git a/a.js b/b.js
@@ -1053,13 +1053,13 @@ QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
		[],
		"Satisfying elements absent, Array-like object used, and grep explicitly uninverted"
	);
} );

QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
	assert.expect( 28 );

	var empty, optionsWithLength, optionsWithDate, myKlass,
		customObject, optionsWithCustomObject, MyNumber, ret,
		nullUndef, target, recursive, obj,
		defaults, defaultsCopy, options1, options1Copy, options2, options2Copy, merged2,
		settings = { "xnumber1": 5, "xnumber2": 7, "xstring1": "peter", "xstring2": "pan" },
		options = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		optionsCopy = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		merged = { "xnumber1": 5, "xnumber2": 1, "xstring1": "peter", "xstring2": "x", "xxx": "newstring" },
		deep1 = { "foo": { "bar": true } },
		deep2 = { "foo": { "baz": true }, "foo2": document },
		deep2copy = { "foo": { "baz": true }, "foo2": document },
		deepmerged = { "foo": { "bar": true, "baz": true }, "foo2": document },
		arr = [ 1, 2, 3 ],
		nestedarray = { "arr": arr };

	jQuery.extend( settings, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( settings, null, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( true, deep1, deep2 );
	assert.deepEqual( deep1[ "foo" ], deepmerged[ "foo" ], "Check if foo: settings must be extended" );
	assert.deepEqual( deep2[ "foo" ], deep2copy[ "foo" ], "Check if not deep2: options must not be modified" );
	assert.equal( deep1[ "foo2" ], document, "Make sure that a deep clone was not attempted on the document" );

	assert.ok( jQuery.extend( true, {}, nestedarray )[ "arr" ] !== arr, "Deep extend of object must clone child array" );

	// #5991
	assert.ok( Array.isArray( jQuery.extend( true, { "arr": {} }, nestedarray )[ "arr" ] ), "Cloned array have to be an Array" );
	assert.ok( jQuery.isPlainObject( jQuery.extend( true, { "arr": arr }, { "arr": {} } )[ "arr" ] ), "Cloned object have to be an plain object" );

	empty = {};
	optionsWithLength = { "foo": { "length": -1 } };
	jQuery.extend( true, empty, optionsWithLength );
	assert.deepEqual( empty[ "foo" ], optionsWithLength[ "foo" ], "The length property must copy correctly" );

	empty = {};
	optionsWithDate = { "foo": { "date": new Date() } };
	jQuery.extend( true, empty, optionsWithDate );
	assert.deepEqual( empty[ "foo" ], optionsWithDate[ "foo" ], "Dates copy correctly" );

	/** @constructor */
	myKlass = function() {};
	customObject = new myKlass();
	optionsWithCustomObject = { "foo": { "date": customObject } };
	empty = {};
	jQuery.extend( true, empty, optionsWithCustomObject );
	assert.ok( empty[ "foo" ] && empty[ "foo" ][ "date" ] === customObject, "Custom objects copy correctly (no methods)" );

	// Makes the class a little more realistic
	myKlass.prototype = { "someMethod": function() {} };
	empty = {};
	jQuery.extend( true, empty, optionsWithCustomObject );
	assert.ok( empty[ "foo" ] && empty[ "foo" ][ "date" ] === customObject, "Custom objects copy correctly" );

	MyNumber = Number;

	ret = jQuery.extend( true, { "foo": 4 }, { "foo": new MyNumber( 5 ) } );
	assert.ok( parseInt( ret.foo, 10 ) === 5, "Wrapped numbers copy correctly" );

	nullUndef = jQuery.extend( {}, options, { "xnumber2": null } );
	assert.ok( nullUndef[ "xnumber2" ] === null, "Check to make sure null values are copied" );

	nullUndef = jQuery.extend( {}, options, { "xnumber2": undefined } );
	assert.ok( nullUndef[ "xnumber2" ] === options[ "xnumber2" ], "Check to make sure undefined values are not copied" );

	nullUndef = jQuery.extend( {}, options, { "xnumber0": null } );
	assert.ok( nullUndef[ "xnumber0" ] === null, "Check to make sure null values are inserted" );

	target = {};
	recursive = { foo:target, bar:5 };
	jQuery.extend( true, target, recursive );
	assert.deepEqual( target, { bar:5 }, "Check to make sure a recursive obj doesn't go never-ending loop by not copying it over" );

	ret = jQuery.extend( true, { foo: [] }, { foo: [ 0 ] } ); // 1907
	assert.equal( ret.foo.length, 1, "Check to make sure a value with coercion 'false' copies over when necessary to fix #1907" );

	ret = jQuery.extend( true, { foo: "1,2,3" }, { foo: [ 1, 2, 3 ] } );
	assert.ok( typeof ret.foo !== "string", "Check to make sure values equal with coercion (but not actually equal) overwrite correctly" );

	ret = jQuery.extend( true, { foo:"bar" }, { foo:null } );
	assert.ok( typeof ret.foo !== "undefined", "Make sure a null value doesn't crash with deep extend, for #1908" );

	obj = { foo:null };
	jQuery.extend( true, obj, { foo:"notnull" } );
	assert.equal( obj.foo, "notnull", "Make sure a null value can be overwritten" );
diff --git a/a.js b/b.js
@@ -1365,7 +1365,7 @@ QUnit.test( "jQuery.parseHTML", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef

	// What about this ?
	// equal(true, jQuery.isEmptyObject(null), "isEmptyObject on null" );
} );

QUnit.test( "jQuery.parseHTML", function( assert ) {
	assert.expect( 23 );

	var html, nodes;

	assert.deepEqual( jQuery.parseHTML(), [], "Without arguments" );
	assert.deepEqual( jQuery.parseHTML( undefined ), [], "Undefined" );
	assert.deepEqual( jQuery.parseHTML( null ), [], "Null" );
	assert.deepEqual( jQuery.parseHTML( false ), [], "Boolean false" );
	assert.deepEqual( jQuery.parseHTML( 0 ), [], "Zero" );
	assert.deepEqual( jQuery.parseHTML( true ), [], "Boolean true" );
	assert.deepEqual( jQuery.parseHTML( 42 ), [], "Positive number" );
	assert.deepEqual( jQuery.parseHTML( "" ), [], "Empty string" );
	assert.throws( function() {
		jQuery.parseHTML( "<div></div>", document.getElementById( "form" ) );
	}, "Passing an element as the context raises an exception (context should be a document)" );

	nodes = jQuery.parseHTML( jQuery( "body" )[ 0 ].innerHTML );
	assert.ok( nodes.length > 4, "Parse a large html string" );
	assert.ok( Array.isArray( nodes ), "parseHTML returns an array rather than a nodelist" );

	html = "<script>undefined()</script>";
	assert.equal( jQuery.parseHTML( html ).length, 0, "Ignore scripts by default" );
	assert.equal( jQuery.parseHTML( html, true )[ 0 ].nodeName.toLowerCase(), "script", "Preserve scripts when requested" );

	html += "<div></div>";
	assert.equal( jQuery.parseHTML( html )[ 0 ].nodeName.toLowerCase(), "div", "Preserve non-script nodes" );
	assert.equal( jQuery.parseHTML( html, true )[ 0 ].nodeName.toLowerCase(), "script", "Preserve script position" );

	assert.equal( jQuery.parseHTML( "text" )[ 0 ].nodeType, 3, "Parsing text returns a text node" );
	assert.equal( jQuery.parseHTML( "\t<div></div>" )[ 0 ].nodeValue, "\t", "Preserve leading whitespace" );

	assert.equal( jQuery.parseHTML( " <div></div> " )[ 0 ].nodeType, 3, "Leading spaces are treated as text nodes (#11290)" );

	html = jQuery.parseHTML( "<div>test div</div>" );

	assert.equal( html[ 0 ].parentNode.nodeType, 11, "parentNode should be documentFragment" );
diff --git a/a.js b/b.js
@@ -1456,11 +1456,17 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid XML not detected" );
	} catch ( e ) {
		assert.ok( e.message.indexOf( "Invalid XML:" ) === 0, "invalid XML detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
		xml = jQuery.parseXML();
		assert.strictEqual( xml, null, "undefined string => null document" );
		xml = jQuery.parseXML( null );
		assert.strictEqual( xml, null, "null string => null document" );
		xml = jQuery.parseXML( true );
		assert.strictEqual( xml, null, "non-string => null document" );
	} catch ( e ) {
		assert.ok( false, "empty input throws exception" );
	}
} );

// Support: IE 11+
// IE throws an error when parsing invalid XML instead of reporting the error
// in a `parsererror` element, skip the test there.
QUnit.testUnlessIE( "jQuery.parseXML - error reporting", function( assert ) {
	assert.expect( 2 );

	var errorArg, lineMatch, line, columnMatch, column;

	sinon.stub( jQuery, "error" );

	jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
	errorArg = jQuery.error.firstCall.lastArg.toLowerCase();
	console.log( "errorArg", errorArg );

	lineMatch = errorArg.match( /line\s*(?:number)?\s*(\d+)/ );
	line = lineMatch && lineMatch[ 1 ];
	columnMatch = errorArg.match( /column\s*(\d+)/ );
	column = columnMatch && columnMatch[ 1 ];

	assert.strictEqual( line, "1", "reports error line" );
	assert.strictEqual( column, "11", "reports error column" );
} );

testIframe(
	"document ready when jQuery loaded asynchronously (#13655)",
	"core/dynamic_ready.html",
	function( assert, jQuery, window, document, ready ) {
		assert.expect( 1 );
		assert.equal( true, ready, "document ready correctly fired when jQuery is loaded after DOMContentLoaded" );
diff --git a/a.js b/b.js
@@ -1469,7 +1475,7 @@ function( assert, jQuery, window, document, ready ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
} );

testIframe(
	"document ready when jQuery loaded asynchronously (#13655)",
	"core/dynamic_ready.html",
	function( assert, jQuery, window, document, ready ) {
		assert.expect( 1 );
		assert.equal( true, ready, "document ready correctly fired when jQuery is loaded after DOMContentLoaded" );
	}
);

testIframe(
	"Tolerating alias-masked DOM properties (#14074)",
	"core/aliased.html",
	function( assert, jQuery, window, document, errors ) {
		assert.expect( 1 );
		assert.deepEqual( errors, [], "jQuery loaded" );
diff --git a/a.js b/b.js
@@ -1478,7 +1484,7 @@ function( assert, jQuery, window, document, errors ) {
A blob:af355c62154baf3edf1b58ad5a5ef02491f344ef
);

testIframe(
	"Tolerating alias-masked DOM properties (#14074)",
	"core/aliased.html",
	function( assert, jQuery, window, document, errors ) {
		assert.expect( 1 );
		assert.deepEqual( errors, [], "jQuery loaded" );
	}
);

testIframe(
	"Don't call window.onready (#14802)",
	"core/onready.html",
	function( assert, jQuery, window, document, error ) {
		assert.expect( 1 );
		assert.equal( error, false, "no call to user-defined onready" );
diff --git a/a.js b/b.js
@@ -33,7 +33,7 @@ QUnit.test( "css(String|Hash)", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
if ( jQuery.css ) {

QUnit.module( "css", { afterEach: moduleTeardown } );

QUnit.test( "css(String|Hash)", function( assert ) {
	assert.expect( 42 );

	assert.equal( jQuery( "#qunit-fixture" ).css( "display" ), "block", "Check for css property \"display\"" );

	var $child, div, div2, width, height, child, prctval, checkval, old;

	$child = jQuery( "#nothiddendivchild" ).css( { "width": "20%", "height": "20%" } );
	assert.notEqual( $child.css( "width" ), "20px", "Retrieving a width percentage on the child of a hidden div returns percentage" );
	assert.notEqual( $child.css( "height" ), "20px", "Retrieving a height percentage on the child of a hidden div returns percentage" );

	div = jQuery( "<div></div>" );

	// These should be "auto" (or some better value)
	// temporarily provide "0px" for backwards compat
	assert.equal( div.css( "width" ), "0px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "0px", "Height on disconnected node." );

	div.css( { "width": 4, "height": 4 } );

	assert.equal( div.css( "width" ), "4px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "4px", "Height on disconnected node." );

	div2 = jQuery( "<div style='display:none;'><input type='text' style='height:20px;'/><textarea style='height:20px;'></textarea><div style='height:20px;'></div></div>" ).appendTo( "body" );

	assert.equal( div2.find( "input" ).css( "height" ), "20px", "Height on hidden input." );
	assert.equal( div2.find( "textarea" ).css( "height" ), "20px", "Height on hidden textarea." );
	assert.equal( div2.find( "div" ).css( "height" ), "20px", "Height on hidden div." );

	div2.remove();

	// handle negative numbers by setting to zero #11604
	jQuery( "#nothiddendiv" ).css( { "width": 1, "height": 1 } );

	width = parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) );
	height = parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) );
diff --git a/a.js b/b.js
@@ -113,7 +113,7 @@ QUnit.test( "css(String|Hash)", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
if ( jQuery.css ) {

QUnit.module( "css", { afterEach: moduleTeardown } );

QUnit.test( "css(String|Hash)", function( assert ) {
	assert.expect( 42 );

	assert.equal( jQuery( "#qunit-fixture" ).css( "display" ), "block", "Check for css property \"display\"" );

	var $child, div, div2, width, height, child, prctval, checkval, old;

	$child = jQuery( "#nothiddendivchild" ).css( { "width": "20%", "height": "20%" } );
	assert.notEqual( $child.css( "width" ), "20px", "Retrieving a width percentage on the child of a hidden div returns percentage" );
	assert.notEqual( $child.css( "height" ), "20px", "Retrieving a height percentage on the child of a hidden div returns percentage" );

	div = jQuery( "<div></div>" );

	// These should be "auto" (or some better value)
	// temporarily provide "0px" for backwards compat
	assert.equal( div.css( "width" ), "0px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "0px", "Height on disconnected node." );

	div.css( { "width": 4, "height": 4 } );

	assert.equal( div.css( "width" ), "4px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "4px", "Height on disconnected node." );

	div2 = jQuery( "<div style='display:none;'><input type='text' style='height:20px;'/><textarea style='height:20px;'></textarea><div style='height:20px;'></div></div>" ).appendTo( "body" );

	assert.equal( div2.find( "input" ).css( "height" ), "20px", "Height on hidden input." );
	assert.equal( div2.find( "textarea" ).css( "height" ), "20px", "Height on hidden textarea." );
	assert.equal( div2.find( "div" ).css( "height" ), "20px", "Height on hidden div." );

	div2.remove();

	// handle negative numbers by setting to zero #11604
	jQuery( "#nothiddendiv" ).css( { "width": 1, "height": 1 } );

	width = parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) );
	height = parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) );
	jQuery( "#nothiddendiv" ).css( { "overflow":"hidden", "width": -1, "height": -1 } );
	assert.equal( parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) ), 0, "Test negative width set to 0" );
	assert.equal( parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) ), 0, "Test negative height set to 0" );

	assert.equal( jQuery( "<div style='display: none;'></div>" ).css( "display" ), "none", "Styles on disconnected nodes" );

	jQuery( "#floatTest" ).css( { "float": "right" } );
	assert.equal( jQuery( "#floatTest" ).css( "float" ), "right", "Modified CSS float using \"float\": Assert float is right" );
	jQuery( "#floatTest" ).css( { "font-size": "30px" } );
	assert.equal( jQuery( "#floatTest" ).css( "font-size" ), "30px", "Modified CSS font-size: Assert font-size is 30px" );
	jQuery.each( "0,0.25,0.5,0.75,1".split( "," ), function( i, n ) {
		jQuery( "#foo" ).css( { "opacity": n } );

		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a String" );
		jQuery( "#foo" ).css( { "opacity": parseFloat( n ) } );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a Number" );
	} );
	jQuery( "#foo" ).css( { "opacity": "" } );
	assert.equal( jQuery( "#foo" ).css( "opacity" ), "1", "Assert opacity is 1 when set to an empty String" );

	assert.equal( jQuery( "#empty" ).css( "opacity" ), "0", "Assert opacity is accessible" );
	jQuery( "#empty" ).css( { "opacity": "1" } );
	assert.equal( jQuery( "#empty" ).css( "opacity" ), "1", "Assert opacity is taken from style attribute when set" );

	div = jQuery( "#nothiddendiv" );
	child = jQuery( "#nothiddendivchild" );

	assert.equal( parseInt( div.css( "fontSize" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( div.css( "font-size" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( child.css( "fontSize" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( child.css( "font-size" ), 10 ), 16, "Verify fontSize px set." );

	child.css( "height", "100%" );
	assert.equal( child[ 0 ].style.height, "100%", "Make sure the height is being set correctly." );

	child.attr( "class", "em" );
	assert.equal( parseInt( child.css( "fontSize" ), 10 ), 32, "Verify fontSize em set." );

	// Have to verify this as the result depends upon the browser's CSS
	// support for font-size percentages
	child.attr( "class", "prct" );
	prctval = parseInt( child.css( "fontSize" ), 10 );
	checkval = 0;
	if ( prctval === 16 || prctval === 24 ) {
		checkval = prctval;
	}

	assert.equal( prctval, checkval, "Verify fontSize % set." );

	assert.equal( typeof child.css( "width" ), "string", "Make sure that a string width is returned from css('width')." );

	old = child[ 0 ].style.height;

	// Test NaN
	child.css( "height", parseFloat( "zoo" ) );
	assert.equal( child[ 0 ].style.height, old, "Make sure height isn't changed on NaN." );

	// Test null
	child.css( "height", null );
	assert.equal( child[ 0 ].style.height, old, "Make sure height isn't changed on null." );

	old = child[ 0 ].style.fontSize;

	// Test NaN
	child.css( "font-size", parseFloat( "zoo" ) );
	assert.equal( child[ 0 ].style.fontSize, old, "Make sure font-size isn't changed on NaN." );

	// Test null
	child.css( "font-size", null );
	assert.equal( child[ 0 ].style.fontSize, old, "Make sure font-size isn't changed on null." );

	assert.strictEqual( child.css( "x-fake" ), undefined, "Make sure undefined is returned from css(nonexistent)." );

	div = jQuery( "<div></div>" ).css( { position: "absolute", "z-index": 1000 } ).appendTo( "#qunit-fixture" );
	assert.strictEqual( div.css( "z-index" ), "1000",
		"Make sure that a string z-index is returned from css('z-index') (#14432)." );
} );

QUnit.test( "css() explicit and relative values", function( assert ) {
	assert.expect( 29 );
diff --git a/a.js b/b.js
@@ -325,11 +325,11 @@ QUnit.test( "css(String, Object)", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	$el.css( "right", "-=25em" );
	assert.equal( Math.round( parseFloat( $el.css( "right" ) ) ), 100,
		"Constraints do not interfere with unit conversion" );
} );

QUnit.test( "css(String, Object)", function( assert ) {
	assert.expect( 19 );
	var j, div, display, ret, success;

	jQuery( "#floatTest" ).css( "float", "left" );
	assert.equal( jQuery( "#floatTest" ).css( "float" ), "left", "Modified CSS float using \"float\": Assert float is left" );
	jQuery( "#floatTest" ).css( "font-size", "20px" );
	assert.equal( jQuery( "#floatTest" ).css( "font-size" ), "20px", "Modified CSS font-size: Assert font-size is 20px" );

	jQuery.each( "0,0.25,0.5,0.75,1".split( "," ), function( i, n ) {
		jQuery( "#foo" ).css( "opacity", n );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a String" );
		jQuery( "#foo" ).css( "opacity", parseFloat( n ) );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a Number" );
	} );
	jQuery( "#foo" ).css( "opacity", "" );
	assert.equal( jQuery( "#foo" ).css( "opacity" ), "1", "Assert opacity is 1 when set to an empty String" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
	j.css( "overflow", "visible" );
	assert.equal( j.css( "overflow" ), "visible", "Check node,textnode,comment css works" );
	assert.equal( jQuery( "#t2037 .hidden" ).css( "display" ), "none", "Make sure browser thinks it is hidden" );

	div = jQuery( "#nothiddendiv" );
	display = div.css( "display" );
	ret = div.css( "display", undefined );

	assert.equal( ret, div, "Make sure setting undefined returns the original set." );
	assert.equal( div.css( "display" ), display, "Make sure that the display wasn't changed." );

	success = true;
	try {
		jQuery( "#foo" ).css( "backgroundColor", "rgba(0, 0, 0, 0.1)" );
	}
	catch ( e ) {
		success = false;
	}
	assert.ok( success, "Setting RGBA values does not throw Error (#5509)" );

	jQuery( "#foo" ).css( "font", "7px/21px sans-serif" );
	assert.strictEqual( jQuery( "#foo" ).css( "line-height" ), "21px",
		"Set font shorthand property (#14759)" );
} );

QUnit.test( "css(String, Object) with negative values", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -699,7 +699,7 @@ QUnit.test( "show/hide detached nodes", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	// Make sure that showing or hiding a text node doesn't cause an error
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

QUnit.test( "show/hide detached nodes", function( assert ) {
	assert.expect( 19 );

	var div, span, tr;

	div = jQuery( "<div>" ).hide();
	assert.equal( div.css( "display" ), "none", "hide() updates inline style of a detached div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A hidden-while-detached div is hidden after attachment" );
	div.show();
	assert.equal( div.css( "display" ), "block",
		"A hidden-while-detached div can be shown after attachment" );

	div = jQuery( "<div class='hidden'>" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached div can be hidden by the CSS cascade" );

	div = jQuery( "<div><div class='hidden'></div></div>" ).children( "div" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached div inside a visible div can be hidden by the CSS cascade" );

	span = jQuery( "<span class='hidden'></span>" );
	span.show().appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "none",
		"A shown-while-detached span can be hidden by the CSS cascade" );

	div = jQuery( "div.hidden" );
	div.detach().show();
	assert.ok( !div[ 0 ].style.display,
		"show() does not update inline style of a cascade-hidden-before-detach div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached cascade-hidden div is hidden after attachment" );
	div.remove();

	span = jQuery( "<span class='hidden'></span>" );
	span.appendTo( "#qunit-fixture" ).detach().show().appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "none",
		"A shown-while-detached cascade-hidden span is hidden after attachment" );
	span.remove();

	div = jQuery( document.createElement( "div" ) );
	div.show().appendTo( "#qunit-fixture" );
	assert.ok( !div[ 0 ].style.display, "A shown-while-detached div has no inline style" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached div has default display after attachment" );
	div.remove();

	div = jQuery( "<div style='display: none'>" );
	div.show();
	assert.equal( div[ 0 ].style.display, "",
		"show() updates inline style of a detached inline-hidden div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached inline-hidden div has default display after attachment" );

	div = jQuery( "<div><div style='display: none'></div></div>" ).children( "div" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached inline-hidden div inside a visible div has default display " +
		"after attachment" );

	span = jQuery( "<span style='display: none'></span>" );
	span.show();
	assert.equal( span[ 0 ].style.display, "",
		"show() updates inline style of a detached inline-hidden span" );
	span.appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "inline",
		"A shown-while-detached inline-hidden span has default display after attachment" );

	div = jQuery( "<div style='display: inline'></div>" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "inline",
		"show() does not update inline style of a detached inline-visible div" );
	div.remove();

	tr = jQuery( "<tr></tr>" );
	jQuery( "#table" ).append( tr );
	tr.detach().hide().show();

	assert.ok( !tr[ 0 ].style.display, "Not-hidden detached tr elements have no inline style" );
	tr.remove();

	span = jQuery( "<span></span>" ).hide().show();
	assert.ok( !span[ 0 ].style.display, "Not-hidden detached span elements have no inline style" );
	span.remove();
} );

// Support: IE 11+
// IE doesn't support Shadow DOM.
QUnit.testUnlessIE(
	"show/hide shadow child nodes", function( assert ) {

	assert.expect( 28 );
	jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );
	var shadowHost = document.querySelector( "#shadowHost" );
	var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
	shadowRoot.innerHTML = "" +
		"<style>.hidden{display: none;}</style>" +
		"<div class='hidden' id='shadowdiv'>" +
		"	<p class='hidden' id='shadowp'>" +
		"		<a href='#' class='hidden' id='shadowa'></a>" +
		"	</p>" +
		"	<code class='hidden' id='shadowcode'></code>" +
		"	<pre class='hidden' id='shadowpre'></pre>" +
		"	<span class='hidden' id='shadowspan'></span>" +
		"</div>" +
		"<table class='hidden' id='shadowtable'>" +
		"	<thead class='hidden' id='shadowthead'>" +
		"		<tr class='hidden' id='shadowtr'>" +
		"			<th class='hidden' id='shadowth'></th>" +
		"		</tr>" +
		"	</thead>" +
		"	<tbody class='hidden' id='shadowtbody'>" +
		"		<tr class='hidden'>" +
		"			<td class='hidden' id='shadowtd'></td>" +
		"		</tr>" +
		"	</tbody>" +
		"</table>" +
		"<ul class='hidden' id='shadowul'>" +
		"	<li class='hidden' id='shadowli'></li>" +
		"</ul>";

	var test = {
		"div": "block",
		"p": "block",
		"a": "inline",
		"code": "inline",
		"pre": "block",
		"span": "inline",
		"table": "table",
		"thead": "table-header-group",
		"tbody": "table-row-group",
		"tr": "table-row",
		"th": "table-cell",
		"td": "table-cell",
		"ul": "block",
		"li": "list-item"
	};

	jQuery.each( test, function( selector, expected ) {
		var shadowChild = shadowRoot.querySelector( "#shadow" + selector );
		var $shadowChild = jQuery( shadowChild );
		assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
		$shadowChild.show();
		assert.strictEqual( $shadowChild.css( "display" ), expected, "Show using correct display type for " + selector );
	} );
} );

QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
	assert.expect( 3 );

	var div = jQuery( "<div style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is hidden by default" );
diff --git a/a.js b/b.js
@@ -712,7 +712,7 @@ QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
		$shadowChild.show();
		assert.strictEqual( $shadowChild.css( "display" ), expected, "Show using correct display type for " + selector );
	} );
} );

QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
	assert.expect( 3 );

	var div = jQuery( "<div style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is hidden by default" );
	div.hide();
	assert.ok( !jQuery._data( div, "olddisplay" ), "olddisplay is undefined after hiding an already-hidden element" );
	div.show();
	assert.equal( div.css( "display" ), "block", "Show a double-hidden element" );

	div.remove();
} );

QUnit.test( "show() after hide() should always set display to initial value (#14750)", function( assert ) {
	assert.expect( 1 );

	var div = jQuery( "<div></div>" ),
		fixture = jQuery( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -988,7 +988,7 @@ QUnit.test( "show/hide 3.0, inline hidden", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
			assert.equal( this.style.display, expected, name + sequence.join( "" ) + " inline" );
		}
	} );
} );

QUnit.test( "show/hide 3.0, inline hidden", function( assert ) {

	assert.expect( 84 );

	var i,
		$elems = jQuery( "<div></div>" )
			.appendTo( "#qunit-fixture" )
			.html( "<span data-expected-display='inline' style='display:none'></span>" +
				"<span class='list-item' data-expected-display='list-item' style='display:none'></span>" +
				"<div data-expected-display='block' style='display:none'></div>" +
				"<div class='list-item' data-expected-display='list-item' style='display:none'></div>" +
				"<ul>" +
					"<li data-expected-display='list-item' style='display:none'></li>" +
					"<li class='block' data-expected-display='block' style='display:none'></li>" +
					"<li class='inline' data-expected-display='inline' style='display:none'></li>" +
				"</ul>" )
			.find( "[data-expected-display]" );

	$elems.each( function() {
		var $elem = jQuery( this ),
			name = this.nodeName,
			expected = this.getAttribute( "data-expected-display" ),
			sequence = [];

		if ( this.className ) {
			name += "." + this.className;
		}
		if ( this.getAttribute( "style" ) ) {
			name += "[style='" + this.getAttribute( "style" ) + "']";
		}
		name += " ";

		for ( i = 0; i < 3; i++ ) {
			sequence.push( ".hide()" );
			$elem.hide();
			assert.equal( $elem.css( "display" ), "none",
				name + sequence.join( "" ) + " computed" );
			assert.equal( this.style.display, "none", name + sequence.join( "" ) + " inline" );

			sequence.push( ".show()" );
			$elem.show();
			assert.equal( $elem.css( "display" ), expected,
				name + sequence.join( "" ) + " computed" );
			assert.equal( this.style.display, "", name + sequence.join( "" ) + " inline" );
		}
	} );
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle ? "test" : "skip" ]( "toggle()", function( assert ) {
	assert.expect( 9 );
	var div, oldHide,
		x = jQuery( "#foo" );

	assert.ok( x.is( ":visible" ), "is visible" );
	x.toggle();
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle();
	assert.ok( x.is( ":visible" ), "is visible again" );

	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible" );
	x.toggle( false );
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible again" );

	div = jQuery( "<div style='display:none'><div></div></div>" ).appendTo( "#qunit-fixture" );
	x = div.find( "div" );
	assert.strictEqual( x.toggle().css( "display" ), "none", "is hidden" );
	assert.strictEqual( x.toggle().css( "display" ), "block", "is visible" );

	// Ensure hide() is called when toggled (#12148)
	oldHide = jQuery.fn.hide;
	jQuery.fn.hide = function() {
		assert.ok( true, name + " method called on toggle" );
		return oldHide.apply( this, arguments );
diff --git a/a.js b/b.js
@@ -1048,7 +1048,7 @@ 	jQuery.fn.hide = function() {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	assert.strictEqual( x.toggle().css( "display" ), "none", "is hidden" );
	assert.strictEqual( x.toggle().css( "display" ), "block", "is visible" );

	// Ensure hide() is called when toggled (#12148)
	oldHide = jQuery.fn.hide;
	jQuery.fn.hide = function() {
		assert.ok( true, name + " method called on toggle" );
		return oldHide.apply( this, arguments );
	};
	x.toggle( name === "show" );
	jQuery.fn.hide = oldHide;
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle ? "test" : "skip" ]( "detached toggle()", function( assert ) {
	assert.expect( 6 );
	var detached = jQuery( "<p><a></a><p>" ).find( "*" ).addBack(),
		hiddenDetached = jQuery( "<p><a></a></p>" ).find( "*" ).addBack().css( "display", "none" ),
		cascadeHiddenDetached = jQuery( "<p><a></a></p>" ).find( "*" ).addBack().addClass( "hidden" );

	detached.toggle();
	detached.appendTo( "#qunit-fixture" );
	assert.equal( detached[ 0 ].style.display, "none", "detached element" );
	assert.equal( detached[ 1 ].style.display, "none", "element in detached tree" );

	hiddenDetached.toggle();
	hiddenDetached.appendTo( "#qunit-fixture" );
	assert.equal( hiddenDetached[ 0 ].style.display, "", "detached, hidden element" );
	assert.equal( hiddenDetached[ 1 ].style.display, "", "hidden element in detached tree" );

	cascadeHiddenDetached.toggle();
	cascadeHiddenDetached.appendTo( "#qunit-fixture" );
	assert.equal( cascadeHiddenDetached[ 0 ].style.display, "none",
		"detached, cascade-hidden element" );
	assert.equal( cascadeHiddenDetached[ 1 ].style.display, "none",
		"cascade-hidden element in detached tree" );
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle && !QUnit.isIE ? "test" : "skip" ](
	"shadow toggle()", function( assert ) {

	assert.expect( 4 );

	jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );
	var shadowHost = document.querySelector( "#shadowHost" );
	var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
	shadowRoot.innerHTML = "" +
		"<style>.hidden{display: none;}</style>" +
		"<div id='shadowHiddenChild' class='hidden'></div>" +
		"<div id='shadowChild'></div>";
	var shadowChild = shadowRoot.querySelector( "#shadowChild" );
	var shadowHiddenChild = shadowRoot.querySelector( "#shadowHiddenChild" );

	var $shadowChild = jQuery( shadowChild );
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );

	$shadowChild = jQuery( shadowHiddenChild );
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
} );

QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	jQuery.css( $checkedtest[ 0 ], "height" );
diff --git a/a.js b/b.js
@@ -1060,7 +1060,7 @@ QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)"
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
} );

QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	jQuery.css( $checkedtest[ 0 ], "height" );

	assert.ok( jQuery( "input[type='radio']", $checkedtest ).first().attr( "checked" ), "Check first radio still checked." );
	assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
	assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
	assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
} );

QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert ) {
	assert.expect( 1 );
	var result = true;

	try {
diff --git a/a.js b/b.js
@@ -1099,18 +1099,18 @@ QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert )
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
	assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
	assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
} );

QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert ) {
	assert.expect( 1 );
	var result = true;

	try {
		jQuery( "#foo" ).css( { "width": "0%" } ).css( "width" );
	} catch ( e ) {
		result = false;
	}

	assert.ok( result, "elem.runtimeStyle does not throw exception" );
} );

QUnit.test( "computed margins (trac-3333; gh-2237)", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "#foo" ),
		$child = jQuery( "#en" );

	$div.css( {
		"width": "1px",
		"marginRight": 0
	} );
	assert.equal( $div.css( "marginRight" ), "0px",
		"marginRight correctly calculated with a width and display block" );

	$div.css( {
		position: "absolute",
		top: 0,
		left: 0,
		width: "100px"
	} );
	$child.css( {
		width: "50px",
		margin: "auto"
	} );
	assert.equal( $child.css( "marginLeft" ), "25px", "auto margins are computed to pixels" );
} );

QUnit.test( "box model properties incorrectly returning % instead of px, see #10639 and #12088", function( assert ) {
	assert.expect( 2 );

	var container = jQuery( "<div></div>" ).width( 400 ).appendTo( "#qunit-fixture" ),
		el = jQuery( "<div></div>" ).css( { "width": "50%", "marginRight": "50%" } ).appendTo( container ),
		el2 = jQuery( "<div></div>" ).css( { "width": "50%", "minWidth": "300px", "marginLeft": "25%" } ).appendTo( container );

	assert.equal( el.css( "marginRight" ), "200px", "css('marginRight') returning % instead of px, see #10639" );
	assert.equal( el2.css( "marginLeft" ), "100px", "css('marginLeft') returning incorrect pixel value, see #12088" );
} );

QUnit.test( "widows & orphans #8936", function( assert ) {

	var $p = jQuery( "<p>" ).appendTo( "#qunit-fixture" );

	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1127,15 +1127,15 @@ QUnit.test( "widows & orphans #8936", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

	assert.equal( el.css( "marginRight" ), "200px", "css('marginRight') returning % instead of px, see #10639" );
	assert.equal( el2.css( "marginLeft" ), "100px", "css('marginLeft') returning incorrect pixel value, see #12088" );
} );

QUnit.test( "widows & orphans #8936", function( assert ) {

	var $p = jQuery( "<p>" ).appendTo( "#qunit-fixture" );

	assert.expect( 2 );

	$p.css( {
		"widows": 3,
		"orphans": 3
	} );

	assert.equal( $p.css( "widows" ) || jQuery.style( $p[ 0 ], "widows" ), 3, "widows correctly set to 3" );
	assert.equal( $p.css( "orphans" ) || jQuery.style( $p[ 0 ], "orphans" ), 3, "orphans correctly set to 3" );

	$p.remove();
} );

QUnit.test( "can't get css for disconnected in IE<9, see #10254 and #8388", function( assert ) {
	assert.expect( 2 );
	var span, div;

	span = jQuery( "<span></span>" ).css( "background-image", "url(" + baseURL + "1x1.jpg)" );
	assert.notEqual( span.css( "background-image" ), null, "can't get background-image in IE<9, see #10254" );

	div = jQuery( "<div></div>" ).css( "top", 10 );
	assert.equal( div.css( "top" ), "10px", "can't get top in IE<9, see #8388" );
} );

QUnit.test( "Ensure styles are retrieving from parsed html on document fragments", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1148,7 +1148,7 @@ QUnit.test( "Ensure styles are retrieving from parsed html on document fragments
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

	div = jQuery( "<div></div>" ).css( "top", 10 );
	assert.equal( div.css( "top" ), "10px", "can't get top in IE<9, see #8388" );
} );

QUnit.test( "Ensure styles are retrieving from parsed html on document fragments", function( assert ) {
	assert.expect( 1 );

	var $span = jQuery(
		jQuery.parseHTML( "<span style=\"font-family: Cuprum,sans-serif; font-size: 14px; color: #999999;\">some text</span>" )
	);

	assert.equal( $span.css( "font-size" ), "14px", "Font-size retrievable on parsed HTML node" );
} );

QUnit.test( "can't get background-position in IE<9, see #10796", function( assert ) {
	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ),
		units = [
			"0 0",
			"12px 12px",
diff --git a/a.js b/b.js
@@ -1167,22 +1167,22 @@ QUnit.test( "can't get background-position in IE<9, see #10796", function( asser
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	);

	assert.equal( $span.css( "font-size" ), "14px", "Font-size retrievable on parsed HTML node" );
} );

QUnit.test( "can't get background-position in IE<9, see #10796", function( assert ) {
	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ),
		units = [
			"0 0",
			"12px 12px",
			"13px 12em",
			"12em 13px",
			"12em center",
			"+12em center",
			"12.2em center",
			"center center"
		],
		l = units.length,
		i = 0;

	assert.expect( l );

	for ( ; i < l; i++ ) {
		div.css( "background-position", units [ i ] );
		assert.ok( div.css( "background-position" ), "can't get background-position in IE<9, see #10796" );
	}
} );

if ( jQuery.fn.offset ) {
	QUnit.test( "percentage properties for left and top should be transformed to pixels, see #9505", function( assert ) {
		assert.expect( 2 );
		var parent = jQuery( "<div style='position:relative;width:200px;height:200px;margin:0;padding:0;border-width:0'></div>" ).appendTo( "#qunit-fixture" ),
			div = jQuery( "<div style='position: absolute; width: 20px; height: 20px; top:50%; left:50%'></div>" ).appendTo( parent );

		assert.equal( div.css( "top" ), "100px", "position properties not transformed to pixels, see #9505" );
		assert.equal( div.css( "left" ), "100px", "position properties not transformed to pixels, see #9505" );
	} );
}

QUnit.test( "Do not append px (#9548, #12990, #2792)", function( assert ) {
	assert.expect( 4 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -1335,16 +1335,16 @@ QUnit.test( "Append px to whitelisted properties", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	$div.css( "letter-spacing", "2px" );
	$div.css( "letter-spacing", 3 );
	assert.equal( $div.css( "letter-spacing" ), "2px", "Do not append px to 'letter-spacing'" );
} );

QUnit.test( "Append px to whitelisted properties", function( assert ) {
	var prop,
		$div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		whitelist = {
			margin: "marginTop",
			marginTop: undefined,
			marginRight: undefined,
			marginBottom: undefined,
			marginLeft: undefined,
			padding: "paddingTop",
			paddingTop: undefined,
			paddingRight: undefined,
			paddingBottom: undefined,
			paddingLeft: undefined,
			top: undefined,
			right: undefined,
			bottom: undefined,
			left: undefined,
			width: undefined,
			height: undefined,
			minWidth: undefined,
			minHeight: undefined,
			maxWidth: undefined,
			maxHeight: undefined,
			border: "borderTopWidth",
			borderWidth: "borderTopWidth",
			borderTop: "borderTopWidth",
			borderTopWidth: undefined,
			borderRight: "borderRightWidth",
			borderRightWidth: undefined,
			borderBottom: "borderBottomWidth",
			borderBottomWidth: undefined,
			borderLeft: "borderLeftWidth",
			borderLeftWidth: undefined
		};

	assert.expect( ( Object.keys( whitelist ).length ) * 2 );

	for ( prop in whitelist ) {
		var propToCheck = whitelist[ prop ] || prop,
			kebabProp = prop.replace( /[A-Z]/g, function( match ) {
				return "-" + match.toLowerCase();
			} ),
			kebabPropToCheck = propToCheck.replace( /[A-Z]/g, function( match ) {
				return "-" + match.toLowerCase();
			} );
		$div.css( prop, 3 )
			.css( "position", "absolute" )
			.css( "border-style", "solid" );
		assert.equal( $div.css( propToCheck ), "3px", "Append px to '" + prop + "'" );
		$div.css( kebabProp, 3 )
			.css( "position", "absolute" )
			.css( "border-style", "solid" );
		assert.equal( $div.css( kebabPropToCheck ), "3px", "Append px to '" + kebabProp + "'" );
	}
} );

QUnit.test( "css('width') and css('height') should respect box-sizing, see #11004", function( assert ) {
	assert.expect( 4 );

	var el_dis = jQuery( "<div style='width:300px;height:300px;margin:2px;padding:2px;box-sizing:border-box;'>test</div>" ),
		el = el_dis.clone().appendTo( "#qunit-fixture" );

	assert.equal( el.css( "width" ), el.css( "width", el.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "width" ), el_dis.css( "width", el_dis.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing for disconnected element, see #11004" );
	assert.equal( el.css( "height" ), el.css( "height", el.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "height" ), el_dis.css( "height", el_dis.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing for disconnected element, see #11004" );
} );

QUnit.test( "table rows width/height should be unaffected by inline styles", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1368,7 +1368,7 @@ QUnit.test( "table rows width/height should be unaffected by inline styles", fun
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	assert.equal( el_dis.css( "width" ), el_dis.css( "width", el_dis.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing for disconnected element, see #11004" );
	assert.equal( el.css( "height" ), el.css( "height", el.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "height" ), el_dis.css( "height", el_dis.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing for disconnected element, see #11004" );
} );

QUnit.test( "table rows width/height should be unaffected by inline styles", function( assert ) {
	assert.expect( 2 );

	var table = jQuery(
		"<table>\n" +
		"  <tr id=\"row\" style=\"height: 1px; width: 1px;\">\n" +
		"    <td>\n" +
		"      <div style=\"height: 100px; width: 100px;\"></div>\n" +
		"    </div>\n" +
		"  </tr>\n" +
		"</table>"
	);
	var tr = table.find( "tr" );

	table.appendTo( "#qunit-fixture" );

	assert.ok( parseInt( tr.css( "width" ) ) > 10, "tr width unaffected by inline style" );
	assert.ok( parseInt( tr.css( "height" ) ) > 10, "tr height unaffected by inline style" );
} );

testIframe(
	"css('width') should work correctly before document ready (#14084)",
	"css/cssWidthBeforeDocReady.html",
	function( assert, jQuery, window, document, cssWidthBeforeDocReady ) {
		assert.expect( 1 );
		assert.strictEqual( cssWidthBeforeDocReady, "100px", "elem.css('width') works correctly before document ready" );
diff --git a/a.js b/b.js
@@ -1409,13 +1409,13 @@ function( assert, jQuery, window, document, widthBeforeSet, widthAfterSet ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
);

testIframe(
	"css('width') should work correctly with browser zooming",
	"css/cssWidthBrowserZoom.html",
	function( assert, jQuery, window, document, widthBeforeSet, widthAfterSet ) {
		assert.expect( 2 );
		assert.strictEqual( widthBeforeSet, "100px", "elem.css('width') works correctly with browser zoom" );
		assert.strictEqual( widthAfterSet, "100px", "elem.css('width', val) works correctly with browser zoom" );
	}
);

QUnit.testUnlessIE( "css('width') and css('height') should return fractional values for nodes in the document", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "<div class='test-div'></div>" ).appendTo( "#qunit-fixture" );
	jQuery( "<style>.test-div { width: 33.3px; height: 88.8px; }</style>" ).appendTo( "#qunit-fixture" );

	assert.equal( Number( el.css( "width" ).replace( /px$/, "" ) ).toFixed( 1 ), "33.3",
		"css('width') should return fractional values" );
	assert.equal( Number( el.css( "height" ).replace( /px$/, "" ) ).toFixed( 1 ), "88.8",
		"css('height') should return fractional values" );
} );

QUnit.testUnlessIE( "css('width') and css('height') should return fractional values for disconnected nodes", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "<div style='width: 33.3px; height: 88.8px;'></div>" );

	assert.equal( Number( el.css( "width" ).replace( /px$/, "" ) ).toFixed( 1 ), "33.3",
		"css('width') should return fractional values" );
	assert.equal( Number( el.css( "height" ).replace( /px$/, "" ) ).toFixed( 1 ), "88.8",
		"css('height') should return fractional values" );
} );

QUnit.test( "certain css values of 'normal' should be convertable to a number, see #8627", function( assert ) {
	assert.expect( 3 );

	var el = jQuery( "<div style='letter-spacing:normal;font-weight:normal;'>test</div>" ).appendTo( "#qunit-fixture" );

	assert.ok( !isNaN( parseFloat( el.css( "letterSpacing" ) ) ), "css('letterSpacing') not convertable to number, see #8627" );
	assert.ok( !isNaN( parseFloat( el.css( "fontWeight" ) ) ), "css('fontWeight') not convertable to number, see #8627" );
	assert.equal( typeof el.css( "fontWeight" ), "string", ".css() returns a string" );
} );

QUnit.test( "cssHooks - expand", function( assert ) {
diff --git a/a.js b/b.js
@@ -1459,7 +1459,7 @@ QUnit.test( "cssHooks - expand", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
	assert.ok( !isNaN( parseFloat( el.css( "letterSpacing" ) ) ), "css('letterSpacing') not convertable to number, see #8627" );
	assert.ok( !isNaN( parseFloat( el.css( "fontWeight" ) ) ), "css('fontWeight') not convertable to number, see #8627" );
	assert.equal( typeof el.css( "fontWeight" ), "string", ".css() returns a string" );
} );

QUnit.test( "cssHooks - expand", function( assert ) {
	assert.expect( 15 );
	var result,
		properties = {
			margin: [ "marginTop", "marginRight", "marginBottom", "marginLeft" ],
			borderWidth: [ "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth" ],
			padding: [ "paddingTop", "paddingRight", "paddingBottom", "paddingLeft" ]
		};

	jQuery.each( properties, function( property, keys ) {
		var hook = jQuery.cssHooks[ property ],
			expected = {};
		jQuery.each( keys, function( _, key ) {
			expected[ key ] = 10;
		} );
		result = hook.expand( 10 );
		assert.deepEqual( result, expected, property + " expands properly with a number" );

		jQuery.each( keys, function( _, key ) {
			expected[ key ] = "10px";
		} );
		result = hook.expand( "10px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px'" );

		expected[ keys[ 1 ] ] = expected[ keys[ 3 ] ] = "20px";
		result = hook.expand( "10px 20px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px'" );

		expected[ keys[ 2 ] ] = "30px";
		result = hook.expand( "10px 20px 30px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px 30px'" );

		expected[ keys[ 3 ] ] = "40px";
		result = hook.expand( "10px 20px 30px 40px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px 30px 40px'" );

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -1487,8 +1487,8 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
diff --git a/a.js b/b.js
@@ -1507,9 +1507,9 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( "display", "block" );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );

	assert.ok( jQuery( "#siblingspan" ).is( ":visible" ), "Span with no content is visible" );
	$div = jQuery( "<div><span></span></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( $div.find( ":visible" ).length, 1, "Span with no content is visible" );
	$div.css( { width: 0, height: 0, overflow: "hidden" } );
	assert.ok( $div.is( ":visible" ), "Div with width and height of 0 is still visible (gh-2227)" );

	$br = jQuery( "<br/>" ).appendTo( "#qunit-fixture" );
	assert.ok( $br.is( ":visible" ), "br element is visible" );

	$table = jQuery( "#table" );
	$table.html( "<tr><td style='display:none'>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 1, "hidden cell is not perceived as visible (#4512). Works on table elements" );
	$table.css( "display", "none" ).html( "<tr><td>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 0, "hidden cell children not perceived as visible (#4512)" );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Is Visible", "#qunit-fixture div:visible:lt(2)", [ "foo", "nothiddendiv" ] );
	} else {
diff --git a/a.js b/b.js
@@ -1524,7 +1524,7 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( "display", "block" );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );

	assert.ok( jQuery( "#siblingspan" ).is( ":visible" ), "Span with no content is visible" );
	$div = jQuery( "<div><span></span></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( $div.find( ":visible" ).length, 1, "Span with no content is visible" );
	$div.css( { width: 0, height: 0, overflow: "hidden" } );
	assert.ok( $div.is( ":visible" ), "Div with width and height of 0 is still visible (gh-2227)" );

	$br = jQuery( "<br/>" ).appendTo( "#qunit-fixture" );
	assert.ok( $br.is( ":visible" ), "br element is visible" );

	$table = jQuery( "#table" );
	$table.html( "<tr><td style='display:none'>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 1, "hidden cell is not perceived as visible (#4512). Works on table elements" );
	$table.css( "display", "none" ).html( "<tr><td>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 0, "hidden cell children not perceived as visible (#4512)" );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Is Visible", "#qunit-fixture div:visible:lt(2)", [ "foo", "nothiddendiv" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Is Not Hidden", "#qunit-fixture:hidden", [] );
	assert.t( "Is Hidden", "#form input:hidden", [ "hidden1", "hidden2" ] );

	$a = jQuery( "<a href='#'><h1>Header</h1></a>" ).appendTo( "#qunit-fixture" );
	assert.ok( $a.is( ":visible" ), "Anchor tag with flow content is visible (gh-2227)" );
} );

QUnit.test( "Keep the last style if the new one isn't recognized by the browser (#14836)", function( assert ) {
	assert.expect( 1 );

	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", "fake value" );
	assert.equal( el.css( "position" ), "absolute", "The old style is kept when setting an unrecognized value" );
diff --git a/a.js b/b.js
@@ -1551,7 +1551,7 @@ QUnit.test( "Reset the style if set to an empty string", function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", " " );
	assert.equal( el.css( "position" ), "absolute", "The old style is kept when setting to a space" );
} );

QUnit.test( "Reset the style if set to an empty string", function( assert ) {
	assert.expect( 1 );
	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", "" );

	// Some browsers return an empty string; others "static". Both those cases mean the style
	// was reset successfully so accept them both.
	assert.equal( el.css( "position" ) || "static", "static",
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
diff --git a/a.js b/b.js
@@ -1626,7 +1626,7 @@ function( assert ) {
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
				name: "backgroundAttachment",
				value: [ "fixed" ]
			}, {
				name: "backgroundColor",
				value: [ "rgb(255, 0, 0)", "rgb(255,0,0)", "#ff0000" ]
			}, {

				// Firefox returns auto's value
				name: "backgroundImage",
				value: [ "url('test.png')", "url(" + baseURL + "test.png)", "url(\"" + baseURL + "test.png\")" ]
			}, {
				name: "backgroundPosition",
				value: [ "5% 5%" ]
			}, {

				// Firefox returns no-repeat
				name: "backgroundRepeat",
				value: [ "repeat-y" ]
			}, {
				name: "backgroundClip",
				value: [ "padding-box" ]
			}, {
				name: "backgroundOrigin",
				value: [ "content-box" ]
			}, {
				name: "backgroundSize",
				value: [ "80px 60px" ]
		} ];

		jQuery.each( styles, function( index, style ) {
			var $clone, $clonedChildren,
				$source = jQuery( "#firstp" ),
				source = $source[ 0 ],
				$children = $source.children();

			if ( source.style[ style.name ] === undefined ) {
				assert.ok( true, style.name +  ": style isn't supported and therefore not an issue" );
				assert.ok( true );

				return true;
			}

			$source.css( style.name, style.value[ 0 ] );
			$children.css( style.name, style.value[ 0 ] );

			$clone = $source.clone();
			$clonedChildren = $clone.children();

			$clone.css( style.name, "" );
			$clonedChildren.css( style.name, "" );

			window.setTimeout( function() {
				assert.notEqual( $clone.css( style.name ), style.value[ 0 ], "Cloned css was changed" );

				assert.ok( jQuery.inArray( $source.css( style.name ) !== -1, style.value ),
					"Clearing clone.css() doesn't affect source.css(): " + style.name +
					"; result: " + $source.css( style.name ) +
					"; expected: " + style.value.join( "," ) );

				assert.ok( jQuery.inArray( $children.css( style.name ) !== -1, style.value ),
					"Clearing clonedChildren.css() doesn't affect children.css(): " + style.name +
					"; result: " + $children.css( style.name ) +
					"; expected: " + style.value.join( "," ) );
			}, 100 );
		} );

		window.setTimeout( done, 1000 );
	}
);

QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert ) {
	assert.expect( 1 );

	var $elem = jQuery( "<div></div>" );

diff --git a/a.js b/b.js
@@ -1635,7 +1635,7 @@ QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert
A blob:100b8c8c5dbbc69db722c251c49d9be7c2db258b

		window.setTimeout( done, 1000 );
	}
);

QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert ) {
	assert.expect( 1 );

	var $elem = jQuery( "<div></div>" );

	$elem.css( "order", 2 );
	assert.equal( $elem.css( "order" ), "2", "2 on order" );
} );

QUnit.test( "Do not throw on frame elements from css method (#15098)", function( assert ) {
	assert.expect( 1 );

	var frameWin, frameDoc,
		frameElement = document.createElement( "iframe" ),
diff --git a/a.js b/b.js
@@ -143,7 +143,7 @@ QUnit.test( "jQuery.data({})", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	var div = document.createElement( "div" );

	dataTests( div, assert );
} );

QUnit.test( "jQuery.data({})", function( assert ) {
	assert.expect( 25 );

	dataTests( {}, assert );
} );

QUnit.test( "jQuery.data(window)", function( assert ) {
	assert.expect( 25 );

	// remove bound handlers from window object to stop potential false positives caused by fix for #5280 in
	// transports/xhr.js
	jQuery( window ).off( "unload" );

	dataTests( window, assert );
diff --git a/a.js b/b.js
@@ -172,7 +172,7 @@ QUnit.test( "jQuery.data(object/flash)", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	assert.expect( 25 );

	dataTests( document.createElement( "embed" ), assert );
} );

QUnit.test( "jQuery.data(object/flash)", function( assert ) {
	assert.expect( 25 );

	var flash = document.createElement( "object" );
	flash.setAttribute( "classid", "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" );

	dataTests( flash, assert );
} );

// attempting to access the data of an undefined jQuery element should be undefined
QUnit.test( "jQuery().data() === undefined (#14101)", function( assert ) {
	assert.expect( 2 );

	assert.strictEqual( jQuery().data(), undefined );
	assert.strictEqual( jQuery().data( "key" ), undefined );
diff --git a/a.js b/b.js
@@ -201,7 +201,7 @@ QUnit.test( ".data()", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c

	assert.strictEqual( jQuery().data(), undefined );
	assert.strictEqual( jQuery().data( "key" ), undefined );
} );

QUnit.test( ".data()", function( assert ) {
	assert.expect( 5 );

	var div, dataObj, nodiv, obj;

	div = jQuery( "#foo" );
	assert.strictEqual( div.data( "foo" ), undefined, "Make sure that missing result is undefined" );
	div.data( "test", "success" );

	dataObj = div.data();

	assert.deepEqual( dataObj, { test: "success" }, "data() returns entire data object with expected properties" );
	assert.strictEqual( div.data( "foo" ), undefined, "Make sure that missing result is still undefined" );

	nodiv = jQuery( "#unfound" );
	assert.equal( nodiv.data(), null, "data() on empty set returns null" );

	obj = { foo: "bar" };
	jQuery( obj ).data( "foo", "baz" );

	dataObj = jQuery.extend( true, {}, jQuery( obj ).data() );

	assert.deepEqual( dataObj, { "foo": "baz" }, "Retrieve data object from a wrapped JS object (#7524)" );
} );

function testDataTypes( $obj, assert ) {
	jQuery.each( {
diff --git a/a.js b/b.js
@@ -232,7 +232,7 @@ QUnit.test( "jQuery(Element).data(String, Object).data(String)", function( asser
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	}, function( type, value ) {
		assert.strictEqual( $obj.data( "test", value ).data( "test" ), value, "Data set to " + type );
	} );
}

QUnit.test( "jQuery(Element).data(String, Object).data(String)", function( assert ) {
	assert.expect( 18 );
	var parent = jQuery( "<div><div></div></div>" ),
		div = parent.children();

	assert.strictEqual( div.data( "test" ), undefined, "No data exists initially" );
	assert.strictEqual( div.data( "test", "success" ).data( "test" ), "success", "Data added" );
	assert.strictEqual( div.data( "test", "overwritten" ).data( "test" ), "overwritten", "Data overwritten" );
	assert.strictEqual( div.data( "test", undefined ).data( "test" ), "overwritten", ".data(key,undefined) does nothing but is chainable (#5571)" );
	assert.strictEqual( div.data( "notexist" ), undefined, "No data exists for unset key" );
	testDataTypes( div, assert );

	parent.remove();
diff --git a/a.js b/b.js
@@ -242,7 +242,7 @@ QUnit.test( "jQuery(Element).data(String, Object).data(String)", function( asser
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	}, function( type, value ) {
		assert.strictEqual( $obj.data( "test", value ).data( "test" ), value, "Data set to " + type );
	} );
}

QUnit.test( "jQuery(Element).data(String, Object).data(String)", function( assert ) {
	assert.expect( 18 );
	var parent = jQuery( "<div><div></div></div>" ),
		div = parent.children();

	assert.strictEqual( div.data( "test" ), undefined, "No data exists initially" );
	assert.strictEqual( div.data( "test", "success" ).data( "test" ), "success", "Data added" );
	assert.strictEqual( div.data( "test", "overwritten" ).data( "test" ), "overwritten", "Data overwritten" );
	assert.strictEqual( div.data( "test", undefined ).data( "test" ), "overwritten", ".data(key,undefined) does nothing but is chainable (#5571)" );
	assert.strictEqual( div.data( "notexist" ), undefined, "No data exists for unset key" );
	testDataTypes( div, assert );

	parent.remove();
} );

QUnit.test( "jQuery(plain Object).data(String, Object).data(String)", function( assert ) {
	assert.expect( 16 );

	// #3748
	var $obj = jQuery( { exists: true } );
	assert.strictEqual( $obj.data( "nothing" ), undefined, "Non-existent data returns undefined" );
	assert.strictEqual( $obj.data( "exists" ), undefined, "Object properties are not returned as data" );
	testDataTypes( $obj, assert );
diff --git a/a.js b/b.js
@@ -253,7 +253,7 @@ QUnit.test( "jQuery(plain Object).data(String, Object).data(String)", function(
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	testDataTypes( div, assert );

	parent.remove();
} );

QUnit.test( "jQuery(plain Object).data(String, Object).data(String)", function( assert ) {
	assert.expect( 16 );

	// #3748
	var $obj = jQuery( { exists: true } );
	assert.strictEqual( $obj.data( "nothing" ), undefined, "Non-existent data returns undefined" );
	assert.strictEqual( $obj.data( "exists" ), undefined, "Object properties are not returned as data" );
	testDataTypes( $obj, assert );

	// Clean up
	$obj.removeData();
	assert.deepEqual( $obj[ 0 ], { exists: true }, "removeData does not clear the object" );
} );

QUnit.test( ".data(object) does not retain references. #13815", function( assert ) {
	assert.expect( 2 );

	var $divs = jQuery( "<div></div><div></div>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -290,7 +290,7 @@ QUnit.test( "data-* attributes", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c

	assert.equal( $divs.eq( 0 ).data( "type" ), "bar", "Correct updated value" );
	assert.equal( $divs.eq( 1 ).data( "type" ), "foo", "Original value retained" );
} );

QUnit.test( "data-* attributes", function( assert ) {
	assert.expect( 46 );

	var prop, i, l, metadata, elem,
		obj, obj2, check, num, num2,
		parseJSON = JSON.parse,
		div = jQuery( "<div>" ),
		child = jQuery( "<div data-myobj='old data' data-ignored=\"DOM\" data-other='test' data-foo-42='boosh'></div>" ),
		dummy = jQuery( "<div data-myobj='old data' data-ignored=\"DOM\" data-other='test' data-foo-42='boosh'></div>" );

	assert.equal( div.data( "attr" ), undefined, "Check for non-existing data-attr attribute" );

	div.attr( "data-attr", "exists" );
	assert.equal( div.data( "attr" ), "exists", "Check for existing data-attr attribute" );

	div.attr( "data-attr", "exists2" );
	assert.equal( div.data( "attr" ), "exists", "Check that updates to data- don't update .data()" );

	div.data( "attr", "internal" ).attr( "data-attr", "external" );
	assert.equal( div.data( "attr" ), "internal", "Check for .data('attr') precedence (internal > external data-* attribute)" );

	div.remove();

	child.appendTo( "#qunit-fixture" );
	assert.equal( child.data( "myobj" ), "old data", "Value accessed from data-* attribute" );
	assert.equal( child.data( "foo-42" ), "boosh", "camelCasing does not affect numbers (#1751)" );

	child.data( "myobj", "replaced" );
	assert.equal( child.data( "myobj" ), "replaced", "Original data overwritten" );

diff --git a/a.js b/b.js
@@ -506,7 +506,7 @@ QUnit.test( ".removeData()", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	jQuery.data( window, "BAD", true );
	jQuery.removeData( window, "BAD" );
	assert.ok( !jQuery.data( window, "BAD" ), "Make sure that the value was not still set." );
} );

QUnit.test( ".removeData()", function( assert ) {
	assert.expect( 6 );
	var div = jQuery( "#foo" );
	div.data( "test", "testing" );
	div.removeData( "test" );
	assert.equal( div.data( "test" ), undefined, "Check removal of data" );

	div.data( "test", "testing" );
	div.data( "test.foo", "testing2" );
	div.removeData( "test.bar" );
	assert.equal( div.data( "test.foo" ), "testing2", "Make sure data is intact" );
	assert.equal( div.data( "test" ), "testing", "Make sure data is intact" );

	div.removeData( "test" );
	assert.equal( div.data( "test.foo" ), "testing2", "Make sure data is intact" );
	assert.equal( div.data( "test" ), undefined, "Make sure data is intact" );

	div.removeData( "test.foo" );
	assert.equal( div.data( "test.foo" ), undefined, "Make sure data is intact" );
} );

QUnit.test( "JSON serialization (#8108)", function( assert ) {
	assert.expect( 1 );

	var obj = { "foo": "bar" };
	jQuery.data( obj, "hidden", true );
diff --git a/a.js b/b.js
@@ -560,7 +560,7 @@ QUnit.test( ".data should not miss preset data-* w/ hyphenated property names",
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	assert.equal( div.data( "foo-bar" ), "d", "Verify updated data-* key (foo-bar)" );

	div.remove();
} );

QUnit.test( ".data should not miss preset data-* w/ hyphenated property names", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div></div>", { id: "hyphened" } ).appendTo( "#qunit-fixture" ),
		test = {
			"camelBar": "camelBar",
			"hyphen-foo": "hyphen-foo"
		};

	div.data( test );

	jQuery.each( test, function( i, k ) {
		assert.equal( div.data( k ), k, "data with property '" + k + "' was correctly found" );
	} );
} );

QUnit.test( "jQuery.data should not miss data-* w/ hyphenated property names #14047", function( assert ) {

	assert.expect( 1 );

	var div = jQuery( "<div></div>" );
diff --git a/a.js b/b.js
@@ -774,7 +774,7 @@ QUnit.test( ".data supports interoperable removal of hyphenated/camelCase proper
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
		assert.deepEqual( div.data( key ), val.value, "get: " + key );
		assert.deepEqual( div.data( val.key ), val.value, "get: " + val.key );
	} );
} );

QUnit.test( ".data supports interoperable removal of hyphenated/camelCase properties", function( assert ) {
	var div = jQuery( "<div></div>", { id: "hyphened" } ).appendTo( "#qunit-fixture" ),
		rdashAlpha = /-([a-z])/g,
		datas = {
			"non-empty": "a string",
			"empty-string": "",
			"one-value": 1,
			"zero-value": 0,
			"an-array": [],
			"an-object": {},
			"bool-true": true,
			"bool-false": false,
			"some-json": "{ \"foo\": \"bar\" }"
		};

	assert.expect( 27 );

	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	jQuery.each( datas, function( key, val ) {
		div.data( key, val );

		assert.deepEqual( div.data( key ), val, "get: " + key );
		assert.deepEqual(
			div.data( key.replace( rdashAlpha, fcamelCase ) ),
			val,
			"get: " + key.replace( rdashAlpha, fcamelCase )
		);

		div.removeData( key );

		assert.equal( div.data( key ), undefined, "get: " + key );

	} );
} );

QUnit.test( ".data supports interoperable removal of properties SET TWICE #13850", function( assert ) {
	var div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		datas = {
			"non-empty": "a string",
			"empty-string": "",
diff --git a/a.js b/b.js
@@ -800,7 +800,7 @@ QUnit.test( ".data supports interoperable removal of properties SET TWICE #13850
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
		assert.equal( div.data( key ), undefined, "get: " + key );

	} );
} );

QUnit.test( ".data supports interoperable removal of properties SET TWICE #13850", function( assert ) {
	var div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		datas = {
			"non-empty": "a string",
			"empty-string": "",
			"one-value": 1,
			"zero-value": 0,
			"an-array": [],
			"an-object": {},
			"bool-true": true,
			"bool-false": false,
			"some-json": "{ \"foo\": \"bar\" }"
		};

	assert.expect( 9 );

	jQuery.each( datas, function( key, val ) {
		div.data( key, val );
		div.data( key, val );

		div.removeData( key );

		assert.equal( div.data( key ), undefined, "removal: " + key );
	} );
} );

QUnit.test( ".removeData supports removal of hyphenated properties via array (#12786, gh-2257)", function( assert ) {
	assert.expect( 4 );

	var div, plain, compare;

diff --git a/a.js b/b.js
@@ -833,7 +833,7 @@ QUnit.test( ".removeData supports removal of hyphenated properties via array (#1
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c

		assert.equal( div.data( key ), undefined, "removal: " + key );
	} );
} );

QUnit.test( ".removeData supports removal of hyphenated properties via array (#12786, gh-2257)", function( assert ) {
	assert.expect( 4 );

	var div, plain, compare;

	div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );
	plain = jQuery( {} );

	// Properties should always be camelCased
	compare = {

		// From batch assignment .data({ "a-a": 1 })
		"aA": 1,

		// From property, value assignment .data( "b-b", 1 )
		"bB": 1
	};

	// Mixed assignment
	div.data( { "a-a": 1 } ).data( "b-b", 1 );
	plain.data( { "a-a": 1 } ).data( "b-b", 1 );

	assert.deepEqual( div.data(), compare, "Data appears as expected. (div)" );
	assert.deepEqual( plain.data(), compare, "Data appears as expected. (plain)" );

	div.removeData( [ "a-a", "b-b" ] );
	plain.removeData( [ "a-a", "b-b" ] );

	assert.deepEqual( div.data(), {}, "Data is empty. (div)" );
	assert.deepEqual( plain.data(), {}, "Data is empty. (plain)" );
} );

// Test originally by Moschel
QUnit.test( ".removeData should not throw exceptions. (#10080)", function( assert ) {
	var done = assert.async();
	assert.expect( 1 );
	var frame = jQuery( "#loadediframe" );
	jQuery( frame[ 0 ].contentWindow ).on( "unload", function() {
diff --git a/a.js b/b.js
@@ -846,7 +846,7 @@ jQuery( frame[ 0 ].contentWindow ).on( "unload", function() {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
// Test originally by Moschel
QUnit.test( ".removeData should not throw exceptions. (#10080)", function( assert ) {
	var done = assert.async();
	assert.expect( 1 );
	var frame = jQuery( "#loadediframe" );
	jQuery( frame[ 0 ].contentWindow ).on( "unload", function() {
		assert.ok( true, "called unload" );
		done();
	} );

	// change the url to trigger unload
	frame.attr( "src", baseURL + "iframe.html?param=true" );
} );

QUnit.test( ".data only checks element attributes once. #8909", function( assert ) {
	assert.expect( 2 );
	var testing = {
			"test": "testing",
			"test2": "testing"
diff --git a/a.js b/b.js
@@ -874,7 +874,7 @@ QUnit.test( "data-* with JSON value can have newlines", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c

	// clean up data cache
	element.remove();
} );

QUnit.test( "data-* with JSON value can have newlines", function( assert ) {
	assert.expect( 1 );

	var x = jQuery( "<div data-some='{\n\"foo\":\n\t\"bar\"\n}'></div>" );
	assert.equal( x.data( "some" ).foo, "bar", "got a JSON data- attribute with spaces" );
	x.remove();
} );

QUnit.test( ".data doesn't throw when calling selection is empty. #13551", function( assert ) {
	assert.expect( 1 );

	try {
		jQuery( null ).data( "prop" );
diff --git a/a.js b/b.js
@@ -911,7 +911,7 @@ QUnit.test( "acceptData", function( assert ) {
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c
	} catch ( e ) {
		assert.ok( false, e.message );
	}
} );

QUnit.test( "acceptData", function( assert ) {
	assert.expect( 10 );

	var flash, pdf, form;

	assert.equal( jQuery( document ).data( "test", 42 ).data( "test" ), 42, "document" );
	assert.equal( jQuery( document.documentElement ).data( "test", 42 ).data( "test" ), 42, "documentElement" );
	assert.equal( jQuery( {} ).data( "test", 42 ).data( "test" ), 42, "object" );
	assert.equal( jQuery( document.createElement( "embed" ) ).data( "test", 42 ).data( "test" ), 42, "embed" );

	flash = document.createElement( "object" );
	flash.setAttribute( "classid", "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" );
	assert.equal( jQuery( flash ).data( "test", 42 ).data( "test" ), 42, "flash" );

	pdf = document.createElement( "object" );
	pdf.setAttribute( "classid", "clsid:CA8A9780-280D-11CF-A24D-444553540000" );
	assert.equal( jQuery( pdf ).data( "test", 42 ).data( "test" ), 42, "pdf" );

	assert.strictEqual( jQuery( document.createComment( "" ) ).data( "test", 42 ).data( "test" ), undefined, "comment" );
	assert.strictEqual( jQuery( document.createTextNode( "" ) ).data( "test", 42 ).data( "test" ), undefined, "text" );
	assert.strictEqual( jQuery( document.createDocumentFragment() ).data( "test", 42 ).data( "test" ), undefined, "documentFragment" );

	form = jQuery( "#form" ).append( "<input id='nodeType'/><input id='nodeName'/>" )[ 0 ];
	assert.equal( jQuery( form ) .data( "test", 42 ).data( "test" ), 42, "form with aliased DOM properties" );
} );

QUnit.test( "Check proper data removal of non-element descendants nodes (#8335)", function( assert ) {
	assert.expect( 1 );

	var div = jQuery( "<div>text</div>" ),
		text = div.contents();
diff --git a/a.js b/b.js
@@ -924,7 +924,7 @@ QUnit.test( "Check proper data removal of non-element descendants nodes (#8335)"
A blob:301bee917dff8af9d1079a69a521c6c898d0cb3c

	form = jQuery( "#form" ).append( "<input id='nodeType'/><input id='nodeName'/>" )[ 0 ];
	assert.equal( jQuery( form ) .data( "test", 42 ).data( "test" ), 42, "form with aliased DOM properties" );
} );

QUnit.test( "Check proper data removal of non-element descendants nodes (#8335)", function( assert ) {
	assert.expect( 1 );

	var div = jQuery( "<div>text</div>" ),
		text = div.contents();

	text.data( "test", "test" ); // This should be a noop.
	div.remove();

	assert.ok( !text.data( "test" ), "Be sure data is not stored in non-element" );
} );

testIframe(
	"enumerate data attrs on body (#14894)",
	"data/dataAttrs.html",
	function( assert, jQuery, window, document, result ) {
		assert.expect( 1 );
		assert.equal( result, "ok", "enumeration of data- attrs on body" );
diff --git a/a.js b/b.js
@@ -77,7 +77,7 @@ jQuery( "#firstp" )
A blob:d6a15cd7e40d7f7840f85993eccbc64afe360c09

	var times = 0,
		handler1 = function() { ++times; },
		handler2 = function() { ++times; };

	jQuery( "#firstp" )
		.hover( handler1, handler2 )
		.mouseenter().mouseleave()
		.off( "mouseenter", handler1 )
		.off( "mouseleave", handler2 )
		.hover( handler1 )
		.mouseenter().mouseleave()
		.off( "mouseenter mouseleave", handler1 )
		.mouseenter().mouseleave();

	assert.equal( times, 4, "hover handlers fired" );
} );

QUnit[ jQuery.fn.click ? "test" : "skip" ]( "trigger() shortcuts", function( assert ) {
	assert.expect( 5 );

	var counter, clickCounter,
		elem = jQuery( "<li><a href='#'>Change location</a></li>" ).prependTo( "#firstUL" );
	elem.find( "a" ).on( "click", function() {
		var close = jQuery( "spanx", this ); // same with jQuery(this).find("span");
		assert.equal( close.length, 0, "Context element does not exist, length must be zero" );
		assert.ok( !close[ 0 ], "Context element does not exist, direct access to element must return undefined" );
		return false;
	} ).click();

	// manually clean up detached elements
	elem.remove();

	jQuery( "#check1" ).click( function() {
		assert.ok( true, "click event handler for checkbox gets fired twice, see #815" );
	} ).click();

	counter = 0;
	jQuery( "#firstp" )[ 0 ].onclick = function() {
diff --git a/a.js b/b.js
@@ -38,7 +38,7 @@ function testWidth( val, assert ) {
A blob:a4485791057c527989fae6bc8fd1ada31754a8de

	fn( value, assert );
		Returns a function that returns the value
*/

function testWidth( val, assert ) {
	assert.expect( 9 );
	var $div, $empty;

	$div = jQuery( "#nothiddendiv" );
	$div.width( val( 30 ) );
	assert.equal( $div.width(), 30, "Test set to 30 correctly" );
	$div.css( "display", "none" );
	assert.equal( $div.width(), 30, "Test hidden div" );
	$div.css( "display", "" );
	$div.width( val( -1 ) ); // handle negative numbers by setting to 0 #11604
	assert.equal( $div.width(), 0, "Test negative width normalized to 0" );
	$div.css( "padding", "20px" );
	assert.equal( $div.width(), 0, "Test padding specified with pixels" );
	$div.css( "border", "2px solid #fff" );
diff --git a/a.js b/b.js
@@ -89,7 +89,7 @@ function testHeight( val, assert ) {
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	} );

	assert.equal( $div.width(), 31, "Make sure value was modified correctly." );
} );

function testHeight( val, assert ) {
	assert.expect( 9 );

	var $div, blah;

	$div = jQuery( "#nothiddendiv" );
	$div.height( val( 30 ) );
	assert.equal( $div.height(), 30, "Test set to 30 correctly" );
	$div.css( "display", "none" );
	assert.equal( $div.height(), 30, "Test hidden div" );
	$div.css( "display", "" );
	$div.height( val( -1 ) ); // handle negative numbers by setting to 0 #11604
	assert.equal( $div.height(), 0, "Test negative height normalized to 0" );
	$div.css( "padding", "20px" );
	assert.equal( $div.height(), 0, "Test padding specified with pixels" );
	$div.css( "border", "2px solid #fff" );
diff --git a/a.js b/b.js
@@ -279,7 +279,7 @@ QUnit.test( "outerHeight()", function( assert ) {
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	assert.equal( div.outerWidth(), 0, "Make sure that disconnected nodes are handled." );

	div.remove();
} );

QUnit.test( "outerHeight()", function( assert ) {
	assert.expect( 12 );

	var $div, div,
		$win = jQuery( window ),
		$doc = jQuery( document ),
		winheight = $win.prop( "innerHeight" );

	assert.equal( jQuery( window ).outerHeight(), winheight, "Test on window without margin option" );
	assert.equal( jQuery( window ).outerHeight( true ), winheight, "Test on window with margin option" );
	assert.equal( jQuery( document ).outerHeight(), $doc.height(), "Test on document without margin option" );
	assert.equal( jQuery( document ).outerHeight( true ), $doc.height(), "Test on document with margin option" );
	assert.strictEqual( jQuery().outerHeight(), undefined, "Test on empty set" );

	$div = jQuery( "#nothiddendiv" );
	$div.css( "height", 30 );

	assert.equal( $div.outerHeight(), 30, "Test with only height set" );
	$div.css( "padding", "20px" );
	assert.equal( $div.outerHeight(), 70, "Test with padding" );
	$div.css( "border", "2px solid #fff" );
	assert.equal( $div.outerHeight(), 74, "Test with padding and border" );
	$div.css( "margin", "10px" );
	assert.equal( $div.outerHeight(), 74, "Test with padding, border and margin without margin option" );
	$div.css( "position", "absolute" );
	assert.equal( $div.outerHeight( true ), 94, "Test with padding, border and margin with margin option" );
	$div.css( "display", "none" );
	assert.equal( $div.outerHeight( true ), 94, "Test hidden div with padding, border and margin with margin option" );

	// reset styles
	$div.css( { "position": "", "display": "", "border": "", "padding": "", "width": "", "height": "" } );

	div = jQuery( "<div>" );

	// Temporarily require 0 for backwards compat - should be auto
	assert.equal( div.outerWidth(), 0, "Make sure that disconnected nodes are handled." );

	div.remove();
} );

QUnit.test( "child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #9441 #9300", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
diff --git a/a.js b/b.js
@@ -290,33 +290,33 @@ QUnit.test( "child of a hidden elem (or unconnected node) has accurate inner/out
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	assert.equal( div.outerWidth(), 0, "Make sure that disconnected nodes are handled." );

	div.remove();
} );

QUnit.test( "child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #9441 #9300", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
		$divChild = $divNormal.clone(),
		$divUnconnected = $divNormal.clone(),
		$divHiddenParent = jQuery( "<div>" ).css( "display", "none" ).append( $divChild ).appendTo( "body" );
	$divNormal.appendTo( "body" );

	// tests that child div of a hidden div works the same as a normal div
	assert.equal( $divChild.width(), $divNormal.width(), "child of a hidden element width() is wrong see #9441" );
	assert.equal( $divChild.innerWidth(), $divNormal.innerWidth(), "child of a hidden element innerWidth() is wrong see #9441" );
	assert.equal( $divChild.outerWidth(), $divNormal.outerWidth(), "child of a hidden element outerWidth() is wrong see #9441" );
	assert.equal( $divChild.outerWidth( true ), $divNormal.outerWidth( true ), "child of a hidden element outerWidth( true ) is wrong see #9300" );

	assert.equal( $divChild.height(), $divNormal.height(), "child of a hidden element height() is wrong see #9441" );
	assert.equal( $divChild.innerHeight(), $divNormal.innerHeight(), "child of a hidden element innerHeight() is wrong see #9441" );
	assert.equal( $divChild.outerHeight(), $divNormal.outerHeight(), "child of a hidden element outerHeight() is wrong see #9441" );
	assert.equal( $divChild.outerHeight( true ), $divNormal.outerHeight( true ), "child of a hidden element outerHeight( true ) is wrong see #9300" );

	// tests that child div of an unconnected div works the same as a normal div
	assert.equal( $divUnconnected.width(), $divNormal.width(), "unconnected element width() is wrong see #9441" );
	assert.equal( $divUnconnected.innerWidth(), $divNormal.innerWidth(), "unconnected element innerWidth() is wrong see #9441" );
	assert.equal( $divUnconnected.outerWidth(), $divNormal.outerWidth(), "unconnected element outerWidth() is wrong see #9441" );
	assert.equal( $divUnconnected.outerWidth( true ), $divNormal.outerWidth( true ), "unconnected element outerWidth( true ) is wrong see #9300" );

	assert.equal( $divUnconnected.height(), $divNormal.height(), "unconnected element height() is wrong see #9441" );
	assert.equal( $divUnconnected.innerHeight(), $divNormal.innerHeight(), "unconnected element innerHeight() is wrong see #9441" );
	assert.equal( $divUnconnected.outerHeight(), $divNormal.outerHeight(), "unconnected element outerHeight() is wrong see #9441" );
	assert.equal( $divUnconnected.outerHeight( true ), $divNormal.outerHeight( true ), "unconnected element outerHeight( true ) is wrong see #9300" );

	// teardown html
	$divHiddenParent.remove();
	$divNormal.remove();
} );

QUnit.test( "getting dimensions shouldn't modify runtimeStyle see #9233", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		div = $div.get( 0 ),
diff --git a/a.js b/b.js
@@ -331,9 +331,9 @@ QUnit.test( "getting dimensions shouldn't modify runtimeStyle see #9233", functi
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	// teardown html
	$divHiddenParent.remove();
	$divNormal.remove();
} );

QUnit.test( "getting dimensions shouldn't modify runtimeStyle see #9233", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		div = $div.get( 0 ),
		runtimeStyle = div.runtimeStyle;

	if ( runtimeStyle ) {
		div.runtimeStyle.marginLeft = "12em";
		div.runtimeStyle.left = "11em";
	}

	$div.outerWidth( true );

	if ( runtimeStyle ) {
		assert.equal( div.runtimeStyle.left, "11em", "getting dimensions modifies runtimeStyle, see #9233" );
	} else {
		assert.ok( true, "this browser doesn't support runtimeStyle, see #9233" );
	}

	$div.remove();
} );
diff --git a/a.js b/b.js
@@ -348,8 +348,8 @@ QUnit.test( "table dimensions", function( assert ) {
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	}

	$div.remove();
} );

QUnit.test( "table dimensions", function( assert ) {
	assert.expect( 2 );

	var table = jQuery( "<table><colgroup><col></col><col></col></colgroup><tbody><tr><td></td><td>a</td></tr><tr><td></td><td>a</td></tr></tbody></table>" ).appendTo( "#qunit-fixture" ),
		tdElem = table.find( "td" ).first(),
		colElem = table.find( "col" ).first().width( 300 );

	table.find( "td" ).css( { "margin": 0, "padding": 0 } );

	assert.equal( tdElem.width(), tdElem.width(), "width() doesn't alter dimension values of empty cells, see #11293" );
	assert.equal( colElem.width(), 300, "col elements have width(), see #12243" );
} );

QUnit.test( "SVG dimensions (basic content-box)", function( assert ) {
	assert.expect( 8 );
diff --git a/a.js b/b.js
@@ -412,7 +412,7 @@ QUnit.test( "SVG dimensions (border-box)", function( assert ) {
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	assert.equal( svg.outerHeight( true ), 112 );

	svg.remove();
} );

QUnit.test( "SVG dimensions (border-box)", function( assert ) {
	assert.expect( 8 );

	var svg = jQuery( "<svg style='width: 100px; height: 100px; box-sizing: border-box; border: 1px solid white; padding: 2px; margin: 3px'></svg>" ).appendTo( "#qunit-fixture" );

	assert.equal( svg.width(), 94, "width" );
	assert.equal( svg.height(), 94, "height" );

	assert.equal( svg.innerWidth(), 98, "innerWidth" );
	assert.equal( svg.innerHeight(), 98, "innerHeight" );

	assert.equal( svg.outerWidth(), 100, "outerWidth" );
	assert.equal( svg.outerHeight(), 100, "outerHeight" );

	assert.equal( svg.outerWidth( true ), 106, "outerWidth( true )" );
	assert.equal( svg.outerHeight( true ), 106, "outerHeight( true )" );

	svg.remove();
} );

QUnit.test( "box-sizing:border-box child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #10413", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "boxSizing": "border-box", "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
diff --git a/a.js b/b.js
@@ -423,38 +423,38 @@ QUnit.test( "box-sizing:border-box child of a hidden elem (or unconnected node)
A blob:a4485791057c527989fae6bc8fd1ada31754a8de
	assert.equal( svg.outerHeight( true ), 106, "outerHeight( true )" );

	svg.remove();
} );

QUnit.test( "box-sizing:border-box child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #10413", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "boxSizing": "border-box", "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
		$divChild = $divNormal.clone(),
		$divUnconnected = $divNormal.clone(),
		$divHiddenParent = jQuery( "<div>" ).css( "display", "none" ).append( $divChild ).appendTo( "body" );
	$divNormal.appendTo( "body" );

	// tests that child div of a hidden div works the same as a normal div
	assert.equal( $divChild.width(), $divNormal.width(), "child of a hidden element width() is wrong see #10413" );
	assert.equal( $divChild.innerWidth(), $divNormal.innerWidth(), "child of a hidden element innerWidth() is wrong see #10413" );
	assert.equal( $divChild.outerWidth(), $divNormal.outerWidth(), "child of a hidden element outerWidth() is wrong see #10413" );
	assert.equal( $divChild.outerWidth( true ), $divNormal.outerWidth( true ), "child of a hidden element outerWidth( true ) is wrong see #10413" );

	assert.equal( $divChild.height(), $divNormal.height(), "child of a hidden element height() is wrong see #10413" );
	assert.equal( $divChild.innerHeight(), $divNormal.innerHeight(), "child of a hidden element innerHeight() is wrong see #10413" );
	assert.equal( $divChild.outerHeight(), $divNormal.outerHeight(), "child of a hidden element outerHeight() is wrong see #10413" );
	assert.equal( $divChild.outerHeight( true ), $divNormal.outerHeight( true ), "child of a hidden element outerHeight( true ) is wrong see #10413" );

	// tests that child div of an unconnected div works the same as a normal div
	assert.equal( $divUnconnected.width(), $divNormal.width(), "unconnected element width() is wrong see #10413" );
	assert.equal( $divUnconnected.innerWidth(), $divNormal.innerWidth(), "unconnected element innerWidth() is wrong see #10413" );
	assert.equal( $divUnconnected.outerWidth(), $divNormal.outerWidth(), "unconnected element outerWidth() is wrong see #10413" );
	assert.equal( $divUnconnected.outerWidth( true ), $divNormal.outerWidth( true ), "unconnected element outerWidth( true ) is wrong see #10413" );

	assert.equal( $divUnconnected.height(), $divNormal.height(), "unconnected element height() is wrong see #10413" );
	assert.equal( $divUnconnected.innerHeight(), $divNormal.innerHeight(), "unconnected element innerHeight() is wrong see #10413" );
	assert.equal( $divUnconnected.outerHeight(), $divNormal.outerHeight(), "unconnected element outerHeight() is wrong see #10413" );
	assert.equal( $divUnconnected.outerHeight( true ), $divNormal.outerHeight( true ), "unconnected element outerHeight( true ) is wrong see #10413" );

	// teardown html
	$divHiddenParent.remove();
	$divNormal.remove();
} );

QUnit.test( "passing undefined is a setter #5571", function( assert ) {
	assert.expect( 4 );
	assert.equal( jQuery( "#nothiddendiv" ).height( 30 ).height( undefined ).height(), 30, ".height(undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#nothiddendiv" ).height( 30 ).innerHeight( undefined ).height(), 30, ".innerHeight(undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#nothiddendiv" ).height( 30 ).outerHeight( undefined ).height(), 30, ".outerHeight(undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#nothiddendiv" ).width( 30 ).width( undefined ).width(), 30, ".width(undefined) is chainable (#5571)" );
} );

QUnit.test( "setters with and without box-sizing:border-box", function( assert ) {
	assert.expect( 120 );
diff --git a/a.js b/b.js
@@ -5,7 +5,8 @@
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
( function() {

// Can't test what ain't there
if ( !jQuery.fx ) {
	return;
}

var oldRaf = window.requestAnimationFrame,
	hideOptions = {
		inline: function() { jQuery.style( this, "display", "none" ); },
		cascade: function() { this.className = "hidden"; }
	};
diff --git a/a.js b/b.js
@@ -15,15 +16,12 @@
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		cascade: function() { this.className = "hidden"; }
	};

QUnit.module( "effects", {
	beforeEach: function() {
		this.sandbox = sinon.createSandbox();
		this.clock = this.sandbox.useFakeTimers( 505877050 );
		this._oldInterval = jQuery.fx.interval;
		window.requestAnimationFrame = null;
		jQuery.fx.step = {};
		jQuery.fx.interval = 10;
	},
	afterEach: function() {
		this.sandbox.restore();
		jQuery.fx.stop();
		jQuery.fx.interval = this._oldInterval;
		window.requestAnimationFrame = oldRaf;
		return moduleTeardown.apply( this, arguments );
	}
} );
diff --git a/a.js b/b.js
@@ -141,7 +139,7 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See #14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
diff --git a/a.js b/b.js
@@ -160,9 +158,9 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See #14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
diff --git a/a.js b/b.js
@@ -172,7 +170,7 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See #14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
					expected === "inline" ? "inline-block" : expected,
					"Correct display type during animation for " + selector
				);
			} );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal( jQuery( this ).css( "display" ), expected,
					"Correct display type after animation for " + selector );
diff --git a/a.js b/b.js
@@ -184,7 +182,7 @@ QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "show(Number) - " + type + " hidden", function( assert ) {
		assert.expect( 30 );

		jQuery(
			"<div id='show-tests'>" +
			"<div><p><a href='#'></a></p><code></code><pre></pre><span></span></div>" +
			"<table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr></tbody>" +
				"</table>" +
			"<ul><li></li></ul></div>"
		).appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		// Note: inline elements are expected to be inline-block
		// because we're showing width/height
		// Can't animate width/height inline
		// See #14344
		var test = {
			"div": "block",
			"p": "block",
			"a": "inline",
			"code": "inline",
			"pre": "block",
			"span": "inline",
			"table": "table",
			"thead": "table-header-group",
			"tbody": "table-row-group",
			"tr": "table-row",
			"th": "table-cell",
			"td": "table-cell",
			"ul": "block",
			"li": "list-item"
		};

		jQuery.each( test, function( selector ) {
			jQuery( selector, "#show-tests" ).show( 100 );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal(
					jQuery( this ).css( "display" ),
					expected === "inline" ? "inline-block" : expected,
					"Correct display type during animation for " + selector
				);
			} );
		} );
		this.clock.tick( 50 );
		jQuery.each( test, function( selector, expected ) {
			jQuery( selector, "#show-tests" ).each( function() {
				assert.equal( jQuery( this ).css( "display" ), expected,
					"Correct display type after animation for " + selector );
			} );
		} );

		jQuery( "#show-tests" ).remove();
	} );
} );

// Supports #7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

diff --git a/a.js b/b.js
@@ -203,17 +201,17 @@ QUnit.test( "Persist correct display value - " + type + " hidden", function( ass
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );
} );

// Supports #7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='show-tests'><span style='position:absolute;'>foo</span></div>" )
			.appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		var $span = jQuery( "#show-tests span" ),
			displayNone = $span.css( "display" ),
			display = "",
			clock = this.clock;

		$span.show();

		display = $span.css( "display" );

		$span.hide();

		$span.fadeIn( 100, function() {
			assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
			$span.fadeOut( 100, function() {
				assert.equal( $span.css( "display" ), displayNone, "Expecting display: " + displayNone );
				$span.fadeIn( 100, function() {
					assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );

	// Support: IE 11+
	// IE doesn't support Shadow DOM.
diff --git a/a.js b/b.js
@@ -235,17 +233,17 @@ QUnit.test( "Persist correct display value - " + type + " hidden", function( ass
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );
} );

// Supports #7397
supportjQuery.each( hideOptions, function( type, setup ) {
	QUnit.test( "Persist correct display value - " + type + " hidden", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='show-tests'><span style='position:absolute;'>foo</span></div>" )
			.appendTo( "#qunit-fixture" ).find( "*" ).each( setup );

		var $span = jQuery( "#show-tests span" ),
			displayNone = $span.css( "display" ),
			display = "",
			clock = this.clock;

		$span.show();

		display = $span.css( "display" );

		$span.hide();

		$span.fadeIn( 100, function() {
			assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
			$span.fadeOut( 100, function() {
				assert.equal( $span.css( "display" ), displayNone, "Expecting display: " + displayNone );
				$span.fadeIn( 100, function() {
					assert.equal( $span.css( "display" ), display, "Expecting display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );

	// Support: IE 11+
	// IE doesn't support Shadow DOM.
	QUnit.testUnlessIE(
		"Persist correct display value - " + type + " hidden, shadow child", function( assert ) {
		assert.expect( 3 );

		jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );

		var shadowHost = document.querySelector( "#shadowHost" );
		var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
		shadowRoot.innerHTML = "<style>.hidden{display: none;}</style>" +
			"<span id='shadowChild' class='hidden'></span>";
		var shadowChild = shadowRoot.querySelector( "#shadowChild" );

		var $shadowChild = jQuery( shadowChild );
		var displayNone = "none";
		var display = "inline";
		var clock = this.clock;

		$shadowChild.fadeIn( 100, function() {
			assert.equal( $shadowChild.css( "display" ), display, "Expecting shadow display: " + display );
			$shadowChild.fadeOut( 100, function() {
				assert.equal( $shadowChild.css( "display" ), displayNone, "Expecting shadow display: " + displayNone );
				$shadowChild.fadeIn( 100, function() {
					assert.equal( $shadowChild.css( "display" ), display, "Expecting shadow display: " + display );
				} );
			} );
		} );

		clock.tick( 300 );
	} );
} );

QUnit.test( "animate(Hash, Object, Function)", function( assert ) {
diff --git a/a.js b/b.js
@@ -284,7 +282,7 @@ QUnit.test( "animate relative values", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery( "#foo" ).animate( hash, 0, function() {
		assert.equal( hash.opacity, hashCopy.opacity, "Check if animate changed the hash parameter" );
	} );
} );

QUnit.test( "animate relative values", function( assert ) {

	var value = 40,
		clock = this.clock,
		bases = [ "%", "px", "em" ],
		adjustments = [ "px", "em" ],
		container = jQuery( "<div></div>" )
			.css( { position: "absolute", height: "50em", width: "50em" } ),
		animations = bases.length * adjustments.length;

	assert.expect( 2 * animations );

	jQuery.each( bases, function( _, baseUnit ) {
		jQuery.each( adjustments, function( _, adjustUnit ) {
			var base = value + baseUnit,
				adjust = { height: "+=2" + adjustUnit, width: "-=2" + adjustUnit },
				elem = jQuery( "<div></div>" )
					.appendTo( container.clone().appendTo( "#qunit-fixture" ) )
					.css( {
						position: "absolute",
						height: base,
						width: value + adjustUnit
					} ),
				baseScale = elem[ 0 ].offsetHeight / value,
				adjustScale = elem[ 0 ].offsetWidth / value;

			elem.css( "width", base ).animate( adjust, 100, function() {
				assert.equal( this.offsetHeight, value * baseScale + 2 * adjustScale,
					baseUnit + "+=" + adjustUnit );
				assert.equal( this.offsetWidth, value * baseScale - 2 * adjustScale,
					baseUnit + "-=" + adjustUnit );
diff --git a/a.js b/b.js
@@ -292,52 +290,52 @@ QUnit.test( "animate relative values", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery( "#foo" ).animate( hash, 0, function() {
		assert.equal( hash.opacity, hashCopy.opacity, "Check if animate changed the hash parameter" );
	} );
} );

QUnit.test( "animate relative values", function( assert ) {

	var value = 40,
		clock = this.clock,
		bases = [ "%", "px", "em" ],
		adjustments = [ "px", "em" ],
		container = jQuery( "<div></div>" )
			.css( { position: "absolute", height: "50em", width: "50em" } ),
		animations = bases.length * adjustments.length;

	assert.expect( 2 * animations );

	jQuery.each( bases, function( _, baseUnit ) {
		jQuery.each( adjustments, function( _, adjustUnit ) {
			var base = value + baseUnit,
				adjust = { height: "+=2" + adjustUnit, width: "-=2" + adjustUnit },
				elem = jQuery( "<div></div>" )
					.appendTo( container.clone().appendTo( "#qunit-fixture" ) )
					.css( {
						position: "absolute",
						height: base,
						width: value + adjustUnit
					} ),
				baseScale = elem[ 0 ].offsetHeight / value,
				adjustScale = elem[ 0 ].offsetWidth / value;

			elem.css( "width", base ).animate( adjust, 100, function() {
				assert.equal( this.offsetHeight, value * baseScale + 2 * adjustScale,
					baseUnit + "+=" + adjustUnit );
				assert.equal( this.offsetWidth, value * baseScale - 2 * adjustScale,
					baseUnit + "-=" + adjustUnit );

			} );

			clock.tick( 100 );
		} );
	} );
} );

QUnit.test( "animate negative height", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { height: -100 }, 100, function() {
		assert.equal( this.offsetHeight, 0, "Verify height." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative margin", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { "marginTop": -100 }, 100, function() {
		assert.equal( jQuery( this ).css( "marginTop" ), "-100px", "Verify margin." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative margin with px", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { marginTop: "-100px" }, 100, function() {
		assert.equal( jQuery( this ).css( "marginTop" ), "-100px", "Verify margin." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate negative padding", function( assert ) {
	assert.expect( 1 );
	jQuery( "#foo" ).animate( { "paddingBottom": -100 }, 100, function() {
		assert.equal( jQuery( this ).css( "paddingBottom" ), "0px", "Verify paddingBottom." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate block as inline width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "#foo" ).css( { display: "inline", width: "", height: "" } ).animate( { width: 42, height: 42 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "inline-block", "inline-block was set on non-floated inline element when animating width/height" );
		assert.equal( this.offsetWidth, 42, "width was animated" );
		assert.equal( this.offsetHeight, 42, "height was animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate native inline width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -346,12 +344,12 @@ QUnit.test( "animate native inline width/height", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( this.offsetHeight, 42, "height was animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate native inline width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "#foo" ).css( { display: "", width: "", height: "" } )
		.append( "<span>text</span>" )
		.children( "span" )
			.animate( { width: 42, height: 42 }, 100, function() {
				assert.equal( jQuery( this ).css( "display" ), "inline-block", "inline-block was set on non-floated inline element when animating width/height" );
				assert.equal( this.offsetWidth, 42, "width was animated" );
				assert.equal( this.offsetHeight, 42, "height was animated" );
			} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -366,7 +364,7 @@ jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
		display: "block",
		width: 20,
		height: 20,
		paddingLeft: 60
	} ).animate( {
		width: 42,
		height: 42
	}, {
		duration: 100,
		step: function() {
			if ( jQuery( this ).width() > 42 ) {
				assert.ok( false, "width was incorrectly augmented during animation" );
			}
diff --git a/a.js b/b.js
@@ -378,16 +376,16 @@ jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
} );

QUnit.test( "animate block width/height", function( assert ) {
	assert.expect( 3 );

	jQuery( "<div>" ).appendTo( "#qunit-fixture" ).css( {
		display: "block",
		width: 20,
		height: 20,
		paddingLeft: 60
	} ).animate( {
		width: 42,
		height: 42
	}, {
		duration: 100,
		step: function() {
			if ( jQuery( this ).width() > 42 ) {
				assert.ok( false, "width was incorrectly augmented during animation" );
			}
		},
		complete: function() {
			assert.equal( jQuery( this ).css( "display" ), "block", "inline-block was not set on block element when animating width/height" );
			assert.equal( jQuery( this ).width(), 42, "width was animated" );
			assert.equal( jQuery( this ).height(), 42, "height was animated" );
		}
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table width/height", function( assert ) {
	assert.expect( 1 );

	jQuery( "#table" ).animate( { width: 42, height: 42 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table", "display mode is correct" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-row width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -397,12 +395,12 @@ QUnit.test( "animate table-row width/height", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( jQuery( this ).css( "display" ), "table", "display mode is correct" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-row width/height", function( assert ) {
	assert.expect( 3 );
	var tr = jQuery( "#table" )
			.attr( { "cellspacing": 0, "cellpadding": 0, "border": 0 } )
			.html( "<tr style='height:42px;'><td style='padding:0;'><div style='width:20px;height:20px;'></div></td></tr>" )
			.find( "tr" );

	tr.animate( { width: 10, height: 10 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table-row", "display mode is correct" );
		assert.equal( this.offsetWidth, 20, "width animated to shrink wrap point" );
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-cell width/height", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -413,12 +411,12 @@ QUnit.test( "animate table-cell width/height", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate table-cell width/height", function( assert ) {
	assert.expect( 3 );

	var td = jQuery( "#table" )
			.attr( { "cellspacing": 0, "cellpadding": 0, "border": 0 } )
			.html( "<tr><td style='width:42px;height:42px;padding:0;'><div style='width:20px;height:20px;'></div></td></tr>" )
			.find( "td" );

	td.animate( { width: 10, height: 10 }, 100, function() {
		assert.equal( jQuery( this ).css( "display" ), "table-cell", "display mode is correct" );
		assert.equal( this.offsetWidth, 20, "width animated to shrink wrap point" );
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate percentage(%) on width/height", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -427,46 +425,25 @@ QUnit.test( "animate percentage(%) on width/height", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( this.offsetHeight, 20, "height animated to shrink wrap point" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate percentage(%) on width/height", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div style='position:absolute;top:-999px;left:-999px;width:60px;height:60px;'><div style='width:50%;height:50%;'></div></div>" )
		.appendTo( "#qunit-fixture" ).children( "div" );

	$div.animate( { width: "25%", height: "25%" }, 13, function() {
		var $this = jQuery( this );
		assert.equal( $this.css( "width" ), "15px", "Width was animated to 15px rather than 25px" );
		assert.equal( $this.css( "height" ), "15px", "Height was animated to 15px rather than 25px" );
	} );
	this.clock.tick( 20 );
} );

QUnit.test( "animate resets overflow-x and overflow-y when finished", function( assert ) {
	assert.expect( 2 );
	jQuery( "#foo" )
		.css( { display: "block", width: 20, height: 20, overflowX: "visible", overflowY: "auto" } )
		.animate( { width: 42, height: 42 }, 100, function() {
			assert.equal( this.style.overflowX, "visible", "overflow-x is visible" );
			assert.equal( this.style.overflowY, "auto", "overflow-y is auto" );
		} );
	this.clock.tick( 100 );
} );

/* // This test ends up being flaky depending upon the CPU load
QUnit.test("animate option (queue === false)", function( assert ) {
	var done = assert.async();
	assert.expect(1);

	var order = [];

	var $foo = jQuery("#foo");
	$foo.animate({width:"100px"}, 3000, function () {
		// should finish after unqueued animation so second
		order.push(2);
		assert.deepEqual( order, [ 1, 2 ], "Animations finished in the correct order" );
		done();
	});
	$foo.animate({fontSize:"2em"}, {queue:false, duration:10, complete:function () {
		// short duration and out of queue so should finish first
		order.push(1);
	}});
});
*/

QUnit.test( "animate option { queue: false }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

diff --git a/a.js b/b.js
@@ -475,12 +452,12 @@ QUnit.test( "animate option { queue: false }", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		order.push(1);
	}});
});
*/

QUnit.test( "animate option { queue: false }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: false,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

diff --git a/a.js b/b.js
@@ -493,7 +470,7 @@ QUnit.test( "animate option { queue: true }", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

QUnit.test( "animate option { queue: true }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: true,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );
diff --git a/a.js b/b.js
@@ -502,7 +479,7 @@ QUnit.test( "animate option { queue: true }", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	this.clock.tick( 10 );

	assert.equal( foo.queue().length, 0, "Queue is empty" );
} );

QUnit.test( "animate option { queue: true }", function( assert ) {
	assert.expect( 2 );
	var foo = jQuery( "#foo" );

	foo.animate( {
		fontSize: "2em"
	}, {
		queue: true,
		duration: 10,
		complete: function() {
			assert.ok( true, "Animation Completed" );
		}
	} );

	assert.notEqual( foo.queue().length, 0, "Default queue is not empty" );

	//clear out existing timers before next test
	this.clock.tick( 10 );
} );

QUnit.test( "animate option { queue: 'name' }", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -533,7 +510,7 @@ QUnit.test( "animate option { queue: 'name' }", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	//clear out existing timers before next test
	this.clock.tick( 10 );
} );

QUnit.test( "animate option { queue: 'name' }", function( assert ) {
	assert.expect( 5 );
	var foo = jQuery( "#foo" ),
		origWidth = parseFloat( foo.css( "width" ) ),
		order = [];

	foo.animate( { width: origWidth + 100 }, {
		queue: "name",
		duration: 1,
		complete: function() {

			// second callback function
			order.push( 2 );
			assert.equal( parseFloat( foo.css( "width" ) ), origWidth + 100, "Animation ended" );
			assert.equal( foo.queue( "name" ).length, 1, "Queue length of 'name' queue" );
		}
	} ).queue( "name", function() {

		// last callback function
		assert.deepEqual( order, [ 1, 2 ], "Callbacks in expected order" );
	} );

	// this is the first callback function that should be called
	order.push( 1 );
	assert.equal( parseFloat( foo.css( "width" ) ), origWidth, "Animation does not start on its own." );
	assert.equal( foo.queue( "name" ).length, 2, "Queue length of 'name' queue" );

	foo.dequeue( "name" );
	this.clock.tick( 10 );

} );

QUnit.test( "animate with no properties", function( assert ) {
diff --git a/a.js b/b.js
@@ -553,10 +530,10 @@ QUnit.test( "animate with no properties", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	foo.dequeue( "name" );
	this.clock.tick( 10 );

} );

QUnit.test( "animate with no properties", function( assert ) {
	assert.expect( 2 );

	var foo,
		divs = jQuery( "div" ),
		count = 0;

	divs.animate( {}, function() {
		count++;
	} );

	assert.equal( divs.length, count, "Make sure that callback is called for each element in the set." );

	foo = jQuery( "#foo" );

	foo.animate( {} );
	foo.animate( { top: 10 }, 100, function() {
		assert.ok( true, "Animation was properly dequeued." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate duration 0", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -589,13 +566,13 @@ QUnit.test( "animate duration 0", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.ok( true, "Animation was properly dequeued." );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "animate duration 0", function( assert ) {
	assert.expect( 11 );

	var $elem,
		$elems = jQuery( [ { a:0 }, { a:0 } ] ),
		counter = 0;

	assert.equal( jQuery.timers.length, 0, "Make sure no animation was running from another test" );

	$elems.eq( 0 ).animate( { a:1 }, 0, function() {
		assert.ok( true, "Animate a simple property." );
		counter++;
	} );

	// Failed until [6115]
	assert.equal( jQuery.timers.length, 0, "Make sure synchronic animations are not left on jQuery.timers" );

	assert.equal( counter, 1, "One synchronic animations" );

	$elems.animate( { a:2 }, 0, function() {
		assert.ok( true, "Animate a second simple property." );
		counter++;
	} );

	assert.equal( counter, 3, "Multiple synchronic animations" );

	$elems.eq( 0 ).animate( { a:3 }, 0, function() {
		assert.ok( true, "Animate a third simple property." );
		counter++;
	} );
	$elems.eq( 1 ).animate( { a:3 }, 200, function() {
		counter++;

		// Failed until [6115]
		assert.equal( counter, 5, "One synchronic and one asynchronic" );
	} );
	this.clock.tick( 200 );

	$elem = jQuery( "<div></div>" );
	$elem.show( 0, function() {
		assert.ok( true, "Show callback with no duration" );
diff --git a/a.js b/b.js
@@ -614,12 +591,12 @@ QUnit.test( "animate hyphenated properties", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	// manually clean up detached elements
	$elem.remove();
} );

QUnit.test( "animate hyphenated properties", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" )
		.css( "font-size", 10 )
		.animate( { "font-size": 20 }, 200, function() {
			assert.equal( this.style.fontSize, "20px", "The font-size property was animated." );
		} );

	// FIXME why is this double only when run with other tests
	this.clock.tick( 400 );

} );

QUnit.test( "animate non-element", function( assert ) {
diff --git a/a.js b/b.js
@@ -628,10 +605,10 @@ QUnit.test( "animate non-element", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	// FIXME why is this double only when run with other tests
	this.clock.tick( 400 );

} );

QUnit.test( "animate non-element", function( assert ) {
	assert.expect( 1 );

	var obj = { test: 0 };

	jQuery( obj ).animate( { test: 200 }, 200, function() {
		assert.equal( obj.test, 200, "The custom property should be modified." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "animate non-element's zIndex without appending \"px\"", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -639,10 +616,10 @@ QUnit.test( "animate non-element's zIndex without appending \"px\"", function( a
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( obj.test, 200, "The custom property should be modified." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "animate non-element's zIndex without appending \"px\"", function( assert ) {
	assert.expect( 1 );

	var obj = { zIndex: 0 };

	jQuery( obj ).animate( { zIndex: 200 }, 200, function() {
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -654,9 +631,9 @@ QUnit.test( "stop()", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

diff --git a/a.js b/b.js
@@ -664,7 +641,7 @@ QUnit.test( "stop()", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	this.clock.tick( 100 );

	$foo.removeData();
	$foo.removeData( undefined, true );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
diff --git a/a.js b/b.js
@@ -672,17 +649,17 @@ QUnit.test( "stop()", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( obj.zIndex, 200, "The custom property should be modified without appending \"px\"." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "stop()", function( assert ) {
	assert.expect( 4 );

	var $one, $two,
		$foo = jQuery( "#foo" ),
		w = 0,
		nw;

	$foo.hide().css( "width", 200 )
		.animate( { "width": "show" }, 1500 );

	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop();

	nw = $foo.css( "width" );
	assert.notEqual( parseFloat( nw ), w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	this.clock.tick( 100 );

	$foo.removeData();
	$foo.removeData( undefined, true );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );

	$one = jQuery( "#fadein" );
	$two = jQuery( "#show" );
	$one.fadeTo( 100, 0, function() {
		$one.stop();
	} );
	this.clock.tick( 100 );
	$two.fadeTo( 100, 0, function() {
		assert.equal( $two.css( "opacity" ), "0", "Stop does not interfere with animations on other elements (#6641)" );

		// Reset styles
		$one.add( $two ).css( "opacity", "" );
	} );
	this.clock.tick( 100 );
} );

QUnit.test( "stop() - several in queue", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -721,12 +698,12 @@ QUnit.test( "stop(clearQueue)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	$foo.stop( true );

	assert.equal( $foo.queue().length, 0, "0 in the queue" );
} );

QUnit.test( "stop(clearQueue)", function( assert ) {
	assert.expect( 4 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { "width": "show" }, 1000 );
	$foo.animate( { "width": "hide" }, 1000 );
	$foo.animate( { "width": "show" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( true );

diff --git a/a.js b/b.js
@@ -735,7 +712,7 @@ QUnit.test( "stop(clearQueue)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	$foo.stop( true );

	assert.equal( $foo.queue().length, 0, "0 in the queue" );
} );

QUnit.test( "stop(clearQueue)", function( assert ) {
	assert.expect( 4 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { "width": "show" }, 1000 );
	$foo.animate( { "width": "hide" }, 1000 );
	$foo.animate( { "width": "show" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( true );

	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "Stop didn't reset the animation " + nw + " " + w + "px" );

	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
diff --git a/a.js b/b.js
@@ -745,13 +722,13 @@ QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
	assert.expect( 1 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( false, true );

diff --git a/a.js b/b.js
@@ -761,7 +738,7 @@ QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.equal( $foo.queue().length, 0, "The animation queue was cleared" );
	this.clock.tick( 100 );
	assert.equal( nw, $foo.css( "width" ), "The animation didn't continue" );
} );

QUnit.test( "stop(clearQueue, gotoEnd)", function( assert ) {
	assert.expect( 1 );

	var $foo = jQuery( "#foo" ),
		w = 0,
		nw;
	$foo.hide().css( "width", 200 ).css( "width" );

	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	$foo.animate( { width: "show" }, 1000 );
	$foo.animate( { width: "hide" }, 1000 );
	this.clock.tick( 100 );
	nw = $foo.css( "width" );
	assert.ok( parseFloat( nw ) !== w, "An animation occurred " + nw + " " + w + "px" );
	$foo.stop( false, true );

	nw = $foo.css( "width" );

	// Disabled, being flaky
	//equal( nw, 1, "Stop() reset the animation" );

	this.clock.tick( 100 );

	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
diff --git a/a.js b/b.js
@@ -776,7 +753,7 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
diff --git a/a.js b/b.js
@@ -786,7 +763,7 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
	} );

	foo.animate( {
		height: 400
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, true );

	assert.equal( parseFloat( foo.css( "height" ) ), 400, "Height was stopped with gotoEnd" );
diff --git a/a.js b/b.js
@@ -795,11 +772,11 @@ QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	// Disabled, being flaky
	//equal( $foo.queue().length, 2, "The next animation continued" );
	$foo.stop( true );
} );

QUnit.test( "stop( queue, ..., ... ) - Stop single queues", function( assert ) {
	assert.expect( 3 );
	var saved,
		foo = jQuery( "#foo" ).css( { width: 200, height: 200 } );

	foo.animate( {
		width: 400
	}, {
		duration: 500,
		complete: function() {
			assert.equal( parseFloat( foo.css( "width" ) ), 400, "Animation completed for standard queue" );
			assert.equal( parseFloat( foo.css( "height" ) ), saved, "Height was not changed after the second stop" );
		}
	} );

	foo.animate( {
		height: 400
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, true );

	assert.equal( parseFloat( foo.css( "height" ) ), 400, "Height was stopped with gotoEnd" );

	foo.animate( {
		height: 200
	}, {
		duration: 1000,
		queue: "height"
	} ).dequeue( "height" ).stop( "height", false, false );
	saved = parseFloat( foo.css( "height" ) );
        this.clock.tick( 500 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "toggle()", function( assert ) {
	assert.expect( 6 );
diff --git a/a.js b/b.js
@@ -832,7 +809,7 @@ QUnit.test( "jQuery.fx.prototype.cur() - <1.8 Back Compat", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible again" );
} );

QUnit.test( "jQuery.fx.prototype.cur() - <1.8 Back Compat", function( assert ) {
	assert.expect( 7 );

	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).css( {
			color: "#ABC",
			border: "5px solid black",
			left: "auto",
			marginBottom: "-11000px"
		} )[ 0 ];

	assert.equal(
		( new jQuery.fx( div, {}, "color" ) ).cur(),
		jQuery.css( div, "color" ),
		"Return the same value as jQuery.css for complex properties (bug #7912)"
	);

	assert.strictEqual(
		( new jQuery.fx( div, {}, "borderLeftWidth" ) ).cur(),
diff --git a/a.js b/b.js
@@ -869,7 +846,7 @@ QUnit.test( "jQuery.fx.prototype.cur() - <1.8 Back Compat", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible again" );
} );

QUnit.test( "jQuery.fx.prototype.cur() - <1.8 Back Compat", function( assert ) {
	assert.expect( 7 );

	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).css( {
			color: "#ABC",
			border: "5px solid black",
			left: "auto",
			marginBottom: "-11000px"
		} )[ 0 ];

	assert.equal(
		( new jQuery.fx( div, {}, "color" ) ).cur(),
		jQuery.css( div, "color" ),
		"Return the same value as jQuery.css for complex properties (bug #7912)"
	);

	assert.strictEqual(
		( new jQuery.fx( div, {}, "borderLeftWidth" ) ).cur(),
		5,
		"Return simple values parsed as Float"
	);

	// backgroundPosition actually returns 0% 0% in most browser
	// this fakes a "" return
	// hook now gets called twice because Tween will grab the current
	// value as it is being newed
	jQuery.cssHooks.backgroundPosition = {
		get: function() {
			assert.ok( true, "hook used" );
			return "";
		}
	};

	assert.strictEqual(
		( new jQuery.fx( div, {}, "backgroundPosition" ) ).cur(),
		0,
		"Return 0 when jQuery.css returns an empty string"
	);

	delete jQuery.cssHooks.backgroundPosition;

	assert.strictEqual(
		( new jQuery.fx( div, {}, "left" ) ).cur(),
		0,
		"Return 0 when jQuery.css returns 'auto'"
	);

	assert.equal(
		( new jQuery.fx( div, {}, "marginBottom" ) ).cur(),
		-11000,
		"support negative values < -10000 (bug #7193)"
	);

	jQuery( div ).remove();
} );
diff --git a/a.js b/b.js
@@ -894,7 +871,7 @@ QUnit.test( "Overflow and Display", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	);

	jQuery( div ).remove();
} );

QUnit.test( "Overflow and Display", function( assert ) {
	assert.expect( 4 );

	var
		testClass = jQuery.makeTest( "Overflow and Display" )
			.addClass( "overflow inline" ),
		testStyle = jQuery.makeTest( "Overflow and Display (inline style)" )
			.css( { overflow: "visible", display: "inline" } ),
		done = function() {
			assert.equal( jQuery.css( this, "overflow" ), "visible", "Overflow should be 'visible'" );
			assert.equal( jQuery.css( this, "display" ), "inline", "Display should be 'inline'" );
		};

	testClass.add( testStyle )
		.addClass( "widewidth" )
		.text( "Some sample text." )
		.before( "text before" )
		.after( "text after" )
		.animate( { opacity: 0.5 }, "slow", done );
	this.clock.tick( 600 );
} );

jQuery.each( {
	"CSS Auto": function( elem, prop ) {
diff --git a/a.js b/b.js
@@ -985,7 +962,7 @@ QUnit.test( fn + " to " + tn, function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		"0": function( elem ) {
			jQuery( elem ).addClass( "noback" );
			return 0;
		}
	}, function( tn, t ) {
		QUnit.test( fn + " to " + tn, function( assert ) {
			var num, anim,
				elem = jQuery.makeTest( fn + " to " + tn ),
				t_w = t( elem, "width" ),
				f_w = f( elem, "width" ),
				t_h = t( elem, "height" ),
				f_h = f( elem, "height" ),
				t_o = t( elem, "opacity" ),
				f_o = f( elem, "opacity" );

			if ( f_o === "" ) {
				f_o = 1;
			}

			num = 0;

			// TODO: uncrowd this
			if ( t_h === "show" ) { num++; }
			if ( t_w === "show" ) { num++; }
			if ( t_w === "hide" || t_w === "show" ) { num++; }
			if ( t_h === "hide" || t_h === "show" ) { num++; }
			if ( t_o === "hide" || t_o === "show" ) { num++; }
			if ( t_w === "hide" ) { num++; }
			if ( t_o.constructor === Number ) { num += 2; }
			if ( t_w.constructor === Number ) { num += 2; }
			if ( t_h.constructor === Number ) { num += 2; }

			assert.expect( num );

			anim = { width: t_w, height: t_h, opacity: t_o };

			elem.animate( anim, 50 );

			jQuery.when( elem ).done( function( $elem ) {
				var cur_o, cur_w, cur_h, old_h,
					elem = $elem[ 0 ];
diff --git a/a.js b/b.js
@@ -1055,7 +1032,7 @@ QUnit.test( fn + " to " + tn, function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		"0": function( elem ) {
			jQuery( elem ).addClass( "noback" );
			return 0;
		}
	}, function( tn, t ) {
		QUnit.test( fn + " to " + tn, function( assert ) {
			var num, anim,
				elem = jQuery.makeTest( fn + " to " + tn ),
				t_w = t( elem, "width" ),
				f_w = f( elem, "width" ),
				t_h = t( elem, "height" ),
				f_h = f( elem, "height" ),
				t_o = t( elem, "opacity" ),
				f_o = f( elem, "opacity" );

			if ( f_o === "" ) {
				f_o = 1;
			}

			num = 0;

			// TODO: uncrowd this
			if ( t_h === "show" ) { num++; }
			if ( t_w === "show" ) { num++; }
			if ( t_w === "hide" || t_w === "show" ) { num++; }
			if ( t_h === "hide" || t_h === "show" ) { num++; }
			if ( t_o === "hide" || t_o === "show" ) { num++; }
			if ( t_w === "hide" ) { num++; }
			if ( t_o.constructor === Number ) { num += 2; }
			if ( t_w.constructor === Number ) { num += 2; }
			if ( t_h.constructor === Number ) { num += 2; }

			assert.expect( num );

			anim = { width: t_w, height: t_h, opacity: t_o };

			elem.animate( anim, 50 );

			jQuery.when( elem ).done( function( $elem ) {
				var cur_o, cur_w, cur_h, old_h,
					elem = $elem[ 0 ];

				if ( t_w === "show" ) {
					assert.equal( $elem.css( "display" ), "block",
						"Showing, display should block: " + elem.style.display );
				}

				if ( t_w === "hide" || t_w === "show" ) {
					assert.ok( f_w === "" ? elem.style.width === f_w : elem.style.width.indexOf( f_w ) === 0, "Width must be reset to " + f_w + ": " + elem.style.width );
				}

				if ( t_h === "hide" || t_h === "show" ) {
					assert.ok( f_h === "" ? elem.style.height === f_h : elem.style.height.indexOf( f_h ) === 0, "Height must be reset to " + f_h + ": " + elem.style.height );
				}

				cur_o = jQuery.style( elem, "opacity" );

				if ( f_o !== jQuery.css( elem, "opacity" ) ) {
					f_o = f( elem, "opacity" );
				}

				if ( t_o === "hide" || t_o === "show" ) {
					assert.equal( cur_o, f_o, "Opacity must be reset to " + f_o + ": " + cur_o );
				}

				if ( t_w === "hide" ) {
					assert.equal( elem.style.display, "none", "Hiding, display should be none: " + elem.style.display );
				}

				if ( t_o.constructor === Number ) {
					assert.equal( cur_o, t_o, "Final opacity should be " + t_o + ": " + cur_o );

					assert.ok( jQuery.css( elem, "opacity" ) !== "" || cur_o === t_o, "Opacity should be explicitly set to " + t_o + ", is instead: " + cur_o );
				}

				if ( t_w.constructor === Number ) {
					assert.equal( elem.style.width, t_w + "px", "Final width should be " + t_w + ": " + elem.style.width );

					cur_w = jQuery.css( elem, "width" );

					assert.ok( elem.style.width !== "" || cur_w === t_w, "Width should be explicitly set to " + t_w + ", is instead: " + cur_w );
				}

				if ( t_h.constructor === Number ) {
					assert.equal( elem.style.height, t_h + "px", "Final height should be " + t_h + ": " + elem.style.height );

					cur_h = jQuery.css( elem, "height" );

					assert.ok( elem.style.height !== "" || cur_h === t_h, "Height should be explicitly set to " + t_h + ", is instead: " + cur_h );
				}

				if ( t_h === "show" ) {
					old_h = jQuery.css( elem, "height" );
					jQuery( elem ).append( "<br/>Some more text<br/>and some more..." );

					if ( /Auto/.test( fn ) ) {
						assert.notEqual( jQuery.css( elem, "height" ), old_h, "Make sure height is auto." );
					} else {
						assert.equal( jQuery.css( elem, "height" ), old_h, "Make sure height is not auto." );
					}
				}

				// manually remove generated element
				jQuery( elem ).remove();

			} );
			this.clock.tick( 100 );
		} );
	} );
} );

diff --git a/a.js b/b.js
@@ -1103,7 +1080,7 @@ 		getProps = function( el ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

			assert.deepEqual( getProps( this ), data, name );

			jQuery.removeData( this );
		},
		getProps = function( el ) {
			var obj = {};
			jQuery.each( props, function( i, prop ) {
				obj[ prop ] = prop === "overflow" && el.style[ prop ] || jQuery.css( el, prop );
			} );
			return obj;
		};

	assert.expect( remaining );

	setup( ".fadeOut().fadeIn()", "#fadein div" ).fadeOut( "fast" ).fadeIn( "fast", check );
	setup( ".fadeIn().fadeOut()", "#fadeout div" ).fadeIn( "fast" ).fadeOut( "fast", check );
	setup( ".hide().show()", "#show div" ).hide( "fast" ).show( "fast", check );
	setup( ".show().hide()", "#hide div" ).show( "fast" ).hide( "fast", check );
	setup( ".show().hide(easing)", "#easehide div" ).show( "fast" ).hide( "fast", "linear", check );
	setup( ".toggle().toggle() - in", "#togglein div" ).toggle( "fast" ).toggle( "fast", check );
	setup( ".toggle().toggle() - out", "#toggleout div" ).toggle( "fast" ).toggle( "fast", check );
	setup( ".toggle().toggle(easing) - out", "#easetoggleout div" ).toggle( "fast" ).toggle( "fast", "linear", check );
	setup( ".slideDown().slideUp()", "#slidedown div" ).slideDown( "fast" ).slideUp( "fast", check );
	setup( ".slideUp().slideDown()", "#slideup div" ).slideUp( "fast" ).slideDown( "fast", check );
	setup( ".slideUp().slideDown(easing)", "#easeslideup div" ).slideUp( "fast" ).slideDown( "fast", "linear", check );
	setup( ".slideToggle().slideToggle() - in", "#slidetogglein div" ).slideToggle( "fast" ).slideToggle( "fast", check );
	setup( ".slideToggle().slideToggle() - out", "#slidetoggleout div" ).slideToggle( "fast" ).slideToggle( "fast", check );
	setup( ".fadeToggle().fadeToggle() - in", "#fadetogglein div" ).fadeToggle( "fast" ).fadeToggle( "fast", check );
	setup( ".fadeToggle().fadeToggle() - out", "#fadetoggleout div" ).fadeToggle( "fast" ).fadeToggle( "fast", check );
	setup( ".fadeTo(0.5).fadeTo(1.0, easing)", "#fadeto div" ).fadeTo( "fast", 0.5 ).fadeTo( "fast", 1.0, "linear", check );

    this.clock.tick( 400 );
} );

jQuery.makeTest = function( text ) {
        var elem = jQuery( "<div></div>" )
diff --git a/a.js b/b.js
@@ -1121,7 +1098,7 @@ jQuery.makeTest = function( text ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	setup( ".fadeTo(0.5).fadeTo(1.0, easing)", "#fadeto div" ).fadeTo( "fast", 0.5 ).fadeTo( "fast", 1.0, "linear", check );

    this.clock.tick( 400 );
} );

jQuery.makeTest = function( text ) {
        var elem = jQuery( "<div></div>" )
                .attr( "id", "test" + jQuery.makeTest.id++ )
                .addClass( "box" );

        jQuery( "<h4></h4>" )
                .text( text )
                .appendTo( "#fx-tests" )
                .after( elem );

        return elem;
};

jQuery.makeTest.id = 1;

QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	$checkedtest.hide().show( "fast", function() {
diff --git a/a.js b/b.js
@@ -1131,15 +1108,14 @@ QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug #1095)", funct
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
        return elem;
};

jQuery.makeTest.id = 1;

QUnit.test( "jQuery.show('fast') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	$checkedtest.hide().show( "fast", function() {
		assert.ok( jQuery( "input[type='radio']", $checkedtest ).first().attr( "checked" ), "Check first radio still checked." );
		assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
		assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
		assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
	} );
	this.clock.tick( 200 );
} );

QUnit.test( "interrupt toggle", function( assert ) {
	assert.expect( 24 );

	var env = this,
		longDuration = 2000,
		shortDuration = 500,
		remaining = 0,
		$elems = jQuery( ".chain-test" ),
		clock = this.clock,
		finish = function() {
diff --git a/a.js b/b.js
@@ -1222,7 +1198,7 @@ 	jQuery.easing._defaultTest = function( p ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery.easing._test2 = function( p ) {
		test2Called = true;
		return p;
	};

	jQuery.easing._defaultTest = function( p ) {
		defaultTestCalled = true;
		return p;
	};

	jQuery( data ).animate( props, 400, "_defaultTest", function() {
		assert.ok( test1Called, "Easing function (_test1) called" );
		assert.ok( test2Called, "Easing function (_test2) called" );
		assert.ok( defaultTestCalled, "Easing function (_default) called" );
		assert.equal( props.a[ 1 ], "_test1", "animate does not change original props (per-property easing would be lost)" );
diff --git a/a.js b/b.js
@@ -1230,7 +1206,7 @@ jQuery( data ).animate( props, 400, "_defaultTest", function() {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	jQuery.easing._defaultTest = function( p ) {
		defaultTestCalled = true;
		return p;
	};

	jQuery( data ).animate( props, 400, "_defaultTest", function() {
		assert.ok( test1Called, "Easing function (_test1) called" );
		assert.ok( test2Called, "Easing function (_test2) called" );
		assert.ok( defaultTestCalled, "Easing function (_default) called" );
		assert.equal( props.a[ 1 ], "_test1", "animate does not change original props (per-property easing would be lost)" );
		assert.equal( props.b[ 1 ], "_test2", "animate does not change original props (per-property easing would be lost)" );
	} );

	this.clock.tick( 400 );
} );

QUnit.test( "animate with CSS shorthand properties", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -1256,7 +1232,8 @@ 	jQuery.easing.propertyScope = function( p ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
			easeAnimation_count++;
		}
		return p;
	};

	jQuery.easing.propertyScope = function( p ) {
		if ( p >= 1 ) {
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
diff --git a/a.js b/b.js
@@ -1264,7 +1241,8 @@ jQuery( "#foo" )
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
			assert.equal( easeAnimation_count, 4, "per-animation default easing called for each property" );
			easeAnimation_count = 0;
		} )
		.animate( propsSpecial, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "1px", "padding-top was animated again" );
			assert.equal( this.style.paddingLeft, "2px", "padding-left was animated again" );
			assert.equal( this.style.paddingRight, "2px", "padding-right was animated again" );
			assert.equal( this.style.paddingBottom, "3px", "padding-bottom was animated again" );
diff --git a/a.js b/b.js
@@ -1276,10 +1254,10 @@ jQuery( "#foo" )
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
			easeProperty_count++;
		}
		return p;
	};

	jQuery( "#foo" )
		.animate( propsBasic, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "10px", "padding-top was animated" );
			assert.equal( this.style.paddingLeft, "20px", "padding-left was animated" );
			assert.equal( this.style.paddingRight, "20px", "padding-right was animated" );
			assert.equal( this.style.paddingBottom, "30px", "padding-bottom was animated" );
			assert.equal( easeAnimation_count, 4, "per-animation default easing called for each property" );
			easeAnimation_count = 0;
		} )
		.animate( propsSpecial, 200, "animationScope", function() {
			assert.equal( this.style.paddingTop, "1px", "padding-top was animated again" );
			assert.equal( this.style.paddingLeft, "2px", "padding-left was animated again" );
			assert.equal( this.style.paddingRight, "2px", "padding-right was animated again" );
			assert.equal( this.style.paddingBottom, "3px", "padding-bottom was animated again" );
			assert.equal( easeAnimation_count, 0, "per-animation default easing not called" );
			assert.equal( easeProperty_count, 4, "special easing called for each property" );

			jQuery( this ).css( "padding", "0" );
			delete jQuery.easing.animationScope;
			delete jQuery.easing.propertyScope;
		} );
		this.clock.tick( 400 );
} );

QUnit.test( "hide hidden elements, with animation (bug #7141)", function( assert ) {
	assert.expect( 4 );

	var div = jQuery( "<div id='bug7141' style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is initially hidden" );
diff --git a/a.js b/b.js
@@ -1294,7 +1272,7 @@ QUnit.test( "hide hidden elements, with animation (bug #7141)", function( assert
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
			delete jQuery.easing.propertyScope;
		} );
		this.clock.tick( 400 );
} );

QUnit.test( "hide hidden elements, with animation (bug #7141)", function( assert ) {
	assert.expect( 4 );

	var div = jQuery( "<div id='bug7141' style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is initially hidden" );
	div.hide( 10, function() {
		assert.equal( div.css( "display" ), "none", "Element is hidden in .hide() callback" );
		div.show( 11, function() {
			assert.equal( div.css( "display" ), "block", "Element is visible in .show() callback" );
		} );
	} );
	this.clock.tick( 50 );
	assert.equal( div.css( "display" ), "block", "Element is visible after animations" );
} );

QUnit.test( "animate unit-less properties (#4966)", function( assert ) {
	assert.expect( 2 );

	var div = jQuery( "<div style='z-index: 0; position: absolute;'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "z-index" ), "0", "z-index is 0" );
diff --git a/a.js b/b.js
@@ -1302,10 +1280,10 @@ QUnit.test( "animate unit-less properties (#4966)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );
	this.clock.tick( 50 );
	assert.equal( div.css( "display" ), "block", "Element is visible after animations" );
} );

QUnit.test( "animate unit-less properties (#4966)", function( assert ) {
	assert.expect( 2 );

	var div = jQuery( "<div style='z-index: 0; position: absolute;'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "z-index" ), "0", "z-index is 0" );
	div.animate( { zIndex: 2 }, function() {
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (#9074)", function( assert ) {
	assert.expect( 6 );

	var ml, l,
		div = jQuery( "<div style='position: absolute; margin-left: 0; left: 0px;'></div>" )
diff --git a/a.js b/b.js
@@ -1320,9 +1298,9 @@ QUnit.test( "animate properties missing px w/ opacity as last (#9074)", function
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (#9074)", function( assert ) {
	assert.expect( 6 );

	var ml, l,
		div = jQuery( "<div style='position: absolute; margin-left: 0; left: 0px;'></div>" )
		.appendTo( "#qunit-fixture" );
	function cssInt( prop ) {
		return parseInt( div.css( prop ), 10 );
	}
	assert.equal( cssInt( "marginLeft" ), 0, "Margin left is 0" );
	assert.equal( cssInt( "left" ), 0, "Left is 0" );
	div.animate( {
		left: 200,
		marginLeft: 200,
		opacity: 0
	}, 2000 );

	this.clock.tick( 500 );

	ml = cssInt( "marginLeft" );
	l = cssInt( "left" );
	assert.notEqual( ml, 0, "Margin left is not 0 after partial animate" );
diff --git a/a.js b/b.js
@@ -1333,7 +1311,7 @@ QUnit.test( "animate properties missing px w/ opacity as last (#9074)", function
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( div.css( "z-index" ), "2", "z-index is 2" );
	} );
	this.clock.tick( 400 );
} );

QUnit.test( "animate properties missing px w/ opacity as last (#9074)", function( assert ) {
	assert.expect( 6 );

	var ml, l,
		div = jQuery( "<div style='position: absolute; margin-left: 0; left: 0px;'></div>" )
		.appendTo( "#qunit-fixture" );
	function cssInt( prop ) {
		return parseInt( div.css( prop ), 10 );
	}
	assert.equal( cssInt( "marginLeft" ), 0, "Margin left is 0" );
	assert.equal( cssInt( "left" ), 0, "Left is 0" );
	div.animate( {
		left: 200,
		marginLeft: 200,
		opacity: 0
	}, 2000 );

	this.clock.tick( 500 );

	ml = cssInt( "marginLeft" );
	l = cssInt( "left" );
	assert.notEqual( ml, 0, "Margin left is not 0 after partial animate" );
	assert.notEqual( ml, 200, "Margin left is not 200 after partial animate" );
	assert.notEqual( l, 0, "Left is not 0 after partial animate" );
	assert.notEqual( l, 200, "Left is not 200 after partial animate" );
	div.stop().remove();
} );

QUnit.test( "callbacks should fire in correct order (#9100)", function( assert ) {
	assert.expect( 1 );

	var a = 1,
		cb = 0;
diff --git a/a.js b/b.js
@@ -1342,17 +1320,17 @@ QUnit.test( "callbacks should fire in correct order (#9100)", function( assert )
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.notEqual( l, 0, "Left is not 0 after partial animate" );
	assert.notEqual( l, 200, "Left is not 200 after partial animate" );
	div.stop().remove();
} );

QUnit.test( "callbacks should fire in correct order (#9100)", function( assert ) {
	assert.expect( 1 );

	var a = 1,
		cb = 0;

	jQuery( "<p data-operation='*2'></p><p data-operation='^2'></p>" ).appendTo( "#qunit-fixture" )

		// The test will always pass if no properties are animated or if the duration is 0
		.animate( { fontSize: 12 }, 13, function() {
			a *= jQuery( this ).data( "operation" ) === "*2" ? 2 : a;
			cb++;
			if ( cb === 2 ) {
				assert.equal( a, 4, "test value has been *2 and _then_ ^2" );
			}
		} );
	this.clock.tick( 20 );
} );

QUnit.test( "callbacks that throw exceptions will be removed (#5684)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );

diff --git a/a.js b/b.js
@@ -1405,7 +1383,7 @@ QUnit.test( "animate will scale margin properties individually", function( asser
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	assert.ok( true, "Test completed without throwing a second exception" );

} );

QUnit.test( "animate will scale margin properties individually", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" ).css( {
		"margin": 0,
		"marginLeft": 100
	} );

	assert.ok( foo.css( "marginLeft" ) !== foo.css( "marginRight" ), "Sanity Check" );

	foo.animate( {
		"margin": 200
	} ).stop();

	assert.ok( foo.css( "marginLeft" ) !== foo.css( "marginRight" ), "The margin properties are different" );

	// clean up for next test
	foo.css( {
		"marginLeft": "",
		"marginRight": "",
		"marginTop": "",
		"marginBottom": ""
	} );
} );

QUnit.test( "Do not append px to 'fill-opacity' #9548", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -1416,13 +1394,13 @@ QUnit.test( "Do not append px to 'fill-opacity' #9548", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		"marginTop": "",
		"marginBottom": ""
	} );
} );

QUnit.test( "Do not append px to 'fill-opacity' #9548", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );

	$div.css( "fill-opacity", 0 ).animate( { "fill-opacity": 1.0 }, 0, function() {
		assert.equal( jQuery( this ).css( "fill-opacity" ), 1, "Do not append px to 'fill-opacity'" );
		$div.remove();
	} );
} );

QUnit.test( "line-height animates correctly (#13855)", function( assert ) {
	assert.expect( 12 );

	var t0,
		clock = this.clock,
		longDuration = 2000,
		shortDuration = 500,
		animated = jQuery(
			"<p style='line-height: 100;'>unitless</p>" +
			"<p style='line-height: 5000px;'>px</p>" +
			"<p style='line-height: 5000%;'>percent</p>" +
diff --git a/a.js b/b.js
@@ -1472,11 +1450,11 @@ setTimeout( function() {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

			t0 = +( new Date() );
			animated.stop( true, true ).hide()
					.animate( { "line-height": "show" }, longDuration, "linear" );

			setTimeout( function() {
				var progress = ( ( new Date() ) - t0 ) / longDuration;

				animated.each( function( i ) {
					var label = jQuery.text( this ),
						initial = initialHeight[ i ],
						height = jQuery( this ).height(),
						upper = initial * progress * tolerance;
					assert.ok( height < upper, "show " + label + ": upper bound; " +
						height + " < " + upper + " @ " + ( progress * 100 ) + "%" );
				} );

				animated.stop( true, true );
			}, shortDuration );
clock.tick( shortDuration );
		}, shortDuration );
clock.tick( shortDuration );
	}, 50 );
clock.tick( 50 );
} );

// Start 1.8 Animation tests
QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
diff --git a/a.js b/b.js
@@ -1504,7 +1482,7 @@ QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	}, 50 );
clock.tick( 50 );
} );

// Start 1.8 Animation tests
QUnit.test( "jQuery.Animation( object, props, opts )", function( assert ) {
	assert.expect( 4 );

	var animation,
		testObject = {
			"foo": 0,
			"bar": 1,
			"width": 100
		},
		testDest = {
			"foo": 1,
			"bar": 0,
			"width": 200
		};

	animation = jQuery.Animation( testObject, testDest, { "duration": 1 } );
	animation.done( function() {
		for ( var prop in testDest ) {
			assert.equal( testObject[ prop ], testDest[ prop ], "Animated: " + prop );
		}
		animation.done( function() {
			assert.deepEqual( testObject, testDest, "No unexpected properties" );
		} );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate Option: step: function( percent, tween )", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1532,7 +1510,7 @@ jQuery( "#foo" ).animate( {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

QUnit.test( "Animate Option: step: function( percent, tween )", function( assert ) {
	assert.expect( 1 );

	var counter = {};
	jQuery( "#foo" ).animate( {
		prop1: 1,
		prop2: 2,
		prop3: 3
	}, {
		duration: 1,
		step: function( value, tween ) {
			var calls = counter[ tween.prop ] = counter[ tween.prop ] || [];

			// in case this is called multiple times for either, lets store it in
			// 0 or 1 in the array
			calls[ value === 0 ? 0 : 1 ] = value;
		}
	} ).queue( function( next ) {
		assert.deepEqual( counter, {
			prop1: [ 0, 1 ],
			prop2: [ 0, 2 ],
			prop3: [ 0, 3 ]
		}, "Step function was called once at 0% and once at 100% for each property" );
		next();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate callbacks have correct context", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1541,18 +1519,18 @@ QUnit.test( "Animate callbacks have correct context", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		next();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animate callbacks have correct context", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	foo.animate( {
		height: 10
	}, 10, function() {
		assert.equal( foo[ 0 ], this, "Complete callback after stop(true) `this` is element" );
	} ).stop( true, true );
	foo.animate( {
		height: 100
	}, 10, function() {
		assert.equal( foo[ 0 ], this, "Complete callback `this` is element" );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "User supplied callback called after show when fx off (#8892)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	jQuery.fx.off = true;
diff --git a/a.js b/b.js
@@ -1571,8 +1549,7 @@ QUnit.test( "User supplied callback called after show when fx off (#8892)", func
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.equal( foo[ 0 ], this, "Complete callback `this` is element" );
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "User supplied callback called after show when fx off (#8892)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" );
	jQuery.fx.off = true;
	foo.hide();
	foo.fadeIn( 500, function() {
		assert.ok( supportjQuery( this ).is( ":visible" ), "Element is visible in callback" );
		foo.fadeOut( 500, function() {
			assert.ok( supportjQuery( this ).is( ":hidden" ), "Element is hidden in callback" );
			jQuery.fx.off = false;
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
diff --git a/a.js b/b.js
@@ -1625,23 +1602,23 @@ QUnit.test( "animate should set display for disconnected nodes", function( asser
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
			animate: [ { width: "show" } ]
		},
		toggleMethods = {
			toggle: [ 1 ],
			slideToggle: []
		},
		$divEmpty = jQuery( "<div></div>" ),
		$divTest = jQuery( "<div>test</div>" ),
		$divNone = jQuery( "<div style='display: none;'></div>" ),
		$divInline = jQuery( "<div style='display: inline;'></div>" ),
		nullParentDisplay = $divEmpty.css( "display" ),
		underFragmentDisplay = $divTest.css( "display" ),
		clock = this.clock;

	assert.strictEqual( $divEmpty[ 0 ].parentNode, null, "Setup: element with null parentNode" );
	assert.strictEqual( ( $divTest[ 0 ].parentNode || {} ).nodeType, 11, "Setup: element under fragment" );

	assert.strictEqual( $divEmpty.show()[ 0 ].style.display, "",
		"set display with show() for element with null parentNode" );
	assert.strictEqual( $divTest.show()[ 0 ].style.display, "",
		"set display with show() for element under fragment" );
	assert.strictEqual( $divNone.show()[ 0 ].style.display, "",
		"show() should change display if it already set to none" );
	assert.strictEqual( $divInline.show()[ 0 ].style.display, "inline",
		"show() should not change display if it already set" );

	jQuery.each( showMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), nullParentDisplay,
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), underFragmentDisplay,
				"." + name + " block under fragment" );
		} ] ) );
	} );
	jQuery.each( toggleMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block under fragment" );
		} ] ) );
	} );
	clock.tick( 400 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Animation callback should not show animated element as :animated (#7157)", function( assert ) {
	assert.expect( 1 );

	var foo = jQuery( "#foo" );

	foo.animate( {
		opacity: 0
	}, 100, function() {
		assert.ok( !foo.is( ":animated" ), "The element is not animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Initial step callback should show element as :animated (#14623)", function( assert ) {
	assert.expect( 1 );

	var foo = jQuery( "#foo" );

diff --git a/a.js b/b.js
@@ -1658,7 +1635,7 @@ QUnit.test( "animate should set display for disconnected nodes", function( asser
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		} );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate should set display for disconnected nodes", function( assert ) {
	assert.expect( 20 );

	var env = this,
		showMethods = {
			fadeIn: [],
			fadeTo: [ "fast", 0.5 ],
			slideDown: [ "fast" ],
			show: [ 1 ],
			animate: [ { width: "show" } ]
		},
		toggleMethods = {
			toggle: [ 1 ],
			slideToggle: []
		},
		$divEmpty = jQuery( "<div></div>" ),
		$divTest = jQuery( "<div>test</div>" ),
		$divNone = jQuery( "<div style='display: none;'></div>" ),
		$divInline = jQuery( "<div style='display: inline;'></div>" ),
		nullParentDisplay = $divEmpty.css( "display" ),
		underFragmentDisplay = $divTest.css( "display" ),
		clock = this.clock;

	assert.strictEqual( $divEmpty[ 0 ].parentNode, null, "Setup: element with null parentNode" );
	assert.strictEqual( ( $divTest[ 0 ].parentNode || {} ).nodeType, 11, "Setup: element under fragment" );

	assert.strictEqual( $divEmpty.show()[ 0 ].style.display, "",
		"set display with show() for element with null parentNode" );
	assert.strictEqual( $divTest.show()[ 0 ].style.display, "",
		"set display with show() for element under fragment" );
	assert.strictEqual( $divNone.show()[ 0 ].style.display, "",
		"show() should change display if it already set to none" );
	assert.strictEqual( $divInline.show()[ 0 ].style.display, "inline",
		"show() should not change display if it already set" );

	jQuery.each( showMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), nullParentDisplay,
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), underFragmentDisplay,
				"." + name + " block under fragment" );
		} ] ) );
	} );
	jQuery.each( toggleMethods, function( name, opt ) {
		jQuery.fn[ name ].apply( jQuery( "<div></div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block with null parentNode" );
		} ] ) );

		jQuery.fn[ name ].apply( jQuery( "<div>test</div>" ), opt.concat( [ function() {
			assert.strictEqual( jQuery( this ).css( "display" ), "none",
				"." + name + " block under fragment" );
		} ] ) );
	} );
	clock.tick( 400 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Animation callback should not show animated element as :animated (#7157)", function( assert ) {
	assert.expect( 1 );

	var foo = jQuery( "#foo" );

	foo.animate( {
		opacity: 0
	}, 100, function() {
		assert.ok( !foo.is( ":animated" ), "The element is not animated" );
	} );
	this.clock.tick( 100 );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "Initial step callback should show element as :animated (#14623)", function( assert ) {
	assert.expect( 1 );

	var foo = jQuery( "#foo" );

	foo.animate( {
		opacity: 0
	}, {
		duration: 100,
		step: function() {
			assert.ok( foo.is( ":animated" ), "The element matches :animated inside step function" );
		}
	} );
	this.clock.tick( 1 );
	foo.stop();
} );

QUnit.test( "hide called on element within hidden parent should set display to none (#10045)", function( assert ) {
	assert.expect( 3 );

	var hidden = jQuery( ".hidden" ),
		elems = jQuery( "<div>hide</div><div>hide0</div><div>hide1</div>" );
diff --git a/a.js b/b.js
@@ -1677,7 +1654,7 @@ QUnit.test( "hide called on element within hidden parent should set display to n
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );
	this.clock.tick( 1 );
	foo.stop();
} );

QUnit.test( "hide called on element within hidden parent should set display to none (#10045)", function( assert ) {
	assert.expect( 3 );

	var hidden = jQuery( ".hidden" ),
		elems = jQuery( "<div>hide</div><div>hide0</div><div>hide1</div>" );

	hidden.append( elems );

	jQuery.when(
		elems.eq( 0 ).hide(),
		elems.eq( 1 ).hide( 0 ),
		elems.eq( 2 ).hide( 1 )
	).done( function() {
		assert.strictEqual( elems.get( 0 ).style.display, "none", "hide() called on element within hidden parent should set display to none" );
		assert.strictEqual( elems.get( 1 ).style.display, "none", "hide( 0 ) called on element within hidden parent should set display to none" );
		assert.strictEqual( elems.get( 2 ).style.display, "none", "hide( 1 ) called on element within hidden parent should set display to none" );

		elems.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "hide, fadeOut and slideUp called on element width height and width = 0 should set display to none", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -1708,10 +1685,10 @@ QUnit.test( "hide, fadeOut and slideUp called on element width height and width
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		elems.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "hide, fadeOut and slideUp called on element width height and width = 0 should set display to none", function( assert ) {
	assert.expect( 5 );

	var foo = jQuery( "#foo" ),
		i = 0,
		elems = jQuery();

	for ( ; i < 5; i++ ) {
		elems = elems.add( "<div style='width:0;height:0;'></div>" );
	}

	foo.append( elems );

	jQuery.when(
		elems.eq( 0 ).hide(),
		elems.eq( 1 ).hide( jQuery.noop ),
		elems.eq( 2 ).hide( 1 ),
		elems.eq( 3 ).fadeOut(),
		elems.eq( 4 ).slideUp()
	).done( function() {
		assert.strictEqual( elems.get( 0 ).style.display, "none", "hide() called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 1 ).style.display, "none",
												"hide( jQuery.noop ) called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 2 ).style.display, "none", "hide( 1 ) called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 3 ).style.display, "none", "fadeOut() called on element width height and width = 0 should set display to none" );
		assert.strictEqual( elems.get( 4 ).style.display, "none", "slideUp() called on element width height and width = 0 should set display to none" );

	} );
	this.clock.tick( 400 );
} );

QUnit.test( "hide should not leave hidden inline elements visible (#14848)", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "#simon1" );

diff --git a/a.js b/b.js
@@ -1735,7 +1712,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
diff --git a/a.js b/b.js
@@ -1743,21 +1720,21 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
diff --git a/a.js b/b.js
@@ -1765,7 +1742,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
		} ).animate( {
			bottom: 10
		}, {
			duration: 10,
			queue: false,
			complete: function() {
				assert.ok( step > 7 && step < 10, "Step eight or nine" );
				step++;
diff --git a/a.js b/b.js
@@ -1776,7 +1753,7 @@ QUnit.test( "Handle queue:false promises", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} );

	this.clock.tick( 100 );
} );

QUnit.test( "Handle queue:false promises", function( assert ) {
	assert.expect( 10 );

	var foo = jQuery( "#foo" ).clone().addBack(),
		step = 1;

	foo.animate( {
		top: 1
	}, {
		duration: 10,
		queue: false,
		complete: function() {
			assert.ok( step++ <= 2, "Step one or two" );
		}
	} ).animate( {
		bottom: 1
	}, {
		duration: 10,
		complete: function() {
			assert.ok( step > 2 && step < 5, "Step three or four" );
			step++;
		}
	} );

	this.clock.tick( 10 );

	foo.promise().done( function() {
		assert.equal( step++, 5, "steps 1-5: queue:false then queue:fx done" );
		foo.animate( {
			top: 10
		}, {
			duration: 10,
			complete: function() {
				assert.ok( step > 5 && step < 8, "Step six or seven" );
				step++;
			}
		} ).animate( {
			bottom: 10
		}, {
			duration: 10,
			queue: false,
			complete: function() {
				assert.ok( step > 7 && step < 10, "Step eight or nine" );
				step++;
			}
		} ).promise().done( function() {
			assert.equal( step++, 10, "steps 6-10: queue:fx then queue:false" );
		} );

	} );
	this.clock.tick( 10 );
} );

QUnit.test( "multiple unqueued and promise", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -1811,10 +1788,10 @@ QUnit.test( "multiple unqueued and promise", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	} );
	this.clock.tick( 10 );
} );

QUnit.test( "multiple unqueued and promise", function( assert ) {
	assert.expect( 4 );

	var foo = jQuery( "#foo" ),
		step = 1;
	foo.animate( {
		marginLeft: 300
	}, {
		duration: 500,
		queue: false,
		complete: function() {
			assert.strictEqual( step++, 2, "Step 2" );
		}
	} ).animate( {
		top: 100
	}, {
		duration: 1000,
		queue: false,
		complete: function() {
			assert.strictEqual( step++, 3, "Step 3" );
		}
	} ).animate( {}, {
		duration: 2000,
		queue: false,
		complete: function() {

			// no properties is a non-op and finishes immediately
			assert.strictEqual( step++, 1, "Step 1" );
		}
	} ).promise().done( function() {
		assert.strictEqual( step++, 4, "Step 4" );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate does not change start value for non-px animation (#7109)", function( assert ) {
	assert.expect( 1 );

	var parent = jQuery( "<div><div></div></div>" ).css( { width: 284, height: 1 } ).appendTo( "#qunit-fixture" ),
		child = parent.children().css( { fontSize: "98.6in", width: "0.01em", height: 1 } ),
diff --git a/a.js b/b.js
@@ -1834,10 +1811,10 @@ QUnit.test( "animate does not change start value for non-px animation (#7109)",
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.strictEqual( step++, 4, "Step 4" );
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "animate does not change start value for non-px animation (#7109)", function( assert ) {
	assert.expect( 1 );

	var parent = jQuery( "<div><div></div></div>" ).css( { width: 284, height: 1 } ).appendTo( "#qunit-fixture" ),
		child = parent.children().css( { fontSize: "98.6in", width: "0.01em", height: 1 } ),
		actual = parseFloat( child.css( "width" ) ),
		computed = [];

	child.animate( { width: "0%" }, {
		duration: 1,
		step: function() {
			computed.push( parseFloat( child.css( "width" ) ) );
		}
	} ).queue( function( next ) {
		var ratio = computed[ 0 ] / actual;
		assert.ok( ratio > 0.9 && ratio < 1.1,
			"Starting width was close enough (" + computed[ 0 ] + " approximates " + actual + ")" );
		next();
		parent.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "non-px animation handles non-numeric start (#11971)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" ),
		initial = foo.css( "backgroundPositionX" );
diff --git a/a.js b/b.js
@@ -1866,10 +1843,10 @@ QUnit.test( "non-px animation handles non-numeric start (#11971)", function( ass
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		parent.remove();
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "non-px animation handles non-numeric start (#11971)", function( assert ) {
	assert.expect( 2 );

	var foo = jQuery( "#foo" ),
		initial = foo.css( "backgroundPositionX" );

	if ( !initial ) {
		assert.expect( 1 );
		assert.ok( true, "Style property not understood" );
		return;
	}

	foo.animate( { backgroundPositionX: "42%" }, {
		duration: 1,
		progress: function( anim, percent ) {
			if ( percent ) {
				return;
			}

			if ( parseFloat( initial ) ) {
				assert.equal( jQuery.style( this, "backgroundPositionX" ), initial, "Numeric start preserved" );
			} else {
				assert.equal( jQuery.style( this, "backgroundPositionX" ), "0%", "Non-numeric start zeroed" );
			}
		},
		done: function() {
			assert.equal( jQuery.style( this, "backgroundPositionX" ), "42%", "End reached" );
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks (#11797)", function( assert ) {
	assert.expect( 15 );

	var prog = 0,
		targets = jQuery( "#foo" ).children(),
diff --git a/a.js b/b.js
@@ -1946,10 +1923,10 @@ QUnit.test( "Animation callbacks (#11797)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks (#11797)", function( assert ) {
	assert.expect( 15 );

	var prog = 0,
		targets = jQuery( "#foo" ).children(),
		done = false,
		expectedProgress = 1;

	targets.eq( 0 ).animate( {}, {
		duration: 1,
		start: function() {
			assert.ok( true, "empty: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, prog, "empty: progress " + prog );
			prog = 1;
		},
		done: function() {
			assert.ok( true, "empty: done" );
		},
		fail: function() {
			assert.ok( false, "empty: fail" );
		},
		always: function() {
			assert.ok( true, "empty: always" );
			done = true;
		}
	} );

	assert.ok( done, "empty: done immediately" );

	done = false;
	targets.eq( 1 ).animate( {
		opacity: 0
	}, {
		duration: 1,
		start: function() {
			assert.ok( true, "stopped: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, 0, "stopped: progress 0" );
		},
		done: function() {
			assert.ok( false, "stopped: done" );
		},
		fail: function() {
			assert.ok( true, "stopped: fail" );
		},
		always: function() {
			assert.ok( true, "stopped: always" );
			done = true;
		}
	} ).stop();

	assert.ok( done, "stopped: stopped immediately" );

	targets.eq( 2 ).animate( {
		opacity: 0
	}, {
		duration: 1,
		start: function() {
			assert.ok( true, "async: start" );
		},
		progress: function( anim, percent ) {
			assert.equal( percent, expectedProgress, "async: progress " + expectedProgress );
			expectedProgress++;
		},
		done: function() {
			assert.ok( true, "async: done" );
		},
		fail: function() {
			assert.ok( false, "async: fail" );
		},
		always: function() {
			assert.ok( true, "async: always" );
		}
	} );
	this.clock.tick( 10 );
} );

QUnit.test( "Animation callbacks in order (#2292)", function( assert ) {
	assert.expect( 9 );

	var done = assert.async(),
		step = 0,
diff --git a/a.js b/b.js
@@ -1986,10 +1963,10 @@ jQuery( "#foo" ).animate( {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	var done = assert.async(),
		step = 0,
		dur = 50;

	jQuery( "#foo" ).animate( {
		width: "5px"
	}, {
		duration: dur,
		start: function() {
			assert.step( "start" );
		},
		progress: function( anim, p, ms ) {
			if ( !( step++ ) ) {
				assert.step( "progress" );
				assert.strictEqual( p, 0, "first progress callback: progress ratio" );
				assert.strictEqual( ms, dur, "first progress callback: remaining ms" );
			} else {
				assert.step( "last progress" );
				assert.strictEqual( p, 1, "last progress callback: progress ratio" );
				assert.strictEqual( ms, 0, "last progress callback: remaining ms" );
			}
		},
		done: function() {
			assert.step( "done" );
		},
		fail: function() {
			assert.ok( false, "Animation failed" );
		},
		always: function() {
			assert.verifySteps( [ "start", "progress", "last progress", "done" ] );
			done();
		}
	} ).finish();

	this.clock.tick( dur + 10 );
} );

QUnit.test( "Animate properly sets overflow hidden when animating width/height (#12117)", function( assert ) {
	assert.expect( 8 );

	jQuery.each( [ "height", "width" ], function( _, prop ) {
		jQuery.each( [ 100, 0 ], function( _, value ) {
diff --git a/a.js b/b.js
@@ -2007,7 +1984,7 @@ QUnit.test( "Animate properly sets overflow hidden when animating width/height (
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	} ).finish();

	this.clock.tick( dur + 10 );
} );

QUnit.test( "Animate properly sets overflow hidden when animating width/height (#12117)", function( assert ) {
	assert.expect( 8 );

	jQuery.each( [ "height", "width" ], function( _, prop ) {
		jQuery.each( [ 100, 0 ], function( _, value ) {
			var div = jQuery( "<div>" ).css( "overflow", "auto" ),
				props = {};
			props[ prop ] = value;
			div.animate( props, 1 );
			assert.equal( div.css( "overflow" ), "hidden",
				"overflow: hidden set when animating " + prop + " to " + value );
			div.stop();
			assert.equal( div.css( "overflow" ), "auto",
				"overflow: auto restored after animating " + prop + " to " + value );
		} );
	} );
} );

QUnit.test( "Each tick of the timer loop uses a fresh time (#12837)", function( assert ) {
	var lastVal,
		tmp = jQuery( {
			test: 0
		} );
diff --git a/a.js b/b.js
@@ -2032,7 +2009,7 @@ QUnit.test( "Each tick of the timer loop uses a fresh time (#12837)", function(
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
				"overflow: auto restored after animating " + prop + " to " + value );
		} );
	} );
} );

QUnit.test( "Each tick of the timer loop uses a fresh time (#12837)", function( assert ) {
	var lastVal,
		tmp = jQuery( {
			test: 0
		} );
	assert.expect( 3 );
	tmp.animate( {
		test: 100
	}, {
		step: function( p, fx ) {
			assert.ok( fx.now !== lastVal, "Current value is not the last value: " + lastVal + " - " + fx.now );
			lastVal = fx.now;
		}
	} );
	this.clock.tick( 1 );

	// now that we have a new time, run another tick
	jQuery.fx.tick();

	this.clock.tick( 1 );

	jQuery.fx.tick();
	tmp.stop();
} );

QUnit.test( "Animations with 0 duration don't ease (#12273)", function( assert ) {
	assert.expect( 1 );

	jQuery.easing.test = function() {
		assert.ok( false, "Called easing" );
diff --git a/a.js b/b.js
@@ -2057,7 +2034,7 @@ jQuery( "#foo" ).animate( {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	jQuery.easing.test = function() {
		assert.ok( false, "Called easing" );
	};

	jQuery( "#foo" ).animate( {
		height: 100
	}, {
		duration: 0,
		easing: "test",
		complete: function() {
			assert.equal( jQuery( this ).height(), 100, "Height is 100" );
		}
	} );

	delete jQuery.easing.test;
} );

jQuery.map( [ "toggle", "slideToggle", "fadeToggle" ], function( method ) {

	// this test would look a lot better if we were using something to override
	// the default timers
	var duration = 1500;
	QUnit.test( "toggle state tests: " + method + " (#8685)", function( assert ) {
		function secondToggle() {
			var stopped = parseFloat( element.css( check ) );
			tested = false;
			element[ method ]( {
diff --git a/a.js b/b.js
@@ -2096,8 +2073,8 @@ QUnit.test( "toggle state tests: " + method + " (#8685)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
jQuery.map( [ "toggle", "slideToggle", "fadeToggle" ], function( method ) {

	// this test would look a lot better if we were using something to override
	// the default timers
	var duration = 1500;
	QUnit.test( "toggle state tests: " + method + " (#8685)", function( assert ) {
		function secondToggle() {
			var stopped = parseFloat( element.css( check ) );
			tested = false;
			element[ method ]( {
				duration: duration,
				step: function( p, fx ) {
					if ( fx.pos > 0.1 && fx.prop === check && !tested ) {
						tested = true;
						assert.equal( fx.start, stopped, check + " starts at " + stopped + " where it stopped" );
						assert.equal( fx.end, original, check + " ending value is " + original );
						element.stop();
					}
				}
			} );
		}

		var tested,
			original,
			check = method === "slideToggle" ? "height" : "opacity",
			element = jQuery( "#foo" ).height( 200 );

		assert.expect( 4 );

		element[ method ]( {
			duration: duration,
			easing: "linear",
			step: function( p, fx ) {
				if ( fx.pos > 0.1 && fx.prop === check && !tested ) {
					tested = true;
					original = fx.start;
					assert.ok( fx.start !== 0, check + " is starting at " + original + " on first toggle (non-zero)" );
					assert.equal( fx.end, 0, check + " is ending at 0 on first toggle" );
					element.stop();
				}
			},
			always: secondToggle
		} );

                //FIXME figure out why 470
		this.clock.tick( 470 );
	} );
} );

QUnit.test( "jQuery.fx.start & jQuery.fx.stop hook points", function( assert ) {
diff --git a/a.js b/b.js
@@ -2286,12 +2263,15 @@ 	queueTester.finish = function() {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	var div = jQuery( "<div>" ),
		inside = 0,
		outside = 0;

	assert.expect( 6 );
	queueTester.finish = function() {
		outside++;
		assert.ok( true, "Finish called on custom queue function" );
	};

	div.queue( queueTester ).queue( queueTester ).queue( queueTester ).finish();

	assert.equal( inside, 1, "1 stop(true) callback" );
	assert.equal( outside, 2, "2 finish callbacks" );

	div.remove();
} );

QUnit.test( ".finish() is applied correctly when multiple elements were animated (#13937)", function( assert ) {
	assert.expect( 3 );

	var elems = jQuery( "<a>0</a><a>1</a><a>2</a>" );

	elems.animate( { opacity: 0 }, 1500 ).animate( { opacity: 1 }, 1500 );
	setTimeout( function() {
		elems.eq( 1 ).finish();
		assert.ok( !elems.eq( 1 ).queue().length, "empty queue for .finish()ed element" );
		assert.ok( elems.eq( 0 ).queue().length, "non-empty queue for preceding element" );
diff --git a/a.js b/b.js
@@ -2300,10 +2280,10 @@ setTimeout( function() {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.expect( 3 );

	var elems = jQuery( "<a>0</a><a>1</a><a>2</a>" );

	elems.animate( { opacity: 0 }, 1500 ).animate( { opacity: 1 }, 1500 );
	setTimeout( function() {
		elems.eq( 1 ).finish();
		assert.ok( !elems.eq( 1 ).queue().length, "empty queue for .finish()ed element" );
		assert.ok( elems.eq( 0 ).queue().length, "non-empty queue for preceding element" );
		assert.ok( elems.eq( 2 ).queue().length, "non-empty queue for following element" );
		elems.stop( true );

	}, 100 );
	this.clock.tick( 1500 );
} );

QUnit.test( "slideDown() after stop() (#13483)", function( assert ) {
		assert.expect( 2 );

		var ul = jQuery( "<ul style='height: 100px; display: block;'></ul>" )
				.appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -2312,31 +2292,31 @@ QUnit.test( "slideDown() after stop() (#13483)", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061

	}, 100 );
	this.clock.tick( 1500 );
} );

QUnit.test( "slideDown() after stop() (#13483)", function( assert ) {
		assert.expect( 2 );

		var ul = jQuery( "<ul style='height: 100px; display: block;'></ul>" )
				.appendTo( "#qunit-fixture" ),
			origHeight = ul.height(),
			clock = this.clock;

        // First test. slideUp() -> stop() in the middle -> slideDown() until the end
		ul.slideUp( 1000 );
		clock.tick( 500 );
		ul.stop( true );
		ul.slideDown( 1, function() {
				assert.equal( ul.height(), origHeight, "slideDown() after interrupting slideUp() with stop(). Height must be in original value" );

				// Second test. slideDown() -> stop() in the middle -> slideDown() until the end
				ul.slideUp( 1 );
				clock.tick( 10 );
				ul.slideDown( 1000 );
				clock.tick( 500 );
				ul.stop( true );
				ul.slideDown( 1 );
				assert.equal( ul.height(), origHeight, "slideDown() after interrupting slideDown() with stop(). Height must be in original value" );

				// Cleanup
				ul.remove();
				clock.tick( 10 );

		} );

		clock.tick( 10 );
} );

QUnit.test( "Respect display value on inline elements (#14824)", function( assert ) {
	assert.expect( 2 );

	var clock = this.clock,
		fromStyleSheet = jQuery( "<span id='span-14824'></span>" ),
diff --git a/a.js b/b.js
@@ -2359,7 +2339,7 @@ QUnit.test( "Respect display value on inline elements (#14824)", function( asser
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		} );

		clock.tick( 10 );
} );

QUnit.test( "Respect display value on inline elements (#14824)", function( assert ) {
	assert.expect( 2 );

	var clock = this.clock,
		fromStyleSheet = jQuery( "<span id='span-14824'></span>" ),
		fromStyleAttr = jQuery( "<span style='display: block;'></span>" );

	jQuery( "#qunit-fixture" ).append( fromStyleSheet, fromStyleAttr );

	fromStyleSheet.slideUp( function() {
		jQuery( this ).slideDown( function() {
			assert.equal( jQuery( this ).css( "display" ), "block",
				"Respect previous display value (from stylesheet) on span element" );
		} );
	} );

	fromStyleAttr.slideUp( function() {
		jQuery( this ).slideDown( function() {
			assert.equal( jQuery( this ).css( "display" ), "block",
				"Respect previous display value (from style attribute) on span element" );
		} );
	} );

	clock.tick( 800 );
} );

QUnit.test( "jQuery.easing._default (gh-2218)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -2383,7 +2363,7 @@ jQuery( "#foo" )
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
} );

QUnit.test( "jQuery.easing._default (gh-2218)", function( assert ) {
	assert.expect( 2 );

	jQuery( "#foo" )
		.animate( { width: "5px" }, {
			duration: 5,
			start: function( anim ) {
				assert.equal( anim.opts.easing, jQuery.easing._default,
					"anim.opts.easing should be equal to jQuery.easing._default when the easing argument is not given" );
			}
		} )
		.animate( { height: "5px" }, {
			duration: 5,
			easing: "linear",
			start: function( anim ) {
				assert.equal( anim.opts.easing, "linear",
					"anim.opts.easing should be equal to the easing argument" );
			}
		} )
		.stop();

	this.clock.tick( 25 );
} );

QUnit.test( "jQuery.easing._default in Animation (gh-2218", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -2411,7 +2391,7 @@ 	jQuery.easing.custom = function( p ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		defaultEasing = jQuery.easing._default,
		called = false,
		testObject = { "width": 100 },
		testDest = { "width": 200 };

	jQuery.easing.custom = function( p ) {
		called = true;
		return p;
	};
	jQuery.easing._default = "custom";

	animation = jQuery.Animation( testObject, testDest, { "duration": 1 } );
	animation.done( function() {
		assert.equal( testObject.width, testDest.width, "Animated width" );
		assert.ok( called, "Custom jQuery.easing._default called" );
		assert.strictEqual( animation.opts.easing, "custom",
			"Animation used custom jQuery.easing._default" );
		jQuery.easing._default = defaultEasing;
		delete jQuery.easing.custom;
	} );

	this.clock.tick( 10 );
} );

QUnit.test( "jQuery.easing._default in Tween (gh-2218)", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -2464,7 +2444,7 @@ QUnit.test( "Show/hide/toggle and display: inline", function( assert ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		div.remove();
	} );
	this.clock.tick( 1000 );
} );

QUnit.test( "Show/hide/toggle and display: inline", function( assert ) {
	assert.expect( 40 );

	var clock = this.clock;

	jQuery( "<span></span><div style='display:inline' title='inline div'></div>" ).each( function() {
		var completed, interrupted,
			N = 100,
			fixture = jQuery( "#qunit-fixture" ),
			$el = jQuery( this ),
			kind = this.title || this.nodeName.toLowerCase();

diff --git a/a.js b/b.js
@@ -2530,7 +2510,7 @@ function testEasing( assert, speed, easing, complete ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
				kind + " display is not inline-block after " + call + "+toggle" );
		} );
	} );
} );

function testEasing( assert, speed, easing, complete ) {
	assert.expect( 4 );
	var options = jQuery.speed( speed, easing, complete );

	assert.equal( options.duration, 10, "Duration set properly" );
	assert.equal(
		typeof options.easing === "function" ? options.easing() : options.easing,
		"linear",
		"Easing set properly"
diff --git a/a.js b/b.js
@@ -2541,7 +2521,7 @@ function testEasing( assert, speed, easing, complete ) {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
				kind + " display is not inline-block after " + call + "+toggle" );
		} );
	} );
} );

function testEasing( assert, speed, easing, complete ) {
	assert.expect( 4 );
	var options = jQuery.speed( speed, easing, complete );

	assert.equal( options.duration, 10, "Duration set properly" );
	assert.equal(
		typeof options.easing === "function" ? options.easing() : options.easing,
		"linear",
		"Easing set properly"
	);
	assert.equal( options.queue, "fx", "Queue defaults to fx" );
	options.complete();
}

QUnit.test( "jQuery.speed( speed, easing, complete )", function( assert ) {
	testEasing( assert, 10, "linear", function() {
		assert.ok( true, "Complete called" );
	} );
} );

diff --git a/a.js b/b.js
@@ -2549,7 +2529,7 @@ testEasing( assert, 10, "linear", function() {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
	assert.equal( options.queue, "fx", "Queue defaults to fx" );
	options.complete();
}

QUnit.test( "jQuery.speed( speed, easing, complete )", function( assert ) {
	testEasing( assert, 10, "linear", function() {
		assert.ok( true, "Complete called" );
	} );
} );

QUnit.test( "jQuery.speed( speed, easing, complete ) - with easing function", function( assert ) {
	testEasing(
		assert,
		10,
		function() {
			return "linear";
		},
		function() {
diff --git a/a.js b/b.js
@@ -2561,7 +2541,7 @@ testEasing(
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		assert.ok( true, "Complete called" );
	} );
} );

QUnit.test( "jQuery.speed( speed, easing, complete ) - with easing function", function( assert ) {
	testEasing(
		assert,
		10,
		function() {
			return "linear";
		},
		function() {
			assert.ok( true, "Complete called" );
		}
	);
} );

QUnit.test( "jQuery.speed( options )", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: "linear",
		complete: function() {
			assert.ok( true, "Complete called" );
		}
diff --git a/a.js b/b.js
@@ -2571,7 +2551,7 @@ testEasing( assert, {
A blob:2278b3afb31f22e274c19512b08cb11e8b65d061
		}
	);
} );

QUnit.test( "jQuery.speed( options )", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: "linear",
		complete: function() {
			assert.ok( true, "Complete called" );
		}
	} );
} );

QUnit.test( "jQuery.speed( options ) - with easing function", function( assert ) {
	testEasing( assert, {
		duration: 10,
		easing: function() {
			return "linear";
		},
		complete: function() {
diff --git a/a.js b/b.js
@@ -8,7 +8,7 @@ beforeEach: function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
QUnit.module( "event", {
	beforeEach: function() {
		document.body.focus();
	},
	afterEach: moduleTeardown
} );

QUnit.test( "null or undefined handler", function( assert ) {
	assert.expect( 4 );

	// Supports Fixes bug #7229
	try {
		jQuery( "#firstp" ).on( "click", null );
		assert.ok( true, "Passing a null handler will not throw an exception" );
	} catch ( e ) {}
diff --git a/a.js b/b.js
@@ -484,7 +484,7 @@ 		neverCallMe = function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
QUnit.test( "trigger() works with events that were previously stopped", function( assert ) {
	assert.expect( 0 );

	var $button = jQuery( "#button" ),
		$parent = $button.parent(),
		neverCallMe = function() {
			assert.ok( false, "propagation should have been stopped" );
		};

	$parent[ 0 ].addEventListener( "click", neverCallMe );
	$button.on( "click", neverCallMe );

	var clickEvent =  jQuery.Event( "click" );
	clickEvent.stopPropagation();
	$button.trigger( clickEvent );

	$parent[ 0 ].removeEventListener( "click", neverCallMe );
	$button.off( "click", neverCallMe );
} );


QUnit.test( "on(), iframes", function( assert ) {
	assert.expect( 1 );

	// events don't work with iframes, see #939 - this test fails in IE because of contentDocument
	var doc = jQuery( "#loadediframe" ).contents();

	jQuery( "div", doc ).on( "click", function() {
		assert.ok( true, "Binding to element inside iframe" );
diff --git a/a.js b/b.js
@@ -552,7 +552,7 @@ jQuery( "#nonnodes" ).contents().on( "tester", function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb

	// Try triggering the custom event (0)
	firstp.trigger( "custom" );

	// using contents will get comments regular, text, and comment nodes
	jQuery( "#nonnodes" ).contents().on( "tester", function() {
		assert.equal( this.nodeType, 1, "Check node,textnode,comment on just does real nodes" );
	} ).trigger( "tester" );

	// Make sure events stick with appendTo'd elements (which are cloned) #2027
	jQuery( "<a href='#fail' class='test'>test</a>" ).on( "click", function() { return false; } ).appendTo( "#qunit-fixture" );
	assert.ok( jQuery( "a.test" ).eq( 0 ).triggerHandler( "click" ) === false, "Handler is bound to appendTo'd elements" );
} );

diff --git a/a.js b/b.js
@@ -589,7 +589,7 @@ jQuery( "#firstp" ).on( "click.test.abc", function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb

	jQuery( "#firstp" ).on( "click.test", function() {
		check( "click.test", "Normal click triggered" );
	} );

	jQuery( "#firstp" ).on( "click.test.abc", function() {
		check( "click.test.abc", "Namespaced click triggered" );
	} );

	// Those would not trigger/off (#5303)
	jQuery( "#firstp" ).trigger( "click.a.test" );
	jQuery( "#firstp" ).off( "click.a.test" );

	// Trigger both bound fn (1)
diff --git a/a.js b/b.js
@@ -812,7 +812,7 @@ QUnit.test( "off(type)", function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	assert.equal( obj && obj[ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ][ "events" ], undefined, "Make sure events object is removed" );
} );

QUnit.test( "off(type)", function( assert ) {
	assert.expect( 1 );

	var message, func,
		$elem = jQuery( "#firstp" );

	function error() {
		assert.ok( false, message );
	}

	message = "unbind passing function";
	$elem.on( "error1", error ).off( "error1", error ).triggerHandler( "error1" );

	message = "unbind all from event";
	$elem.on( "error1", error ).off( "error1" ).triggerHandler( "error1" );

	message = "unbind all";
	$elem.on( "error1", error ).off().triggerHandler( "error1" );

	message = "unbind many with function";
	$elem.on( "error1 error2", error )
		.off( "error1 error2", error )
		.trigger( "error1" ).triggerHandler( "error2" );

	message = "unbind many"; // #3538
	$elem.on( "error1 error2", error )
		.off( "error1 error2" )
		.trigger( "error1" ).triggerHandler( "error2" );

diff --git a/a.js b/b.js
@@ -1041,7 +1041,7 @@ 	$elem[ 0 ].click = function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	// Triggers handlers and native
	// Trigger 5
	$elem.on( "click", handler ).trigger( "click", [ 1, "2", "abc" ] );

	// Simulate a "native" click
	$elem[ 0 ].click = function() {
		assert.ok( false, "Native call was triggered" );
	};

	// Trigger only the handlers (no native)
	// Triggers 5
	assert.equal( $elem.triggerHandler( "click", [ 1, "2", "abc" ] ), "test", "Verify handler response" );

	pass = true;
	try {
		elem2 = jQuery( "#form input" ).eq( 0 );
		elem2.get( 0 ).style.display = "none";
		elem2.trigger( "focus" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger focus on hidden element" );

	pass = true;
	try {
		jQuery( "#qunit-fixture table" ).eq( 0 ).on( "test:test", function() {} ).trigger( "test:test" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger on a table with a colon in the even type, see #3533" );

	form = jQuery( "<form action=''></form>" ).appendTo( "body" );

	// Make sure it can be prevented locally
diff --git a/a.js b/b.js
@@ -1069,7 +1069,7 @@ jQuery( document ).on( "submit", function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	// Trigger 1
	form.trigger( "submit" );

	form.off( "submit" );

	jQuery( document ).on( "submit", function() {
		assert.ok( true, "Make sure bubble works up to document." );
		return false;
	} );

	// Trigger 1
	form.trigger( "submit" );

	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
diff --git a/a.js b/b.js
@@ -1105,7 +1105,7 @@ QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
		$fixture = jQuery( "#qunit-fixture" ),
		$wrapperDiv = jQuery( "<div></div>" ).appendTo( $fixture );

	function noSubmit( e ) {
		e.preventDefault();
	}
	function delegatedSubmit() {
		assert.ok( true, "Make sure submit event bubbles up." );
		return false;
	}

	// Attach a delegated submit handler to the parent element
	$fixture.on( "submit", "form", delegatedSubmit );

	// Trigger form submission to introduce the _submit_attached property
	$testForm.on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Copy the form via .clone() and .html()
	$formByClone = $testForm.clone( true, true ).removeAttr( "id" );
	$formByHTML = jQuery( jQuery.parseHTML( $fixture.html() ) ).filter( "#testForm" ).removeAttr( "id" );
	$wrapperDiv.append( $formByClone, $formByHTML );

	// Check submit bubbling on the copied forms
	$wrapperDiv.find( "form" ).on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "submit", "form", delegatedSubmit );
	$testForm.off( "submit", noSubmit );
} );

QUnit.test( "change event bubbles on copied forms (#11796)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$form = jQuery( "#form" ),
diff --git a/a.js b/b.js
@@ -1227,7 +1227,7 @@ QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "change", "form", delegatedChange );
} );

QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
	assert.expect( 28 );

	var event,
		$parent = jQuery( "<div id='par'></div>" ).appendTo( "body" ),
		$child = jQuery( "<p id='child'>foo</p>" ).appendTo( $parent );

	$parent.get( 0 ).style.display = "none";

	event = jQuery.Event( "noNew" );
	assert.ok( event !== window, "Instantiate jQuery.Event without the 'new' keyword" );
	assert.equal( event.type, "noNew", "Verify its type" );

	assert.equal( event.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
	assert.equal( event.isPropagationStopped(), false, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

	event.preventDefault();
	assert.equal( event.isDefaultPrevented(), true, "Verify isDefaultPrevented" );
	event.stopPropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );

	event.isPropagationStopped = function() { return false; };
	event.stopImmediatePropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), true, "Verify isPropagationStopped" );

	$parent.on( "foo", function( e ) {

		// Tries bubbling
		assert.equal( e.type, "foo", "Verify event type when passed passing an event object" );
		assert.equal( e.target.id, "child", "Verify event.target when passed passing an event object" );
		assert.equal( e.currentTarget.id, "par", "Verify event.currentTarget when passed passing an event object" );
		assert.equal( e.secret, "boo!", "Verify event object's custom attribute when passed passing an event object" );
	} );

	// test with an event object
	event = new jQuery.Event( "foo" );
	event.secret = "boo!";
	$child.trigger( event );

	// test with a literal object
	$child.trigger( { "type": "foo", "secret": "boo!" } );

	$parent.off();

	function error() {
		assert.ok( false, "This assertion shouldn't be reached" );
	}

	$parent.on( "foo", error );

	$child.on( "foo", function( e, a, b, c ) {
		assert.equal( arguments.length, 4, "Check arguments length" );
		assert.equal( a, 1, "Check first custom argument" );
		assert.equal( b, 2, "Check second custom argument" );
		assert.equal( c, 3, "Check third custom argument" );

		assert.equal( e.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
		assert.equal( e.isPropagationStopped(), false, "Verify isPropagationStopped" );
		assert.equal( e.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

		// Skips both errors
		e.stopImmediatePropagation();

		return "result";
	} );

	// We should add this back in when we want to test the order
	// in which event handlers are iterated.
	//$child.on("foo", error );

	event = new jQuery.Event( "foo" );
	$child.trigger( event, [ 1, 2, 3 ] ).off();
	assert.equal( event.result, "result", "Check event.result attribute" );

	// Will error if it bubbles
	$child.triggerHandler( "foo" );

	$child.off();
	$parent.off().remove();

	// Ensure triggerHandler doesn't molest its event object (#xxx)
	event = jQuery.Event( "zowie" );
	jQuery( document ).triggerHandler( event );
	assert.equal( event.type, "zowie", "Verify its type" );
	assert.equal( event.isPropagationStopped(), false, "propagation not stopped" );
	assert.equal( event.isDefaultPrevented(), false, "default not prevented" );
} );

QUnit.test( ".trigger() bubbling on disconnected elements (#10489)", function( assert ) {
	assert.expect( 2 );

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
diff --git a/a.js b/b.js
@@ -1251,7 +1251,7 @@ jQuery( "<div><p>hi</p></div>" )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
	} );

	jQuery( "<div><p>hi</p></div>" )
		.on( "click", function() {
			assert.ok( true, "click fired on div" );
		} )
		.find( "p" )
			.on( "click", function() {
				assert.ok( true, "click fired on p" );
			} )
			.trigger( "click" )
			.off( "click" )
		.end()
		.off( "click" )
		.remove();

	jQuery( window ).off( "click" );
} );

QUnit.test( ".trigger() doesn't bubble load event (#10717)", function( assert ) {
	assert.expect( 1 );

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
diff --git a/a.js b/b.js
@@ -1269,7 +1269,7 @@ jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
	} );

	jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
		.appendTo( "body" )
		.on( "load", function() {
			assert.ok( true, "load fired on img" );
		} )
		.trigger( "load" )
		.remove();

	jQuery( window ).off( "load" );
} );

QUnit.test( "Delegated events in SVG (#10791; #13180)", function( assert ) {
	assert.expect( 2 );

	var useElem, e,
		svg = jQuery(
diff --git a/a.js b/b.js
@@ -1295,7 +1295,7 @@ jQuery( "#qunit-fixture" )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
			"<rect id='svg-by-id' x='10' y='20' width='100' height='60' r='10' rx='10' ry='10'></rect>" +
			"<use id='use' xlink:href='#ref'></use>" +
			"</svg>"
		);

	jQuery( "#qunit-fixture" )
		.append( svg )
		.on( "click", "#svg-by-id", function() {
			assert.ok( true, "delegated id selector" );
		} )
		.on( "click", "[class~='svg-by-class']", function() {
			assert.ok( true, "delegated class selector" );
		} )
		.find( "#svg-by-id, [class~='svg-by-class']" )
			.trigger( "click" )
		.end();

	// Fire a native click on an SVGElementInstance (the instance tree of an SVG <use>)
	// to confirm that it doesn't break our event delegation handling (#13180)
	useElem = svg.find( "#use" )[ 0 ];
	if ( document.createEvent && useElem && useElem.instanceRoot ) {
		e = document.createEvent( "MouseEvents" );
		e.initEvent( "click", true, true );
diff --git a/a.js b/b.js
@@ -1321,7 +1321,7 @@ QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( ass
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	}

	jQuery( "#qunit-fixture" ).off( "click" );
} );

QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( assert ) {
	assert.expect( 3 );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", ":not", function() {} );
	}, "malformed selector throws on attach" );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", "nonexistent:not", function() {} );
	}, "short-circuitable malformed selector throws on attach" );

	jQuery( "#foo > :first-child" ).trigger( "click" );
	assert.ok( true, "malformed selector does not throw on event" );
} );

QUnit.test( "Delegated events in forms (#10844; #11145; #8165; #11382, #11764)", function( assert ) {
	assert.expect( 5 );

	// Alias names like "id" cause havoc
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ jQuery( "body" )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form.append( "<input type='text' name='disabled' value='differently abled' />" );
	jQuery( "body" )
		.on( "submit", "#myform", function() {
			assert.ok( true, "delegated id selector with aliased disabled" );
		} )
		.find( "#myform" )
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form
		.append( "<button id='nestyDisabledBtn'><span>Zing</span></button>" )
		.on( "click", "#nestyDisabledBtn", function() {
			assert.ok( true, "click on enabled/disabled button with nesty elements" );
		} )
		.on( "mouseover", "#nestyDisabledBtn", function() {
			assert.ok( true, "mouse on enabled/disabled button with nesty elements" );
		} )
		.find( "span" )
			.trigger( "click" )		// yep
			.trigger( "mouseover" )	// yep
		.end()
		.find( "#nestyDisabledBtn" ).prop( "disabled", true ).end()
		.find( "span" )
			.trigger( "click" )		// nope
			.trigger( "mouseover" )	// yep
		.end()
		.off( "click" );

	form.remove();
} );

QUnit.test( "Submit event can be stopped (#11049)", function( assert ) {
	assert.expect( 1 );

	// Since we manually bubble in IE, make sure inner handlers get a chance to cancel
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1450,7 +1450,7 @@ 			handler = function( event ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
QUnit.test( "jQuery.Event( type, props )", function( assert ) {

	assert.expect( 6 );

	var event = jQuery.Event( "keydown", { keyCode: 64 } ),
			handler = function( event ) {
				assert.ok( "keyCode" in event, "Special property 'keyCode' exists" );
				assert.equal( event.keyCode, 64, "event.keyCode has explicit value '64'" );
			};

	// Supports jQuery.Event implementation
	assert.equal( event.type, "keydown", "Verify type" );

	// ensure "type" in props won't clobber the one set by constructor
	assert.equal( jQuery.inArray( "type", jQuery.event.props ), -1, "'type' property not in props (#10375)" );

	assert.ok( "keyCode" in event, "Special 'keyCode' property exists" );

	assert.strictEqual( jQuery.isPlainObject( event ), false, "Instances of $.Event should not be identified as a plain object." );
diff --git a/a.js b/b.js
@@ -1844,7 +1844,7 @@ function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
diff --git a/a.js b/b.js
@@ -1859,7 +1859,7 @@ function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
diff --git a/a.js b/b.js
@@ -1879,7 +1879,7 @@ function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
			.find( "#ul0" )
				.on( "click", "li:first>a", function() {
					assert.ok( this.id === "a0_0", "first li under #u10 was clicked" );
				} )
			.end()
			.find( "a" ).trigger( "click" ).end()
			.find( "#ul0" ).off();
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	markup.remove();
} );

QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

diff --git a/a.js b/b.js
@@ -1893,7 +1893,7 @@ jQuery( "#foo" ).on( "click", "toString", function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

	jQuery( "#foo" ).on( "click", "toString", function() {
		matched++;
	} );

	jQuery( "#anchor2" ).trigger( "click" );

	assert.equal( matched, 0, "Nothing matched 'toString'" );
} );

QUnit.test( "delegated event with intermediate DOM manipulation (#13208)", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" ).on( "click", "[id=sap]", function() {} );
	jQuery( "#sap" ).on( "click", "[id=anchor2]", function() {
diff --git a/a.js b/b.js
@@ -2187,7 +2187,7 @@ jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		order = 0;

	// focus the element so DOM focus won't fire
	input[ 0 ].focus();

	jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
		assert.equal( 1, order++, "focusin on the body second" );
	} );

	input.on( "focusin.focusinBubblesTest", function() {
		assert.equal( 0, order++, "focusin on the element first" );
	} );

// Removed since DOM focus is unreliable on test swarm
	// DOM focus method
//	input[0].focus();

	// To make the next focus test work, we need to take focus off the input.
	// This will fire another focusin event, so set order to reflect that.
//	order = 1;
//	jQuery("#text1")[0].focus();

	// jQuery trigger, which calls DOM focus
	order = 0;
	input.trigger( "focus" );

	input.remove();
	jQuery( "body" ).off( "focusin.focusinBubblesTest" );
} );

QUnit.test( "custom events with colons (#3533, #8272)", function( assert ) {
	assert.expect( 1 );

	var tab = jQuery( "<table><tr><td>trigger</td></tr></table>" ).appendTo( "body" );
	try {
diff --git a/a.js b/b.js
@@ -2370,7 +2370,7 @@ jQuery( "<p>Gut Feeling</p>" )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		.off( ".Devo" )
		.trigger( "gutfeeling" )
		.remove();

	// Ensure .one() events are removed after their maiden voyage
	jQuery( "<p>Gut Feeling</p>" )
		.one( "gutfeeling", jQuery.noop )
		.trigger( "gutfeeling" )	// This one should
		.trigger( "gutfeeling" )	// This one should not
		.remove();

	delete jQuery.event.special[ "gutfeeling" ];
} );

QUnit.test( ".on and .off, selective mixed removal (#10705)", function( assert ) {
	assert.expect( 7 );

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
diff --git a/a.js b/b.js
@@ -2392,7 +2392,7 @@ jQuery( "<p>Strange Pursuit</p>" )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
	};

	jQuery( "<p>Strange Pursuit</p>" )
		.on( "click", timingx )
		.on( "click.duty", timingx )
		.on( "click.now", timingx )
		.on( "devo", timingx )
		.on( "future", timingx )
		.trigger( "click" )		// 3
		.trigger( "devo" )		// 1
		.off( ".duty devo " )	// trailing space
		.trigger( "future" )	// 1
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
diff --git a/a.js b/b.js
@@ -2408,7 +2408,7 @@ QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
		data = "bar",
		map = {
			"foo": function( event ) {
				assert.equal( event.data, "bar", "event.data correctly relayed with null selector" );
				$p.remove();
			}
		};

	$p.on( map, null, data ).trigger( "foo" );
} );

QUnit.test( "clone() delegated events (#11076)", function( assert ) {
	assert.expect( 3 );

	var counter = { "center": 0, "fold": 0, "centerfold": 0 },
		clicked = function() {
diff --git a/a.js b/b.js
@@ -2745,7 +2745,7 @@ QUnit.test( "trigger click on checkbox, fires change event", function( assert )
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	$fixture.remove();

	jQuery.removeEvent = originRemoveEvent;
} );

QUnit.test( "trigger click on checkbox, fires change event", function( assert ) {
	assert.expect( 1 );

	var check = jQuery( "#check2" );
	var done = assert.async();

	check.on( "change", function() {

		// get it?
		check.off( "change" );
		assert.ok( true, "Change event fired as a result of triggered click" );
		done();
	} ).trigger( "click" );
} );

QUnit.test( "Namespace preserved when passed an Event (#12739)", function( assert ) {
	assert.expect( 4 );

	var markup = jQuery(
			"<div id='parent'><div id='child'></div></div>"
diff --git a/a.js b/b.js
@@ -2833,7 +2833,7 @@ QUnit.test( "make sure events cloned correctly", function( assert ) {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
	markup.remove();

	assert.equal( triggered, 3, "foo.bar triggered" );
} );

QUnit.test( "make sure events cloned correctly", function( assert ) {
	assert.expect( 18 );

	var clone,
		fixture = jQuery( "#qunit-fixture" ),
		checkbox = jQuery( "#check1" ),
		p = jQuery( "#firstp" );

	fixture.on( "click change", function( event, result ) {
		assert.ok( result,  event.type + " on original element is fired" );

	} ).on( "click", "#firstp", function( event, result ) {
		assert.ok( result, "Click on original child element though delegation is fired" );

	} ).on( "change", "#check1", function( event, result ) {
		assert.ok( result, "Change on original child element though delegation is fired" );
	} );

	p.on( "click", function() {
		assert.ok( true, "Click on original child element is fired" );
	} );

	checkbox.on( "change", function() {
		assert.ok( true, "Change on original child element is fired" );
	} );

	fixture.clone().trigger( "click" ).trigger( "change" ); // 0 events should be fired

	clone = fixture.clone( true );

	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone = fixture.clone( true, true );
	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire

	fixture.off();
	p.off();
	checkbox.off();

	p.trigger( "click" ); // 0 should be fired
	checkbox.trigger( "change" ); // 0 should be fired

	clone.find( "p" ).eq( 0 ).trigger( "click", true );  // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};
diff --git a/a.js b/b.js
@@ -2848,7 +2848,7 @@ QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#1336
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};

	try {
		jQuery( "<p>" ).trigger( "foo.bar" );
	} catch ( e ) {
		errored = true;
	}
	assert.equal( errored, false, "trigger() did not throw exception" );
	delete String.prototype.namespace;
} );

QUnit.test( "Inline event result is returned (#13993)", function( assert ) {
	assert.expect( 1 );

	var result = jQuery( "<p onclick='return 42'>hello</p>" ).triggerHandler( "click" );

diff --git a/a.js b/b.js
@@ -3137,7 +3137,7 @@ setTimeout( function() {
A blob:1f76c54b9d08400af2a1e18200088b45819cabdb
		input[ 0 ].focus();

		// then lose it
		inputExternal[ 0 ].focus();

		setTimeout( function() {

			// DOM focus is unreliable in TestSwarm
			if ( QUnit.isSwarm && !focus ) {
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
			}

			// cleanup
			parent.off();
			input.off();

			done();
		}, 50 );
	}, 50 );
} );

QUnit.test( "focus-blur order (#12868)", function( assert ) {
	assert.expect( 5 );

	var order,
		$text = jQuery( "#text1" ),
diff --git a/a.js b/b.js
@@ -39,9 +39,9 @@ QUnit.test( "text()", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	functionReturningObj( value );
		Returns a function that returns the value
*/

QUnit.test( "text()", function( assert ) {

	assert.expect( 5 );

	var expected, frag, $newLineTest;

	expected = "This link has class=\"blog\": Simon Willison's Weblog";
	assert.equal( jQuery( "#sap" ).text(), expected, "Check for merged text of more then one element." );

	// Check serialization of text values
	assert.equal( jQuery( document.createTextNode( "foo" ) ).text(), "foo", "Text node was retrieved from .text()." );
	assert.notEqual( jQuery( document ).text(), "", "Retrieving text for the document retrieves all text (#10724)." );

	// Retrieve from document fragments #10864
	frag = document.createDocumentFragment();
	frag.appendChild( document.createTextNode( "foo" ) );

	assert.equal( jQuery( frag ).text(), "foo", "Document Fragment Text node was retrieved from .text()." );
diff --git a/a.js b/b.js
@@ -49,7 +49,7 @@ QUnit.test( "text()", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	functionReturningObj( value );
		Returns a function that returns the value
*/

QUnit.test( "text()", function( assert ) {

	assert.expect( 5 );

	var expected, frag, $newLineTest;

	expected = "This link has class=\"blog\": Simon Willison's Weblog";
	assert.equal( jQuery( "#sap" ).text(), expected, "Check for merged text of more then one element." );

	// Check serialization of text values
	assert.equal( jQuery( document.createTextNode( "foo" ) ).text(), "foo", "Text node was retrieved from .text()." );
	assert.notEqual( jQuery( document ).text(), "", "Retrieving text for the document retrieves all text (#10724)." );

	// Retrieve from document fragments #10864
	frag = document.createDocumentFragment();
	frag.appendChild( document.createTextNode( "foo" ) );

	assert.equal( jQuery( frag ).text(), "foo", "Document Fragment Text node was retrieved from .text()." );

	$newLineTest = jQuery( "<div>test<br/>testy</div>" ).appendTo( "#moretests" );
	$newLineTest.find( "br" ).replaceWith( "\n" );
	assert.equal( $newLineTest.text(), "test\ntesty", "text() does not remove new lines (#11153)" );

	$newLineTest.remove();
} );

diff --git a/a.js b/b.js
@@ -58,7 +58,7 @@ QUnit.test( "text(undefined)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.equal( $newLineTest.text(), "test\ntesty", "text() does not remove new lines (#11153)" );

	$newLineTest.remove();
} );

QUnit.test( "text(undefined)", function( assert ) {

	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).text( "<div" ).text( undefined )[ 0 ].innerHTML, "&lt;div", ".text(undefined) is chainable (#5571)" );
} );

function testText( valueObj, assert ) {

diff --git a/a.js b/b.js
@@ -78,16 +78,16 @@ function testText( valueObj, assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).text( "<div" ).text( undefined )[ 0 ].innerHTML, "&lt;div", ".text(undefined) is chainable (#5571)" );
} );

function testText( valueObj, assert ) {

	assert.expect( 6 );

	var val, j, expected, $multipleElements, $parentDiv, $childDiv;

	val = valueObj( "<div><b>Hello</b> cruel world!</div>" );
	assert.equal( jQuery( "#foo" ).text( val )[ 0 ].innerHTML.replace( />/g, "&gt;" ), "&lt;div&gt;&lt;b&gt;Hello&lt;/b&gt; cruel world!&lt;/div&gt;", "Check escaped text" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
	j.text( valueObj( "hi!" ) );
	assert.equal( jQuery( j[ 0 ] ).text(), "hi!", "Check node,textnode,comment with text()" );
	assert.equal( j[ 1 ].nodeValue, " there ", "Check node,textnode,comment with text()" );

	assert.equal( j[ 2 ].nodeType, 8, "Check node,textnode,comment with text()" );

	// Update multiple elements #11809
	expected = "New";

	$multipleElements = jQuery( "<div>Hello</div>" ).add( "<div>World</div>" );
	$multipleElements.text( expected );

	assert.equal( $multipleElements.eq( 0 ).text(), expected, "text() updates multiple elements (#11809)" );
	assert.equal( $multipleElements.eq( 1 ).text(), expected, "text() updates multiple elements (#11809)" );

	// Prevent memory leaks #11809
	$childDiv = jQuery( "<div></div>" );
	$childDiv.data( "leak", true );
	$parentDiv = jQuery( "<div></div>" );
	$parentDiv.append( $childDiv );
diff --git a/a.js b/b.js
@@ -187,7 +187,7 @@ function testAppendForObject( valueObj, isFragment, assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	} );

	assert.equal( jQuery( "#sap" ).text(), "foobar", "Check for merged text of more then one element." );
} );

function testAppendForObject( valueObj, isFragment, assert ) {
	var $base,
		type = isFragment ? " (DocumentFragment)" : " (Element)",
		text = "This link has class=\"blog\": Simon Willison's Weblog",
		el = document.getElementById( "sap" ).cloneNode( true ),
		first = document.getElementById( "first" ),
		yahoo = document.getElementById( "yahoo" );

	if ( isFragment ) {
		$base = document.createDocumentFragment();
		jQuery( el ).contents().each( function() {
			$base.appendChild( this );
		} );
		$base = jQuery( $base );
	} else {
		$base = jQuery( el );
	}

	assert.equal( $base.clone().append( valueObj( first.cloneNode( true ) ) ).text(),
		text + "Try them out:",
		"Check for appending of element" + type
	);

	assert.equal( $base.clone().append( valueObj( [ first.cloneNode( true ), yahoo.cloneNode( true ) ] ) ).text(),
		text + "Try them out:Yahoo",
		"Check for appending of array of elements" + type
	);

	assert.equal( $base.clone().append( valueObj( jQuery( "#yahoo, #first" ).clone() ) ).text(),
		text + "YahooTry them out:",
		"Check for appending of jQuery object" + type
	);

	assert.equal( $base.clone().append( valueObj( 5 ) ).text(),
		text + "5",
		"Check for appending a number" + type
	);

	assert.equal( $base.clone().append( valueObj( [ jQuery( "#first" ).clone(), jQuery( "#yahoo, #google" ).clone() ] ) ).text(),
		text + "Try them out:GoogleYahoo",
		"Check for appending of array of jQuery objects"
	);

	assert.equal( $base.clone().append( valueObj( " text with spaces " ) ).text(),
		text + " text with spaces ",
		"Check for appending text with spaces" + type
	);

	assert.equal( $base.clone().append( valueObj( [] ) ).text(),
		text,
		"Check for appending an empty array" + type
	);

	assert.equal( $base.clone().append( valueObj( "" ) ).text(),
		text,
		"Check for appending an empty string" + type
	);

	assert.equal( $base.clone().append( valueObj( document.getElementsByTagName( "foo" ) ) ).text(),
		text,
		"Check for appending an empty nodelist" + type
	);

	assert.equal( $base.clone().append( "<span></span>", "<span></span>", "<span></span>" ).children().length,
		$base.children().length + 3,
		"Make sure that multiple arguments works." + type
	);

	assert.equal( $base.clone().append( valueObj( document.getElementById( "form" ).cloneNode( true ) ) ).children( "form" ).length,
		1,
		"Check for appending a form (#910)" + type
	);
}

function testAppend( valueObj, assert ) {
diff --git a/a.js b/b.js
@@ -272,7 +272,7 @@ jQuery( "#form" )
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	} );

	jQuery( "#table colgroup" ).append( valueObj( "<col></col>" ) );
	assert.equal( jQuery( "#table colgroup col" ).length, 1, "Append col" );

	jQuery( "#form" )
		.append( valueObj( "<select id='appendSelect1'></select>" ) )
		.append( valueObj( "<select id='appendSelect2'><option>Test</option></select>" ) );
	assert.t( "Append Select", "#appendSelect1, #appendSelect2", [ "appendSelect1", "appendSelect2" ] );

	assert.equal( "Two nodes", jQuery( "<div></div>" ).append( "Two", " nodes" ).text(), "Appending two text nodes (#4011)" );
	assert.equal( jQuery( "<div></div>" ).append( "1", "", 3 ).text(), "13", "If median is false-like value, subsequent arguments should not be ignored" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
diff --git a/a.js b/b.js
@@ -310,7 +310,7 @@ QUnit.test( "append(Function)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

QUnit.test( "append(String|Element|Array<Element>|jQuery)", function( assert ) {
	testAppend( manipulationBareObj, assert );
} );

QUnit.test( "append(Function)", function( assert ) {
	testAppend( manipulationFunctionReturningObj, assert );
} );

QUnit.test( "append(param) to object, see #11280", function( assert ) {

	assert.expect( 5 );

	var object = jQuery( document.createElement( "object" ) ).appendTo( document.body );
diff --git a/a.js b/b.js
@@ -402,7 +402,7 @@ jQuery( "#sap" ).append( function( i, val ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
QUnit.test( "append(Function) returns Number", function( assert ) {

	assert.expect( 2 );
	var old = jQuery( "#sap" ).html();

	jQuery( "#sap" ).append( function( i, val ) {
		assert.equal( val, old, "Make sure the incoming value is correct." );
		return 5;
	} );
	assert.ok( jQuery( "#sap" )[ 0 ].innerHTML.match( /5$/ ), "Check for appending a number" );
} );

QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {

	assert.expect( 5 );

	var xmlDoc1 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state x='100' y='100' initial='actions' id='provisioning'></state><state x='100' y='100' id='error'></state><state x='100' y='100' id='finished' final='true'></state></scxml>" ),
diff --git a/a.js b/b.js
@@ -430,7 +430,7 @@ QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		return 5;
	} );
	assert.ok( jQuery( "#sap" )[ 0 ].innerHTML.match( /5$/ ), "Check for appending a number" );
} );

QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {

	assert.expect( 5 );

	var xmlDoc1 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state x='100' y='100' initial='actions' id='provisioning'></state><state x='100' y='100' id='error'></state><state x='100' y='100' id='finished' final='true'></state></scxml>" ),
		xmlDoc2 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state id='provisioning3'></state></scxml>" ),
		xml1 = jQuery( xmlDoc1 ),
		xml2 = jQuery( xmlDoc2 ),
		scxml1 = jQuery( "scxml", xml1 ),
		scxml2 = jQuery( "scxml", xml2 ),
		state = scxml2.find( "state" );

	scxml1.append( state );
	assert.strictEqual( scxml1[ 0 ].lastChild, state[ 0 ], "append" );

	scxml1.prepend( state );
	assert.strictEqual( scxml1[ 0 ].firstChild, state[ 0 ], "prepend" );

	scxml1.find( "#finished" ).after( state );
	assert.strictEqual( scxml1[ 0 ].lastChild, state[ 0 ], "after" );

	scxml1.find( "#provisioning" ).before( state );
	assert.strictEqual( scxml1[ 0 ].firstChild, state[ 0 ], "before" );

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;
diff --git a/a.js b/b.js
@@ -445,7 +445,7 @@ QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;

	jQuery( "#qunit-fixture" ).append( "<article style='font-size:10px'><section><aside>HTML5 elements</aside></section></article>" );

	article = jQuery( "article" );
	aside = jQuery( "aside" );

	assert.equal( article.get( 0 ).style.fontSize, "10px", "HTML5 elements are styleable" );
	assert.equal( aside.length, 1, "HTML5 elements do not collapse their children" );
} );

QUnit[ jQuery.fn.css ? "test" : "skip" ]( "HTML5 Elements inherit styles from style rules (Bug #10501)", function( assert ) {

	assert.expect( 1 );

	jQuery( "#qunit-fixture" ).append( "<article id='article'></article>" );
diff --git a/a.js b/b.js
@@ -456,7 +456,7 @@ QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;

	jQuery( "#qunit-fixture" ).append( "<article style='font-size:10px'><section><aside>HTML5 elements</aside></section></article>" );

	article = jQuery( "article" );
	aside = jQuery( "aside" );

	assert.equal( article.get( 0 ).style.fontSize, "10px", "HTML5 elements are styleable" );
	assert.equal( aside.length, 1, "HTML5 elements do not collapse their children" );
} );

QUnit[ jQuery.fn.css ? "test" : "skip" ]( "HTML5 Elements inherit styles from style rules (Bug #10501)", function( assert ) {

	assert.expect( 1 );

	jQuery( "#qunit-fixture" ).append( "<article id='article'></article>" );
	jQuery( "#article" ).append( "<section>This section should have a pink background.</section>" );

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
diff --git a/a.js b/b.js
@@ -465,7 +465,7 @@ QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().length, 1, "Make sure HTML5 article elements can hold children. innerHTML shortcut path" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().children().length, 1, "Make sure nested HTML5 elements can hold children." );
} );

QUnit.test( "html(String) tag-hyphenated elements (Bug #1987)", function( assert ) {

	assert.expect( 27 );

	jQuery.each( "thead tbody tfoot colgroup caption tr th td".split( " " ), function( i, name ) {
diff --git a/a.js b/b.js
@@ -561,7 +561,7 @@ QUnit.test( "IE8 serialization bug", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		assert.equal( child.nodeName.toUpperCase(), "DIV",
			method + "(): Self-closing tag name terminated by " + description );
	}
} );

QUnit.test( "IE8 serialization bug", function( assert ) {

	assert.expect( 2 );
	var wrapper = jQuery( "<div></div>" );

	wrapper.html( "<div></div><article></article>" );
	assert.equal( wrapper.children( "article" ).length, 1, "HTML5 elements are insertable with .html()" );

	wrapper.html( "<div></div><link></link>" );
	assert.equal( wrapper.children( "link" ).length, 1, "Link elements are insertable with .html()" );
} );

QUnit.test( "html() object element #10324", function( assert ) {

	assert.expect( 1 );

	var object = jQuery( "<object id='object2'><param name='object2test' value='test'></param></object>?" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -959,7 +959,7 @@ QUnit.test( "before(no-op)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	expected = "This is a normal link: Try them out:GooglediveintomarkYahoo";
	jQuery( "#yahoo" ).before( manipulationFunctionReturningObj( [ jQuery( "#first" ), jQuery( "#mark, #google" ) ] ) );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert array of jQuery objects before" );
} );

QUnit.test( "before(no-op)", function( assert ) {

	assert.expect( 2 );

	var set;
	set = jQuery( "<div></div>" ).before( "<span>test</span>" );
	assert.equal( set[ 0 ].nodeName.toLowerCase(), "div", "Insert before a disconnected node should be a no-op" );
	assert.equal( set.length, 1, "Insert the element before the disconnected node. should be a no-op" );
} );

QUnit.test( "before and after w/ empty object (#10812)", function( assert ) {

	assert.expect( 1 );

	var res;
diff --git a/a.js b/b.js
@@ -1195,7 +1195,7 @@ function testReplaceWith( val, assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
diff --git a/a.js b/b.js
@@ -1208,7 +1208,7 @@ function testReplaceWith( val, assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with array of elements" );
	assert.ok( !jQuery( "#google" )[ 0 ], "Verify that original element is gone, after array of elements" );

	jQuery( "#groups" ).replaceWith( val( jQuery( "#mark, #first" ) ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with jQuery collection" );
	assert.ok( !jQuery( "#groups" )[ 0 ], "Verify that original element is gone, after jQuery collection" );

	jQuery( "#mark, #first" ).replaceWith( val( "<span class='replacement'></span><span class='replacement'></span>" ) );
	assert.equal( jQuery( "#qunit-fixture .replacement" ).length, 4, "Replace multiple elements (#12449)" );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), [], "Verify that original elements are gone, after replace multiple" );

	tmp = jQuery( "<b>content</b>" )[ 0 ];
	jQuery( "#anchor1" ).contents().replaceWith( val( tmp ) );
diff --git a/a.js b/b.js
@@ -1256,7 +1256,7 @@ function testReplaceWith( val, assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with array of elements" );
	assert.ok( !jQuery( "#google" )[ 0 ], "Verify that original element is gone, after array of elements" );

	jQuery( "#groups" ).replaceWith( val( jQuery( "#mark, #first" ) ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with jQuery collection" );
	assert.ok( !jQuery( "#groups" )[ 0 ], "Verify that original element is gone, after jQuery collection" );

	jQuery( "#mark, #first" ).replaceWith( val( "<span class='replacement'></span><span class='replacement'></span>" ) );
	assert.equal( jQuery( "#qunit-fixture .replacement" ).length, 4, "Replace multiple elements (#12449)" );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), [], "Verify that original elements are gone, after replace multiple" );

	tmp = jQuery( "<b>content</b>" )[ 0 ];
	jQuery( "#anchor1" ).contents().replaceWith( val( tmp ) );
	assert.deepEqual( jQuery( "#anchor1" ).contents().get(), [ tmp ], "Replace text node with element" );

	tmp = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( true, "Newly bound click run." );
	} );
	y = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( false, "Previously bound click run." );
	} );
	child = y.append( "<b>test</b>" ).find( "b" ).on( "click", function() {
		assert.ok( true, "Child bound click run." );
		return false;
	} );

	y.replaceWith( val( tmp ) );

	tmp.trigger( "click" );
	y.trigger( "click" ); // Shouldn't be run
	child.trigger( "click" ); // Shouldn't be run

	y = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( false, "Previously bound click run." );
	} );
	child2 = y.append( "<u>test</u>" ).find( "u" ).on( "click", function() {
		assert.ok( true, "Child 2 bound click run." );
		return false;
	} );

	y.replaceWith( val( child2 ) );

	child2.trigger( "click" );

	set = jQuery( "<div></div>" ).replaceWith( val( "<span>test</span>" ) );
	assert.equal( set[ 0 ].nodeName.toLowerCase(), "div", "No effect on a disconnected node." );
	assert.equal( set.length, 1, "No effect on a disconnected node." );
	assert.equal( set[ 0 ].childNodes.length, 0, "No effect on a disconnected node." );

	child = jQuery( "#qunit-fixture" ).children().first();
	$div = jQuery( "<div class='pathological'></div>" ).insertBefore( child );
	$div.replaceWith( $div );
	assert.deepEqual( jQuery( ".pathological", "#qunit-fixture" ).get(), $div.get(),
		"Self-replacement" );
	$div.replaceWith( child );
	assert.deepEqual( jQuery( "#qunit-fixture" ).children().first().get(), child.get(),
		"Replacement with following sibling (#13810)" );
	assert.deepEqual( jQuery( ".pathological", "#qunit-fixture" ).get(), [],
		"Replacement with following sibling (context removed)" );

	nonExistent = jQuery( "#does-not-exist" ).replaceWith( val( "<b>should not throw an error</b>" ) );
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ QUnit.test( "replaceAll(jQuery)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with array of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with array of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after array of elements" );
} );

QUnit.test( "replaceAll(jQuery)", function( assert ) {

	assert.expect( 3 );

	jQuery( "#mark, #first" ).replaceAll( "#yahoo" );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with set of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with set of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after set of elements" );
} );

QUnit.test( "jQuery.clone() (#8017)", function( assert ) {

	assert.expect( 2 );

	assert.ok( jQuery.clone && typeof jQuery.clone === "function", "jQuery.clone() utility exists and is a function." );
diff --git a/a.js b/b.js
@@ -1388,7 +1388,7 @@ QUnit.test( "jQuery.clone() (#8017)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with set of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with set of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after set of elements" );
} );

QUnit.test( "jQuery.clone() (#8017)", function( assert ) {

	assert.expect( 2 );

	assert.ok( jQuery.clone && typeof jQuery.clone === "function", "jQuery.clone() utility exists and is a function." );

	var main = jQuery( "#qunit-fixture" )[ 0 ],
		clone = jQuery.clone( main );

	assert.equal( main.childNodes.length, clone.childNodes.length, "Simple child length to ensure a large dom tree copies correctly" );
} );

QUnit.test( "append to multiple elements (#8070)", function( assert ) {

	assert.expect( 2 );

	var selects = jQuery( "<select class='test8070'></select><select class='test8070'></select>" ).appendTo( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -1543,7 +1543,7 @@ QUnit.test( "clone()", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	height = table[ 0 ].offsetHeight;
	table.prepend( "<tr><td>DATA</td></tr>" );
	assert.ok( table[ 0 ].offsetHeight - height >= 15, "prepended rows are visible" );
} );

QUnit.test( "clone()", function( assert ) {

	assert.expect( 45 );

	var div, clone, form, body;

	assert.equal( jQuery( "#en" ).text(), "This is a normal link: Yahoo", "Assert text for #en" );
	assert.equal( jQuery( "#first" ).append( jQuery( "#yahoo" ).clone() ).text(), "Try them out:Yahoo", "Check for clone" );
	assert.equal( jQuery( "#en" ).text(), "This is a normal link: Yahoo", "Reassert text for #en" );

	jQuery.each( "table thead tbody tfoot tr td div button ul ol li select option textarea iframe".split( " " ), function( i, nodeName ) {
		assert.equal( jQuery( "<" + nodeName + "/>" ).clone()[ 0 ].nodeName.toLowerCase(), nodeName, "Clone a " + nodeName );
	} );
	assert.equal( jQuery( "<input type='checkbox' />" ).clone()[ 0 ].nodeName.toLowerCase(), "input", "Clone a <input type='checkbox' />" );

	// Check cloning non-elements
	assert.equal( jQuery( "#nonnodes" ).contents().clone().length, 3, "Check node,textnode,comment clone works (some browsers delete comments on clone)" );

	// Verify that clones of clones can keep event listeners
	div = jQuery( "<div><ul><li>test</li></ul></div>" ).on( "click", function() {
		assert.ok( true, "Bound event still exists." );
	} );
	clone = div.clone( true ); div.remove();
	div = clone.clone( true ); clone.remove();

	assert.equal( div.length, 1, "One element cloned" );
	assert.equal( div[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	div.trigger( "click" );

	// Manually clean up detached elements
	div.remove();

	// Verify that cloned children can keep event listeners
	div = jQuery( "<div></div>" ).append( [ document.createElement( "table" ), document.createElement( "table" ) ] );
	div.find( "table" ).on( "click", function() {
		assert.ok( true, "Bound event still exists." );
	} );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	clone.find( "table" ).trigger( "click" );

	// Manually clean up detached elements
	div.remove();
	clone.remove();

	// Make sure that doing .clone() doesn't clone event listeners
	div = jQuery( "<div><ul><li>test</li></ul></div>" ).on( "click", function() {
		assert.ok( false, "Bound event still exists after .clone()." );
	} );
	clone = div.clone();

	clone.trigger( "click" );

	// Manually clean up detached elements
	clone.remove();
	div.remove();

	// Test both html() and clone() for <embed> and <object> types
	div = jQuery( "<div></div>" ).html( "<embed height='355' width='425' src='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'></embed>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone.html(), div.html(), "Element contents cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );

	// this is technically an invalid object, but because of the special
	// classid instantiation it is the only kind that IE has trouble with,
	// so let's test with it too.
	div = jQuery( "<div></div>" ).html( "<object height='355' width='425' classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'>  <param name='movie' value='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='wmode' value='transparent'> </object>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	div = div.find( "object" );
	clone = clone.find( "object" );

	// oldIE adds extra attributes and <param> elements, so just test for existence of the defined set
	jQuery.each( [ "height", "width", "classid" ], function( i, attr ) {
		assert.equal( clone.attr( attr ), div.attr( attr ), "<object> attribute cloned: " + attr );
	} );
	( function() {
		var params = {};

		clone.find( "param" ).each( function( index, param ) {
			params[ param.attributes.name.nodeValue.toLowerCase() ] =
				param.attributes.value.nodeValue.toLowerCase();
		} );

		div.find( "param" ).each( function( index, param ) {
			var key = param.attributes.name.nodeValue.toLowerCase();
			assert.equal( params[ key ], param.attributes.value.nodeValue.toLowerCase(), "<param> cloned: " + key );
		} );
	} )();

	// and here's a valid one.
	div = jQuery( "<div></div>" ).html( "<object height='355' width='425' type='application/x-shockwave-flash' data='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='movie' value='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='wmode' value='transparent'> </object>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone.html(), div.html(), "Element contents cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );

	div = jQuery( "<div></div>" ).data( { "a": true } );
	clone = div.clone( true );
	assert.equal( clone.data( "a" ), true, "Data cloned." );
	clone.data( "a", false );
	assert.equal( clone.data( "a" ), false, "Ensure cloned element data object was correctly modified" );
	assert.equal( div.data( "a" ), true, "Ensure cloned element data object is copied, not referenced" );

	// manually clean up detached elements
	div.remove();
	clone.remove();

	form = document.createElement( "form" );
	form.action = "/test/";

	div = document.createElement( "div" );
	div.appendChild( document.createTextNode( "test" ) );
	form.appendChild( div );

	assert.equal( jQuery( form ).clone().children().length, 1, "Make sure we just get the form back." );

	body = jQuery( "body" ).clone();
	assert.equal( body.children()[ 0 ].id, "qunit", "Make sure cloning body works" );
	body.remove();
} );

QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {

	assert.expect( 3 );

	var src = jQuery( "<script type='text/filler'>Lorem ipsum dolor sit amet</script><q><script type='text/filler'>consectetur adipiscing elit</script></q>" ),
diff --git a/a.js b/b.js
@@ -1556,7 +1556,7 @@ QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	body = jQuery( "body" ).clone();
	assert.equal( body.children()[ 0 ].id, "qunit", "Make sure cloning body works" );
	body.remove();
} );

QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {

	assert.expect( 3 );

	var src = jQuery( "<script type='text/filler'>Lorem ipsum dolor sit amet</script><q><script type='text/filler'>consectetur adipiscing elit</script></q>" ),
		dest = src.clone();

	assert.equal( dest[ 0 ].text, "Lorem ipsum dolor sit amet", "Cloning preserves script text" );
	assert.equal( dest.last().html(), src.last().html(), "Cloning preserves nested script text" );
	assert.ok( /^\s*<scr.pt\s+type=['"]?text\/filler['"]?\s*>consectetur adipiscing elit<\/scr.pt>\s*$/i.test( dest.last().html() ), "Cloning preserves nested script text" );
	dest.remove();
} );

QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {

	assert.expect( 5 );

	var clone, element;
diff --git a/a.js b/b.js
@@ -1581,7 +1581,7 @@ QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.equal( dest.last().html(), src.last().html(), "Cloning preserves nested script text" );
	assert.ok( /^\s*<scr.pt\s+type=['"]?text\/filler['"]?\s*>consectetur adipiscing elit<\/scr.pt>\s*$/i.test( dest.last().html() ), "Cloning preserves nested script text" );
	dest.remove();
} );

QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {

	assert.expect( 5 );

	var clone, element;

	element = jQuery( "<select><option>Foo</option><option value='selected' selected>Bar</option></select>" );

	assert.equal( element.clone().find( "option" ).filter( function() { return this.selected; } ).val(), "selected", "Selected option cloned correctly" );

	element = jQuery( "<input type='checkbox' value='foo'>" ).attr( "checked", "checked" );
	clone = element.clone();

	assert.equal( clone.is( ":checked" ), element.is( ":checked" ), "Checked input cloned correctly" );
	assert.equal( clone[ 0 ].defaultValue, "foo", "Checked input defaultValue cloned correctly" );

	element = jQuery( "<input type='text' value='foo'>" );
	clone = element.clone();
	assert.equal( clone[ 0 ].defaultValue, "foo", "Text input defaultValue cloned correctly" );

	element = jQuery( "<textarea>foo</textarea>" );
	clone = element.clone();
	assert.equal( clone[ 0 ].defaultValue, "foo", "Textarea defaultValue cloned correctly" );
} );

QUnit.test( "clone(multiple selected options) (Bug #8129)", function( assert ) {

	assert.expect( 1 );

	var element = jQuery( "<select><option>Foo</option><option selected>Bar</option><option selected>Baz</option></select>" );
diff --git a/a.js b/b.js
@@ -1630,14 +1630,14 @@ QUnit.test( "html(undefined)", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	assert.equal( $meter[ 0 ].nodeName, "meter", "Check if nodeName was not changed due to cloning" );
	assert.equal( $meter[ 0 ].nodeType, 1, "Check if nodeType is not changed due to cloning" );
} );

QUnit.test( "html(undefined)", function( assert ) {

	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).html( "<i>test</i>" ).html( undefined ).html().toLowerCase(), "<i>test</i>", ".html(undefined) is chainable (#5571)" );
} );

QUnit.test( "html() on empty set", function( assert ) {

	assert.expect( 1 );

	assert.strictEqual( jQuery().html(), undefined, ".html() returns undefined for empty sets (#11962)" );
} );

function childNodeNames( node ) {
	return jQuery.map( node.childNodes, function( child ) {
diff --git a/a.js b/b.js
@@ -1738,7 +1738,7 @@ jQuery( "#nonnodes" ).contents().html( valueObj( "<b>bold</b>" ) ).each( functio
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.equal( div.html( valueObj( tmp ) ).html().replace( />/g, "&gt;" ), tmp, "Escaped html, leading x" );
	tmp = " " + tmp.slice( 1 );
	assert.equal( div.html( valueObj( tmp ) ).html().replace( />/g, "&gt;" ), tmp, "Escaped html, leading space" );

	actual = []; expected = []; tmp = {};
	jQuery( "#nonnodes" ).contents().html( valueObj( "<b>bold</b>" ) ).each( function() {
		var html = jQuery( this ).html();
		tmp[ this.nodeType ] = true;
		expected.push( this.nodeType === 1 ? "<b>bold</b>" : undefined );
		actual.push( html ? html.toLowerCase() : html );
	} );
	assert.deepEqual( actual, expected, "Set containing element, text node, comment" );
	assert.ok( tmp[ 1 ], "element" );
	assert.ok( tmp[ 3 ], "text node" );
	assert.ok( tmp[ 8 ], "comment" );

	actual = []; expected = [];
	fixture.children( "div" ).html( valueObj( "<b>test</b>" ) ).each( function() {
		expected.push( "B" );
		actual.push( childNodeNames( this ) );
	} );
	assert.equal( expected.length, 7, "Expecting many parents" );
	assert.deepEqual( actual, expected, "Correct childNodes after setting HTML" );

	actual = []; expected = [];
	fixture.html( valueObj( "<style>.foobar{color:green;}</style>" ) ).each( function() {
		expected.push( "STYLE" );
		actual.push( childNodeNames( this ) );
	} );
	assert.equal( expected.length, 1, "Expecting one parent" );
	assert.deepEqual( actual, expected, "Found the inserted style element" );

	fixture.html( valueObj( "<select></select>" ) );
	jQuery( "#qunit-fixture select" ).html( valueObj( "<option>O1</option><option selected='selected'>O2</option><option>O3</option>" ) );
	assert.equal( jQuery( "#qunit-fixture select" ).val(), "O2", "Selected option correct" );

	tmp = fixture.html(
		valueObj( [
			"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: non-script' );</script>",
			"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: text/javascript' );</script>",
			"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: text/ecmascript' );</script>",
			"<script>QUnit.assert.ok( true, 'evaluated: no type' );</script>",
			"<div>",
				"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: inner non-script' );</script>",
				"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: inner text/javascript' );</script>",
				"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: inner text/ecmascript' );</script>",
				"<script>QUnit.assert.ok( true, 'evaluated: inner no type' );</script>",
			"</div>"
		].join( "" ) )
	).find( "script" );
	assert.equal( tmp.length, 8, "All script tags remain." );
	assert.equal( tmp[ 0 ].type, "something/else", "Non-evaluated type." );
	assert.equal( tmp[ 1 ].type, "text/javascript", "Evaluated type." );

	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "foo <form><script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script (#975)' );</script></form>" ) );

	jQuery.scriptorder = 0;
	fixture.html( valueObj( [
		"<script>",
diff --git a/a.js b/b.js
@@ -1888,7 +1888,7 @@ QUnit.test( "html(Function) with incoming value -- jQuery.contents()", function(
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		}
	} );
	assert.ok( pass, "Set HTML" );
} );

QUnit.test( "html(Function) with incoming value -- jQuery.contents()", function( assert ) {

	assert.expect( 14 );

	var actualhtml, j, $div, $div2, insert;

	j = jQuery( "#nonnodes" ).contents();
	actualhtml = j.map( function() {
		return jQuery( this ).html();
	} );

	j.html( function( i, val ) {
		assert.equal( val, actualhtml[ i ], "Make sure the incoming value is correct." );
		return "<b>bold</b>";
	} );

	// Handle the case where no comment is in the document
	if ( j.length === 2 ) {
		assert.equal( null, null, "Make sure the incoming value is correct." );
	}

	assert.equal( j.html().replace( / xmlns="[^"]+"/g, "" ).toLowerCase(), "<b>bold</b>", "Check node,textnode,comment with html()" );

	$div = jQuery( "<div></div>" );

	assert.equal( $div.html( function( i, val ) {
		assert.equal( val, "", "Make sure the incoming value is correct." );
		return 5;
	} ).html(), "5", "Setting a number as html" );

	assert.equal( $div.html( function( i, val ) {
		assert.equal( val, "5", "Make sure the incoming value is correct." );
		return 0;
	} ).html(), "0", "Setting a zero as html" );

	$div2 = jQuery( "<div></div>" );
	insert = "&lt;div&gt;hello1&lt;/div&gt;";
	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val, "", "Make sure the incoming value is correct." );
		return insert;
	} ).html().replace( />/g, "&gt;" ), insert, "Verify escaped insertion." );

	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val.replace( />/g, "&gt;" ), insert, "Make sure the incoming value is correct." );
		return "x" + insert;
	} ).html().replace( />/g, "&gt;" ), "x" + insert, "Verify escaped insertion." );

	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val.replace( />/g, "&gt;" ), "x" + insert, "Make sure the incoming value is correct." );
		return " " + insert;
	} ).html().replace( />/g, "&gt;" ), " " + insert, "Verify escaped insertion." );
} );

QUnit.test( "clone()/html() don't expose jQuery/Sizzle expandos (#12858)", function( assert ) {

	assert.expect( 2 );

	var $content = jQuery( "<div><b><i>text</i></b></div>" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -1975,7 +1975,7 @@ QUnit.test( "remove() event cleaning ", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	assert.ok( jQuery( "#nonnodes" ).contents().length >= 2, "Check node,textnode,comment remove works" );
	jQuery( "#nonnodes" ).contents().remove();
	assert.equal( jQuery( "#nonnodes" ).contents().length, 0, "Check node,textnode,comment remove works" );
} );

QUnit.test( "remove() event cleaning ", function( assert ) {
	assert.expect( 1 );

	var count, first, cleanUp;

	count = 0;
	first = jQuery( "#ap" ).children().first();
	cleanUp = first.on( "click", function() {
		count++;
	} ).remove().appendTo( "#qunit-fixture" ).trigger( "click" );

	assert.strictEqual( 0, count, "Event handler has been removed" );

	// Clean up detached data
	cleanUp.remove();
} );

QUnit.test( "remove() in document order #13779", function( assert ) {
	assert.expect( 1 );

	var last,
		cleanData = jQuery.cleanData;
diff --git a/a.js b/b.js
@@ -2336,7 +2336,7 @@ 	window.corsCallback = function( response ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	var done = assert.async(),
		timeout;

	Globals.register( "corsCallback" );
	window.corsCallback = function( response ) {
		assert.ok( typeof response.headers.origin === "string", "Origin header sent" );
		window.clearTimeout( timeout );
		done();
	};

	var src = baseURL + "mock.php?action=script&cors=1&callback=corsCallback";
	src = src.replace( "localhost", "127.0.0.1" );
	var html = "<script type=\"text/javascript\" src=\"" + src + "\" crossorigin=\"anonymous\"><\/script>";

	jQuery( document.body ).append( html );
	timeout = window.setTimeout( function() {
		assert.ok( false, "Origin header should have been sent" );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function( assert ) {

	assert.expect( 1 );

	try {
diff --git a/a.js b/b.js
@@ -2348,7 +2348,7 @@ QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function(
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		assert.ok( false, "Origin header should have been sent" );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function( assert ) {

	assert.expect( 1 );

	try {
		jQuery( "#no-clone-exception" ).clone();
		assert.ok( true, "cloned with no exceptions" );
	} catch ( e ) {
		assert.ok( false, e.message );
	}
} );

QUnit.test( "Cloned, detached HTML5 elems (#10667,10670)", function( assert ) {

	assert.expect( 7 );

	var $clone,
diff --git a/a.js b/b.js
@@ -2428,7 +2428,7 @@ QUnit.test( "Guard against exceptions when clearing safeChildNodes", function( a
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	// Unbind any remaining events
	$section.off( "click" );
	$clone.off( "click" );
} );

QUnit.test( "Guard against exceptions when clearing safeChildNodes", function( assert ) {

	assert.expect( 1 );

	var div;

	try {
		div = jQuery( "<div></div><hr/><code></code><b></b>" );
	} catch ( e ) {}

	assert.ok( div && div.jquery, "Created nodes safely, guarded against exceptions on safeChildNodes[ -1 ]" );
} );

QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( assert ) {

	assert.expect( 5 );

	assert.strictEqual( jQuery( "<div></div>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.clone" );
diff --git a/a.js b/b.js
@@ -2439,7 +2439,7 @@ QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( asse
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	} catch ( e ) {}

	assert.ok( div && div.jquery, "Created nodes safely, guarded against exceptions on safeChildNodes[ -1 ]" );
} );

QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( assert ) {

	assert.expect( 5 );

	assert.strictEqual( jQuery( "<div></div>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.clone" );
	assert.strictEqual( jQuery( "<div></div>" ).find( "p" ).end().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.fn.find" );
	assert.strictEqual( jQuery( "<div></div>" ).text( "test" ).addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.fn.text" );
	assert.strictEqual( jQuery( "<bdi></bdi>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after clone html5 element" );
	assert.strictEqual( jQuery( "<p></p>" ).appendTo( "<div></div>" ).end().length, jQuery( "<p>test</p>" ).appendTo( "<div></div>" ).end().length, "Elements created with createElement and with createDocumentFragment should be treated alike" );
} );

QUnit.test( "html() - script exceptions bubble (#11743)", function( assert ) {
	assert.expect( 2 );
	var done = assert.async(),
		onerror = window.onerror;

diff --git a/a.js b/b.js
@@ -2481,7 +2481,7 @@ QUnit.test( "checked state is cloned with clone()", function( assert ) {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	};

	jQuery( "#qunit-fixture" ).html( "<script>undefined();</script>" );
} );

QUnit.test( "checked state is cloned with clone()", function( assert ) {

	assert.expect( 2 );

	var elem = jQuery.parseHTML( "<input type='checkbox' checked='checked'/>" )[ 0 ];
	elem.checked = false;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, false, "Checked false state correctly cloned" );

	elem = jQuery.parseHTML( "<input type='checkbox'/>" )[ 0 ];
	elem.checked = true;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, true, "Checked true state correctly cloned" );
} );

QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div>a</div>" ).append( "&nbsp;", jQuery( "<span>b</span>" ), "&nbsp;", jQuery( "<span>c</span>" ) ),
diff --git a/a.js b/b.js
@@ -2497,7 +2497,7 @@ QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( asser
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	elem = jQuery.parseHTML( "<input type='checkbox'/>" )[ 0 ];
	elem.checked = true;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, true, "Checked true state correctly cloned" );
} );

QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div>a</div>" ).append( "&nbsp;", jQuery( "<span>b</span>" ), "&nbsp;", jQuery( "<span>c</span>" ) ),
		nbsp = String.fromCharCode( 160 );

	assert.equal( div.text(), "a" + nbsp + "b" + nbsp + "c", "Appending mixed jQuery with text nodes" );

	div = jQuery( "<div><div></div></div>" )
		.find( "div" )
		.after( "<p>a</p>", "<p>b</p>" )
		.parent();
	assert.equal( div.find( "*" ).length, 3, "added 2 paragraphs after inner div" );
} );

QUnit.test( "script evaluation (#11795)", function( assert ) {

	assert.expect( 13 );

	var scriptsIn, scriptsOut,
diff --git a/a.js b/b.js
@@ -2551,7 +2551,7 @@ 		notOk = function() {
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		fixture = jQuery( "#qunit-fixture" ).empty(),
		objGlobal = ( function() {
			return this;
		} )(),
		isOk = objGlobal.ok,
		notOk = function() {
			var args = arguments;
			args[ 0 ] = !args[ 0 ];
			return isOk.apply( this, args );
		};

	objGlobal.ok = notOk;
	scriptsIn = jQuery( [
		"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: non-script' );</script>",
		"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: text/javascript' );</script>",
		"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: text/ecmascript' );</script>",
		"<script>QUnit.assert.ok( true, 'evaluated: no type' );</script>",
		"<div>",
			"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: inner non-script' );</script>",
			"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: inner text/javascript' );</script>",
			"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: inner text/ecmascript' );</script>",
			"<script>QUnit.assert.ok( true, 'evaluated: inner no type' );</script>",
		"</div>"
	].join( "" ) );
	scriptsIn.appendTo( jQuery( "<div class='detached'></div>" ) );
	objGlobal.ok = isOk;

	scriptsOut = fixture.append( scriptsIn ).find( "script" );
	assert.equal( scriptsOut[ 0 ].type, "something/else", "Non-evaluated type." );
	assert.equal( scriptsOut[ 1 ].type, "text/javascript", "Evaluated type." );
	assert.deepEqual( scriptsOut.get(), fixture.find( "script" ).get(), "All script tags remain." );

	objGlobal.ok = notOk;
	scriptsOut = scriptsOut.add( scriptsOut.clone() ).appendTo( fixture.find( "div" ) );
	assert.deepEqual( fixture.find( "div script" ).get(), scriptsOut.get(), "Scripts cloned without reevaluation" );
	fixture.append( scriptsOut.detach() );
	assert.deepEqual( fixture.children( "script" ).get(), scriptsOut.get(), "Scripts detached without reevaluation" );
	objGlobal.ok = isOk;

	if ( jQuery.ajax ) {
		Globals.register( "testBar" );
		jQuery( "#qunit-fixture" ).append( "<script src='" + url( "mock.php?action=testbar" ) + "'></script>" );
		assert.strictEqual( window.testBar, "bar", "Global script evaluation" );
	} else {
		assert.ok( true, "No jQuery.ajax" );
		assert.ok( true, "No jQuery.ajax" );
	}
} );

QUnit[ jQuery.ajax ? "test" : "skip" ]( "jQuery._evalUrl (#12838)", function( assert ) {

	assert.expect( 5 );

	var message, expectedArgument,
diff --git a/a.js b/b.js
@@ -2620,7 +2620,7 @@ setTimeout( function() {
A blob:30bf169ac46377a62dbd33195eff541897ee9873

	assert.equal( invocations, 3, "htmlPrefilter invoked for all DOM manipulations" );
	assert.equal( fixture.html(), "A-B-C-D-E-F-", "htmlPrefilter modified HTML" );

	// Allow asynchronous script execution to generate assertions
	setTimeout( function() {
		jQuery.htmlPrefilter = htmlPrefilter;
		done();
	}, 100 );
} );

QUnit.test( "insertAfter, insertBefore, etc do not work when destination is original element. Element is removed (#4087)", function( assert ) {

	assert.expect( 10 );

	var elems;
diff --git a/a.js b/b.js
@@ -2654,7 +2654,7 @@ QUnit.test( "insertAfter, insertBefore, etc do not work when destination is orig
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		jQuery.htmlPrefilter = htmlPrefilter;
		done();
	}, 100 );
} );

QUnit.test( "insertAfter, insertBefore, etc do not work when destination is original element. Element is removed (#4087)", function( assert ) {

	assert.expect( 10 );

	var elems;

	jQuery.each( [
		"appendTo",
		"prependTo",
		"insertBefore",
		"insertAfter",
		"replaceAll"
	], function( index, name ) {
		elems = jQuery( [
			"<ul id='test4087-complex'><li class='test4087'><div>c1</div>h1</li><li><div>c2</div>h2</li></ul>",
			"<div id='test4087-simple'><div class='test4087-1'>1<div class='test4087-2'>2</div><div class='test4087-3'>3</div></div></div>",
			"<div id='test4087-multiple'><div class='test4087-multiple'>1</div><div class='test4087-multiple'>2</div></div>"
		].join( "" ) ).appendTo( "#qunit-fixture" );

		// complex case based on https://jsfiddle.net/pbramos/gZ7vB/
		jQuery( "#test4087-complex div" )[ name ]( "#test4087-complex li:last-child div:last-child" );
		assert.equal( jQuery( "#test4087-complex li:last-child div" ).length, name === "replaceAll" ? 1 : 2, name + " a node to itself, complex case." );

		// simple case
		jQuery( ".test4087-1" )[ name ]( ".test4087-1" );
		assert.equal( jQuery( ".test4087-1" ).length, 1, name + " a node to itself, simple case." );

		// clean for next test
		jQuery( "#test4087-complex" ).remove();
		jQuery( "#test4087-simple" ).remove();
		jQuery( "#test4087-multiple" ).remove();
	} );
} );

QUnit.test( "Index for function argument should be received (#13094)", function( assert ) {
	assert.expect( 2 );

	var i = 0;

diff --git a/a.js b/b.js
@@ -2676,7 +2676,7 @@ QUnit.test( "Make sure jQuery.fn.remove can work on elements in documentFragment
A blob:30bf169ac46377a62dbd33195eff541897ee9873
		assert.equal( index, i++, "Index should be correct" );
	} );

} );

QUnit.test( "Make sure jQuery.fn.remove can work on elements in documentFragment", function( assert ) {
	assert.expect( 1 );

	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) );

	jQuery( div ).remove();

	assert.equal( fragment.childNodes.length, 0, "div element was removed from documentFragment" );
} );

QUnit.test( "Make sure specific elements with content created correctly (#13232)", function( assert ) {
	assert.expect( 20 );

	var results = [],
		args = [],
diff --git a/a.js b/b.js
@@ -2711,7 +2711,7 @@ QUnit.test( "Make sure specific elements with content created correctly (#13232)
A blob:30bf169ac46377a62dbd33195eff541897ee9873
	jQuery( div ).remove();

	assert.equal( fragment.childNodes.length, 0, "div element was removed from documentFragment" );
} );

QUnit.test( "Make sure specific elements with content created correctly (#13232)", function( assert ) {
	assert.expect( 20 );

	var results = [],
		args = [],
		elems = {
			thead: "<tr><td>thead</td></tr>",
			tbody: "<tr><td>tbody</td></tr>",
			tfoot: "<tr><td>tfoot</td></tr>",
			colgroup: "<col span='5'></col>",
			caption: "caption",
			tr: "<td>tr</td>",
			th: "th",
			td: "<div>td</div>",
			optgroup: "<option>optgroup</option>",
			option: "option"
		};

	jQuery.each( elems, function( name, value ) {
		var html = "<" + name + ">" + value + "</" + name + ">";
		assert.strictEqual(
			jQuery.parseHTML( "<" + name + ">" + value + "</" + name + ">" )[ 0 ].nodeName.toLowerCase(),
			name,
			name + " is created correctly"
		);

		results.push( name );
		args.push( html );
	} );

	jQuery.fn.append.apply( jQuery( "<div></div>" ), args ).children().each( function( i ) {
		assert.strictEqual( this.nodeName.toLowerCase(), results[ i ] );
	} );
} );

QUnit.test( "Validate creation of multiple quantities of certain elements (#13818)", function( assert ) {
	assert.expect( 22 );

	var tags = [ "thead", "tbody", "tfoot", "colgroup", "col", "caption", "tr", "th", "td", "optgroup", "option" ];

diff --git a/a.js b/b.js
@@ -54,8 +54,8 @@ 	checkSupport = function( assert ) {
A blob:82360c874b42b3e8775a0659051ec55bf9656860
	return;
}

var supportsScroll, alwaysScrollable,
	forceScroll = supportjQuery( "<div></div>" ).css( { width: 2000, height: 2000 } ),
	checkSupport = function( assert ) {

		// Only run once
		checkSupport = false;

		// Append forceScroll to the body instead of #qunit-fixture because the latter is hidden
		forceScroll.appendTo( "body" );
		window.scrollTo( 200, 200 );
		supportsScroll = document.documentElement.scrollTop || document.body.scrollTop;
		forceScroll.detach();

		// Support: iOS <=7 - 12+
		// Hijack the iframe test infrastructure to detect viewport scrollability
		// for pages with position:fixed document element
		var done = assert.async();
		testIframe(
			null,
			"offset/boxes.html",
			function( assert, $, win, doc ) {
				var scrollTop = win.pageYOffset,
					scrollLeft = win.pageXOffset;
				doc.documentElement.style.position = "fixed";
				win.scrollTo( scrollLeft, scrollTop );
				alwaysScrollable = win.pageXOffset !== 0;
				done();
			},
			function mockQUnit_test( _, testCallback ) {
				setTimeout( function() {
					testCallback( assert );
				} );
			}
		);
	};

QUnit.module( "offset", { beforeEach: function( assert ) {
	if ( typeof checkSupport === "function" ) {
		checkSupport( assert );
	}

	// Force a scroll value on the main window to ensure incorrect results
	// if offset is using the scroll offset of the parent window
	forceScroll.appendTo( "body" );
	window.scrollTo( 1, 1 );
	forceScroll.detach();
}, afterEach: moduleTeardown } );

QUnit.test( "empty set", function( assert ) {
	assert.expect( 2 );
	assert.strictEqual( jQuery().offset(), undefined, "offset() returns undefined for empty set (#11962)" );
	assert.strictEqual( jQuery().position(), undefined, "position() returns undefined for empty set (#11962)" );
} );

QUnit.test( "disconnected element", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -187,7 +187,7 @@ testIframe( "absolute", "offset/absolute.html", function( assert, $ ) {
A blob:82360c874b42b3e8775a0659051ec55bf9656860
		assert.equal( jQuery( this.id, doc ).position().top,  this.top,  "jQuery('" + this.id + "').position().top" );
		assert.equal( jQuery( this.id, doc ).position().left, this.left, "jQuery('" + this.id + "').position().left" );
	} );
} );

testIframe( "absolute", "offset/absolute.html", function( assert, $ ) {
	assert.expect( 178 );

	var tests, offset;

	// get offset tests
	tests = [
		{ "id": "#absolute-1",     "top":  1, "left":  1 },
		{ "id": "#absolute-1-1",   "top":  5, "left":  5 },
		{ "id": "#absolute-1-1-1", "top":  9, "left":  9 },
		{ "id": "#absolute-2",     "top": 20, "left": 20 }
	];
	jQuery.each( tests, function() {
		assert.equal( $( this.id ).offset().top,  this.top,  "jQuery('" + this.id + "').offset().top" );
		assert.equal( $( this.id ).offset().left, this.left, "jQuery('" + this.id + "').offset().left" );
	} );

	// get position
	tests = [
		{ "id": "#absolute-1",     "top":  0, "left":  0 },
		{ "id": "#absolute-1-1",   "top":  1, "left":  1 },
		{ "id": "#absolute-1-1-1", "top":  1, "left":  1 },
		{ "id": "#absolute-2",     "top": 19, "left": 19 }
	];
	jQuery.each( tests, function() {
		assert.equal( $( this.id ).position().top,  this.top,  "jQuery('" + this.id + "').position().top" );
		assert.equal( $( this.id ).position().left, this.left, "jQuery('" + this.id + "').position().left" );
	} );

	// test #5781
	offset = $( "#positionTest" ).offset( { "top": 10, "left": 10 } ).offset();
	assert.equal( offset.top,  10, "Setting offset on element with position absolute but 'auto' values." );
	assert.equal( offset.left, 10, "Setting offset on element with position absolute but 'auto' values." );

diff --git a/a.js b/b.js
@@ -468,8 +468,8 @@ testIframe( "scroll", "offset/scroll.html", function( assert, $, win ) {
A blob:82360c874b42b3e8775a0659051ec55bf9656860

	assert.equal( $( "#th-1" ).offset().top, 10, "jQuery('#th-1').offset().top" );
	assert.equal( $( "#th-1" ).offset().left, 10, "jQuery('#th-1').offset().left" );
} );

testIframe( "scroll", "offset/scroll.html", function( assert, $, win ) {
	assert.expect( 26 );

	assert.equal( $( "#scroll-1" ).offset().top, 7, "jQuery('#scroll-1').offset().top" );
	assert.equal( $( "#scroll-1" ).offset().left, 7, "jQuery('#scroll-1').offset().left" );

	assert.equal( $( "#scroll-1-1" ).offset().top, 11, "jQuery('#scroll-1-1').offset().top" );
	assert.equal( $( "#scroll-1-1" ).offset().left, 11, "jQuery('#scroll-1-1').offset().left" );

	// These tests are solely for main/compat consistency
	// Retrieving offset on disconnected/hidden elements is not officially
	// valid input, but will return zeros for back-compat
	assert.equal( $( "#hidden" ).offset().top, 0, "Hidden elements do not subtract scroll" );
	assert.equal( $( "#hidden" ).offset().left, 0, "Hidden elements do not subtract scroll" );

	// scroll offset tests .scrollTop/Left
	assert.equal( $( "#scroll-1" ).scrollTop(), 5, "jQuery('#scroll-1').scrollTop()" );
	assert.equal( $( "#scroll-1" ).scrollLeft(), 5, "jQuery('#scroll-1').scrollLeft()" );

	assert.equal( $( "#scroll-1-1" ).scrollTop(), 0, "jQuery('#scroll-1-1').scrollTop()" );
	assert.equal( $( "#scroll-1-1" ).scrollLeft(), 0, "jQuery('#scroll-1-1').scrollLeft()" );

	// scroll method chaining
	assert.equal( $( "#scroll-1" ).scrollTop( undefined ).scrollTop(), 5, ".scrollTop(undefined) is chainable (#5571)" );
	assert.equal( $( "#scroll-1" ).scrollLeft( undefined ).scrollLeft(), 5, ".scrollLeft(undefined) is chainable (#5571)" );

	win.name = "test";

	if ( !window.supportsScroll ) {
diff --git a/a.js b/b.js
@@ -519,7 +519,7 @@ QUnit.test( "chaining", function( assert ) {
A blob:82360c874b42b3e8775a0659051ec55bf9656860
	assert.equal( $( "body" ).offset().left, 1, "jQuery('#body').offset().left" );
	assert.equal( $( "#firstElement" ).position().left, 5, "$('#firstElement').position().left" );
	assert.equal( $( "#firstElement" ).position().top, 5, "$('#firstElement').position().top" );
} );

QUnit.test( "chaining", function( assert ) {
	assert.expect( 3 );

	var coords = { "top":  1, "left":  1 };
	assert.equal( jQuery( "#absolute-1" ).offset( coords ).jquery, jQuery.fn.jquery, "offset(coords) returns jQuery object" );
	assert.equal( jQuery( "#non-existent" ).offset( coords ).jquery, jQuery.fn.jquery, "offset(coords) with empty jQuery set returns jQuery object" );
	assert.equal( jQuery( "#absolute-1" ).offset( undefined ).jquery, jQuery.fn.jquery, "offset(undefined) returns jQuery object (#5571)" );
} );

// Test complex content under a variety of <html>/<body> positioning styles
( function() {
diff --git a/a.js b/b.js
@@ -729,11 +729,11 @@ QUnit.test( "offsetParent", function( assert ) {
A blob:82360c874b42b3e8775a0659051ec55bf9656860
			} );
		} );
	} );
} )();

QUnit.test( "offsetParent", function( assert ) {
	assert.expect( 13 );

	var body, header, div, area;

	body = jQuery( "body" ).offsetParent();
	assert.equal( body.length, 1, "Only one offsetParent found." );
	assert.equal( body[ 0 ], document.documentElement, "The html element is the offsetParent of the body." );

	header = jQuery( "#qunit" ).offsetParent();
	assert.equal( header.length, 1, "Only one offsetParent found." );
	assert.equal( header[ 0 ], document.documentElement, "The html element is the offsetParent of #qunit." );

	jQuery( "#qunit-fixture" ).css( "position", "absolute" );
	div = jQuery( "#nothiddendivchild" ).offsetParent();
	assert.equal( div.length, 1, "Only one offsetParent found." );
	assert.equal( div[ 0 ], document.getElementById( "qunit-fixture" ), "The #qunit-fixture is the offsetParent of #nothiddendivchild." );
	jQuery( "#qunit-fixture" ).css( "position", "" );

	jQuery( "#nothiddendiv" ).css( "position", "relative" );

	div = jQuery( "#nothiddendivchild" ).offsetParent();
	assert.equal( div.length, 1, "Only one offsetParent found." );
	assert.equal( div[ 0 ], jQuery( "#nothiddendiv" )[ 0 ], "The div is the offsetParent." );

	div = jQuery( "body, #nothiddendivchild" ).offsetParent();
	assert.equal( div.length, 2, "Two offsetParent found." );
	assert.equal( div[ 0 ], document.documentElement, "The html element is the offsetParent of the body." );
	assert.equal( div[ 1 ], jQuery( "#nothiddendiv" )[ 0 ], "The div is the offsetParent." );

	area = jQuery( "<map name=\"imgmap\"><area shape=\"rect\" coords=\"0,0,200,50\"></map>" ).appendTo( "body" ).find( "area" );
	assert.equal( area.offsetParent()[ 0 ], document.documentElement, "The html element is the offsetParent of a map area." );
	area.remove();

	div = jQuery( "<div>" ).css( { "position": "absolute" } ).appendTo( "body" );
	assert.equal( div.offsetParent()[ 0 ], document.documentElement, "Absolutely positioned div returns html as offset parent, see #12139" );
	div.remove();
} );

QUnit.test( "fractions (see #7730 and #7885)", function( assert ) {
	assert.expect( 2 );

	jQuery( "body" ).append( "<div id='fractions'></div>" );

diff --git a/a.js b/b.js
@@ -41,7 +41,7 @@ QUnit.test( "queue() with other types", function( assert ) {
A blob:7735544bce34004729ac24ca1694d149329128ba

if ( !jQuery.fn.queue ) {
	return;
}

QUnit.test( "queue() with other types", function( assert ) {
	var done = assert.async( 2 );
	assert.expect( 14 );


	var $div = jQuery( {} ),
		counter = 0;

	$div.promise( "foo" ).done( function() {
		assert.equal( counter, 0, "Deferred for collection with no queue is automatically resolved" );
	} );

	$div
		.queue( "foo", function() {
			assert.equal( ++counter, 1, "Dequeuing" );
			jQuery.dequeue( this, "foo" );
		} )
		.queue( "foo", function() {
			assert.equal( ++counter, 2, "Dequeuing" );
			jQuery( this ).dequeue( "foo" );
		} )
		.queue( "foo", function() {
			assert.equal( ++counter, 3, "Dequeuing" );
		} )
		.queue( "foo", function() {
			assert.equal( ++counter, 4, "Dequeuing" );
		} );

	$div.promise( "foo" ).done( function() {
		assert.equal( counter, 4, "Testing previous call to dequeue in deferred"  );
		done();
	} );

	assert.equal( $div.queue( "foo" ).length, 4, "Testing queue length" );

	assert.equal( $div.queue( "foo", undefined ).queue( "foo" ).length, 4, ".queue('name',undefined) does nothing but is chainable (#5571)" );

	$div.dequeue( "foo" );

	assert.equal( counter, 3, "Testing previous call to dequeue" );
diff --git a/a.js b/b.js
@@ -55,10 +55,10 @@ QUnit.test( "element", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		}
	}
	assert.ok( good, "Select all elements, no comment nodes" );
} );

QUnit.test( "element", function( assert ) {
	assert.expect( 37 );

	var i, lengthtest, siblingTest, html;
	var fixture = document.getElementById( "qunit-fixture" );

	assert.deepEqual( jQuery( "p", fixture ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a Node context." );
	assert.deepEqual( jQuery( "p", "#qunit-fixture" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a selector context." );
	assert.deepEqual( jQuery( "p", jQuery( "#qunit-fixture" ) ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a jQuery object context." );
	assert.deepEqual( jQuery( "#qunit-fixture" ).find( "p" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a context via .find()." );

	assert.ok( jQuery( "#length" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );
	assert.ok( jQuery( "#lengthtest input" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );

	// #7533
	assert.equal( jQuery( "<div id=\"A'B~C.D[E]\"><p>foo</p></div>" ).find( "p" ).length, 1, "Find where context root is a node and has an ID with CSS3 meta characters" );

	assert.equal( jQuery( "" ).length, 0, "Empty selector returns an empty array" );
	assert.deepEqual( jQuery( "div", document.createTextNode( "" ) ).get(), [],
diff --git a/a.js b/b.js
@@ -142,7 +142,8 @@ QUnit.test( "element", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		}
	}
	assert.ok( good, "Select all elements, no comment nodes" );
} );

QUnit.test( "element", function( assert ) {
	assert.expect( 37 );

	var i, lengthtest, siblingTest, html;
	var fixture = document.getElementById( "qunit-fixture" );

	assert.deepEqual( jQuery( "p", fixture ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a Node context." );
	assert.deepEqual( jQuery( "p", "#qunit-fixture" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a selector context." );
	assert.deepEqual( jQuery( "p", jQuery( "#qunit-fixture" ) ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a jQuery object context." );
	assert.deepEqual( jQuery( "#qunit-fixture" ).find( "p" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a context via .find()." );

	assert.ok( jQuery( "#length" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );
	assert.ok( jQuery( "#lengthtest input" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );

	// #7533
	assert.equal( jQuery( "<div id=\"A'B~C.D[E]\"><p>foo</p></div>" ).find( "p" ).length, 1, "Find where context root is a node and has an ID with CSS3 meta characters" );

	assert.equal( jQuery( "" ).length, 0, "Empty selector returns an empty array" );
	assert.deepEqual( jQuery( "div", document.createTextNode( "" ) ).get(), [],
		"Text element as context fails silently" );

	assert.t( "Element Selector", "html", [ "html" ] );
	assert.t( "Element Selector", "body", [ "body" ] );
	assert.t( "Element Selector", "#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	assert.t( "Leading space", " #qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading tab", "\t#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading carriage return", "\r#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading line feed", "\n#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading form feed", "\f#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing space", "#qunit-fixture p ", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing tab", "#qunit-fixture p\t", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing carriage return", "#qunit-fixture p\r",
		[ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing line feed", "#qunit-fixture p\n", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing form feed", "#qunit-fixture p\f", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	assert.deepEqual(
		jQuery( jQuery( "div ol" ) ).filter( "#qunit-fixture *" ).get(),
		q( "empty", "listWithTabIndex" ),
		"Parent Element"
	);
	assert.deepEqual(
		jQuery( jQuery( "div\tol" ) ).filter( "#qunit-fixture *" ).get(),
		q( "empty", "listWithTabIndex" ),
		"Parent Element (non-space descendant combinator)"
	);

	// Check for unique-ness and sort order
	assert.deepEqual( jQuery( "p, div p" ), jQuery( "p" ), "Check for duplicates: p, div p" );

	jQuery( "<h1 id='h1'></h1><h2 id='h2'></h2><h2 id='h2-2'></h2>" ).prependTo( "#qunit-fixture" );
	assert.t( "Checking sort order", "#qunit-fixture h2, #qunit-fixture h1", [ "h1", "h2", "h2-2" ] );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Checking sort order", "#qunit-fixture h2:first, #qunit-fixture h1:first", [ "h1", "h2" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Checking sort order", "#qunit-fixture p, #qunit-fixture p a",
		[ "firstp", "simon1", "ap", "google", "groups", "anchor1", "mark", "sndp", "en", "yahoo",
			"sap", "anchor2", "simon", "first" ] );

	// Test Conflict ID
	lengthtest = document.getElementById( "lengthtest" );
	assert.deepEqual( jQuery( "#idTest", lengthtest ).get(), q( "idTest" ),
		"Finding element with id of ID." );
	assert.deepEqual( jQuery( "[name='id']", lengthtest ).get(), q( "idTest" ),
		"Finding element with id of ID." );
	assert.deepEqual( jQuery( "input[id='idTest']", lengthtest ).get(), q( "idTest" ),
		"Finding elements with id of ID." );

	if ( QUnit.jQuerySelectors ) {
		siblingTest = document.getElementById( "siblingTest" );
		assert.deepEqual( jQuery( "div em", siblingTest ).get(), [],
			"Element-rooted QSA does not select based on document context" );
		assert.deepEqual( jQuery( "div em, div em, div em:not(div em)", siblingTest ).get(), [],
			"Element-rooted QSA does not select based on document context" );
		assert.deepEqual( jQuery( "div em, em\\,", siblingTest ).get(), [],
			"Escaped commas do not get treated with an id in element-rooted QSA" );
	} else {
		assert.ok( "skip", "Element-rooted QSA behavior different in selector-native" );
		assert.ok( "skip", "Element-rooted QSA behavior different in selector-native" );
		assert.ok( "skip", "Element-rooted QSA behavior different in selector-native" );
	}

	html = "";
	for ( i = 0; i < 100; i++ ) {
		html = "<div>" + html + "</div>";
	}
	html = jQuery( html ).appendTo( document.body );
	assert.ok( !!jQuery( "body div div div" ).length,
		"No stack or performance problems with large amounts of descendants" );
	assert.ok( !!jQuery( "body>div div div" ).length,
		"No stack or performance problems with large amounts of descendants" );
	html.remove();

	// Real use case would be using .watch in browsers with window.watch (see Issue #157)
	q( "qunit-fixture" )[ 0 ].appendChild( document.createElement( "toString" ) ).id = "toString";
	assert.t( "Element name matches Object.prototype property", "toString#toString", [ "toString" ] );
} );

diff --git a/a.js b/b.js
@@ -169,7 +170,7 @@ QUnit.test( "XML Document Selectors", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	// Real use case would be using .watch in browsers with window.watch (see Issue #157)
	q( "qunit-fixture" )[ 0 ].appendChild( document.createElement( "toString" ) ).id = "toString";
	assert.t( "Element name matches Object.prototype property", "toString#toString", [ "toString" ] );
} );

QUnit.test( "XML Document Selectors", function( assert ) {
	assert.expect( 11 );

	var xml = createWithFriesXML();

	assert.equal( jQuery( "foo_bar", xml ).length, 1, "Element Selector with underscore" );
	assert.equal( jQuery( ".component", xml ).length, 1, "Class selector" );
	assert.equal( jQuery( "[class*=component]", xml ).length, 1, "Attribute selector for class" );
	assert.equal( jQuery( "property[name=prop2]", xml ).length, 1, "Attribute selector with name" );
	assert.equal( jQuery( "[name=prop2]", xml ).length, 1, "Attribute selector with name" );
	assert.equal( jQuery( "#seite1", xml ).length, 1, "Attribute selector with ID" );
	assert.equal( jQuery( "component#seite1", xml ).length, 1, "Attribute selector with ID" );
	assert.equal( jQuery( "component", xml ).filter( "#seite1" ).length, 1,
		"Attribute selector filter with ID" );
	assert.equal( jQuery( "meta property thing", xml ).length, 2,
		"Descendent selector and dir caching" );
	if ( QUnit.jQuerySelectors ) {
		assert.ok( jQuery( xml.lastChild ).is( "soap\\:Envelope" ), "Check for namespaced element" );

		xml = jQuery.parseXML( "<?xml version='1.0' encoding='UTF-8'?><root><elem id='1'/></root>" );

		assert.equal( jQuery( "elem:not(:has(*))", xml ).length, 1,
			"Non-qSA path correctly handles numeric ids (jQuery #14142)" );
	} else {
		assert.ok( "skip", "namespaced elements not matching correctly in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}
diff --git a/a.js b/b.js
@@ -214,7 +215,7 @@ QUnit.test( "broken selectors throw", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		assert.ok( "skip", "namespaced elements not matching correctly in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}
} );

QUnit.test( "broken selectors throw", function( assert ) {
	assert.expect( 33 );

	function broken( name, selector ) {
		assert.throws( function() {
			jQuery( selector );
		}, name + ": " + selector );
	}

	broken( "Broken Selector", "[" );
	broken( "Broken Selector", "(" );
	broken( "Broken Selector", "{" );
	broken( "Broken Selector", "<" );
	broken( "Broken Selector", "()" );
	broken( "Broken Selector", "<>" );
	broken( "Broken Selector", "{}" );
	broken( "Broken Selector", "," );
	broken( "Broken Selector", ",a" );
	broken( "Broken Selector", "a," );
	broken( "Post-comma invalid selector", "*,:x" );
	broken( "Identifier with bad escape", "foo\\\fbaz" );
	broken( "Broken Selector", "[id=012345678901234567890123456789" );
	broken( "Doesn't exist", ":visble" );
	broken( "Nth-child", ":nth-child" );
	broken( "Nth-child", ":nth-child(-)" );
	broken( "Nth-child", ":nth-child(asdf)", [] );
	broken( "Nth-child", ":nth-child(2n+-0)" );
	broken( "Nth-child", ":nth-child(2+0)" );
	broken( "Nth-child", ":nth-child(- 1n)" );
	broken( "Nth-child", ":nth-child(-1 n)" );
	broken( "First-child", ":first-child(n)" );
	broken( "Last-child", ":last-child(n)" );
	broken( "Only-child", ":only-child(n)" );
	broken( "Nth-last-last-child", ":nth-last-last-child(1)" );
	broken( "First-last-child", ":first-last-child" );
	broken( "Last-last-child", ":last-last-child" );
	broken( "Only-last-child", ":only-last-child" );

	// Make sure attribute value quoting works correctly. See: #6093
	jQuery( "<input type='hidden' value='2' name='foo.baz' id='attrbad1'/>" +
		"<input type='hidden' value='2' name='foo[baz]' id='attrbad2'/>" )
		.appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -267,7 +268,7 @@ QUnit.test( "id", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	broken( "Attribute equals unquoted non-identifier", "input[name=foo[baz]]" );
	broken( "Attribute equals bad string", "input[name=''double-quoted'']" );
	broken( "Attribute equals bad string", "input[name='apostrophe'd']" );
} );

QUnit.test( "id", function( assert ) {
	assert.expect( 34 );

	var fiddle, a;

	assert.t( "ID Selector", "#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "body#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "ul#first", [] );
	assert.t( "ID selector with existing ID descendant", "#firstp #simon1", [ "simon1" ] );
	assert.t( "ID selector with non-existent descendant", "#firstp #foobar", [] );
	assert.t( "ID selector using UTF8", "#Taibei", [ "Taibei" ] );
	assert.t( "Multiple ID selectors using UTF8", "#Taibei, #", [ "Taibei", "" ] );
	assert.t( "Descendant ID selector using UTF8", "div #", [ "" ] );
	assert.t( "Child ID selector using UTF8", "form > #", [ "" ] );

	assert.t( "Escaped ID", "#foo\\:bar", [ "foo:bar" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Escaped ID with descendant", "#foo\\:bar span:not(:input)", [ "foo_descendant" ] );
	} else {
		assert.ok( "skip", ":input not supported in selector-native" );
	}

	assert.t( "Escaped ID", "#test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Descendant escaped ID", "div #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Descendant escaped ID", "div #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Child escaped ID", "form > #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Child escaped ID", "form > #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );

	fiddle = jQuery( "<div id='fiddle\\Foo'><span id='fiddleSpan'></span></div>" )
		.appendTo( "#qunit-fixture" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "> span", jQuery( "#fiddle\\\\Foo" )[ 0 ] ).get(),
			q( [ "fiddleSpan" ] ), "Escaped ID as context" );
	} else {
		assert.ok( "skip", "leading > not supported in selector-native" );
	}

	fiddle.remove();

	assert.t( "ID Selector, child ID present", "#form > #radio1", [ "radio1" ] ); // bug #267
	assert.t( "ID Selector, not an ancestor ID", "#form #first", [] );
	assert.t( "ID Selector, not a child ID", "#form > #option1a", [] );

	assert.t( "All Children of ID", "#foo > *", [ "sndp", "en", "sap" ] );
diff --git a/a.js b/b.js
@@ -288,7 +289,7 @@ QUnit.test( "id", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	broken( "Attribute equals unquoted non-identifier", "input[name=foo[baz]]" );
	broken( "Attribute equals bad string", "input[name=''double-quoted'']" );
	broken( "Attribute equals bad string", "input[name='apostrophe'd']" );
} );

QUnit.test( "id", function( assert ) {
	assert.expect( 34 );

	var fiddle, a;

	assert.t( "ID Selector", "#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "body#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "ul#first", [] );
	assert.t( "ID selector with existing ID descendant", "#firstp #simon1", [ "simon1" ] );
	assert.t( "ID selector with non-existent descendant", "#firstp #foobar", [] );
	assert.t( "ID selector using UTF8", "#Taibei", [ "Taibei" ] );
	assert.t( "Multiple ID selectors using UTF8", "#Taibei, #", [ "Taibei", "" ] );
	assert.t( "Descendant ID selector using UTF8", "div #", [ "" ] );
	assert.t( "Child ID selector using UTF8", "form > #", [ "" ] );

	assert.t( "Escaped ID", "#foo\\:bar", [ "foo:bar" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Escaped ID with descendant", "#foo\\:bar span:not(:input)", [ "foo_descendant" ] );
	} else {
		assert.ok( "skip", ":input not supported in selector-native" );
	}

	assert.t( "Escaped ID", "#test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Descendant escaped ID", "div #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Descendant escaped ID", "div #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Child escaped ID", "form > #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Child escaped ID", "form > #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );

	fiddle = jQuery( "<div id='fiddle\\Foo'><span id='fiddleSpan'></span></div>" )
		.appendTo( "#qunit-fixture" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "> span", jQuery( "#fiddle\\\\Foo" )[ 0 ] ).get(),
			q( [ "fiddleSpan" ] ), "Escaped ID as context" );
	} else {
		assert.ok( "skip", "leading > not supported in selector-native" );
	}

	fiddle.remove();

	assert.t( "ID Selector, child ID present", "#form > #radio1", [ "radio1" ] ); // bug #267
	assert.t( "ID Selector, not an ancestor ID", "#form #first", [] );
	assert.t( "ID Selector, not a child ID", "#form > #option1a", [] );

	assert.t( "All Children of ID", "#foo > *", [ "sndp", "en", "sap" ] );
	assert.t( "All Children of ID with no children", "#firstUL > *", [] );

	assert.equal( jQuery( "#tName1" )[ 0 ].id, "tName1",
		"ID selector with same value for a name attribute" );
	assert.t( "ID selector non-existing but name attribute on an A tag", "#tName2", [] );
	assert.t( "Leading ID selector non-existing but name attribute on an A tag", "#tName2 span", [] );
	assert.t( "Leading ID selector existing, retrieving the child", "#tName1 span", [ "tName1-span" ] );
	assert.equal( jQuery( "div > div #tName1" )[ 0 ].id, jQuery( "#tName1-span" )[ 0 ].parentNode.id,
		"Ending with ID" );

	a = jQuery( "<a id='backslash\\foo'></a>" ).appendTo( "#qunit-fixture" );
	assert.t( "ID Selector contains backslash", "#backslash\\\\foo", [ "backslash\\foo" ] );
	a.remove();

	assert.t( "ID Selector on Form with an input that has a name of 'id'", "#lengthtest", [ "lengthtest" ] );

	assert.t( "ID selector with non-existent ancestor", "#asdfasdf #foobar", [] ); // bug #986

	assert.deepEqual( jQuery( "div#form", document.body ).get(), [],
		"ID selector within the context of another element" );

diff --git a/a.js b/b.js
@@ -485,7 +486,7 @@ QUnit.test( "child and adjacent", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	assert.equal( fixture.find( "h2, div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "p" ).length, 2, "has to find two <p>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
} );

QUnit.test( "child and adjacent", function( assert ) {
	assert.expect( 43 );

	var siblingFirst, en, nothiddendiv;

	assert.t( "Child", "p > a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus leading whitespace", "p> a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus trailing whitespace", "p >a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus whitespace", "p>a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child w/ Class", "p > a.blog", [ "mark", "simon" ] );
	assert.t( "All Children", "code > *", [ "anchor1", "anchor2" ] );
	assert.selectInFixture( "All Grandchildren", "p > * > *", [ "anchor1", "anchor2" ] );

	assert.t( "Rooted tag adjacent", "#qunit-fixture a + a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus whitespace", "#qunit-fixture a+a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus leading whitespace", "#qunit-fixture a +a",
		[ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus trailing whitespace", "#qunit-fixture a+ a",
		[ "groups", "tName2ID" ] );

	assert.t( "Tag adjacent", "p + p", [ "ap", "en", "sap" ] );
	assert.t( "#id adjacent", "#firstp + p", [ "ap" ] );
	assert.t( "Tag#id adjacent", "p#firstp + p", [ "ap" ] );
	assert.t( "Tag[attr] adjacent", "p[lang=en] + p", [ "sap" ] );
	assert.t( "Tag.class adjacent", "a.GROUPS + code + a", [ "mark" ] );
	assert.t( "Comma, Child, and Adjacent", "#qunit-fixture a + a, code > a",
		[ "groups", "anchor1", "anchor2", "tName2ID" ] );

	assert.t( "Element Preceded By", "#qunit-fixture p ~ div",
		[ "foo", "nothiddendiv", "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#first ~ div",
		[ "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#groups ~ a", [ "mark" ] );
	assert.t( "Element Preceded By", "#length ~ input", [ "idTest" ] );
	assert.t( "Element Preceded By", "#siblingfirst ~ em", [ "siblingnext", "siblingthird" ] );
	assert.t( "Element Preceded By (multiple)", "#siblingTest em ~ em ~ em ~ span", [ "siblingspan" ] );

	siblingFirst = document.getElementById( "siblingfirst" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "+ em", siblingFirst ).get(), q( "siblingnext" ),
			"Element Directly Preceded By with a context." );
		assert.deepEqual( jQuery( "~ em", siblingFirst ).get(), q( "siblingnext", "siblingthird" ),
			"Element Preceded By with a context." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading ~ not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.deepEqual( jQuery( "~ em:first", siblingFirst ).get(), q( "siblingnext" ),
			"Element Preceded By positional with a context." );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	if ( QUnit.jQuerySelectors ) {
		en = document.getElementById( "en" );
		assert.deepEqual( jQuery( "+ p, a", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, beginning with sibling test." );
		assert.deepEqual( jQuery( "a, + p", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, containing sibling test." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading + not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Element Preceded By, Containing", "#liveHandlerOrder ~ div em:contains('1')", [ "siblingfirst" ] );
		assert.t( "Combinators are not skipped when mixing general and specific", "#siblingTest > em:contains('x') + em ~ span", [] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.equal( jQuery( "#listWithTabIndex li:eq(2) ~ li" ).length, 1, "Find by general sibling combinator (#8310)" );

		nothiddendiv = document.getElementById( "nothiddendiv" );
		assert.deepEqual( jQuery( "> :first", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
diff --git a/a.js b/b.js
@@ -505,9 +506,9 @@ QUnit.test( "child and adjacent", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	assert.equal( fixture.find( "h2, div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "p" ).length, 2, "has to find two <p>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
} );

QUnit.test( "child and adjacent", function( assert ) {
	assert.expect( 43 );

	var siblingFirst, en, nothiddendiv;

	assert.t( "Child", "p > a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus leading whitespace", "p> a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus trailing whitespace", "p >a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus whitespace", "p>a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child w/ Class", "p > a.blog", [ "mark", "simon" ] );
	assert.t( "All Children", "code > *", [ "anchor1", "anchor2" ] );
	assert.selectInFixture( "All Grandchildren", "p > * > *", [ "anchor1", "anchor2" ] );

	assert.t( "Rooted tag adjacent", "#qunit-fixture a + a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus whitespace", "#qunit-fixture a+a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus leading whitespace", "#qunit-fixture a +a",
		[ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus trailing whitespace", "#qunit-fixture a+ a",
		[ "groups", "tName2ID" ] );

	assert.t( "Tag adjacent", "p + p", [ "ap", "en", "sap" ] );
	assert.t( "#id adjacent", "#firstp + p", [ "ap" ] );
	assert.t( "Tag#id adjacent", "p#firstp + p", [ "ap" ] );
	assert.t( "Tag[attr] adjacent", "p[lang=en] + p", [ "sap" ] );
	assert.t( "Tag.class adjacent", "a.GROUPS + code + a", [ "mark" ] );
	assert.t( "Comma, Child, and Adjacent", "#qunit-fixture a + a, code > a",
		[ "groups", "anchor1", "anchor2", "tName2ID" ] );

	assert.t( "Element Preceded By", "#qunit-fixture p ~ div",
		[ "foo", "nothiddendiv", "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#first ~ div",
		[ "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#groups ~ a", [ "mark" ] );
	assert.t( "Element Preceded By", "#length ~ input", [ "idTest" ] );
	assert.t( "Element Preceded By", "#siblingfirst ~ em", [ "siblingnext", "siblingthird" ] );
	assert.t( "Element Preceded By (multiple)", "#siblingTest em ~ em ~ em ~ span", [ "siblingspan" ] );

	siblingFirst = document.getElementById( "siblingfirst" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "+ em", siblingFirst ).get(), q( "siblingnext" ),
			"Element Directly Preceded By with a context." );
		assert.deepEqual( jQuery( "~ em", siblingFirst ).get(), q( "siblingnext", "siblingthird" ),
			"Element Preceded By with a context." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading ~ not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.deepEqual( jQuery( "~ em:first", siblingFirst ).get(), q( "siblingnext" ),
			"Element Preceded By positional with a context." );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	if ( QUnit.jQuerySelectors ) {
		en = document.getElementById( "en" );
		assert.deepEqual( jQuery( "+ p, a", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, beginning with sibling test." );
		assert.deepEqual( jQuery( "a, + p", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, containing sibling test." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading + not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Element Preceded By, Containing", "#liveHandlerOrder ~ div em:contains('1')", [ "siblingfirst" ] );
		assert.t( "Combinators are not skipped when mixing general and specific", "#siblingTest > em:contains('x') + em ~ span", [] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.equal( jQuery( "#listWithTabIndex li:eq(2) ~ li" ).length, 1, "Find by general sibling combinator (#8310)" );

		nothiddendiv = document.getElementById( "nothiddendiv" );
		assert.deepEqual( jQuery( "> :first", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
		assert.deepEqual( jQuery( "> :eq(0)", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
		assert.deepEqual( jQuery( "> *:first", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Multiple combinators selects all levels", "#siblingTest em *", [ "siblingchild", "siblinggrandchild", "siblinggreatgrandchild" ] );
	assert.t( "Multiple combinators selects all levels", "#siblingTest > em *", [ "siblingchild", "siblinggrandchild", "siblinggreatgrandchild" ] );
	assert.t( "Multiple sibling combinators doesn't miss general siblings", "#siblingTest > em:first-child + em ~ span", [ "siblingspan" ] );

	assert.equal( jQuery( "#listWithTabIndex" ).length, 1, "Parent div for next test is found via ID (#8310)" );
	assert.equal( jQuery( "#__sizzle__" ).length, 0, "Make sure the temporary id assigned by sizzle is cleared out (#8310)" );
	assert.equal( jQuery( "#listWithTabIndex" ).length, 1, "Parent div for previous test is still found via ID (#8310)" );

	assert.t( "Verify deep class selector", "div.blah > p > a", [] );
	assert.t( "No element deep selector", "div.foo > span > a", [] );
	assert.t( "Non-existent ancestors", ".fototab > .thumbnails > a", [] );
diff --git a/a.js b/b.js
@@ -555,7 +556,7 @@ QUnit.test( "attributes - equals", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	assert.t( "On implicit element", "#qunit-fixture [title]", [ "google" ] );
	assert.t( "Boolean", "#select2 option[selected]", [ "option2d" ] );
	assert.t( "For attribute on label", "form label[for]", [ "label-for" ] );
} );

QUnit.test( "attributes - equals", function( assert ) {
	assert.expect( 20 );

	var withScript;

	assert.t( "Identifier", "#qunit-fixture a[rel=bookmark]", [ "simon1" ] );
	assert.t( "Identifier with underscore", "input[id=types_all]", [ "types_all" ] );
	assert.t( "String", "#qunit-fixture a[rel='bookmark']", [ "simon1" ] );
	assert.t( "String (whitespace ignored)", "#qunit-fixture a[ rel = 'bookmark' ]", [ "simon1" ] );
	assert.t( "Non-identifier string", "#qunit-fixture a[href='https://www.google.com/']", [ "google" ] );
	assert.t( "Empty string", "#select1 option[value='']", [ "option1a" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Number",
			"#qunit-fixture option[value=1]",
			[ "option1b", "option2b", "option3b", "option4b", "option5c" ] );
		assert.t( "negative number",
			"#qunit-fixture li[tabIndex=-1]", [ "foodWithNegativeTabIndex" ] );
	} else {
		assert.ok( "skip", "Number value not supported in selector-native" );
		assert.ok( "skip", "Negative number value not supported in selector-native" );
	}

	assert.t( "Non-ASCII identifier", "span[lang=]", [ "" ] );

	assert.t( "input[type=text]", "#form input[type=text]", [ "text1", "text2", "hidden2", "name" ] );
	assert.t( "input[type=search]", "#form input[type=search]", [ "search" ] );

	withScript = supportjQuery( "<div><span><script src=''></script></span></div>" );
	assert.ok( withScript.find( "#moretests script[src]" ).has( "script" ), "script[src] (jQuery #13777)" );

	assert.t( "Boolean attribute equals name", "#select2 option[selected='selected']", [ "option2d" ] );
	assert.t( "for Attribute in form", "#form [for=action]", [ "label-for" ] );
	assert.t( "Grouped Form Elements - name", "input[name='foo[bar]']", [ "hidden2" ] );
diff --git a/a.js b/b.js
@@ -642,7 +643,7 @@ QUnit.test( "attributes - special characters", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		"#names-group span[id|='name-is']",
		[ "name-is-example", "name-is-div" ] );
	assert.t( "string ending with hyphen", "#names-group span[id|='name-is-']", [] );
} );

QUnit.test( "attributes - special characters", function( assert ) {
	assert.expect( 16 );

	var attrbad;
	var div = document.createElement( "div" );

	// trac-3279
	div.innerHTML = "<div id='foo' xml:test='something'></div>";
	assert.deepEqual( jQuery( "[xml\\:test]", div ).get(),
		[ div.firstChild ],
		"attribute name containing colon" );
diff --git a/a.js b/b.js
@@ -741,7 +742,7 @@ QUnit.test( "attributes - others", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	assert.deepEqual( jQuery( attrbad ).filter( "input[data-attr='\\01D306A']" ).get(),
		q( "attrbad_unicode" ),
		"Long numeric escape (non-BMP)" );
} );

QUnit.test( "attributes - others", function( assert ) {
	assert.expect( 14 );

	var div = document.getElementById( "foo" );

	assert.t( "Find elements with a tabindex attribute", "[tabindex]", [ "listWithTabIndex", "foodWithNegativeTabIndex", "linkWithTabIndex", "linkWithNegativeTabIndex", "linkWithNoHrefWithTabIndex", "linkWithNoHrefWithNegativeTabIndex" ] );

	assert.t( "Selector list with multiple quoted attribute-equals",
		"#form input[type='radio'], #form input[type='hidden']",
		[ "radio1", "radio2", "hidden1" ] );
	assert.t( "Selector list with differently-quoted attribute-equals",
		"#form input[type='radio'], #form input[type=\"hidden\"]",
		[ "radio1", "radio2", "hidden1" ] );
	assert.t( "Selector list with quoted and unquoted attribute-equals",
		"#form input[type='radio'], #form input[type=hidden]",
		[ "radio1", "radio2", "hidden1" ] );

	assert.t( "Object.prototype property \"constructor\" (negative)", "[constructor]", [] );
	assert.t( "Gecko Object.prototype property \"watch\" (negative)", "[watch]", [] );
	div.setAttribute( "constructor", "foo" );
	div.setAttribute( "watch", "bar" );
	assert.t( "Object.prototype property \"constructor\"", "[constructor='foo']", [ "foo" ] );
	assert.t( "Gecko Object.prototype property \"watch\"", "[watch='bar']", [ "foo" ] );

	// #11115
	assert.ok( jQuery( "<input type='checkbox' checked='checked'/>" ).prop( "checked", false ).is( "[checked]" ),
		"[checked] selects by attribute (positive)"
	);
	assert.ok( !jQuery( "<input type='checkbox'/>" ).prop( "checked", true ).is( "[checked]" ),
diff --git a/a.js b/b.js
@@ -1283,7 +1284,7 @@ QUnit.test( "pseudo - :not", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit.test( "pseudo - :not", function( assert ) {
	assert.expect( 43 );

	assert.t( "Not", "a.blog:not(.link)", [ "mark" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Not - multiple", "#form option:not(:contains(Nothing),#option1b,:selected)", [ "option1c", "option1d", "option2b", "option2c", "option3d", "option3e", "option4e", "option5b", "option5c" ] );
		assert.t( "Not - recursive", "#form option:not(:not(:selected))[id^='option3']", [ "option3b", "option3c" ] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":selected not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( ":not() with :first", "#foo p:not(:first) .link", [ "simon" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( ":not() failing interior", "#qunit-fixture p:not(.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not() failing interior", "#qunit-fixture p:not(#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	if ( QUnit.jQuerySelectors || !QUnit.isIE ) {
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	} else {
		// Support: IE 11+
		// IE doesn't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	assert.t( ":not Multiple", "#qunit-fixture p:not(a)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( a )", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( p )", [] );
	assert.t( ":not Multiple", "p:not(p)", [] );

	if ( QUnit.jQuerySelectors || !QUnit.isIE ) {
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b, div)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "p:not(a,p)", [] );
		assert.t( ":not Multiple", "p:not(p,a)", [] );
		assert.t( ":not Multiple", "p:not(a,p,b)", [] );
	} else {
		// Support: IE 11+
		// IE doesn't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( ":not Multiple", ":input:not(:image,:input,:submit)", [] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(:has(a), :nth-child(1))", [ "first" ] );
	} else {
		assert.ok( "skip", ":image, :input, :submit not supported in selector-native" );
		assert.ok( "skip", ":has not supported in selector-native" );
	}

	assert.t( "No element not selector", ".container div:not(.excluded) div", [] );

	assert.t( ":not() Existing attribute", "#form select:not([multiple])", [ "select1", "select2", "select5" ] );
	assert.t( ":not() Equals attribute", "#form select:not([name=select1])", [ "select2", "select3", "select4", "select5" ] );
	assert.t( ":not() Equals quoted attribute", "#form select:not([name='select1'])", [ "select2", "select3", "select4", "select5" ] );

	assert.t( ":not() Multiple Class", "#foo a:not(.blog)", [ "yahoo", "anchor2" ] );
	assert.t( ":not() Multiple Class", "#foo a:not(.link)", [ "yahoo", "anchor2" ] );

	if ( QUnit.jQuerySelectors || !QUnit.isIE ) {
		assert.t( ":not() Multiple Class", "#foo a:not(.blog.link)", [ "yahoo", "anchor2" ] );
	} else {
		// Support: IE 11+
		// IE doesn't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( ":not chaining (compound)", "#qunit-fixture div[id]:not(:has(div, span)):not(:has(*))", [ "nothiddendivchild", "divWithNoTabIndex", "fx-tests" ] );
		assert.t( ":not chaining (with attribute)", "#qunit-fixture form[id]:not([action$='formaction']):not(:button)", [ "lengthtest", "name-tests", "testForm", "disabled-tests" ] );
		assert.t( ":not chaining (colon in attribute)", "#qunit-fixture form[id]:not([action='form:action']):not(:button)", [ "form", "lengthtest", "name-tests", "testForm", "disabled-tests" ] );
		assert.t( ":not chaining (colon in attribute and nested chaining)", "#qunit-fixture form[id]:not([action='form:action']:button):not(:input)", [ "form", "lengthtest", "name-tests", "testForm", "disabled-tests" ] );
		assert.t( ":not chaining", "#form select:not(.select1):contains(Nothing) > option:not(option)", [] );
	} else {
		assert.ok( "skip", ":has not supported in selector-native" );
		assert.ok( "skip", ":button not supported in selector-native" );
		assert.ok( "skip", ":button not supported in selector-native" );
		assert.ok( "skip", ":button not supported in selector-native" );
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "positional :not()", "#foo p:not(:last)", [ "sndp", "en" ] );
		assert.t( "positional :not() prefix", "#foo p:not(:last) a", [ "yahoo" ] );
		assert.t( "compound positional :not()", "#foo p:not(:first, :last)", [ "en" ] );
		assert.t( "compound positional :not()", "#foo p:not(:first, :even)", [ "en" ] );
		assert.t( "compound positional :not()", "#foo p:not(:first, :odd)", [ "sap" ] );
		assert.t( "reordered compound positional :not()", "#foo p:not(:odd, :first)", [ "sap" ] );

		assert.t( "positional :not() with pre-filter", "#foo p:not([id]:first)", [ "en", "sap" ] );
		assert.t( "positional :not() with post-filter", "#foo p:not(:first[id])", [ "en", "sap" ] );
		assert.t( "positional :not() with pre-filter", "#foo p:not([lang]:first)", [ "sndp", "sap" ] );
		assert.t( "positional :not() with post-filter", "#foo p:not(:first[lang])", [ "sndp", "en", "sap" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );

		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit[ QUnit.jQuerySelectorsPos ? "test" : "skip" ]( "pseudo - position", function( assert ) {
	assert.expect( 34 );

	assert.t( "First element", "#qunit-fixture p:first", [ "firstp" ] );
	assert.t( "First element(case-insensitive)", "#qunit-fixture p:fiRst", [ "firstp" ] );
	assert.t( "nth Element", "#qunit-fixture p:nth(1)", [ "ap" ] );
	assert.t( "First Element", "#qunit-fixture p:first", [ "firstp" ] );
	assert.t( "Last Element", "p:last", [ "first" ] );
	assert.t( "Even Elements", "#qunit-fixture p:even", [ "firstp", "sndp", "sap" ] );
	assert.t( "Odd Elements", "#qunit-fixture p:odd", [ "ap", "en", "first" ] );
	assert.t( "Position Equals", "#qunit-fixture p:eq(1)", [ "ap" ] );
	assert.t( "Position Equals (negative)", "#qunit-fixture p:eq(-1)", [ "first" ] );
	assert.t( "Position Greater Than", "#qunit-fixture p:gt(0)", [ "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Position Less Than", "#qunit-fixture p:lt(3)", [ "firstp", "ap", "sndp" ] );
	assert.t( "Position Less Than Big Number", "#qunit-fixture p:lt(9007199254740991)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	assert.t( "Check position filtering", "div#nothiddendiv:eq(0)", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div#nothiddendiv:last", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div#nothiddendiv:not(:gt(0))", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "#foo > :not(:first)", [ "en", "sap" ] );
	assert.t( "Check position filtering", "#qunit-fixture select > :not(:gt(2))", [ "option1a", "option1b", "option1c" ] );
	assert.t( "Check position filtering", "#qunit-fixture select:lt(2) :not(:first)", [ "option1b", "option1c", "option1d", "option2a", "option2b", "option2c", "option2d" ] );
	assert.t( "Check position filtering", "div.nothiddendiv:eq(0)", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div.nothiddendiv:last", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div.nothiddendiv:not(:lt(0))", [ "nothiddendiv" ] );

	assert.t( "Check element position", "#qunit-fixture div div:eq(0)", [ "nothiddendivchild" ] );
	assert.t( "Check element position", "#select1 option:eq(3)", [ "option1d" ] );
	assert.t( "Check element position", "#qunit-fixture div div:eq(10)", [ "no-clone-exception" ] );
	assert.t( "Check element position", "#qunit-fixture div div:first", [ "nothiddendivchild" ] );
	assert.t( "Check element position", "#qunit-fixture div > div:first", [ "nothiddendivchild" ] );
	assert.t( "Check element position", "#qunit-fixture div:first a:first", [ "yahoo" ] );
	assert.t( "Check element position", "#qunit-fixture div:first > p:first", [ "sndp" ] );
	assert.t( "Check element position", "div#nothiddendiv:first > div:first", [ "nothiddendivchild" ] );
	assert.t( "Chained pseudo after a pos pseudo", "#listWithTabIndex li:eq(0):contains(Rice)", [ "foodWithNegativeTabIndex" ] );

	assert.t( "Check sort order with POS and comma", "#qunit-fixture em>em>em>em:first-child,div>em:first", [ "siblingfirst", "siblinggreatgrandchild" ] );

	assert.t( "Isolated position", "#qunit-fixture :last", [ "last" ] );

	assert.deepEqual(
		jQuery( "#qunit-fixture > p" ).filter( "*:lt(2) + *" ).get(),
		q( "ap" ),
		"Seeded pos with trailing relative" );

	// jQuery #12526
	var context = jQuery( "#qunit-fixture" ).append( "<div id='jquery12526'></div>" )[ 0 ];
	assert.deepEqual( jQuery( ":last", context ).get(), q( "jquery12526" ),
		"Post-manipulation positional" );
} );
diff --git a/a.js b/b.js
@@ -1654,7 +1655,7 @@ QUnit.test( "context", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		docElem.setAttribute( "xml:lang", docXmlLang );
	}
	docElem.lang = docLang;
} );

QUnit.test( "context", function( assert ) {
	assert.expect( 21 );

	var context,
		selector = ".blog",
		expected = q( "mark", "simon" ),
		iframe = document.getElementById( "iframe" ),
		iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

	assert.deepEqual( jQuery( selector, document ).get(), expected, "explicit document context" );
	assert.deepEqual( jQuery( selector ).get(), expected, "unspecified context becomes document" );
	assert.deepEqual( jQuery( selector, undefined ).get(), expected,
		"undefined context becomes document" );
	assert.deepEqual( jQuery( selector, null ).get(), expected, "null context becomes document" );

	iframeDoc.open();
	iframeDoc.write( "<body><p id='foo'>bar</p></body>" );
	iframeDoc.close();
	expected = [ iframeDoc.getElementById( "foo" ) ];
	assert.deepEqual( jQuery( "p", iframeDoc ).get(), expected, "Other document context (simple)" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "p:contains(ar)", iframeDoc ).get(), expected,
			"Other document context (complex)" );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	assert.deepEqual( jQuery( "span", iframeDoc ).get(), [],
		"Other document context (simple, no results)" );
	assert.deepEqual( jQuery( "* span", iframeDoc ).get(), [],
		"Other document context (complex, no results)" );

	context = document.getElementById( "nothiddendiv" );
	assert.deepEqual( jQuery( "*", context ).get(), q( "nothiddendivchild" ), "<div> context" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "* > *", context ).get(), [], "<div> context (no results)" );
	} else {
		assert.ok( "skip", "The whole selector not required to be under context in selector-native" );
	}

	context.removeAttribute( "id" );
	assert.deepEqual( jQuery( "*", context ).get(), q( "nothiddendivchild" ), "no-id element context" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "* > *", context ).get(), [], "no-id element context (no results)" );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	assert.strictEqual( context.getAttribute( "id" ) || "", "", "id not added by no-id selection" );

	context = document.getElementById( "lengthtest" );
	assert.deepEqual( jQuery( "input", context ).get(), q( "length", "idTest" ), "<form> context" );
	assert.deepEqual( jQuery( "select", context ).get(), [], "<form> context (no results)" );

	context = document.getElementById( "Taibei" );
	expected = q( "Taibei-child" );
	assert.deepEqual( jQuery( "span[id]", context ).get(), expected, "context with non-ASCII id" );
	assert.deepEqual( jQuery( "#Taibei span[id]", context.parentNode ).get(), expected,
		"context with non-ASCII id selector prefix" );

	context = document.createDocumentFragment();

	// Capture *independent* expected nodes before they're detached from the page
	expected = q( "siblingnext", "siblingspan" );
	context.appendChild( document.getElementById( "siblingTest" ) );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual(
			jQuery( "em:nth-child(2)", context ).get(),
			expected.slice( 0, 1 ),
			"DocumentFragment context"
		);
		assert.deepEqual( jQuery( "span", context ).get(), expected.slice( 1 ),
			"DocumentFragment context by tag name" );
		assert.deepEqual( jQuery( "p", context ).get(), [], "DocumentFragment context (no results)" );
	} else {
		assert.ok( "skip", "selection on document fragments not supported in selector-native" );
		assert.ok( "skip", "selection on document fragments not supported in selector-native" );
		assert.ok( "skip", "selection on document fragments not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual(
			jQuery( "em + :not(:has(*)):not(:empty), foo", context.firstChild ).get(),
			expected.slice( 0, 1 ),
			"Non-qSA path correctly sets detached context for sibling selectors (jQuery #14351)"
		);
	} else {
		assert.ok( "skip", ":has not supported in selector-native" );
	}
diff --git a/a.js b/b.js
@@ -1705,7 +1706,7 @@ QUnit.test( "caching does not introduce bugs", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
		assert.ok( true, "Mutation observer didn't fire during selection" );
		done();
	} );
} );

QUnit.test( "caching does not introduce bugs", function( assert ) {
	assert.expect( 3 );

	var sap = document.getElementById( "sap" );

	jQuery( ":not(code)", document.getElementById( "ap" ) );
	assert.deepEqual(
		jQuery( ":not(code)", document.getElementById( "foo" ) ).get(),
		q( "sndp", "en", "yahoo", "sap", "anchor2", "simon" ),
		"Reusing selector with new context"
	);

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Deep ancestry caching in post-positional element matcher (jQuery #14657)",
			"#qunit-fixture a:lt(3):parent",
			[ "simon1", "google", "groups" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
diff --git a/a.js b/b.js
@@ -1836,9 +1837,9 @@ function( assert, jQuery, window, document ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
} );

testIframe(
	"attributes - jQuery.attr",
	"selector/html5_selector.html",
	function( assert, jQuery, window, document ) {
		assert.expect( 38 );

		/**
		 * Returns an array of elements with the given IDs
		 * q & t are added here for the iFrame's context
		 */
		function q() {
			var r = [],
				i = 0;

			for ( ; i < arguments.length; i++ ) {
				r.push( document.getElementById( arguments[ i ] ) );
			}
			return r;
		}

		/**
		 * Asserts that a select matches the given IDs
		 * @example t("Check for something", "//[a]", ["foo", "bar"]);
		 * @param {String} message - Assertion name
		 * @param {String} selector - jQuery selector
		 * @param {Array} expectedIds - Array of ids to construct what is expected
		 */
		function t( message, selector, expectedIds ) {
			var elems = jQuery( selector ).get();

			assert.deepEqual( elems, q.apply( q, expectedIds ), message + " (" + selector + ")" );
		}

		// ====== All known boolean attributes, including html5 booleans ======
		// autobuffer, autofocus, autoplay, async, checked,
		// compact, controls, declare, defer, disabled,
		// formnovalidate, hidden, indeterminate (property only),
		// ismap, itemscope, loop, multiple, muted, nohref, noresize,
		// noshade, nowrap, novalidate, open, pubdate, readonly, required,
		// reversed, scoped, seamless, selected, truespeed, visible (skipping visible attribute, which is on a barprop object)

		t( "Attribute Exists", "[autobuffer]",     [ "video1" ] );
		t( "Attribute Exists", "[autofocus]",      [ "text1" ] );
		t( "Attribute Exists", "[autoplay]",       [ "video1" ] );
		t( "Attribute Exists", "[async]",          [ "script1" ] );
		t( "Attribute Exists", "[checked]",        [ "check1" ] );
		t( "Attribute Exists", "[compact]",        [ "dl" ] );
		t( "Attribute Exists", "[controls]",       [ "video1" ] );
		t( "Attribute Exists", "[declare]",        [ "object1" ] );
		t( "Attribute Exists", "[defer]",          [ "script1" ] );
		t( "Attribute Exists", "[disabled]",       [ "check1" ] );
		t( "Attribute Exists", "[formnovalidate]", [ "form1" ] );
		t( "Attribute Exists", "[hidden]",         [ "div1" ] );
		t( "Attribute Exists", "[indeterminate]",  [] );
		t( "Attribute Exists", "[ismap]",          [ "img1" ] );
		t( "Attribute Exists", "[itemscope]",      [ "div1" ] );
		t( "Attribute Exists", "[loop]",           [ "video1" ] );
		t( "Attribute Exists", "[multiple]",       [ "select1" ] );
		t( "Attribute Exists", "[muted]",          [ "audio1" ] );
		t( "Attribute Exists", "[nohref]",         [ "area1" ] );
		t( "Attribute Exists", "[noresize]",       [ "textarea1" ] );
		t( "Attribute Exists", "[noshade]",        [ "hr1" ] );
		t( "Attribute Exists", "[nowrap]",         [ "td1", "div1" ] );
		t( "Attribute Exists", "[novalidate]",     [ "form1" ] );
		t( "Attribute Exists", "[open]",           [ "details1" ] );
		t( "Attribute Exists", "[pubdate]",        [ "article1" ] );
		t( "Attribute Exists", "[readonly]",       [ "text1" ] );
		t( "Attribute Exists", "[required]",       [ "text1" ] );
		t( "Attribute Exists", "[reversed]",       [ "ol1" ] );
		t( "Attribute Exists", "[scoped]",         [ "style1" ] );
		t( "Attribute Exists", "[seamless]",       [ "iframe1" ] );
		t( "Attribute Exists", "[selected]",       [ "option1" ] );
		t( "Attribute Exists", "[truespeed]",      [ "marquee1" ] );

		// Enumerated attributes (these are not boolean content attributes)
		jQuery.expandedEach = jQuery.each;
		jQuery.expandedEach( [ "draggable", "contenteditable", "aria-disabled" ], function( i, val ) {
			t( "Enumerated attribute", "[" + val + "]", [ "div1" ] );
		} );
		t( "Enumerated attribute", "[spellcheck]", [ "span1" ] );

		t( "tabindex selector does not retrieve all elements in IE6/7 (#8473)",
			"form, [tabindex]", [ "form1", "text1" ] );
		t( "Improperly named form elements do not interfere with form selections (#9570)", "form[name='formName']", [ "form1" ] );
	}
);

QUnit.test( "jQuery.contains", function( assert ) {
diff --git a/a.js b/b.js
@@ -1894,9 +1895,7 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
diff --git a/a.js b/b.js
@@ -1958,8 +1957,12 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
		body = document.body,
		fixture = document.getElementById( "qunit-fixture" ),
		detached1 = document.createElement( "p" ),
		detached2 = document.createElement( "ul" ),
		detachedChild = detached1.appendChild( document.createElement( "a" ) ),
		detachedGrandchild = detachedChild.appendChild( document.createElement( "b" ) );

	for ( i = 0; i < 12; i++ ) {
		detached.push( document.createElement( "li" ) );
		detached[ i ].id = "detached" + i;
		detached2.appendChild( document.createElement( "li" ) ).id = "detachedChild" + i;
	}

	tests = {
		"Empty": {
			input: [],
			expected: []
		},
		"Single-element": {
			input: [ fixture ],
			expected: [ fixture ]
		},
		"No duplicates": {
			input: [ fixture, body ],
			expected: [ body, fixture ]
		},
		"Duplicates": {
			input: [ body, fixture, fixture, body ],
			expected: [ body, fixture ]
		},
		"Detached": {
			input: detached.slice( 0 ),
			expected: detached.slice( 0 )
		},
		"Detached children": {
			input: [
				detached2.childNodes[ 3 ],
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 1 ]
			],
			expected: [
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 1 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 3 ]
			]
		},
		"Attached/detached mixture": {
			input: [ detached1, fixture, detached2, document, detachedChild, body, detachedGrandchild ],
			expected: [ document, body, fixture ],
			length: 3
		}
	};

	jQuery.each( tests, function( label, test ) {
		var length = test.length || test.input.length;
		assert.deepEqual( jQuery.uniqueSort( test.input ).slice( 0, length ), test.expected, label + " (array)" );
		assert.deepEqual( jQuery.uniqueSort( new Arrayish( test.input ) ).slice( 0, length ), test.expected, label + " (quasi-array)" );
	} );
} );

testIframe(
diff --git a/a.js b/b.js
@@ -1987,7 +1990,7 @@ function( assert, jQuery, window, document ) {
A blob:41d9d0f70a41b899b213ab59f3ab21d6505b45b5
);

testIframe(
	"jQuery selector cache collides with multiple jQueries on a page",
	"selector/cache.html",
	function( assert, jQuery, window, document ) {
		var $cached = window.$cached;

		assert.expect( 4 );
		assert.notStrictEqual( jQuery, $cached, "Loaded two engines" );
		assert.deepEqual( $cached( ".test a" ).get(), [ document.getElementById( "collision" ) ], "Select collision anchor with first sizzle" );
		assert.equal( jQuery( ".evil a" ).length, 0, "Select nothing with second sizzle" );
		assert.equal( jQuery( ".evil a" ).length, 0, "Select nothing again with second sizzle" );
	}
);

QUnit.test( "Iframe dispatch should not affect jQuery (#13936)", function( assert ) {
	assert.expect( 1 );
	var loaded = false,
		thrown = false,
		iframe = document.getElementById( "iframe" ),
diff --git a/a.js b/b.js
@@ -34,7 +34,7 @@ QUnit.test( "jQuery.param()", function( assert ) {
A blob:c4e6a6c5ed71adca29679bc90dd788d492bdef7b
QUnit.module( "serialize", { afterEach: moduleTeardown } );

QUnit.test( "jQuery.param()", function( assert ) {
	assert.expect( 24 );

	var params;

	params = { "foo":"bar", "baz":42, "quux":"All your base are belong to us" };
	assert.equal( jQuery.param( params ), "foo=bar&baz=42&quux=All%20your%20base%20are%20belong%20to%20us", "simple" );

	params = { "string":"foo", "null":null, "undefined":undefined };
	assert.equal( jQuery.param( params ), "string=foo&null=&undefined=", "handle nulls and undefineds properly" );

	params = { "someName": [ 1, 2, 3 ], "regularThing": "blah" };
	assert.equal( jQuery.param( params ), "someName%5B%5D=1&someName%5B%5D=2&someName%5B%5D=3&regularThing=blah", "with array" );

	params = { "foo": [ "a", "b", "c" ] };
	assert.equal( jQuery.param( params ), "foo%5B%5D=a&foo%5B%5D=b&foo%5B%5D=c", "with array of strings" );

	params = { "foo": [ "baz", 42, "All your base are belong to us" ] };
	assert.equal( jQuery.param( params ), "foo%5B%5D=baz&foo%5B%5D=42&foo%5B%5D=All%20your%20base%20are%20belong%20to%20us", "more array" );

	params = { "foo": { "bar": "baz", "beep": 42, "quux": "All your base are belong to us" } };
	assert.equal( jQuery.param( params ), "foo%5Bbar%5D=baz&foo%5Bbeep%5D=42&foo%5Bquux%5D=All%20your%20base%20are%20belong%20to%20us", "even more arrays" );

	params = { a:[ 1, 2 ], b:{ c:3, d:[ 4, 5 ], e:{ x:[ 6 ], y:7, z:[ 8, 9 ] }, f:true, g:false, h:undefined }, i:[ 10, 11 ], j:true, k:false, l:[ undefined, 0 ], m:"cowboy hat?" };
	assert.equal( decodeURIComponent( jQuery.param( params ) ), "a[]=1&a[]=2&b[c]=3&b[d][]=4&b[d][]=5&b[e][x][]=6&b[e][y]=7&b[e][z][]=8&b[e][z][]=9&b[f]=true&b[g]=false&b[h]=&i[]=10&i[]=11&j=true&k=false&l[]=&l[]=0&m=cowboy hat?", "huge structure" );

	params = { "a": [ 0, [ 1, 2 ], [ 3, [ 4, 5 ], [ 6 ] ], { "b": [ 7, [ 8, 9 ], [ { "c": 10, "d": 11 } ], [ [ 12 ] ], [ [ [ 13 ] ] ], { "e": { "f": { "g": [ 14, [ 15 ] ] } } }, 16 ] }, 17 ] };
	assert.equal( decodeURIComponent( jQuery.param( params ) ), "a[]=0&a[1][]=1&a[1][]=2&a[2][]=3&a[2][1][]=4&a[2][1][]=5&a[2][2][]=6&a[3][b][]=7&a[3][b][1][]=8&a[3][b][1][]=9&a[3][b][2][0][c]=10&a[3][b][2][0][d]=11&a[3][b][3][0][]=12&a[3][b][4][0][0][]=13&a[3][b][5][e][f][g][]=14&a[3][b][5][e][f][g][1][]=15&a[3][b][]=16&a[]=17", "nested arrays" );

	params = { "a":[ 1, 2 ], "b":{ "c":3, "d":[ 4, 5 ], "e":{ "x":[ 6 ], "y":7, "z":[ 8, 9 ] }, "f":true, "g":false, "h":undefined }, "i":[ 10, 11 ], "j":true, "k":false, "l":[ undefined, 0 ], "m":"cowboy hat?" };
	assert.equal( jQuery.param( params, true ), "a=1&a=2&b=%5Bobject%20Object%5D&i=10&i=11&j=true&k=false&l=&l=0&m=cowboy%20hat%3F", "huge structure, forced traditional" );

	assert.equal( decodeURIComponent( jQuery.param( { "a": [ 1, 2, 3 ], "b[]": [ 4, 5, 6 ], "c[d]": [ 7, 8, 9 ], "e": { "f": [ 10 ], "g": [ 11, 12 ], "h": 13 } } ) ), "a[]=1&a[]=2&a[]=3&b[]=4&b[]=5&b[]=6&c[d][]=7&c[d][]=8&c[d][]=9&e[f][]=10&e[g][]=11&e[g][]=12&e[h]=13", "Make sure params are not double-encoded." );

	// #7945
	assert.equal( jQuery.param( { "jquery": "1.4.2" } ), "jquery=1.4.2", "Check that object with a jQuery property get serialized correctly" );

	params = { "foo":"bar", "baz":42, "quux":"All your base are belong to us" };
	assert.equal( jQuery.param( params, true ), "foo=bar&baz=42&quux=All%20your%20base%20are%20belong%20to%20us", "simple" );
diff --git a/a.js b/b.js
@@ -19,7 +19,7 @@ function getComputedSupport( support ) {
A blob:f0755cbf636f0b44c4d7236c7c9c833ad8044b9f
QUnit.module( "support", { afterEach: moduleTeardown } );

var computedSupport = getComputedSupport( jQuery.support );

function getComputedSupport( support ) {
	var prop,
		result = {};

	for ( prop in support ) {
		if ( typeof support[ prop ] === "function" ) {
			result[ prop ] = support[ prop ]();
		} else {
			result[ prop ] = support[ prop ];
		}
	}

	return result;
}

if ( jQuery.css ) {
	testIframe(
		"body background is not lost if set prior to loading jQuery (#9239)",
		"support/bodyBackground.html",
		function( assert, jQuery, window, document, color, support ) {
			assert.expect( 2 );
			var okValue = {
diff --git a/a.js b/b.js
@@ -47,7 +47,7 @@ QUnit.test( "find(node|jQuery object)", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	assert.deepEqual( jQuery( "#qunit-fixture" ).find( "> #foo > p" ).get(), q( "sndp", "en", "sap" ), "find child elements" );

	assert.deepEqual( jQuery( "#siblingTest, #siblingfirst" ).find( "+ *" ).get(), q( "siblingnext", "fx-test-group" ), "ensure document order" );
} );

QUnit.test( "find(node|jQuery object)", function( assert ) {
	assert.expect( 13 );

	var $foo = jQuery( "#foo" ),
		$blog = jQuery( ".blogTest" ),
		$first = jQuery( "#first" ),
		$two = $blog.add( $first ),
		$twoMore = jQuery( "#ap" ).add( $blog ),
		$fooTwo = $foo.add( $blog );

	assert.equal( $foo.find( $blog ).text(), "Yahoo", "Find with blog jQuery object" );
	assert.equal( $foo.find( $blog[ 0 ] ).text(), "Yahoo", "Find with blog node" );
	assert.equal( $foo.find( $first ).length, 0, "#first is not in #foo" );
	assert.equal( $foo.find( $first[ 0 ] ).length, 0, "#first not in #foo (node)" );
	assert.deepEqual( $foo.find( $two ).get(), $blog.get(), "Find returns only nodes within #foo" );
	assert.deepEqual( $foo.find( $twoMore ).get(), $blog.get(), "...regardless of order" );
	assert.ok( $fooTwo.find( $blog ).is( ".blogTest" ), "Blog is part of the collection, but also within foo" );
	assert.ok( $fooTwo.find( $blog[ 0 ] ).is( ".blogTest" ), "Blog is part of the collection, but also within foo(node)" );

	assert.equal( $two.find( $foo ).length, 0, "Foo is not in two elements" );
	assert.equal( $two.find( $foo[ 0 ] ).length, 0, "Foo is not in two elements(node)" );
	assert.equal( $two.find( $first ).length, 0, "first is in the collection and not within two" );
	assert.equal( $two.find( $first ).length, 0, "first is in the collection and not within two(node)" );

	assert.equal( $two.find( $foo[ 0 ] ).addBack().length, 2, "find preserves the pushStack, see #12009" );
} );

QUnit.test( "is(falsy|invalid)", function( assert ) {
	assert.expect( 5 );
diff --git a/a.js b/b.js
@@ -135,7 +135,7 @@ QUnit.test( "is(String)", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	assert.ok( !jQuery( "#foo" ).is( "" ), "Expected false for an invalid expression - \"\"" );
	assert.ok( !jQuery( "#foo" ).is( undefined ), "Expected false for an invalid expression - undefined" );
	assert.ok( !jQuery( "#foo" ).is( { plain: "object" } ), "Check passing invalid object" );
} );

QUnit.test( "is(String)", function( assert ) {
	assert.expect( 33 );

	var link = document.getElementById( "simon1" ),
		input = document.getElementById( "text1" ),
		option = document.getElementById( "option1a" ),
		disconnected = document.createElement( "div" );

	assert.ok( jQuery( "#form" ).is( "form" ), "Check for element: A form must be a form" );
	assert.ok( !jQuery( "#form" ).is( "div" ), "Check for element: A form is not a div" );
	assert.ok( jQuery( "#mark" ).is( ".blog" ), "Check for class: Expected class 'blog'" );
	assert.ok( !jQuery( "#mark" ).is( ".link" ), "Check for class: Did not expect class 'link'" );
	assert.ok( jQuery( "#simon" ).is( ".blog.link" ), "Check for multiple classes: Expected classes 'blog' and 'link'" );
	assert.ok( !jQuery( "#simon" ).is( ".blogTest" ), "Check for multiple classes: Expected classes 'blog' and 'link', but not 'blogTest'" );
	assert.ok( jQuery( "#en" ).is( "[lang=\"en\"]" ), "Check for attribute: Expected attribute lang to be 'en'" );
	assert.ok( !jQuery( "#en" ).is( "[lang=\"de\"]" ), "Check for attribute: Expected attribute lang to be 'en', not 'de'" );
	assert.ok( jQuery( "#text1" ).is( "[type=\"text\"]" ), "Check for attribute: Expected attribute type to be 'text'" );
	assert.ok( !jQuery( "#text1" ).is( "[type=\"radio\"]" ), "Check for attribute: Expected attribute type to be 'text', not 'radio'" );
	assert.ok( jQuery( "#text2" ).is( ":disabled" ), "Check for pseudoclass: Expected to be disabled" );
	assert.ok( !jQuery( "#text1" ).is( ":disabled" ), "Check for pseudoclass: Expected not disabled" );
	assert.ok( jQuery( "#radio2" ).is( ":checked" ), "Check for pseudoclass: Expected to be checked" );
	assert.ok( !jQuery( "#radio1" ).is( ":checked" ), "Check for pseudoclass: Expected not checked" );

	// test is() with comma-separated expressions
	assert.ok( jQuery( "#en" ).is( "[lang=\"en\"],[lang=\"de\"]" ), "Comma-separated; Check for lang attribute: Expect en or de" );
	assert.ok( jQuery( "#en" ).is( "[lang=\"de\"],[lang=\"en\"]" ), "Comma-separated; Check for lang attribute: Expect en or de" );
	assert.ok( jQuery( "#en" ).is( "[lang=\"en\"] , [lang=\"de\"]" ), "Comma-separated; Check for lang attribute: Expect en or de" );
	assert.ok( jQuery( "#en" ).is( "[lang=\"de\"] , [lang=\"en\"]" ), "Comma-separated; Check for lang attribute: Expect en or de" );

	link.title = "Don't click me";
	assert.ok( jQuery( link ).is( "[rel='bookmark']" ), "attribute-equals string (delimited via apostrophes)" );
	assert.ok( jQuery( link ).is( "[rel=bookmark]" ), "attribute-equals identifier" );
	assert.ok( jQuery( link ).is( "[\nrel = bookmark\t]" ),
		"attribute-equals identifier (whitespace ignored)" );
	assert.ok( jQuery( link ).is( "a[title=\"Don't click me\"]" ),
		"attribute-equals string containing single quote" );

	// jQuery trac-12303
	input.setAttribute( "data-pos", ":first" );
	assert.ok( jQuery( input ).is( "input[data-pos=\\:first]" ),
		"attribute-equals POS in identifier" );
	assert.ok( jQuery( input ).is( "input[data-pos=':first']" ),
		"attribute-equals POS in string" );

	if ( QUnit.jQuerySelectors ) {
		assert.ok( jQuery( input ).is( ":input[data-pos=':first']" ),
			"attribute-equals POS in string after pseudo" );
	} else {
		assert.ok( "skip", ":input not supported in selector-native" );
	}

	option.setAttribute( "test", "" );
	assert.ok( jQuery( option ).is( "[id=option1a]" ),
		"id attribute-equals identifier" );

	if ( QUnit.jQuerySelectors ) {
		assert.ok( jQuery( option ).is( "[id*=option1][type!=checkbox]" ),
			"attribute-not-equals identifier" );
	} else {
		assert.ok( "skip", "attribute-not-equals not supported in selector-native" );
	}

	assert.ok( jQuery( option ).is( "[id*=option1]" ), "attribute-contains identifier" );
	assert.ok( !jQuery( option ).is( "[test^='']" ),
		"attribute-starts-with empty string (negative)" );

	option.className = "=]";
	assert.ok( jQuery( option ).is( ".\\=\\]" ),
		"class selector with attribute-equals confusable" );

	assert.ok( jQuery( disconnected ).is( "div" ), "disconnected element" );
	assert.ok( jQuery( link ).is( "* > *" ), "child combinator matches in document" );
	assert.ok( !jQuery( disconnected ).is( "* > *" ), "child combinator fails in fragment" );
} );

QUnit.test( "is() against non-elements (#10178)", function( assert ) {
	assert.expect( 14 );

	var label, i, test,
		collection = jQuery( document ),
diff --git a/a.js b/b.js
@@ -241,10 +241,10 @@ 		isit = function( sel, match, expect ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	var
		posp = jQuery(
			"<p id='posp'><a class='firsta' href='#'><em>first</em></a>" +
			"<a class='seconda' href='#'><b>test</b></a><em></em></p>"
		).appendTo( "#qunit-fixture" ),
		isit = function( sel, match, expect ) {
			assert.equal(
				jQuery( sel ).is( match ),
				expect,
				"jQuery('" + sel + "').is('" + match + "')"
			);
		};

	isit( "#posp", "p:last", true );
	isit( "#posp", "#posp:first", true );
	isit( "#posp", "#posp:eq(2)", false );
	isit( "#posp", "#posp a:first", false );

	isit( "#posp .firsta", "#posp a:first", true );
	isit( "#posp .firsta", "#posp a:last", false );
	isit( "#posp .firsta", "#posp a:even", true );
	isit( "#posp .firsta", "#posp a:odd", false );
	isit( "#posp .firsta", "#posp a:eq(0)", true );
	isit( "#posp .firsta", "#posp a:eq(9)", false );
	isit( "#posp .firsta", "#posp em:eq(0)", false );
	isit( "#posp .firsta", "#posp em:first", false );
	isit( "#posp .firsta", "#posp:first", false );

	isit( "#posp .seconda", "#posp a:first", false );
	isit( "#posp .seconda", "#posp a:last", true );
	isit( "#posp .seconda", "#posp a:gt(0)", true );
	isit( "#posp .seconda", "#posp a:lt(5)", true );
	isit( "#posp .seconda", "#posp a:lt(1)", false );

	isit( "#posp em", "#posp a:eq(0) em", true );
	isit( "#posp em", "#posp a:lt(1) em", true );
	isit( "#posp em", "#posp a:gt(1) em", false );
	isit( "#posp em", "#posp a:first em", true );
	isit( "#posp em", "#posp a em:last", true );
	isit( "#posp em", "#posp a em:eq(2)", false );

	assert.ok( jQuery( "#option1b" ).is( "#select1 option:not(:first)" ), "POS inside of :not() (#10970)" );

	assert.ok( jQuery( posp[ 0 ] ).is( "p:last" ), "context constructed from a single node (#13797)" );
	assert.ok( !jQuery( posp[ 0 ] ).find( "#firsta" ).is( "a:first" ), "context derived from a single node (#13797)" );
} );

QUnit.test( "index()", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -405,14 +405,14 @@ QUnit.test( "closest()", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	filterit( "#posp .seconda", "#posp a:gt(0)", 0 );
	filterit( "#posp .seconda", "#posp a:lt(5)", 1 );
	filterit( "#posp .seconda", "#posp a:lt(1)", 1 );
} );

QUnit.test( "closest()", function( assert ) {
	assert.expect( 14 );

	var jq;

	assert.deepEqual( jQuery( "body" ).closest( "body" ).get(), q( "body" ), "closest(body)" );
	assert.deepEqual( jQuery( "body" ).closest( "html" ).get(), q( "html" ), "closest(html)" );
	assert.deepEqual( jQuery( "body" ).closest( "div" ).get(), [], "closest(div)" );
	assert.deepEqual( jQuery( "#qunit-fixture" ).closest( "span,#html" ).get(), q( "html" ), "closest(span,#html)" );

	// Test .closest() limited by the context
	jq = jQuery( "#nothiddendivchild" );
	assert.deepEqual( jq.closest( "html", document.body ).get(), [], "Context limited." );
	assert.deepEqual( jq.closest( "body", document.body ).get(), [], "Context limited." );
	assert.deepEqual( jq.closest( "#nothiddendiv", document.body ).get(), q( "nothiddendiv" ), "Context not reached." );

	//Test that .closest() returns unique'd set
	assert.equal( jQuery( "#qunit-fixture p" ).closest( "#qunit-fixture" ).length, 1, "Closest should return a unique set" );

	// Test on disconnected node
	assert.equal( jQuery( "<div><p></p></div>" ).find( "p" ).closest( "table" ).length, 0, "Make sure disconnected closest work." );

	assert.deepEqual(
		jQuery( "#firstp" ).closest( q( "qunit-fixture" ) ).get(),
		q( "qunit-fixture" ),
		"Non-string match target"
	);

	// Bug #7369
	assert.equal( jQuery( "<div foo='bar'></div>" ).closest( "[foo]" ).length, 1, "Disconnected nodes with attribute selector" );
	assert.equal( jQuery( "<div>text</div>" ).closest( "[lang]" ).length, 0, "Disconnected nodes with text and non-existent attribute selector" );

	assert.ok( !jQuery( document ).closest( "#foo" ).length, "Calling closest on a document fails silently" );

	jq = jQuery( "<div>text</div>" );
	assert.deepEqual( jq.contents().closest( "*" ).get(), jq.get(), "Text node input (#13332)" );
} );

QUnit[ QUnit.jQuerySelectorsPos ? "test" : "skip" ]( "closest() with positional selectors", function( assert ) {
	assert.expect( 3 );
diff --git a/a.js b/b.js
@@ -624,8 +624,8 @@ QUnit.test( "siblings([String])", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	assert.deepEqual( jQuery( "#sndp, #en" ).parent().addBack().get(), q( "foo", "sndp", "en" ), "Check for parent and self" );
	assert.deepEqual( jQuery( "#groups" ).parents( "p, div" ).addBack().get(), q( "qunit-fixture", "ap", "groups" ), "Check for parents and self" );
	assert.deepEqual( jQuery( "#select1 > option" ).filter( ":first-child" ).addBack( ":last-child" ).get(), q( "option1a", "option1d" ), "Should contain the last elems plus the *filtered* prior set elements" );
} );

QUnit.test( "siblings([String])", function( assert ) {
	assert.expect( 6 );
	assert.deepEqual( jQuery( "#en" ).siblings().get(), q( "sndp", "sap" ), "Check for siblings" );
	assert.deepEqual( jQuery( "#nonnodes" ).contents().eq( 1 ).siblings().get(), q( "nonnodesElement" ), "Check for text node siblings" );
	assert.deepEqual(
		jQuery( "#foo" ).siblings( "form, b" ).get(),
		q( "form", "floatTest", "lengthtest", "name-tests", "testForm", "disabled-tests" ),
		"Check for multiple filters"
	);

	var set = q( "sndp", "en", "sap" );
	assert.deepEqual( jQuery( "#en, #sndp" ).siblings().get(), set, "Check for unique results from siblings" );
	assert.deepEqual( jQuery( "#option5a" ).siblings( "option[data-attr]" ).get(), q( "option5c" ), "Has attribute selector in siblings (#9261)" );
	assert.equal( jQuery( "<a></a>" ).siblings().length, 0, "Detached elements have no siblings (#11370)" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "siblings([String])", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -657,7 +657,7 @@ QUnit.test( "parent([String])", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "children([String])", function( assert ) {
	assert.expect( 1 );
	assert.deepEqual( jQuery( "#foo" ).children( ":has(code)" ).get(), q( "sndp", "sap" ), "Check for filtered children" );
} );

QUnit.test( "parent([String])", function( assert ) {
	assert.expect( 6 );

	var $el;

	assert.equal( jQuery( "#groups" ).parent()[ 0 ].id, "ap", "Simple parent check" );
	assert.equal( jQuery( "#groups" ).parent( "p" )[ 0 ].id, "ap", "Filtered parent check" );
	assert.equal( jQuery( "#groups" ).parent( "div" ).length, 0, "Filtered parent check, no match" );
	assert.equal( jQuery( "#groups" ).parent( "div, p" )[ 0 ].id, "ap", "Check for multiple filters" );
	assert.deepEqual( jQuery( "#en, #sndp" ).parent().get(), q( "foo" ), "Check for unique results from parent" );

	$el = jQuery( "<div>text</div>" );
	assert.deepEqual( $el.contents().parent().get(), $el.get(), "Check for parent of text node (#13265)" );
} );

QUnit.test( "parents([String])", function( assert ) {
	assert.expect( 6 );
diff --git a/a.js b/b.js
@@ -1067,7 +1067,7 @@ QUnit.test( "add(String, Context)", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	// For the time being, we're discontinuing support for jQuery(form.elements) since it's ambiguous in IE
	// use jQuery([]).add(form.elements) instead.
	//equal( jQuery([]).add(jQuery("#form")[0].elements).length, jQuery(jQuery("#form")[0].elements).length, "Array in constructor must equals array in add()" );
} );

QUnit.test( "add(String, Context)", function( assert ) {
	assert.expect( 6 );

	assert.deepEqual( jQuery( "#firstp" ).add( "#ap" ).get(), q( "firstp", "ap" ), "Add selector to selector " );
	assert.deepEqual( jQuery( document.getElementById( "firstp" ) ).add( "#ap" ).get(), q( "firstp", "ap" ), "Add gEBId to selector" );
	assert.deepEqual( jQuery( document.getElementById( "firstp" ) ).add( document.getElementById( "ap" ) ).get(), q( "firstp", "ap" ), "Add gEBId to gEBId" );

	var ctx = document.getElementById( "firstp" );
	assert.deepEqual( jQuery( "#firstp" ).add( "#ap", ctx ).get(), q( "firstp" ), "Add selector to selector " );
	assert.deepEqual( jQuery( document.getElementById( "firstp" ) ).add( "#ap", ctx ).get(), q( "firstp" ), "Add gEBId to selector, not in context" );
	assert.deepEqual( jQuery( document.getElementById( "firstp" ) ).add( "#ap", document.getElementsByTagName( "body" )[ 0 ] ).get(), q( "firstp", "ap" ), "Add gEBId to selector, in context" );
} );

QUnit.test( "eq('-1') #10616", function( assert ) {
	assert.expect( 3 );
	var $divs = jQuery( "div" );

	assert.equal( $divs.eq( -1 ).length, 1, "The number -1 returns a selection that has length 1" );
diff --git a/a.js b/b.js
@@ -1076,7 +1076,7 @@ QUnit.test( "eq('-1') #10616", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	assert.deepEqual( jQuery( "#firstp" ).add( "#ap", ctx ).get(), q( "firstp" ), "Add selector to selector " );
	assert.deepEqual( jQuery( document.getElementById( "firstp" ) ).add( "#ap", ctx ).get(), q( "firstp" ), "Add gEBId to selector, not in context" );
	assert.deepEqual( jQuery( document.getElementById( "firstp" ) ).add( "#ap", document.getElementsByTagName( "body" )[ 0 ] ).get(), q( "firstp", "ap" ), "Add gEBId to selector, in context" );
} );

QUnit.test( "eq('-1') #10616", function( assert ) {
	assert.expect( 3 );
	var $divs = jQuery( "div" );

	assert.equal( $divs.eq( -1 ).length, 1, "The number -1 returns a selection that has length 1" );
	assert.equal( $divs.eq( "-1" ).length, 1, "The string '-1' returns a selection that has length 1" );
	assert.deepEqual( $divs.eq( "-1" ), $divs.eq( -1 ), "String and number -1 match" );
} );

QUnit.test( "index(no arg) #10977", function( assert ) {
	assert.expect( 2 );
	var $list, fragment, div;

	$list = jQuery( "<ul id='indextest'><li class='zero'>THIS ONE</li><li class='one'>a</li><li class='two'>b</li><li class='three'>c</li></ul>" );
diff --git a/a.js b/b.js
@@ -1091,7 +1091,7 @@ QUnit.test( "index(no arg) #10977", function( assert ) {
A blob:53b9f11a624dfa234e7104497f1c2109a58cb8f1
	assert.equal( $divs.eq( -1 ).length, 1, "The number -1 returns a selection that has length 1" );
	assert.equal( $divs.eq( "-1" ).length, 1, "The string '-1' returns a selection that has length 1" );
	assert.deepEqual( $divs.eq( "-1" ), $divs.eq( -1 ), "String and number -1 match" );
} );

QUnit.test( "index(no arg) #10977", function( assert ) {
	assert.expect( 2 );
	var $list, fragment, div;

	$list = jQuery( "<ul id='indextest'><li class='zero'>THIS ONE</li><li class='one'>a</li><li class='two'>b</li><li class='three'>c</li></ul>" );
	jQuery( "#qunit-fixture" ).append( $list );
	assert.strictEqual( jQuery( "#indextest li.zero" ).first().index(), 0, "No Argument Index Check" );
	$list.remove();

	fragment = document.createDocumentFragment();
	div = fragment.appendChild( document.createElement( "div" ) );

	assert.equal( jQuery( div ).index(), 0, "If jQuery#index called on element whose parent is fragment, it still should work correctly" );
} );

QUnit.test( "traversing non-elements with attribute filters (#12523)", function( assert ) {
	assert.expect( 5 );

	var nonnodes = jQuery( "#nonnodes" ).contents();

diff --git a/a.js b/b.js
@@ -47,11 +47,11 @@ jQuery( "#check1" ).on( "click", function() {
A blob:3c0990eac25b70a433153cf2a213e7775275eb6a
	);
	assert.equal(
		result.text(), defaultText, "Check for element wrapping"
	);

	jQuery( "#check1" ).on( "click", function() {
		var checkbox = this;

		assert.ok(
		checkbox.checked, "Checkbox's state is erased after wrap() action, see #769"
	);
		jQuery( checkbox ).wrap( val( "<div id='c1' style='display:none;'></div>" ) );
		assert.ok(
		checkbox.checked, "Checkbox's state is erased after wrap() action, see #769"
	);
	} ).prop( "checked", false )[ 0 ].click();

	// using contents will get comments regular, text, and comment nodes
diff --git a/a.js b/b.js
@@ -131,7 +131,7 @@ QUnit.test( "wrap(Function)", function( assert ) {
A blob:3c0990eac25b70a433153cf2a213e7775275eb6a

QUnit.test( "wrap(String|Element)", function( assert ) {
	testWrap( manipulationBareObj, assert );
} );

QUnit.test( "wrap(Function)", function( assert ) {
	testWrap( manipulationFunctionReturningObj, assert );
} );

QUnit.test( "wrap(Function) with index (#10177)", function( assert ) {
	var expectedIndex = 0,
		targets = jQuery( "#qunit-fixture p" );

	assert.expect( targets.length );
diff --git a/a.js b/b.js
@@ -147,7 +147,7 @@ QUnit.test( "wrap(Function) with index (#10177)", function( assert ) {
A blob:3c0990eac25b70a433153cf2a213e7775275eb6a

QUnit.test( "wrap(Function)", function( assert ) {
	testWrap( manipulationFunctionReturningObj, assert );
} );

QUnit.test( "wrap(Function) with index (#10177)", function( assert ) {
	var expectedIndex = 0,
		targets = jQuery( "#qunit-fixture p" );

	assert.expect( targets.length );
	targets.wrap( function( i ) {
		assert.equal(
		i, expectedIndex,
		"Check if the provided index (" + i + ") is as expected (" + expectedIndex + ")"
	);
		expectedIndex++;

		return "<div id='wrap_index_'" + i + "'></div>";
	} );
} );

QUnit.test( "wrap(String) consecutive elements (#10177)", function( assert ) {
	var targets = jQuery( "#qunit-fixture p" );

	assert.expect( targets.length * 2 );
	targets.wrap( "<div class='wrapper'></div>" );
diff --git a/a.js b/b.js
@@ -484,7 +484,7 @@ jQuery( "body" ).append(
A blob:3c0990eac25b70a433153cf2a213e7775275eb6a

QUnit.test( "unwrap( selector )", function( assert ) {

	assert.expect( 5 );

	jQuery( "body" ).append(
		"  <div id='unwrap' style='display: none;'> <div id='unwrap1'>" +
		"<span class='unwrap'>a</span> <span class='unwrap'>b</span> </div>" +
		" <div id='unwrap2'> <span class='unwrap'>c</span> <span class='unwrap'>d</span>" +
		" </div> </div>"
	);

	// Shouldn't unwrap, no match
	jQuery( "#unwrap1 span" ) .unwrap( "#unwrap2" );
	assert.equal(
		jQuery( "#unwrap1" ).length, 1, "still wrapped"
	);

	// Shouldn't unwrap, no match
	jQuery( "#unwrap1 span" ) .unwrap( "span" );
	assert.equal(
		jQuery( "#unwrap1" ).length, 1, "still wrapped"
	);

	// Unwraps
	jQuery( "#unwrap1 span" ) .unwrap( "#unwrap1" );
	assert.equal(
		jQuery( "#unwrap1" ).length, 0, "unwrapped match"
	);

	// Check return values
	assert.deepEqual(
		jQuery( "#unwrap2 span" ).get(), jQuery( "#unwrap2 span" ).unwrap( "quote" ).get(),
		"return on unmatched unwrap"
	);
	assert.deepEqual(
		jQuery( "#unwrap2 span" ).get(), jQuery( "#unwrap2 span" ).unwrap( "#unwrap2" ).get(),
		"return on matched unwrap"
	);

	jQuery( "body > span.unwrap" ).remove();
} );

QUnit.test( "jQuery(<tag>) & wrap[Inner/All]() handle unknown elems (#10667)", function( assert ) {

	assert.expect( 2 );

	var $wraptarget = jQuery( "<div id='wrap-target'>Target</div>" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -503,7 +503,7 @@ QUnit.test( "jQuery(<tag>) & wrap[Inner/All]() handle unknown elems (#10667)", f
A blob:3c0990eac25b70a433153cf2a213e7775275eb6a
	);

	jQuery( "body > span.unwrap" ).remove();
} );

QUnit.test( "jQuery(<tag>) & wrap[Inner/All]() handle unknown elems (#10667)", function( assert ) {

	assert.expect( 2 );

	var $wraptarget = jQuery( "<div id='wrap-target'>Target</div>" ).appendTo( "#qunit-fixture" ),
		$section = jQuery( "<section>" ).appendTo( "#qunit-fixture" );

	$wraptarget.wrapAll( "<aside style='background-color:green'></aside>" );

	assert.notEqual(
		$wraptarget.parent( "aside" ).get( 0 ).style.backgroundColor, "transparent",
		"HTML5 elements created with wrapAll inherit styles"
	);
	assert.notEqual(
		$section.get( 0 ).style.backgroundColor, "transparent",
		"HTML5 elements create with jQuery( string ) inherit styles"
	);
} );

QUnit.test( "wrapping scripts (#10470)", function( assert ) {

	assert.expect( 2 );

	var script = document.createElement( "script" );
diff --git a/a.js b/b.js
@@ -16,6 +16,12 @@ function curCSS( elem, name, computed ) {
A blob:6d8b6a2d3bd25e8dde11a41c40ffbe3a69ea7d9d
import isAttached from "../core/isAttached.js";
import getStyles from "./var/getStyles.js";
import rcustomProp from "./var/rcustomProp.js";
import rtrim from "../var/rtrim.js";

function curCSS( elem, name, computed ) {
	var ret,
		isCustomProp = rcustomProp.test( name );

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for `.css('--customProperty')` (gh-3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		// trim whitespace for custom property (issue gh-4926)
		if ( isCustomProp ) {
			ret = ret.replace( rtrim, "$1" );
		}

		if ( ret === "" && !isAttached( elem ) ) {
diff --git a/a.js b/b.js
@@ -22,7 +22,7 @@ module.exports = function( grunt ) {
A blob:ad9dd6d698e8133e4e639f663ebdc25d28ee11b9
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isCi = process.env.TRAVIS || process.env.GITHUB_ACTION,
		ciBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
diff --git a/a.js b/b.js
@@ -613,7 +613,7 @@ ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				complete: callback( "complete" )
			} ]
		};
	} );

	ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
		function nocallback( msg ) {
			return function() {
				assert.equal( typeof this.url, "string", "context is settings on callback " + msg );
			};
		}
		return {
			url: url( "404.txt" ),
			beforeSend: nocallback( "beforeSend" ),
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
diff --git a/a.js b/b.js
@@ -629,7 +629,7 @@ ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function(
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
				holder = jQuery.event;
				delete jQuery.event;
			},
			complete: function() {
				assert.ok( true, "Call can be made without jQuery.event" );
				jQuery.event = holder;
			},
			success: true
		};
	} );

	ajaxTest( "#15160 - jQuery.ajax() - request manually aborted in ajaxSend", 3, function( assert ) {
		return {
			setup: function() {
				jQuery( document ).on( "ajaxSend", function( e, jqXHR ) {
					jqXHR.abort();
diff --git a/a.js b/b.js
@@ -1634,12 +1634,25 @@ ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
			},
			error: true
		};
	} );

	ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
		return {
			url: "bogus.html",
			data: { devo: "A Beautiful World" },
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.deepEqual( s.data, { devo: "A Beautiful World" }, "data is not processed" );
				return false;
			},
			error: true
		};
	} );

		ajaxTest( "jQuery.ajax() - data - process string with GET", 2, function( assert ) {
		return {
			url: "bogus.html",
			data: "a=1&b=2",
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.equal( s.url, "bogus.html?a=1&b=2", "added data to url" );
				assert.equal( s.data, undefined, "removed data from settings" );
				return false;
			},
			error: true
		};
	} );

	var ifModifiedNow = new Date();

	jQuery.each(
		/* jQuery.each arguments start */
		{
			" (cache)": true,
			" (no cache)": false
		},
		function( label, cache ) {
			jQuery.each(
				{
					"If-Modified-Since": "mock.php?action=ims",
					"Etag": "mock.php?action=etag"
				},
				function( type, url ) {
					url = baseURL + url + "&ts=" + ifModifiedNow++;
					QUnit.test( "jQuery.ajax() - " + type + " support" + label, function( assert ) {
						assert.expect( 4 );
						var done = assert.async();
						jQuery.ajax( {
							url: url,
diff --git a/a.js b/b.js
@@ -1882,7 +1895,7 @@ ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				}
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success callback.", 1, function( assert ) {
		return {
			url: url( "mock.php?action=echoData" ),
			error: function( _, __, error ) {
				assert.equal( typeof error === "object", true,  "Didn't get back error object for empty json response" );
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
diff --git a/a.js b/b.js
@@ -1908,7 +1921,7 @@ ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( ass
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
					beforeSend: function() {
						assert.ok( true, "beforeSend got called, canceling" );
						return false;
					},
					success: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					complete: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					error: function() {
						assert.ok( false, "request didn't get canceled" );
					}
				} );
			},
			fail: function( _, reason ) {
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
diff --git a/a.js b/b.js
@@ -1922,7 +1935,7 @@ ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, f
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
					return "value";
				}
			},
			success: function( result ) {
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
diff --git a/a.js b/b.js
@@ -1940,7 +1953,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -1954,7 +1967,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function() {
					assert.strictEqual( this.cache, false, "cache must be false on JSON request" );
					return false;
				},
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
diff --git a/a.js b/b.js
@@ -1993,7 +2006,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -2031,7 +2044,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function( jqXHR, s ) {
					s.callback = s.jsonpCallback;

					assert.ok( this.callback in window, "JSONP callback name is in the window" );
				},
				success: function() {
					var previous = this;

					assert.strictEqual(
						previous.jsonpCallback,
						undefined,
						"jsonpCallback option is set back to default in callbacks"
					);

					assert.ok(
						!( this.callback in window ),
						"JSONP callback name was removed from the window"
					);

					jQuery.ajax( {
						url: baseURL + "mock.php?action=jsonp",
						dataType: "jsonp",
						crossDomain: crossDomain,
						beforeSend: function() {
							assert.strictEqual( this.jsonpCallback, previous.callback, "JSONP callback name is re-used" );
							return false;
						}
					} );
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
diff --git a/a.js b/b.js
@@ -2065,7 +2078,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
diff --git a/a.js b/b.js
@@ -2075,7 +2088,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
diff --git a/a.js b/b.js
@@ -2089,7 +2102,7 @@ ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
				return string;
			},
			error: function( jqXHR ) {
				assert.strictEqual( jqXHR.responseText, "{ \"code\": 40, \"message\": \"Bad Request\" }", "Error body properly set" );
				assert.deepEqual( jqXHR.responseJSON, { code: 40, message: "Bad Request" }, "Error body properly parsed" );
			}
		};
	} );

	ajaxTest( "#11426 - jQuery.ajax() - loading binary data shouldn't throw an exception in IE", 1, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			success: function( data ) {
				assert.ok( data === undefined || /JFIF/.test( data ), "success callback reached" );
diff --git a/a.js b/b.js
@@ -2122,7 +2135,7 @@ ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception",
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
		s.xhrFields = { responseType: "arraybuffer" };
		s.responseFields.arraybuffer = "response";
		s.converters[ "binary arraybuffer" ] = true;
	} );

	ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception", 2, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			dataType: "arraybuffer",
			success: function( data, s, jqxhr ) {
				assert.ok( data instanceof window.ArrayBuffer, "correct data type" );
				assert.ok( jqxhr.response instanceof window.ArrayBuffer, "data in jQXHR" );
			}
		};
	} );
}

	QUnit.test( "#11743 - jQuery.ajax() - script, throws exception", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		var onerror = window.onerror;
		window.onerror = function() {
diff --git a/a.js b/b.js
@@ -2157,7 +2170,7 @@ 				options.success = function( msg ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
diff --git a/a.js b/b.js
@@ -2176,7 +2189,7 @@ 				options.success = function( msg ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
						var options = {};
						options[ globalOption ] = "POST";
						jQuery.ajaxSetup( options );
					},
					requests: [
						request( assert, "type" ),
						request( assert, "method" ),
						request( assert )
					]
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
diff --git a/a.js b/b.js
@@ -2194,7 +2207,7 @@ ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from aja
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
				var parsedXML = jQuery( jQuery.parseXML( "<tab title=\"Added\">blibli</tab>" ) ).find( "tab" );
				ajaxXML = jQuery( ajaxXML );
				try {
					ajaxXML.find( "infowindowtab" ).append( parsedXML );
				} catch ( e ) {
					assert.strictEqual( e, undefined, "error" );
					return;
				}
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
diff --git a/a.js b/b.js
@@ -2216,7 +2229,7 @@ ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3,
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
				"* testing": function() {
					throw "converter was called";
				}
			},
			success: function( data, status, jqXHR ) {
				assert.strictEqual( jqXHR.status, 204, "status code is 204" );
				assert.strictEqual( status, "nocontent", "status text is 'nocontent'" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
diff --git a/a.js b/b.js
@@ -2228,7 +2241,7 @@ ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
				assert.notStrictEqual( resp, undefined, "XML document exists" );
				assert.ok( "responseXML" in jqXHR, "jqXHR.responseXML exists" );
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
diff --git a/a.js b/b.js
@@ -2259,7 +2272,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
diff --git a/a.js b/b.js
@@ -2268,7 +2281,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
			}
		);
	}

	ajaxTest( "#14683 - jQuery.ajax() - Exceptions thrown synchronously by xhr.send should be caught", 4, function( assert ) {
		return [ {
			url: baseURL + "mock.php?action=echoData",
			method: "POST",
			data: {
diff --git a/a.js b/b.js
@@ -2491,7 +2504,7 @@ QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function(
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
			error: pass,
			success: fail
		} );
	} );

	QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			timeout: 50
		} );
		jQuery.ajax( {
			type: "GET",
			timeout: 15000,
			url: url( "mock.php?action=wait&wait=1" ),
			error: function() {
				assert.ok( false, "Check for local timeout failed" );
				done();
			},
			success: function() {
				assert.ok( true, "Check for local timeout" );
				done();
			}
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
diff --git a/a.js b/b.js
@@ -2508,7 +2521,7 @@ QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
		} );

		jQuery( document ).on( "ajaxStart ajaxStop", function() {
			assert.ok( false, "Global event triggered" );
		} );

		jQuery( "#qunit-fixture" ).append( "<script src='" + baseURL + "mock.php?action=script'></script>" );

		jQuery( document ).off( "ajaxStart ajaxStop" );
	} );

	QUnit.test(
		"jQuery#load() - always use GET method even if it overrided through ajaxSetup (#11264)",
		function( assert ) {
			assert.expect( 1 );
			var done = assert.async();

diff --git a/a.js b/b.js
@@ -2545,7 +2558,7 @@ QUnit.test(
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				done();
			} );
		}
	);

	QUnit.test(
		"jQuery#load() - should resolve with correct context",
		function( assert ) {
			assert.expect( 2 );
			var done = assert.async();
			var ps = jQuery( "<p></p><p></p>" );
			var i = 0;

			ps.appendTo( "#qunit-fixture" );

			ps.load( baseURL + "mock.php?action=echoMethod", function() {
				assert.strictEqual( this, ps[ i++ ] );

				if ( i === 2 ) {
					done();
				}
			} );
		}
	);

	QUnit.test(
		"#11402 - jQuery.domManip() - script in comments are properly evaluated",
		function( assert ) {
			assert.expect( 2 );
			jQuery( "#qunit-fixture" ).load( baseURL + "cleanScript.html", assert.async() );
		}
diff --git a/a.js b/b.js
@@ -2568,7 +2581,7 @@ QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
		}
	);

//----------- jQuery.get()

	QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on nodes", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();
		jQuery.get( url( "dashboard.xml" ), function( xml ) {
			var content = [];
			jQuery( "tab", xml ).each( function() {
				content.push( jQuery( this ).text() );
			} );
			assert.strictEqual( content[ 0 ], "blabla", "Check first tab" );
			assert.strictEqual( content[ 1 ], "blublu", "Check second tab" );
			done();
		} );
	} );

	QUnit.test( "#8277 - jQuery.get( String, Function ) - data in ajaxSettings", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			data: "helloworld"
diff --git a/a.js b/b.js
@@ -2659,7 +2672,7 @@ QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( asse
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				done();
			} );
		}
	);

	QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( assert ) {
		assert.expect( 1 );
		Globals.register( "testBar" );
		jQuery.getScript( url( "mock.php?action=testbar" ) ).done( assert.async() );
	} );

	QUnit.test( "#8082 - jQuery.getScript( String, Function ) - source as responseText", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();

		Globals.register( "testBar" );
diff --git a/a.js b/b.js
@@ -2746,7 +2759,7 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
		} );
		jQuery( "#first" ).load( baseURL + "name.html", undefined, assert.async() );
	} );

	// check if load can be called with only url
	QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html div.user", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 2, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
diff --git a/a.js b/b.js
@@ -2756,9 +2769,9 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	// Selector should include any valid non-HTML whitespace (#3003)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with non-HTML whitespace(#3003) )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #whitespace\\\\xA0 ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
diff --git a/a.js b/b.js
@@ -2889,7 +2902,7 @@ QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function(
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
			assert.ok( $node.find( "#query" ).text().match( /foo=3&bar=ok/ ), "Check if a string of data is passed correctly" );
			done();
		} );
	} );

	QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function( assert ) {
		assert.expect( 8 );
		var completeArgs = {},
			done = assert.async();

		jQuery.ajaxSetup( {
			success: function( _, status, jqXHR ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			},
			error: function( jqXHR, status ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			}
		} );

		jQuery.when.apply(
			jQuery,
			jQuery.map( [
				{
					type: "success",
					url: baseURL + "mock.php?action=echoQuery&arg=pop"
				},
				{
					type: "error",
					url: baseURL + "404.txt"
				}
			],
			function( options ) {
				return jQuery.Deferred( function( defer ) {
					jQuery( "#foo" ).load( options.url, function() {
						var args = arguments;
						assert.strictEqual( completeArgs[ options.url ].length, args.length, "same number of arguments (" + options.type + ")" );
						jQuery.each( completeArgs[ options.url ], function( i, value ) {
							assert.strictEqual( args[ i ], value, "argument #" + i + " is the same (" + options.type + ")" );
						} );
						defer.resolve();
					} );
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
diff --git a/a.js b/b.js
@@ -2904,7 +2917,7 @@ QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataTy
A blob:fc8ed3ef0b1a2ce951276d218b466638691b6408
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
			dataType: "json"
		} );
		jQuery( document ).on( "ajaxComplete", function( e, xml, s ) {
			assert.strictEqual( s.dataType, "html", "Verify the load() dataType was html" );
			jQuery( document ).off( "ajaxComplete" );
			done();
		} );
		jQuery( "#first" ).load( baseURL + "test3.html" );
	} );

	QUnit.test( "#10524 - jQuery.fn.load() - data specified in ajaxSettings is merged in", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		var data = {
diff --git a/a.js b/b.js
@@ -613,7 +613,7 @@ ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				complete: callback( "complete" )
			} ]
		};
	} );

	ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
		function nocallback( msg ) {
			return function() {
				assert.equal( typeof this.url, "string", "context is settings on callback " + msg );
			};
		}
		return {
			url: url( "404.txt" ),
			beforeSend: nocallback( "beforeSend" ),
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
diff --git a/a.js b/b.js
@@ -629,7 +629,7 @@ ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function(
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
				holder = jQuery.event;
				delete jQuery.event;
			},
			complete: function() {
				assert.ok( true, "Call can be made without jQuery.event" );
				jQuery.event = holder;
			},
			success: true
		};
	} );

	ajaxTest( "#15160 - jQuery.ajax() - request manually aborted in ajaxSend", 3, function( assert ) {
		return {
			setup: function() {
				jQuery( document ).on( "ajaxSend", function( e, jqXHR ) {
					jqXHR.abort();
diff --git a/a.js b/b.js
@@ -1634,12 +1634,25 @@ ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
			},
			error: true
		};
	} );

	ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
		return {
			url: "bogus.html",
			data: { devo: "A Beautiful World" },
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.deepEqual( s.data, { devo: "A Beautiful World" }, "data is not processed" );
				return false;
			},
			error: true
		};
	} );

		ajaxTest( "jQuery.ajax() - data - process string with GET", 2, function( assert ) {
		return {
			url: "bogus.html",
			data: "a=1&b=2",
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.equal( s.url, "bogus.html?a=1&b=2", "added data to url" );
				assert.equal( s.data, undefined, "removed data from settings" );
				return false;
			},
			error: true
		};
	} );

	var ifModifiedNow = new Date();

	jQuery.each(
		/* jQuery.each arguments start */
		{
			" (cache)": true,
			" (no cache)": false
		},
		function( label, cache ) {
			jQuery.each(
				{
					"If-Modified-Since": "mock.php?action=ims",
					"Etag": "mock.php?action=etag"
				},
				function( type, url ) {
					url = baseURL + url + "&ts=" + ifModifiedNow++;
					QUnit.test( "jQuery.ajax() - " + type + " support" + label, function( assert ) {
						assert.expect( 4 );
						var done = assert.async();
						jQuery.ajax( {
							url: url,
diff --git a/a.js b/b.js
@@ -1704,7 +1717,8 @@ QUnit.test( "jQuery.ajax() - statusText", function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.ok( true, "success" );
			}
		};
	} );

	QUnit.test( "jQuery.ajax() - statusText", function( assert ) {
		assert.expect( 3 );
		var done = assert.async();
		jQuery.ajax( url( "mock.php?action=status&code=200&text=Hello" ) ).done( function( _, statusText, jqXHR ) {
			assert.strictEqual( statusText, "success", "callback status text ok for success" );
			assert.ok( jqXHR.statusText === "Hello" || jqXHR.statusText === "OK", "jqXHR status text ok for success (" + jqXHR.statusText + ")" );
			jQuery.ajax( url( "mock.php?action=status&code=404&text=World" ) ).fail( function( jqXHR, statusText ) {
				assert.strictEqual( statusText, "error", "callback status text ok for error" );
				done();
			} );
diff --git a/a.js b/b.js
@@ -1881,7 +1895,7 @@ ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				}
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success callback.", 1, function( assert ) {
		return {
			url: url( "mock.php?action=echoData" ),
			error: function( _, __, error ) {
				assert.equal( typeof error === "object", true,  "Didn't get back error object for empty json response" );
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
diff --git a/a.js b/b.js
@@ -1907,7 +1921,7 @@ ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( ass
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
					beforeSend: function() {
						assert.ok( true, "beforeSend got called, canceling" );
						return false;
					},
					success: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					complete: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					error: function() {
						assert.ok( false, "request didn't get canceled" );
					}
				} );
			},
			fail: function( _, reason ) {
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
diff --git a/a.js b/b.js
@@ -1921,7 +1935,7 @@ ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, f
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
					return "value";
				}
			},
			success: function( result ) {
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
diff --git a/a.js b/b.js
@@ -1939,7 +1953,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -1953,7 +1967,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function() {
					assert.strictEqual( this.cache, false, "cache must be false on JSON request" );
					return false;
				},
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
diff --git a/a.js b/b.js
@@ -1992,7 +2006,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -2030,7 +2044,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function( jqXHR, s ) {
					s.callback = s.jsonpCallback;

					assert.ok( this.callback in window, "JSONP callback name is in the window" );
				},
				success: function() {
					var previous = this;

					assert.strictEqual(
						previous.jsonpCallback,
						undefined,
						"jsonpCallback option is set back to default in callbacks"
					);

					assert.ok(
						!( this.callback in window ),
						"JSONP callback name was removed from the window"
					);

					jQuery.ajax( {
						url: baseURL + "mock.php?action=jsonp",
						dataType: "jsonp",
						crossDomain: crossDomain,
						beforeSend: function() {
							assert.strictEqual( this.jsonpCallback, previous.callback, "JSONP callback name is re-used" );
							return false;
						}
					} );
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
diff --git a/a.js b/b.js
@@ -2064,7 +2078,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
diff --git a/a.js b/b.js
@@ -2074,7 +2088,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
diff --git a/a.js b/b.js
@@ -2088,7 +2102,7 @@ ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
				return string;
			},
			error: function( jqXHR ) {
				assert.strictEqual( jqXHR.responseText, "{ \"code\": 40, \"message\": \"Bad Request\" }", "Error body properly set" );
				assert.deepEqual( jqXHR.responseJSON, { code: 40, message: "Bad Request" }, "Error body properly parsed" );
			}
		};
	} );

	ajaxTest( "#11426 - jQuery.ajax() - loading binary data shouldn't throw an exception in IE", 1, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			success: function( data ) {
				assert.ok( data === undefined || /JFIF/.test( data ), "success callback reached" );
diff --git a/a.js b/b.js
@@ -2121,7 +2135,7 @@ ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception",
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
		s.xhrFields = { responseType: "arraybuffer" };
		s.responseFields.arraybuffer = "response";
		s.converters[ "binary arraybuffer" ] = true;
	} );

	ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception", 2, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			dataType: "arraybuffer",
			success: function( data, s, jqxhr ) {
				assert.ok( data instanceof window.ArrayBuffer, "correct data type" );
				assert.ok( jqxhr.response instanceof window.ArrayBuffer, "data in jQXHR" );
			}
		};
	} );
}

	QUnit.test( "#11743 - jQuery.ajax() - script, throws exception", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		var onerror = window.onerror;
		window.onerror = function() {
diff --git a/a.js b/b.js
@@ -2156,7 +2170,7 @@ 				options.success = function( msg ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
diff --git a/a.js b/b.js
@@ -2175,7 +2189,7 @@ 				options.success = function( msg ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
						var options = {};
						options[ globalOption ] = "POST";
						jQuery.ajaxSetup( options );
					},
					requests: [
						request( assert, "type" ),
						request( assert, "method" ),
						request( assert )
					]
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
diff --git a/a.js b/b.js
@@ -2193,7 +2207,7 @@ ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from aja
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
				var parsedXML = jQuery( jQuery.parseXML( "<tab title=\"Added\">blibli</tab>" ) ).find( "tab" );
				ajaxXML = jQuery( ajaxXML );
				try {
					ajaxXML.find( "infowindowtab" ).append( parsedXML );
				} catch ( e ) {
					assert.strictEqual( e, undefined, "error" );
					return;
				}
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
diff --git a/a.js b/b.js
@@ -2215,7 +2229,7 @@ ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3,
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
				"* testing": function() {
					throw "converter was called";
				}
			},
			success: function( data, status, jqXHR ) {
				assert.strictEqual( jqXHR.status, 204, "status code is 204" );
				assert.strictEqual( status, "nocontent", "status text is 'nocontent'" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
diff --git a/a.js b/b.js
@@ -2227,7 +2241,7 @@ ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
				assert.notStrictEqual( resp, undefined, "XML document exists" );
				assert.ok( "responseXML" in jqXHR, "jqXHR.responseXML exists" );
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
diff --git a/a.js b/b.js
@@ -2258,7 +2272,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
diff --git a/a.js b/b.js
@@ -2267,7 +2281,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
			}
		);
	}

	ajaxTest( "#14683 - jQuery.ajax() - Exceptions thrown synchronously by xhr.send should be caught", 4, function( assert ) {
		return [ {
			url: baseURL + "mock.php?action=echoData",
			method: "POST",
			data: {
diff --git a/a.js b/b.js
@@ -2490,7 +2504,7 @@ QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function(
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
			error: pass,
			success: fail
		} );
	} );

	QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			timeout: 50
		} );
		jQuery.ajax( {
			type: "GET",
			timeout: 15000,
			url: url( "mock.php?action=wait&wait=1" ),
			error: function() {
				assert.ok( false, "Check for local timeout failed" );
				done();
			},
			success: function() {
				assert.ok( true, "Check for local timeout" );
				done();
			}
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
diff --git a/a.js b/b.js
@@ -2507,7 +2521,7 @@ QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
		} );

		jQuery( document ).on( "ajaxStart ajaxStop", function() {
			assert.ok( false, "Global event triggered" );
		} );

		jQuery( "#qunit-fixture" ).append( "<script src='" + baseURL + "mock.php?action=script'></script>" );

		jQuery( document ).off( "ajaxStart ajaxStop" );
	} );

	QUnit.test(
		"jQuery#load() - always use GET method even if it overrided through ajaxSetup (#11264)",
		function( assert ) {
			assert.expect( 1 );
			var done = assert.async();

diff --git a/a.js b/b.js
@@ -2544,7 +2558,7 @@ QUnit.test(
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				done();
			} );
		}
	);

	QUnit.test(
		"jQuery#load() - should resolve with correct context",
		function( assert ) {
			assert.expect( 2 );
			var done = assert.async();
			var ps = jQuery( "<p></p><p></p>" );
			var i = 0;

			ps.appendTo( "#qunit-fixture" );

			ps.load( baseURL + "mock.php?action=echoMethod", function() {
				assert.strictEqual( this, ps[ i++ ] );

				if ( i === 2 ) {
					done();
				}
			} );
		}
	);

	QUnit.test(
		"#11402 - jQuery.domManip() - script in comments are properly evaluated",
		function( assert ) {
			assert.expect( 2 );
			jQuery( "#qunit-fixture" ).load( baseURL + "cleanScript.html", assert.async() );
		}
diff --git a/a.js b/b.js
@@ -2567,7 +2581,7 @@ QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
		}
	);

//----------- jQuery.get()

	QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on nodes", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();
		jQuery.get( url( "dashboard.xml" ), function( xml ) {
			var content = [];
			jQuery( "tab", xml ).each( function() {
				content.push( jQuery( this ).text() );
			} );
			assert.strictEqual( content[ 0 ], "blabla", "Check first tab" );
			assert.strictEqual( content[ 1 ], "blublu", "Check second tab" );
			done();
		} );
	} );

	QUnit.test( "#8277 - jQuery.get( String, Function ) - data in ajaxSettings", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			data: "helloworld"
diff --git a/a.js b/b.js
@@ -2658,7 +2672,7 @@ QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( asse
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				done();
			} );
		}
	);

	QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( assert ) {
		assert.expect( 1 );
		Globals.register( "testBar" );
		jQuery.getScript( url( "mock.php?action=testbar" ) ).done( assert.async() );
	} );

	QUnit.test( "#8082 - jQuery.getScript( String, Function ) - source as responseText", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();

		Globals.register( "testBar" );
diff --git a/a.js b/b.js
@@ -2745,7 +2759,7 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
		} );
		jQuery( "#first" ).load( baseURL + "name.html", undefined, assert.async() );
	} );

	// check if load can be called with only url
	QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html div.user", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 2, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
diff --git a/a.js b/b.js
@@ -2755,9 +2769,9 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	// Selector should include any valid non-HTML whitespace (#3003)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with non-HTML whitespace(#3003) )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #whitespace\\\\xA0 ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
diff --git a/a.js b/b.js
@@ -2888,7 +2902,7 @@ QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function(
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
			assert.ok( $node.find( "#query" ).text().match( /foo=3&bar=ok/ ), "Check if a string of data is passed correctly" );
			done();
		} );
	} );

	QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function( assert ) {
		assert.expect( 8 );
		var completeArgs = {},
			done = assert.async();

		jQuery.ajaxSetup( {
			success: function( _, status, jqXHR ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			},
			error: function( jqXHR, status ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			}
		} );

		jQuery.when.apply(
			jQuery,
			jQuery.map( [
				{
					type: "success",
					url: baseURL + "mock.php?action=echoQuery&arg=pop"
				},
				{
					type: "error",
					url: baseURL + "404.txt"
				}
			],
			function( options ) {
				return jQuery.Deferred( function( defer ) {
					jQuery( "#foo" ).load( options.url, function() {
						var args = arguments;
						assert.strictEqual( completeArgs[ options.url ].length, args.length, "same number of arguments (" + options.type + ")" );
						jQuery.each( completeArgs[ options.url ], function( i, value ) {
							assert.strictEqual( args[ i ], value, "argument #" + i + " is the same (" + options.type + ")" );
						} );
						defer.resolve();
					} );
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
diff --git a/a.js b/b.js
@@ -2903,7 +2917,7 @@ QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataTy
A blob:4ab17e8eb56359c566a25a2ed4c6f0da4c033edf
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
			dataType: "json"
		} );
		jQuery( document ).on( "ajaxComplete", function( e, xml, s ) {
			assert.strictEqual( s.dataType, "html", "Verify the load() dataType was html" );
			jQuery( document ).off( "ajaxComplete" );
			done();
		} );
		jQuery( "#first" ).load( baseURL + "test3.html" );
	} );

	QUnit.test( "#10524 - jQuery.fn.load() - data specified in ajaxSettings is merged in", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		var data = {
diff --git a/a.js b/b.js
@@ -22,8 +22,8 @@ module.exports = function( grunt ) {
A blob:a3e4f0c467835146b2b75de0450d5c7d4cfd06ff
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}
diff --git a/a.js b/b.js
@@ -241,10 +241,10 @@ module.exports = function( grunt ) {
A blob:a3e4f0c467835146b2b75de0450d5c7d4cfd06ff
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...fs
						.readFileSync( `${ __dirname }/.eslintignore`, "utf-8" )
						.split( "\n" )
						.filter( filePath => filePath )
						.map( filePath => filePath[ 0 ] === "!" ?
							filePath.slice( 1 ) :
							`!${ filePath }`
						)
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,

				// 2 minutes; has to be longer than QUnit.config.testTimeout
				browserNoActivityTimeout: 120e3,

				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -259,7 +259,7 @@ module.exports = function( grunt ) {
A blob:a3e4f0c467835146b2b75de0450d5c7d4cfd06ff
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...fs
						.readFileSync( `${ __dirname }/.eslintignore`, "utf-8" )
						.split( "\n" )
						.filter( filePath => filePath )
						.map( filePath => filePath[ 0 ] === "!" ?
							filePath.slice( 1 ) :
							`!${ filePath }`
						)
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,

				// 2 minutes; has to be longer than QUnit.config.testTimeout
				browserNoActivityTimeout: 120e3,

				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -50,7 +50,7 @@ attr: function( elem, name, value ) {
A blob:2773a383c5bd1c6f0b2f290296e8639b0b0b45c7
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ];
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
diff --git a/a.js b/b.js
@@ -264,6 +264,14 @@ trustedHtml: function( req, resp ) {
A blob:0bd44f95b7d4f5285cd62c1021aecc3aeb55a401
	cspClean: function( req, resp ) {
		cspLog = "";
		resp.writeHead( 200 );
		resp.end();
	},
	trustedHtml: function( req, resp ) {
		resp.writeHead( 200, {
			"Content-Type": "text/html",
			"Content-Security-Policy": "require-trusted-types-for 'script'; report-uri /base/test/data/mock.php?action=cspLog"
		} );
		var body = fs.readFileSync( __dirname + "/data/trusted-html.html" ).toString();
		resp.end( body );
	},
	errorWithScript: function( req, resp ) {
		if ( req.query.withScriptContentType ) {
			resp.writeHead( 404, { "Content-Type": "application/javascript" } );
		} else {
diff --git a/a.js b/b.js
@@ -82,9 +82,9 @@ QUnit.test( "attr(String)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	};

	assert.deepEqual( props, jQuery.propFix, "jQuery.propFix passes integrity check" );
} );

QUnit.test( "attr(String)", function( assert ) {
	assert.expect( 50 );

	var extras, body, $body,
		select, optgroup, option, $img, styleElem,
		$button, $form, $a;

	assert.equal( jQuery( "#text1" ).attr( "type" ), "text", "Check for type attribute" );
	assert.equal( jQuery( "#radio1" ).attr( "type" ), "radio", "Check for type attribute" );
	assert.equal( jQuery( "#check1" ).attr( "type" ), "checkbox", "Check for type attribute" );
	assert.equal( jQuery( "#simon1" ).attr( "rel" ), "bookmark", "Check for rel attribute" );
	assert.equal( jQuery( "#google" ).attr( "title" ), "Google!", "Check for title attribute" );
	assert.equal( jQuery( "#mark" ).attr( "hreflang" ), "en", "Check for hreflang attribute" );
	assert.equal( jQuery( "#en" ).attr( "lang" ), "en", "Check for lang attribute" );
	assert.equal( jQuery( "#simon" ).attr( "class" ), "blog link", "Check for class attribute" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "name", "Check for name attribute" );
	assert.equal( jQuery( "#text1" ).attr( "name" ), "action", "Check for name attribute" );
	assert.ok( jQuery( "#form" ).attr( "action" ).indexOf( "formaction" ) >= 0, "Check for action attribute" );
	assert.equal( jQuery( "#text1" ).attr( "value", "t" ).attr( "value" ), "t", "Check setting the value attribute" );
	assert.equal( jQuery( "#text1" ).attr( "value", "" ).attr( "value" ), "", "Check setting the value attribute to empty string" );
	assert.equal( jQuery( "<div value='t'></div>" ).attr( "value" ), "t", "Check setting custom attr named 'value' on a div" );
	assert.equal( jQuery( "#form" ).attr( "blah", "blah" ).attr( "blah" ), "blah", "Set non-existent attribute on a form" );
	assert.equal( jQuery( "#foo" ).attr( "height" ), undefined, "Non existent height attribute should return undefined" );

	// [7472] & [3113] (form contains an input with name="action" or name="id")
	extras = jQuery( "<input id='id' name='id' /><input id='name' name='name' /><input id='target' name='target' />" ).appendTo( "#testForm" );
	assert.equal( jQuery( "#form" ).attr( "action", "newformaction" ).attr( "action" ), "newformaction", "Check that action attribute was changed" );
	assert.equal( jQuery( "#testForm" ).attr( "target" ), undefined, "Retrieving target does not equal the input with name=target" );
	assert.equal( jQuery( "#testForm" ).attr( "target", "newTarget" ).attr( "target" ), "newTarget", "Set target successfully on a form" );
	assert.equal( jQuery( "#testForm" ).removeAttr( "id" ).attr( "id" ), undefined, "Retrieving id does not equal the input with name=id after id is removed [#7472]" );

	// Bug #3685 (form contains input with name="name")
	assert.equal( jQuery( "#testForm" ).attr( "name" ), undefined, "Retrieving name does not retrieve input with name=name" );
	extras.remove();

	assert.equal( jQuery( "#text1" ).attr( "maxlength" ), "30", "Check for maxlength attribute" );
diff --git a/a.js b/b.js
@@ -142,13 +142,13 @@ jQuery( "<a></a>" ).attr( {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	assert.equal( jQuery( "#text1" ).attr( "maxlength" ), "30", "Check for maxlength attribute" );
	assert.equal( jQuery( "#text1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );
	assert.equal( jQuery( "#area1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );

	// using innerHTML in IE causes href attribute to be serialized to the full path
	jQuery( "<a></a>" ).attr( {
		"id": "tAnchor5",
		"href": "#5"
	} ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).attr( "href" ), "#5", "Check for non-absolute href (an anchor)" );
	jQuery( "<a id='tAnchor6' href='#5'></a>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#tAnchor6" ).prop( "href" ), "Check for absolute href prop on an anchor" );

	jQuery( "<script type='jquery/test' src='#5' id='scriptSrc'></script>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#scriptSrc" ).prop( "src" ), "Check for absolute src prop on a script" );

	// list attribute is readonly by default in browsers that support it
	jQuery( "#list-test" ).attr( "list", "datalist" );
	assert.equal( jQuery( "#list-test" ).attr( "list" ), "datalist", "Check setting list attribute" );

	// Related to [5574] and [5683]
	body = document.body;
	$body = jQuery( body );

	assert.strictEqual( $body.attr( "foo" ), undefined, "Make sure that a non existent attribute returns undefined" );

	body.setAttribute( "foo", "baz" );
	assert.equal( $body.attr( "foo" ), "baz", "Make sure the dom attribute is retrieved when no expando is found" );

	$body.attr( "foo", "cool" );
	assert.equal( $body.attr( "foo" ), "cool", "Make sure that setting works well when both expando and dom attribute are available" );

	body.removeAttribute( "foo" ); // Cleanup

	select = document.createElement( "select" );
	optgroup = document.createElement( "optgroup" );
	option = document.createElement( "option" );

	optgroup.appendChild( option );
	select.appendChild( optgroup );

	assert.equal( jQuery( option ).prop( "selected" ), true, "Make sure that a single option is selected, even when in an optgroup." );

	$img = jQuery( "<img style='display:none' width='215' height='53' src='" + baseURL + "1x1.jpg'/>" ).appendTo( "body" );
	assert.equal( $img.attr( "width" ), "215", "Retrieve width attribute on an element with display:none." );
	assert.equal( $img.attr( "height" ), "53", "Retrieve height attribute on an element with display:none." );

	// Check for style support
	styleElem = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).css( {
		background: "url(UPPERlower.gif)"
	} );
	assert.ok( !!~styleElem.attr( "style" ).indexOf( "UPPERlower.gif" ), "Check style attribute getter" );
	assert.ok( !!~styleElem.attr( "style", "position:absolute;" ).attr( "style" ).indexOf( "absolute" ), "Check style setter" );

	// Check value on button element (#1954)
	$button = jQuery( "<button>text</button>" ).insertAfter( "#button" );
	assert.strictEqual( $button.attr( "value" ), undefined, "Absence of value attribute on a button" );
	assert.equal( $button.attr( "value", "foobar" ).attr( "value" ), "foobar", "Value attribute on a button does not return innerHTML" );
	assert.equal( $button.attr( "value", "baz" ).html(), "text", "Setting the value attribute does not change innerHTML" );

	// Attributes with a colon on a table element (#1591)
	assert.equal( jQuery( "#table" ).attr( "test:attrib" ), undefined, "Retrieving a non-existent attribute on a table with a colon does not throw an error." );
	assert.equal( jQuery( "#table" ).attr( "test:attrib", "foobar" ).attr( "test:attrib" ), "foobar", "Setting an attribute on a table with a colon does not throw an error." );

	$form = jQuery( "<form class='something'></form>" ).appendTo( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -166,11 +166,11 @@ jQuery( "<a></a>" ).attr( {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	assert.equal( jQuery( "#text1" ).attr( "maxlength" ), "30", "Check for maxlength attribute" );
	assert.equal( jQuery( "#text1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );
	assert.equal( jQuery( "#area1" ).attr( "maxLength" ), "30", "Check for maxLength attribute" );

	// using innerHTML in IE causes href attribute to be serialized to the full path
	jQuery( "<a></a>" ).attr( {
		"id": "tAnchor5",
		"href": "#5"
	} ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).attr( "href" ), "#5", "Check for non-absolute href (an anchor)" );
	jQuery( "<a id='tAnchor6' href='#5'></a>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#tAnchor6" ).prop( "href" ), "Check for absolute href prop on an anchor" );

	jQuery( "<script type='jquery/test' src='#5' id='scriptSrc'></script>" ).appendTo( "#qunit-fixture" );
	assert.equal( jQuery( "#tAnchor5" ).prop( "href" ), jQuery( "#scriptSrc" ).prop( "src" ), "Check for absolute src prop on a script" );

	// list attribute is readonly by default in browsers that support it
	jQuery( "#list-test" ).attr( "list", "datalist" );
	assert.equal( jQuery( "#list-test" ).attr( "list" ), "datalist", "Check setting list attribute" );

	// Related to [5574] and [5683]
	body = document.body;
	$body = jQuery( body );

	assert.strictEqual( $body.attr( "foo" ), undefined, "Make sure that a non existent attribute returns undefined" );

	body.setAttribute( "foo", "baz" );
	assert.equal( $body.attr( "foo" ), "baz", "Make sure the dom attribute is retrieved when no expando is found" );

	$body.attr( "foo", "cool" );
	assert.equal( $body.attr( "foo" ), "cool", "Make sure that setting works well when both expando and dom attribute are available" );

	body.removeAttribute( "foo" ); // Cleanup

	select = document.createElement( "select" );
	optgroup = document.createElement( "optgroup" );
	option = document.createElement( "option" );

	optgroup.appendChild( option );
	select.appendChild( optgroup );

	assert.equal( jQuery( option ).prop( "selected" ), true, "Make sure that a single option is selected, even when in an optgroup." );

	$img = jQuery( "<img style='display:none' width='215' height='53' src='" + baseURL + "1x1.jpg'/>" ).appendTo( "body" );
	assert.equal( $img.attr( "width" ), "215", "Retrieve width attribute on an element with display:none." );
	assert.equal( $img.attr( "height" ), "53", "Retrieve height attribute on an element with display:none." );

	// Check for style support
	styleElem = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).css( {
		background: "url(UPPERlower.gif)"
	} );
	assert.ok( !!~styleElem.attr( "style" ).indexOf( "UPPERlower.gif" ), "Check style attribute getter" );
	assert.ok( !!~styleElem.attr( "style", "position:absolute;" ).attr( "style" ).indexOf( "absolute" ), "Check style setter" );

	// Check value on button element (#1954)
	$button = jQuery( "<button>text</button>" ).insertAfter( "#button" );
	assert.strictEqual( $button.attr( "value" ), undefined, "Absence of value attribute on a button" );
	assert.equal( $button.attr( "value", "foobar" ).attr( "value" ), "foobar", "Value attribute on a button does not return innerHTML" );
	assert.equal( $button.attr( "value", "baz" ).html(), "text", "Setting the value attribute does not change innerHTML" );

	// Attributes with a colon on a table element (#1591)
	assert.equal( jQuery( "#table" ).attr( "test:attrib" ), undefined, "Retrieving a non-existent attribute on a table with a colon does not throw an error." );
	assert.equal( jQuery( "#table" ).attr( "test:attrib", "foobar" ).attr( "test:attrib" ), "foobar", "Setting an attribute on a table with a colon does not throw an error." );

	$form = jQuery( "<form class='something'></form>" ).appendTo( "#qunit-fixture" );
	assert.equal( $form.attr( "class" ), "something", "Retrieve the class attribute on a form." );

	$a = jQuery( "<a href='#' onclick='something()'>Click</a>" ).appendTo( "#qunit-fixture" );
	assert.equal( $a.attr( "onclick" ), "something()", "Retrieve ^on attribute without anonymous function wrapper." );

	assert.ok( jQuery( "<div></div>" ).attr( "doesntexist" ) === undefined, "Make sure undefined is returned when no attribute is found." );
	assert.ok( jQuery( "<div></div>" ).attr( "title" ) === undefined, "Make sure undefined is returned when no attribute is found." );
	assert.equal( jQuery( "<div></div>" ).attr( "title", "something" ).attr( "title" ), "something", "Set the title attribute." );
	assert.ok( jQuery().attr( "doesntexist" ) === undefined, "Make sure undefined is returned when no element is there." );
	assert.equal( jQuery( "<div></div>" ).attr( "value" ), undefined, "An unset value on a div returns undefined." );
	assert.strictEqual( jQuery( "<select><option value='property'></option></select>" ).attr( "value" ), undefined, "An unset value on a select returns undefined." );

	$form = jQuery( "#form" ).attr( "enctype", "multipart/form-data" );
	assert.equal( $form.prop( "enctype" ), "multipart/form-data", "Set the enctype of a form (encoding in IE6/7 #6743)" );

} );

QUnit.test( "attr(String) on cloned elements, #9646", function( assert ) {
	assert.expect( 4 );

	var div,
		input = jQuery( "<input name='tester' />" );
diff --git a/a.js b/b.js
@@ -295,7 +295,7 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
diff --git a/a.js b/b.js
@@ -377,13 +377,13 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

diff --git a/a.js b/b.js
@@ -402,7 +402,7 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

	// Register the property on the window for the previous assertion so it will be clean up
	Globals.register( "nonexisting" );

	table = jQuery( "#table" ).append( "<tr><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr>" );
	td = table.find( "td" ).eq( 0 );
	td.attr( "rowspan", "2" );
	assert.equal( td[ 0 ][ "rowSpan" ], 2, "Check rowspan is correctly set" );
	td.attr( "colspan", "2" );
	assert.equal( td[ 0 ][ "colSpan" ], 2, "Check colspan is correctly set" );
	table.attr( "cellspacing", "2" );
	assert.equal( table[ 0 ][ "cellSpacing" ], "2", "Check cellspacing is correctly set" );

	assert.equal( jQuery( "#area1" ).attr( "value" ), undefined, "Value attribute is distinct from value property." );

	// for #1070
	jQuery( "#name" ).attr( "someAttr", "0" );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to a string of '0'" );
	jQuery( "#name" ).attr( "someAttr", 0 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to the number 0" );
diff --git a/a.js b/b.js
@@ -462,7 +462,7 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

	// Register the property on the window for the previous assertion so it will be clean up
	Globals.register( "nonexisting" );

	table = jQuery( "#table" ).append( "<tr><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr>" );
	td = table.find( "td" ).eq( 0 );
	td.attr( "rowspan", "2" );
	assert.equal( td[ 0 ][ "rowSpan" ], 2, "Check rowspan is correctly set" );
	td.attr( "colspan", "2" );
	assert.equal( td[ 0 ][ "colSpan" ], 2, "Check colspan is correctly set" );
	table.attr( "cellspacing", "2" );
	assert.equal( table[ 0 ][ "cellSpacing" ], "2", "Check cellspacing is correctly set" );

	assert.equal( jQuery( "#area1" ).attr( "value" ), undefined, "Value attribute is distinct from value property." );

	// for #1070
	jQuery( "#name" ).attr( "someAttr", "0" );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to a string of '0'" );
	jQuery( "#name" ).attr( "someAttr", 0 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to the number 0" );
	jQuery( "#name" ).attr( "someAttr", 1 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "1", "Set attribute to the number 1" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();

	j.attr( "name", "attrvalue" );
	assert.equal( j.attr( "name" ), "attrvalue", "Check node,textnode,comment for attr" );
	j.removeAttr( "name" );

	// Type
	type = jQuery( "#check2" ).attr( "type" );
	try {
		jQuery( "#check2" ).attr( "type", "hidden" );
		assert.ok( true, "No exception thrown on input type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on input type change: " + e );
	}

	check = document.createElement( "input" );
	thrown = true;
	try {
		jQuery( check ).attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", jQuery( check ).attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	check = jQuery( "<input />" );
	thrown = true;
	try {
		check.attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", check.attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	button = jQuery( "#button" );
	try {
		button.attr( "type", "submit" );
		assert.ok( true, "No exception thrown on button type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on button type change: " + e );
	}

	$radio = jQuery( "<input>", {
		"value": "sup",
		// Use uppercase here to ensure the type
		// attrHook is still used
		"TYPE": "radio"
	} ).appendTo( "#testForm" );
	assert.equal( $radio.val(), "sup", "Value is not reset when type is set after value on a radio" );

	// Setting attributes on svg elements (bug #3116)
	$svg = jQuery(
		"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1' baseProfile='full' width='200' height='200'>" +

			"<circle cx='200' cy='200' r='150' />" +
diff --git a/a.js b/b.js
@@ -474,9 +474,9 @@ QUnit.test( "attr(String, Object)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
		"0",
		"Set attribute to computed value #2"
	);
} );

QUnit.test( "attr(String, Object)", function( assert ) {
	assert.expect( 71 );

	var $input, $text, $details,
		attributeNode, commentNode, textNode, obj,
		table, td, j, type,
		check, thrown, button, $radio, $radios, $svg,
		div = jQuery( "#qunit-fixture div" ).attr( "foo", "bar" ),
		i = 0,
		fail = false;

	for ( ; i < div.length; i++ ) {
		if ( div[ i ].getAttribute( "foo" ) !== "bar" ) {
			fail = i;
			break;
		}
	}

	assert.equal( fail, false, "Set Attribute, the #" + fail + " element didn't get the attribute 'foo'" );

	assert.ok(
		jQuery( "#foo" ).attr( {
			"width": null
		} ),
		"Try to set an attribute to nothing"
	);

	jQuery( "#name" ).attr( "name", "something" );
	assert.equal( jQuery( "#name" ).attr( "name" ), "something", "Set name attribute" );
	jQuery( "#name" ).attr( "name", null );
	assert.equal( jQuery( "#name" ).attr( "name" ), undefined, "Remove name attribute" );

	$input = jQuery( "<input>", {
		name: "something",
		id: "specified"
	} );
	assert.equal( $input.attr( "name" ), "something", "Check element creation gets/sets the name attribute." );
	assert.equal( $input.attr( "id" ), "specified", "Check element creation gets/sets the id attribute." );

	// As of fixing #11115, we only guarantee boolean property update for checked and selected
	$input = jQuery( "<input type='checkbox'/>" ).attr( "checked", true );
	assert.equal( $input.prop( "checked" ), true, "Setting checked updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].checked, true, "Setting checked updates property (verified by native property)" );
	$input = jQuery( "<option></option>" ).attr( "selected", true );
	assert.equal( $input.prop( "selected" ), true, "Setting selected updates property (verified by .prop)" );
	assert.equal( $input[ 0 ].selected, true, "Setting selected updates property (verified by native property)" );

	$input = jQuery( "#check2" );
	$input.prop( "checked", true ).prop( "checked", false ).attr( "checked", true );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked (verified by .attr)" );
	$input.prop( "checked", false ).prop( "checked", true ).attr( "checked", false );
	assert.equal( $input.attr( "checked" ), undefined, "Remove checked (verified by .attr)" );

	$input = jQuery( "#text1" ).prop( "readOnly", true ).prop( "readOnly", false ).attr( "readonly", true );
	assert.equal( $input.attr( "readonly" ), "readonly", "Set readonly (verified by .attr)" );
	$input.prop( "readOnly", false ).prop( "readOnly", true ).attr( "readonly", false );
	assert.equal( $input.attr( "readonly" ), undefined, "Remove readonly (verified by .attr)" );

	$input = jQuery( "#check2" ).attr( "checked", true ).attr( "checked", false ).prop( "checked", true );
	assert.equal( $input[ 0 ].checked, true, "Set checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), true, "Set checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), undefined, "Setting checked property doesn't affect checked attribute" );
	$input.attr( "checked", false ).attr( "checked", true ).prop( "checked", false );
	assert.equal( $input[ 0 ].checked, false, "Clear checked property (verified by native property)" );
	assert.equal( $input.prop( "checked" ), false, "Clear checked property (verified by .prop)" );
	assert.equal( $input.attr( "checked" ), "checked", "Clearing checked property doesn't affect checked attribute" );

	$input = jQuery( "#check2" ).attr( "checked", false ).attr( "checked", "checked" );
	assert.equal( $input.attr( "checked" ), "checked", "Set checked to 'checked' (verified by .attr)" );

	$radios = jQuery( "#checkedtest" ).find( "input[type='radio']" );
	$radios.eq( 1 ).trigger( "click" );
	assert.equal( $radios.eq( 1 ).prop( "checked" ), true, "Second radio was checked when clicked" );
	assert.equal( $radios.eq( 0 ).attr( "checked" ), "checked", "First radio is still [checked]" );

	$input = jQuery( "#text1" ).attr( "readonly", false ).prop( "readOnly", true );
	assert.equal( $input[ 0 ].readOnly, true, "Set readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), true, "Set readonly property (verified by .prop)" );
	$input.attr( "readonly", true ).prop( "readOnly", false );
	assert.equal( $input[ 0 ].readOnly, false, "Clear readonly property (verified by native property)" );
	assert.equal( $input.prop( "readOnly" ), false, "Clear readonly property (verified by .prop)" );

	$input = jQuery( "#name" ).attr( "maxlength", "5" );
	assert.equal( $input[ 0 ].maxLength, 5, "Set maxlength (verified by native property)" );
	$input.attr( "maxLength", "10" );
	assert.equal( $input[ 0 ].maxLength, 10, "Set maxlength (verified by native property)" );

	// HTML5 boolean attributes
	$text = jQuery( "#text1" ).attr( {
		"autofocus": true,
		"required": true
	} );
	assert.equal( $text.attr( "autofocus" ), "autofocus", "Reading autofocus attribute yields 'autofocus'" );
	assert.equal( $text.attr( "autofocus", false ).attr( "autofocus" ), undefined, "Setting autofocus to false removes it" );
	assert.equal( $text.attr( "required" ), "required", "Reading required attribute yields 'required'" );
	assert.equal( $text.attr( "required", false ).attr( "required" ), undefined, "Setting required attribute to false removes it" );

	$details = jQuery( "<details open></details>" ).appendTo( "#qunit-fixture" );
	assert.equal( $details.attr( "open" ), "open", "open attribute presence indicates true" );
	assert.equal( $details.attr( "open", false ).attr( "open" ), undefined, "Setting open attribute to false removes it" );

	$text.attr( "data-something", true );
	assert.equal( $text.attr( "data-something" ), "true", "Set data attributes" );
	assert.equal( $text.data( "something" ), true, "Setting data attributes are not affected by boolean settings" );
	$text.attr( "data-another", false );
	assert.equal( $text.attr( "data-another" ), "false", "Set data attributes" );
	assert.equal( $text.data( "another" ), false, "Setting data attributes are not affected by boolean settings" );
	assert.equal( $text.attr( "aria-disabled", false ).attr( "aria-disabled" ), "false", "Setting aria attributes are not affected by boolean settings" );
	$text.removeData( "something" ).removeData( "another" ).removeAttr( "aria-disabled" );

	jQuery( "#foo" ).attr( "contenteditable", true );
	assert.equal( jQuery( "#foo" ).attr( "contenteditable" ), "true", "Enumerated attributes are set properly" );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};

	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, elem ) {
		var $elem = jQuery( elem );
		$elem.attr( "nonexisting", "foo" );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr(name, value) works correctly on comment and text nodes (bug #7500)." );
	} );

	jQuery.each( [ window, document, obj, "#firstp" ], function( i, elem ) {
		var oldVal = elem.nonexisting,
			$elem = jQuery( elem );
		assert.strictEqual( $elem.attr( "nonexisting" ), undefined, "attr works correctly for non existing attributes (bug #7500)." );
		assert.equal( $elem.attr( "nonexisting", "foo" ).attr( "nonexisting" ), "foo", "attr falls back to prop on unsupported arguments" );
		elem.nonexisting = oldVal;
	} );

	// Register the property on the window for the previous assertion so it will be clean up
	Globals.register( "nonexisting" );

	table = jQuery( "#table" ).append( "<tr><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr><tr><td>cell</td><td>cell</td></tr>" );
	td = table.find( "td" ).eq( 0 );
	td.attr( "rowspan", "2" );
	assert.equal( td[ 0 ][ "rowSpan" ], 2, "Check rowspan is correctly set" );
	td.attr( "colspan", "2" );
	assert.equal( td[ 0 ][ "colSpan" ], 2, "Check colspan is correctly set" );
	table.attr( "cellspacing", "2" );
	assert.equal( table[ 0 ][ "cellSpacing" ], "2", "Check cellspacing is correctly set" );

	assert.equal( jQuery( "#area1" ).attr( "value" ), undefined, "Value attribute is distinct from value property." );

	// for #1070
	jQuery( "#name" ).attr( "someAttr", "0" );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to a string of '0'" );
	jQuery( "#name" ).attr( "someAttr", 0 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "0", "Set attribute to the number 0" );
	jQuery( "#name" ).attr( "someAttr", 1 );
	assert.equal( jQuery( "#name" ).attr( "someAttr" ), "1", "Set attribute to the number 1" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();

	j.attr( "name", "attrvalue" );
	assert.equal( j.attr( "name" ), "attrvalue", "Check node,textnode,comment for attr" );
	j.removeAttr( "name" );

	// Type
	type = jQuery( "#check2" ).attr( "type" );
	try {
		jQuery( "#check2" ).attr( "type", "hidden" );
		assert.ok( true, "No exception thrown on input type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on input type change: " + e );
	}

	check = document.createElement( "input" );
	thrown = true;
	try {
		jQuery( check ).attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", jQuery( check ).attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	check = jQuery( "<input />" );
	thrown = true;
	try {
		check.attr( "type", "checkbox" );
	} catch ( e ) {
		thrown = false;
	}
	assert.ok( thrown, "Exception thrown when trying to change type property" );
	assert.equal( "checkbox", check.attr( "type" ), "Verify that you can change the type of an input element that isn't in the DOM" );

	button = jQuery( "#button" );
	try {
		button.attr( "type", "submit" );
		assert.ok( true, "No exception thrown on button type change" );
	} catch ( e ) {
		assert.ok( true, "Exception thrown on button type change: " + e );
	}

	$radio = jQuery( "<input>", {
		"value": "sup",
		// Use uppercase here to ensure the type
		// attrHook is still used
		"TYPE": "radio"
	} ).appendTo( "#testForm" );
	assert.equal( $radio.val(), "sup", "Value is not reset when type is set after value on a radio" );

	// Setting attributes on svg elements (bug #3116)
	$svg = jQuery(
		"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1' baseProfile='full' width='200' height='200'>" +

			"<circle cx='200' cy='200' r='150' />" +
			"</svg>"
		).appendTo( "body" );
	assert.equal( $svg.attr( "cx", 100 ).attr( "cx" ), "100", "Set attribute on svg element" );
	$svg.remove();

	// undefined values are chainable
	jQuery( "#name" ).attr( "maxlength", "5" ).removeAttr( "nonexisting" );
	assert.equal( typeof jQuery( "#name" ).attr( "maxlength", undefined ), "object", ".attr('attribute', undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#name" ).attr( "maxlength", undefined ).attr( "maxlength" ), "5", ".attr('attribute', undefined) does not change value (#5571)" );
	assert.equal( jQuery( "#name" ).attr( "nonexisting", undefined ).attr( "nonexisting" ), undefined, ".attr('attribute', undefined) does not create attribute (#5571)" );
} );

QUnit.test( "attr(non-ASCII)", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -573,7 +573,7 @@ QUnit.test( "removeAttr(String)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	element.attr( "tabindex", -1 );
	assert.equal( element.attr( "tabindex" ), "-1", "set negative tabindex" );
} );

QUnit.test( "removeAttr(String)", function( assert ) {
	assert.expect( 12 );
	var $first;

	assert.equal( jQuery( "<div class='hello'></div>" ).removeAttr( "class" ).attr( "class" ), undefined, "remove class" );
	assert.equal( jQuery( "#form" ).removeAttr( "id" ).attr( "id" ), undefined, "Remove id" );
	assert.equal( jQuery( "#foo" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute" );
	assert.equal( jQuery( "#form" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute on a form" );
	assert.equal( jQuery( "<div style='position: absolute'></div>" ).appendTo( "#foo" ).removeAttr( "style" ).prop( "style" ).cssText, "", "Check removing style attribute (#9699 Webkit)" );
	assert.equal( jQuery( "#fx-test-group" ).attr( "height", "3px" ).removeAttr( "height" ).get( 0 ).style.height, "1px", "Removing height attribute has no effect on height set with style attribute" );

	jQuery( "#check1" ).removeAttr( "checked" ).prop( "checked", true ).removeAttr( "checked" );
	assert.equal( document.getElementById( "check1" ).checked, true, "removeAttr should not set checked to false, since the checked attribute does NOT mirror the checked property" );
diff --git a/a.js b/b.js
@@ -582,13 +582,13 @@ QUnit.test( "removeAttr(String)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	element.attr( "tabindex", -1 );
	assert.equal( element.attr( "tabindex" ), "-1", "set negative tabindex" );
} );

QUnit.test( "removeAttr(String)", function( assert ) {
	assert.expect( 12 );
	var $first;

	assert.equal( jQuery( "<div class='hello'></div>" ).removeAttr( "class" ).attr( "class" ), undefined, "remove class" );
	assert.equal( jQuery( "#form" ).removeAttr( "id" ).attr( "id" ), undefined, "Remove id" );
	assert.equal( jQuery( "#foo" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute" );
	assert.equal( jQuery( "#form" ).attr( "style", "position:absolute;" ).removeAttr( "style" ).attr( "style" ), undefined, "Check removing style attribute on a form" );
	assert.equal( jQuery( "<div style='position: absolute'></div>" ).appendTo( "#foo" ).removeAttr( "style" ).prop( "style" ).cssText, "", "Check removing style attribute (#9699 Webkit)" );
	assert.equal( jQuery( "#fx-test-group" ).attr( "height", "3px" ).removeAttr( "height" ).get( 0 ).style.height, "1px", "Removing height attribute has no effect on height set with style attribute" );

	jQuery( "#check1" ).removeAttr( "checked" ).prop( "checked", true ).removeAttr( "checked" );
	assert.equal( document.getElementById( "check1" ).checked, true, "removeAttr should not set checked to false, since the checked attribute does NOT mirror the checked property" );
	jQuery( "#text1" ).prop( "readOnly", true ).removeAttr( "readonly" );
	assert.equal( document.getElementById( "text1" ).readOnly, false, "removeAttr sets boolean properties to false" );

	jQuery( "#option2c" ).removeAttr( "selected" );
	assert.equal( jQuery( "#option2d" ).attr( "selected" ), "selected", "Removing `selected` from an option that is not selected does not remove selected from the currently selected option (#10870)" );

	try {
		$first = jQuery( "#first" ).attr( "contenteditable", "true" ).removeAttr( "contenteditable" );
		assert.equal( $first.attr( "contenteditable" ), undefined, "Remove the contenteditable attribute" );
	} catch ( e ) {
		assert.ok( false, "Removing contenteditable threw an error (#10429)" );
	}

	$first = jQuery( "<div Case='mixed'></div>" );
	assert.equal( $first.attr( "Case" ), "mixed", "case of attribute doesn't matter" );
diff --git a/a.js b/b.js
@@ -714,26 +714,26 @@ QUnit.test( "prop(String, Object) on null/undefined", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	assert.equal( jQuery( "#table" ).prop( "useMap" ), 1, "Check setting and retrieving useMap" );
	jQuery( "#table" ).prop( "frameborder", 1 );
	assert.equal( jQuery( "#table" ).prop( "frameBorder" ), 1, "Check setting and retrieving frameBorder" );
} );

QUnit.test( "prop(String, Object) on null/undefined", function( assert ) {

  assert.expect( 14 );

	var select, optgroup, option, attributeNode, commentNode, textNode, obj, $form,
		body = document.body,
		$body = jQuery( body );

	assert.ok( $body.prop( "nextSibling" ) === null, "Make sure a null expando returns null" );
	body[ "foo" ] = "bar";
	assert.equal( $body.prop( "foo" ), "bar", "Make sure the expando is preferred over the dom attribute" );
	body[ "foo" ] = undefined;
	assert.ok( $body.prop( "foo" ) === undefined, "Make sure the expando is preferred over the dom attribute, even if undefined" );

	select = document.createElement( "select" );
	optgroup = document.createElement( "optgroup" );
	option = document.createElement( "option" );

	optgroup.appendChild( option );
	select.appendChild( optgroup );

	assert.equal( jQuery( option ).prop( "selected" ), true, "Make sure that a single option is selected, even when in an optgroup." );
	assert.equal( jQuery( document ).prop( "nodeName" ), "#document", "prop works correctly on document nodes (bug #7451)." );

	attributeNode = document.createAttribute( "irrelevant" );
	commentNode = document.createComment( "some comment" );
	textNode = document.createTextNode( "some text" );
	obj = {};
	jQuery.each( [ document, attributeNode, commentNode, textNode, obj, "#firstp" ], function( i, ele ) {
		assert.strictEqual( jQuery( ele ).prop( "nonexisting" ), undefined, "prop works correctly for non existing attributes (bug #7500)." );
	} );

	obj = {};
	jQuery.each( [ document, obj ], function( i, ele ) {
		var $ele = jQuery( ele );
		$ele.prop( "nonexisting", "foo" );
		assert.equal( $ele.prop( "nonexisting" ), "foo", "prop(name, value) works correctly for non existing attributes (bug #7500)." );
	} );
	jQuery( document ).removeProp( "nonexisting" );

	$form = jQuery( "#form" ).prop( "enctype", "multipart/form-data" );
	assert.equal( $form.prop( "enctype" ), "multipart/form-data", "Set the enctype of a form (encoding in IE6/7 #6743)" );
} );

QUnit.test( "prop('tabindex')", function( assert ) {
	assert.expect( 11 );
diff --git a/a.js b/b.js
@@ -856,12 +856,12 @@ QUnit.test( "removeProp(String)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	$select.find( "[value=b]" ).prop( "selected", true );

	assert.equal( $select[ 0 ].selectedIndex, 1, "Setting option in optgroup selected affects selectedIndex" );
} );

QUnit.test( "removeProp(String)", function( assert ) {
	assert.expect( 6 );
	var attributeNode = document.createAttribute( "irrelevant" ),
		commentNode = document.createComment( "some comment" ),
		textNode = document.createTextNode( "some text" ),
		obj = {};

	assert.strictEqual(
		jQuery( "#firstp" ).prop( "nonexisting", "foo" ).removeProp( "nonexisting" )[ 0 ][ "nonexisting" ],
		undefined,
		"removeprop works correctly on DOM element nodes"
	);

	jQuery.each( [ document, obj ], function( i, ele ) {
		var $ele = jQuery( ele );
		$ele.prop( "nonexisting", "foo" ).removeProp( "nonexisting" );
		assert.strictEqual( ele[ "nonexisting" ], undefined, "removeProp works correctly on non DOM element nodes (bug #7500)." );
	} );
	jQuery.each( [ commentNode, textNode, attributeNode ], function( i, ele ) {
		var $ele = jQuery( ele );
		$ele.prop( "nonexisting", "foo" ).removeProp( "nonexisting" );
		assert.strictEqual( ele[ "nonexisting" ], undefined, "removeProp works correctly on non DOM element nodes (bug #7500)." );
	} );
} );

QUnit.test( "val() after modification", function( assert ) {
diff --git a/a.js b/b.js
@@ -880,7 +880,7 @@ QUnit.test( "val()", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	document.getElementById( "text1" ).value = "bla";
	assert.equal( jQuery( "#text1" ).val(), "bla", "Check for modified value of input element" );
} );

QUnit.test( "val()", function( assert ) {

	assert.expect( 20 + ( jQuery.fn.serialize ? 6 : 0 ) );

	var checks, $button;
	assert.equal( jQuery( "#text1" ).val(), "Test", "Check for value of input element" );

	// ticket #1714 this caused a JS error in IE
	assert.equal( jQuery( "#first" ).val(), "", "Check a paragraph element to see if it has a value" );
	assert.ok( jQuery( [] ).val() === undefined, "Check an empty jQuery object will return undefined from val" );

	assert.equal( jQuery( "#select2" ).val(), "3", "Call val() on a single='single' select" );
diff --git a/a.js b/b.js
@@ -918,7 +918,7 @@ QUnit.test( "val()", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	document.getElementById( "text1" ).value = "bla";
	assert.equal( jQuery( "#text1" ).val(), "bla", "Check for modified value of input element" );
} );

QUnit.test( "val()", function( assert ) {

	assert.expect( 20 + ( jQuery.fn.serialize ? 6 : 0 ) );

	var checks, $button;
	assert.equal( jQuery( "#text1" ).val(), "Test", "Check for value of input element" );

	// ticket #1714 this caused a JS error in IE
	assert.equal( jQuery( "#first" ).val(), "", "Check a paragraph element to see if it has a value" );
	assert.ok( jQuery( [] ).val() === undefined, "Check an empty jQuery object will return undefined from val" );

	assert.equal( jQuery( "#select2" ).val(), "3", "Call val() on a single='single' select" );

	assert.deepEqual( jQuery( "#select3" ).val(), [ "1", "2" ], "Call val() on a multiple='multiple' select" );

	assert.equal( jQuery( "#option3c" ).val(), "2", "Call val() on a option element with value" );

	assert.equal( jQuery( "#option3a" ).val(), "", "Call val() on a option element with empty value" );

	assert.equal( jQuery( "#option3e" ).val(), "no value", "Call val() on a option element with no value attribute" );

	assert.equal( jQuery( "#option3a" ).val(), "", "Call val() on a option element with no value attribute" );

	jQuery( "#select3" ).val( "" );
	assert.deepEqual( jQuery( "#select3" ).val(), [ "" ], "Call val() on a multiple='multiple' select" );

	assert.deepEqual( jQuery( "#select4" ).val(), [], "Call val() on multiple='multiple' select with all disabled options" );

	jQuery( "#select4 optgroup" ).add( "#select4 > [disabled]" ).attr( "disabled", false );
	assert.deepEqual( jQuery( "#select4" ).val(), [ "2", "3" ], "Call val() on multiple='multiple' select with some disabled options" );

	jQuery( "#select4" ).attr( "disabled", true );
	assert.deepEqual( jQuery( "#select4" ).val(), [ "2", "3" ], "Call val() on disabled multiple='multiple' select" );

	assert.equal( jQuery( "#select5" ).val(), "3", "Check value on ambiguous select." );

	jQuery( "#select5" ).val( 1 );
	assert.equal( jQuery( "#select5" ).val(), "1", "Check value on ambiguous select." );

	jQuery( "#select5" ).val( 3 );
	assert.equal( jQuery( "#select5" ).val(), "3", "Check value on ambiguous select." );

	assert.strictEqual(
		jQuery( "<select name='select12584' id='select12584'><option value='1' disabled='disabled'>1</option></select>" ).val(),
		null,
		"Select-one with only option disabled (#12584)"
	);

	if ( jQuery.fn.serialize ) {
		checks = jQuery( "<input type='checkbox' name='test' value='1'/><input type='checkbox' name='test' value='2'/><input type='checkbox' name='test' value=''/><input type='checkbox' name='test'/>" ).appendTo( "#form" );
diff --git a/a.js b/b.js
@@ -966,7 +966,7 @@ QUnit.test( "val() with non-matching values on dropdown list", function( assert
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	assert.equal( $button.val( "baz" ).html(), "text", "Setting the value does not change innerHTML" );

	assert.equal( jQuery( "<option></option>" ).val( "test" ).attr( "value" ), "test", "Setting value sets the value attribute" );
} );

QUnit.test( "val() with non-matching values on dropdown list", function( assert ) {
	assert.expect( 3 );

	jQuery( "#select5" ).val( "" );
	assert.equal( jQuery( "#select5" ).val(), null, "Non-matching set on select-one" );

	var select6 = jQuery( "<select multiple id=\"select6\"><option value=\"1\">A</option><option value=\"2\">B</option></select>" ).appendTo( "#form" );
	jQuery( select6 ).val( "nothing" );
	assert.deepEqual( jQuery( select6 ).val(), [], "Non-matching set (single value) on select-multiple" );

	jQuery( select6 ).val( [ "nothing1", "nothing2" ] );
	assert.deepEqual( jQuery( select6 ).val(), [], "Non-matching set (array of values) on select-multiple" );

	select6.remove();
} );

QUnit.test( "val() respects numbers without exception (Bug #9319) - progress",
	function( assert ) {

	assert.expect( 2 );

diff --git a/a.js b/b.js
@@ -983,7 +983,7 @@ function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	select6.remove();
} );

QUnit.test( "val() respects numbers without exception (Bug #9319) - progress",
	function( assert ) {

	assert.expect( 2 );

	var $progress = jQuery( "<progress max='10' value='1.5'></progress>" );

	try {
		assert.equal( typeof $progress.val(), "number", "progress, returns a number and does not throw exception" );
		assert.equal( $progress.val(), $progress[ 0 ].value, "progress, api matches host and does not throw exception" );

	} catch ( e ) {}

	$progress.remove();
} );

// IE doesn't support <meter>
QUnit.testUnlessIE( "val() respects numbers without exception (Bug #9319) - meter",
	function( assert ) {

	assert.expect( 2 );

diff --git a/a.js b/b.js
@@ -1045,7 +1045,7 @@ QUnit.test( "val(Function)", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

QUnit.test( "val(String/Number)", function( assert ) {
	testVal( bareObj, assert );
} );

QUnit.test( "val(Function)", function( assert ) {
	testVal( functionReturningObj, assert );
} );

QUnit.test( "val(Array of Numbers) (Bug #7123)", function( assert ) {
	assert.expect( 4 );
	jQuery( "#form" ).append( "<input type='checkbox' name='arrayTest' value='1' /><input type='checkbox' name='arrayTest' value='2' /><input type='checkbox' name='arrayTest' value='3' checked='checked' /><input type='checkbox' name='arrayTest' value='4' />" );
	var elements = jQuery( "#form input[name=arrayTest]" ).val( [ 1, 2 ] );
	assert.ok( elements[ 0 ].checked, "First element was checked" );
diff --git a/a.js b/b.js
@@ -1109,7 +1109,7 @@ jQuery( "#select1" ).val( function( i, val ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	jQuery( "#select1" ).append( "<option value='4'>four</option>" );

	oldVal = jQuery( "#select1" ).val();

	jQuery( "#select1" ).val( function( i, val ) {
		assert.equal( val, oldVal, "Make sure the incoming value is correct." );
		return 4;
	} );

	assert.equal( jQuery( "#select1" ).val(), "4", "Should be possible to set the val() to a newly created option" );
} );

// testing if a form.reset() breaks a subsequent call to a select element's .val() (in IE only)
QUnit.test( "val(select) after form.reset() (Bug #2551)", function( assert ) {
	assert.expect( 3 );

	jQuery( "<form id='kk' name='kk'><select id='kkk'><option value='cf'>cf</option><option value='gf'>gf</option></select></form>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -1644,6 +1644,44 @@ QUnit.test( "addClass, removeClass, hasClass on elements with classes with non-H
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	assert.equal( elem[ 2 ].className, "hi", "Check removal of two classes" );

	assert.ok( elem.hasClass( "hi" ), "Check has1" );
} );

QUnit.test( "addClass, removeClass, hasClass on elements with classes with non-HTML whitespace (gh-3072, gh-3003)", function( assert ) {
	assert.expect( 9 );

	var $elem = jQuery( "<div class='&#xA0;test'></div>" );

	function testMatches() {
		assert.ok( $elem.is( ".\\A0 test" ), "Element matches with collapsed space" );
		assert.ok( $elem.is( ".\\A0test" ), "Element matches with non-breaking space" );
		assert.ok( $elem.hasClass( "\xA0test" ), "Element has class with non-breaking space" );
	}

	testMatches();
	$elem.addClass( "foo" );
	testMatches();
	$elem.removeClass( "foo" );
	testMatches();
} );

QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div><span class='foo'></span><!-- comment -->text</div>" ),
diff --git a/a.js b/b.js
@@ -1654,7 +1692,7 @@ QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	testMatches();
	$elem.removeClass( "foo" );
	testMatches();
} );

QUnit.test( "contents().hasClass() returns correct values", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "<div><span class='foo'></span><!-- comment -->text</div>" ),
	$contents = $div.contents();

	assert.ok( $contents.hasClass( "foo" ), "Found 'foo' in $contents" );
	assert.ok( !$contents.hasClass( "undefined" ), "Did not find 'undefined' in $contents (correctly)" );
} );

QUnit.test( "hasClass correctly interprets non-space separators (#13835)", function( assert ) {
	assert.expect( 4 );

	var
		map = {
diff --git a/a.js b/b.js
@@ -1674,7 +1712,7 @@ QUnit.test( "hasClass correctly interprets non-space separators (#13835)", funct
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411

	assert.ok( $contents.hasClass( "foo" ), "Found 'foo' in $contents" );
	assert.ok( !$contents.hasClass( "undefined" ), "Did not find 'undefined' in $contents (correctly)" );
} );

QUnit.test( "hasClass correctly interprets non-space separators (#13835)", function( assert ) {
	assert.expect( 4 );

	var
		map = {
			tab: "&#9;",
			"line-feed": "&#10;",
			"form-feed": "&#12;",
			"carriage-return": "&#13;"
		},
		classes = jQuery.map( map, function( separator, label ) {
			return " " + separator + label + separator + " ";
		} ),
		$div = jQuery( "<div class='" + classes + "'></div>" );

	jQuery.each( map, function( label ) {
		assert.ok( $div.hasClass( label ), label.replace( "-", " " ) );
	} );
} );

QUnit.test( "coords returns correct values in IE6/IE7, see #10828", function( assert ) {
	assert.expect( 1 );

	var area,
		map = jQuery( "<map></map>" );
diff --git a/a.js b/b.js
@@ -1684,7 +1722,7 @@ QUnit.test( "coords returns correct values in IE6/IE7, see #10828", function( as
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	jQuery.each( map, function( label ) {
		assert.ok( $div.hasClass( label ), label.replace( "-", " " ) );
	} );
} );

QUnit.test( "coords returns correct values in IE6/IE7, see #10828", function( assert ) {
	assert.expect( 1 );

	var area,
		map = jQuery( "<map></map>" );

	area = map.html( "<area shape='rect' coords='0,0,0,0' href='#' alt='a'></area>" ).find( "area" );
	assert.equal( area.attr( "coords" ), "0,0,0,0", "did not retrieve coords correctly" );
} );

QUnit.test( "should not throw at $(option).val() (#14686)", function( assert ) {
	assert.expect( 1 );

	try {
		jQuery( "<option></option>" ).val();
diff --git a/a.js b/b.js
@@ -1700,7 +1738,7 @@ QUnit.test( "option value not trimmed when setting via parent select", function(
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
	} catch ( _ ) {
		assert.ok( false );
	}
} );

QUnit.test( "option value not trimmed when setting via parent select", function( assert ) {
	assert.expect( 1 );
	assert.equal( jQuery( "<select><option> 2</option></select>" ).val( "2" ).val(), "2" );
} );

QUnit.test( "Insignificant white space returned for $(option).val() (#14858, gh-2978)", function( assert ) {
	assert.expect( 16 );

	var val = jQuery( "<option></option>" ).val();
	assert.equal( val.length, 0, "Empty option should have no value" );
diff --git a/a.js b/b.js
@@ -1764,3 +1802,23 @@ QUnit.test( "non-lowercase boolean attribute getters should not crash", function
A blob:d83375172bd8e58adcbf8f424b6a34fa4bb50411
		elem.toggleClass( "awesome" );
		assert.ok( !elem.hasClass( "awesome" ), "SVG element (" + this + ") toggles the class off" );
	} );
} );

QUnit.test( "non-lowercase boolean attribute getters should not crash", function( assert ) {
	assert.expect( 3 );

	var elem = jQuery( "<input checked required autofocus type='checkbox'>" );

	jQuery.each( {
		checked: "Checked",
		required: "requiRed",
		autofocus: "AUTOFOCUS"
	}, function( lowercased, original ) {
		try {
			assert.strictEqual( elem.attr( original ), lowercased,
				"The '" + this + "' attribute getter should return the lowercased name" );
		} catch ( e ) {
			assert.ok( false, "The '" + this + "' attribute getter threw" );
		}
	} );
} );

diff --git a/a.js b/b.js
@@ -22,8 +22,8 @@ module.exports = function( grunt ) {
A blob:b10ebb2dcc1c6ac5b6c4f58242b53d805951aae2
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}
diff --git a/a.js b/b.js
@@ -232,15 +232,19 @@ module.exports = function( grunt ) {
A blob:b10ebb2dcc1c6ac5b6c4f58242b53d805951aae2
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...fs
						.readFileSync( `${ __dirname }/.eslintignore`, "utf-8" )
						.split( "\n" )
						.filter( filePath => filePath )
						.map( filePath => filePath[ 0 ] === "!" ?
							filePath.slice( 1 ) :
							`!${ filePath }`
						)
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -255,7 +259,7 @@ module.exports = function( grunt ) {
A blob:b10ebb2dcc1c6ac5b6c4f58242b53d805951aae2
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	// Support: Node.js <12
	// Skip running tasks that dropped support for Node.js 10
	// in this Node version.
	function runIfNewNode( task ) {
		return oldNode ? "print_old_node_message:" + task : task;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		oldNode = /^v10\./.test( process.version ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," );

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...fs
						.readFileSync( `${ __dirname }/.eslintignore`, "utf-8" )
						.split( "\n" )
						.filter( filePath => filePath )
						.map( filePath => filePath[ 0 ] === "!" ?
							filePath.slice( 1 ) :
							`!${ filePath }`
						)
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -12,11 +12,18 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}
diff --git a/a.js b/b.js
@@ -117,9 +124,14 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
diff --git a/a.js b/b.js
@@ -220,15 +232,19 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -243,7 +259,7 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -334,11 +350,18 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
diff --git a/a.js b/b.js
@@ -346,16 +369,16 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
diff --git a/a.js b/b.js
@@ -378,7 +401,7 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"npmcopy",
		"qunit_fixture",
		"babel:tests"
	] );

	grunt.registerTask( "test", [
		"test:prepare",
		"test:fast",
		"test:slow"
	] );

	grunt.registerTask( "dev", [
		"build:*:*",
		"newer:eslint:dev",
		"newer:uglify",
		"remove_map_comment",
		"dist:*",
		"qunit_fixture",
diff --git a/a.js b/b.js
@@ -387,14 +410,14 @@ module.exports = function( grunt ) {
A blob:fc35a843a49f66952f204a901e31cd64097a0096
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"core-js-bundle/core-js-bundle.js": "core-js-bundle/minified.js",
					"core-js-bundle/LICENSE": "core-js-bundle/LICENSE",

					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"npmcopy",
		"qunit_fixture",
		"babel:tests"
	] );

	grunt.registerTask( "test", [
		"test:prepare",
		"test:fast",
		"test:slow"
	] );

	grunt.registerTask( "dev", [
		"build:*:*",
		"newer:eslint:dev",
		"newer:uglify",
		"remove_map_comment",
		"dist:*",
		"qunit_fixture",
		"compare_size"
	] );

	grunt.registerTask( "default", [
		"eslint:dev",
		"build:*:*",
		"amd",
		"uglify",
		"remove_map_comment",
		"dist:*",
		"test:prepare",
		"eslint:dist",
		"test:fast",
		"compare_size"
	] );
};
diff --git a/a.js b/b.js
@@ -10,9 +10,8 @@
A blob:31d749dd1f150fec6c726ce791dc48d1993bf7bf
import indexOf from "./var/indexOf.js";
import class2type from "./var/class2type.js";
import toString from "./var/toString.js";
import hasOwn from "./var/hasOwn.js";
import fnToString from "./var/fnToString.js";
import ObjectFunctionString from "./var/ObjectFunctionString.js";
import support from "./var/support.js";
import isWindow from "./var/isWindow.js";
import DOMEval from "./core/DOMEval.js";
import toType from "./core/toType.js";

var version = "@VERSION",

	rhtmlSuffix = /HTML$/i,
diff --git a/a.js b/b.js
@@ -398,17 +397,4 @@ function( _i, name ) {
A blob:31d749dd1f150fec6c726ce791dc48d1993bf7bf
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	var length = !!obj && obj.length,
		type = toType( obj );

	if ( typeof obj === "function" || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}

export default jQuery;

diff --git a/a.js b/b.js
@@ -2,6 +2,7 @@
A blob:a97fc1060914c64ea12382d96b5dce0f279fe4e1
// Initialize a jQuery object
import jQuery from "../core.js";
import document from "../var/document.js";
import rsingleTag from "./var/rsingleTag.js";

import "../traversing/findFilter.js";

// A central reference to the root jQuery(document)
diff --git a/a.js b/b.js
@@ -9,8 +10,8 @@
A blob:a97fc1060914c64ea12382d96b5dce0f279fe4e1

import "../traversing/findFilter.js";

// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
diff --git a/a.js b/b.js
@@ -26,20 +27,41 @@ 	init = jQuery.fn.init = function( selector, context, root ) {
A blob:a97fc1060914c64ea12382d96b5dce0f279fe4e1
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
diff --git a/a.js b/b.js
@@ -84,7 +106,7 @@ 	init = jQuery.fn.init = function( selector, context, root ) {
A blob:a97fc1060914c64ea12382d96b5dce0f279fe4e1
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( typeof this[ match ] === "function" ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
diff --git a/a.js b/b.js
@@ -93,24 +115,8 @@ 	init = jQuery.fn.init = function( selector, context, root ) {
A blob:a97fc1060914c64ea12382d96b5dce0f279fe4e1
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( typeof this[ match ] === "function" ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( typeof selector === "function" ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;
diff --git a/a.js b/b.js
@@ -2,13 +2,14 @@
A blob:15278fa0242ab5eb06c2ddf4e61cb227fb95524e
import jQuery from "../core.js";
import document from "../var/document.js";
import rsingleTag from "./var/rsingleTag.js";
import buildFragment from "../manipulation/buildFragment.js";

// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
diff --git a/a.js b/b.js
@@ -7,6 +7,7 @@
A blob:9ac71acc932e26b1ec41c0493f302c18dc946110
import isAttached from "../core/isAttached.js";
import arr from "../var/arr.js";
import rtagName from "./var/rtagName.js";
import rscriptType from "./var/rscriptType.js";
import wrapMap from "./wrapMap.js";
import getAll from "./getAll.js";
import setGlobalEval from "./setGlobalEval.js";

var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
diff --git a/a.js b/b.js
@@ -23,7 +24,7 @@ function buildFragment( elems, context, scripts, selection, ignored ) {
A blob:9ac71acc932e26b1ec41c0493f302c18dc946110
import getAll from "./getAll.js";
import setGlobalEval from "./setGlobalEval.js";

var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
diff --git a/a.js b/b.js
@@ -51,7 +52,7 @@ function buildFragment( elems, context, scripts, selection, ignored ) {
A blob:9ac71acc932e26b1ec41c0493f302c18dc946110
import getAll from "./getAll.js";
import setGlobalEval from "./setGlobalEval.js";

var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || arr;

				// Create wrappers & descend into them.
				j = wrap.length;
				while ( --j > -1 ) {
					tmp = tmp.appendChild( context.createElement( wrap[ j ] ) );
				}

				tmp.innerHTML = jQuery.htmlPrefilter( elem );

				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}
diff --git a/a.js b/b.js
@@ -222,7 +222,7 @@ testHTML: function( req, resp ) {
A blob:04b01d652ca28247279e0aac3f2ab924bbcd8462
	},
	status: function( req, resp, next ) {
		resp.writeHead( Number( req.query.code ) );
		resp.end();
	},
	testHTML: function( req, resp ) {
		resp.writeHead( 200, { "Content-Type": "text/html" } );
		var body = fs.readFileSync( __dirname + "/data/test.include.html" ).toString();
		body = body.replace( /{{baseURL}}/g, req.query.baseURL );
		resp.end( body );
	},
	cspFrame: function( req, resp ) {
		resp.writeHead( 200, {
			"Content-Type": "text/html",
			"Content-Security-Policy": "default-src 'self'; report-uri /base/test/data/mock.php?action=cspLog"
		} );
		var body = fs.readFileSync( __dirname + "/data/csp.include.html" ).toString();
		resp.end( body );
	},
diff --git a/a.js b/b.js
@@ -256,6 +256,22 @@ cspClean: function( req, resp ) {
A blob:04b01d652ca28247279e0aac3f2ab924bbcd8462
	cspLog: function( req, resp ) {
		cspLog = "error";
		resp.writeHead( 200 );
		resp.end();
	},
	cspClean: function( req, resp ) {
		cspLog = "";
		resp.writeHead( 200 );
		resp.end();
	},
	errorWithScript: function( req, resp ) {
		if ( req.query.withScriptContentType ) {
			resp.writeHead( 404, { "Content-Type": "application/javascript" } );
		} else {
diff --git a/a.js b/b.js
@@ -39,9 +39,9 @@ QUnit.test( "text()", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	functionReturningObj( value );
		Returns a function that returns the value
*/

QUnit.test( "text()", function( assert ) {

	assert.expect( 5 );

	var expected, frag, $newLineTest;

	expected = "This link has class=\"blog\": Simon Willison's Weblog";
	assert.equal( jQuery( "#sap" ).text(), expected, "Check for merged text of more then one element." );

	// Check serialization of text values
	assert.equal( jQuery( document.createTextNode( "foo" ) ).text(), "foo", "Text node was retrieved from .text()." );
	assert.notEqual( jQuery( document ).text(), "", "Retrieving text for the document retrieves all text (#10724)." );

	// Retrieve from document fragments #10864
	frag = document.createDocumentFragment();
	frag.appendChild( document.createTextNode( "foo" ) );

	assert.equal( jQuery( frag ).text(), "foo", "Document Fragment Text node was retrieved from .text()." );
diff --git a/a.js b/b.js
@@ -49,7 +49,7 @@ QUnit.test( "text()", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	functionReturningObj( value );
		Returns a function that returns the value
*/

QUnit.test( "text()", function( assert ) {

	assert.expect( 5 );

	var expected, frag, $newLineTest;

	expected = "This link has class=\"blog\": Simon Willison's Weblog";
	assert.equal( jQuery( "#sap" ).text(), expected, "Check for merged text of more then one element." );

	// Check serialization of text values
	assert.equal( jQuery( document.createTextNode( "foo" ) ).text(), "foo", "Text node was retrieved from .text()." );
	assert.notEqual( jQuery( document ).text(), "", "Retrieving text for the document retrieves all text (#10724)." );

	// Retrieve from document fragments #10864
	frag = document.createDocumentFragment();
	frag.appendChild( document.createTextNode( "foo" ) );

	assert.equal( jQuery( frag ).text(), "foo", "Document Fragment Text node was retrieved from .text()." );

	$newLineTest = jQuery( "<div>test<br/>testy</div>" ).appendTo( "#moretests" );
	$newLineTest.find( "br" ).replaceWith( "\n" );
	assert.equal( $newLineTest.text(), "test\ntesty", "text() does not remove new lines (#11153)" );

	$newLineTest.remove();
} );

diff --git a/a.js b/b.js
@@ -58,7 +58,7 @@ QUnit.test( "text(undefined)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.equal( $newLineTest.text(), "test\ntesty", "text() does not remove new lines (#11153)" );

	$newLineTest.remove();
} );

QUnit.test( "text(undefined)", function( assert ) {

	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).text( "<div" ).text( undefined )[ 0 ].innerHTML, "&lt;div", ".text(undefined) is chainable (#5571)" );
} );

function testText( valueObj, assert ) {

diff --git a/a.js b/b.js
@@ -78,16 +78,16 @@ function testText( valueObj, assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).text( "<div" ).text( undefined )[ 0 ].innerHTML, "&lt;div", ".text(undefined) is chainable (#5571)" );
} );

function testText( valueObj, assert ) {

	assert.expect( 6 );

	var val, j, expected, $multipleElements, $parentDiv, $childDiv;

	val = valueObj( "<div><b>Hello</b> cruel world!</div>" );
	assert.equal( jQuery( "#foo" ).text( val )[ 0 ].innerHTML.replace( />/g, "&gt;" ), "&lt;div&gt;&lt;b&gt;Hello&lt;/b&gt; cruel world!&lt;/div&gt;", "Check escaped text" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
	j.text( valueObj( "hi!" ) );
	assert.equal( jQuery( j[ 0 ] ).text(), "hi!", "Check node,textnode,comment with text()" );
	assert.equal( j[ 1 ].nodeValue, " there ", "Check node,textnode,comment with text()" );

	assert.equal( j[ 2 ].nodeType, 8, "Check node,textnode,comment with text()" );

	// Update multiple elements #11809
	expected = "New";

	$multipleElements = jQuery( "<div>Hello</div>" ).add( "<div>World</div>" );
	$multipleElements.text( expected );

	assert.equal( $multipleElements.eq( 0 ).text(), expected, "text() updates multiple elements (#11809)" );
	assert.equal( $multipleElements.eq( 1 ).text(), expected, "text() updates multiple elements (#11809)" );

	// Prevent memory leaks #11809
	$childDiv = jQuery( "<div></div>" );
	$childDiv.data( "leak", true );
	$parentDiv = jQuery( "<div></div>" );
	$parentDiv.append( $childDiv );
diff --git a/a.js b/b.js
@@ -187,7 +187,7 @@ function testAppendForObject( valueObj, isFragment, assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	} );

	assert.equal( jQuery( "#sap" ).text(), "foobar", "Check for merged text of more then one element." );
} );

function testAppendForObject( valueObj, isFragment, assert ) {
	var $base,
		type = isFragment ? " (DocumentFragment)" : " (Element)",
		text = "This link has class=\"blog\": Simon Willison's Weblog",
		el = document.getElementById( "sap" ).cloneNode( true ),
		first = document.getElementById( "first" ),
		yahoo = document.getElementById( "yahoo" );

	if ( isFragment ) {
		$base = document.createDocumentFragment();
		jQuery( el ).contents().each( function() {
			$base.appendChild( this );
		} );
		$base = jQuery( $base );
	} else {
		$base = jQuery( el );
	}

	assert.equal( $base.clone().append( valueObj( first.cloneNode( true ) ) ).text(),
		text + "Try them out:",
		"Check for appending of element" + type
	);

	assert.equal( $base.clone().append( valueObj( [ first.cloneNode( true ), yahoo.cloneNode( true ) ] ) ).text(),
		text + "Try them out:Yahoo",
		"Check for appending of array of elements" + type
	);

	assert.equal( $base.clone().append( valueObj( jQuery( "#yahoo, #first" ).clone() ) ).text(),
		text + "YahooTry them out:",
		"Check for appending of jQuery object" + type
	);

	assert.equal( $base.clone().append( valueObj( 5 ) ).text(),
		text + "5",
		"Check for appending a number" + type
	);

	assert.equal( $base.clone().append( valueObj( [ jQuery( "#first" ).clone(), jQuery( "#yahoo, #google" ).clone() ] ) ).text(),
		text + "Try them out:GoogleYahoo",
		"Check for appending of array of jQuery objects"
	);

	assert.equal( $base.clone().append( valueObj( " text with spaces " ) ).text(),
		text + " text with spaces ",
		"Check for appending text with spaces" + type
	);

	assert.equal( $base.clone().append( valueObj( [] ) ).text(),
		text,
		"Check for appending an empty array" + type
	);

	assert.equal( $base.clone().append( valueObj( "" ) ).text(),
		text,
		"Check for appending an empty string" + type
	);

	assert.equal( $base.clone().append( valueObj( document.getElementsByTagName( "foo" ) ) ).text(),
		text,
		"Check for appending an empty nodelist" + type
	);

	assert.equal( $base.clone().append( "<span></span>", "<span></span>", "<span></span>" ).children().length,
		$base.children().length + 3,
		"Make sure that multiple arguments works." + type
	);

	assert.equal( $base.clone().append( valueObj( document.getElementById( "form" ).cloneNode( true ) ) ).children( "form" ).length,
		1,
		"Check for appending a form (#910)" + type
	);
}

function testAppend( valueObj, assert ) {
diff --git a/a.js b/b.js
@@ -272,7 +272,7 @@ jQuery( "#form" )
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	} );

	jQuery( "#table colgroup" ).append( valueObj( "<col></col>" ) );
	assert.equal( jQuery( "#table colgroup col" ).length, 1, "Append col" );

	jQuery( "#form" )
		.append( valueObj( "<select id='appendSelect1'></select>" ) )
		.append( valueObj( "<select id='appendSelect2'><option>Test</option></select>" ) );
	assert.t( "Append Select", "#appendSelect1, #appendSelect2", [ "appendSelect1", "appendSelect2" ] );

	assert.equal( "Two nodes", jQuery( "<div></div>" ).append( "Two", " nodes" ).text(), "Appending two text nodes (#4011)" );
	assert.equal( jQuery( "<div></div>" ).append( "1", "", 3 ).text(), "13", "If median is false-like value, subsequent arguments should not be ignored" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
diff --git a/a.js b/b.js
@@ -310,7 +310,7 @@ QUnit.test( "append(Function)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

QUnit.test( "append(String|Element|Array<Element>|jQuery)", function( assert ) {
	testAppend( manipulationBareObj, assert );
} );

QUnit.test( "append(Function)", function( assert ) {
	testAppend( manipulationFunctionReturningObj, assert );
} );

QUnit.test( "append(param) to object, see #11280", function( assert ) {

	assert.expect( 5 );

	var object = jQuery( document.createElement( "object" ) ).appendTo( document.body );
diff --git a/a.js b/b.js
@@ -402,7 +402,7 @@ jQuery( "#sap" ).append( function( i, val ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
QUnit.test( "append(Function) returns Number", function( assert ) {

	assert.expect( 2 );
	var old = jQuery( "#sap" ).html();

	jQuery( "#sap" ).append( function( i, val ) {
		assert.equal( val, old, "Make sure the incoming value is correct." );
		return 5;
	} );
	assert.ok( jQuery( "#sap" )[ 0 ].innerHTML.match( /5$/ ), "Check for appending a number" );
} );

QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {

	assert.expect( 5 );

	var xmlDoc1 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state x='100' y='100' initial='actions' id='provisioning'></state><state x='100' y='100' id='error'></state><state x='100' y='100' id='finished' final='true'></state></scxml>" ),
diff --git a/a.js b/b.js
@@ -430,7 +430,7 @@ QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		return 5;
	} );
	assert.ok( jQuery( "#sap" )[ 0 ].innerHTML.match( /5$/ ), "Check for appending a number" );
} );

QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {

	assert.expect( 5 );

	var xmlDoc1 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state x='100' y='100' initial='actions' id='provisioning'></state><state x='100' y='100' id='error'></state><state x='100' y='100' id='finished' final='true'></state></scxml>" ),
		xmlDoc2 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state id='provisioning3'></state></scxml>" ),
		xml1 = jQuery( xmlDoc1 ),
		xml2 = jQuery( xmlDoc2 ),
		scxml1 = jQuery( "scxml", xml1 ),
		scxml2 = jQuery( "scxml", xml2 ),
		state = scxml2.find( "state" );

	scxml1.append( state );
	assert.strictEqual( scxml1[ 0 ].lastChild, state[ 0 ], "append" );

	scxml1.prepend( state );
	assert.strictEqual( scxml1[ 0 ].firstChild, state[ 0 ], "prepend" );

	scxml1.find( "#finished" ).after( state );
	assert.strictEqual( scxml1[ 0 ].lastChild, state[ 0 ], "after" );

	scxml1.find( "#provisioning" ).before( state );
	assert.strictEqual( scxml1[ 0 ].firstChild, state[ 0 ], "before" );

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;
diff --git a/a.js b/b.js
@@ -445,7 +445,7 @@ QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;

	jQuery( "#qunit-fixture" ).append( "<article style='font-size:10px'><section><aside>HTML5 elements</aside></section></article>" );

	article = jQuery( "article" );
	aside = jQuery( "aside" );

	assert.equal( article.get( 0 ).style.fontSize, "10px", "HTML5 elements are styleable" );
	assert.equal( aside.length, 1, "HTML5 elements do not collapse their children" );
} );

QUnit[ jQuery.fn.css ? "test" : "skip" ]( "HTML5 Elements inherit styles from style rules (Bug #10501)", function( assert ) {

	assert.expect( 1 );

	jQuery( "#qunit-fixture" ).append( "<article id='article'></article>" );
diff --git a/a.js b/b.js
@@ -456,7 +456,7 @@ QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;

	jQuery( "#qunit-fixture" ).append( "<article style='font-size:10px'><section><aside>HTML5 elements</aside></section></article>" );

	article = jQuery( "article" );
	aside = jQuery( "aside" );

	assert.equal( article.get( 0 ).style.fontSize, "10px", "HTML5 elements are styleable" );
	assert.equal( aside.length, 1, "HTML5 elements do not collapse their children" );
} );

QUnit[ jQuery.fn.css ? "test" : "skip" ]( "HTML5 Elements inherit styles from style rules (Bug #10501)", function( assert ) {

	assert.expect( 1 );

	jQuery( "#qunit-fixture" ).append( "<article id='article'></article>" );
	jQuery( "#article" ).append( "<section>This section should have a pink background.</section>" );

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
diff --git a/a.js b/b.js
@@ -465,7 +465,7 @@ QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().length, 1, "Make sure HTML5 article elements can hold children. innerHTML shortcut path" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().children().length, 1, "Make sure nested HTML5 elements can hold children." );
} );

QUnit.test( "html(String) tag-hyphenated elements (Bug #1987)", function( assert ) {

	assert.expect( 27 );

	jQuery.each( "thead tbody tfoot colgroup caption tr th td".split( " " ), function( i, name ) {
diff --git a/a.js b/b.js
@@ -561,7 +561,7 @@ QUnit.test( "IE8 serialization bug", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		assert.equal( child.nodeName.toUpperCase(), "DIV",
			method + "(): Self-closing tag name terminated by " + description );
	}
} );

QUnit.test( "IE8 serialization bug", function( assert ) {

	assert.expect( 2 );
	var wrapper = jQuery( "<div></div>" );

	wrapper.html( "<div></div><article></article>" );
	assert.equal( wrapper.children( "article" ).length, 1, "HTML5 elements are insertable with .html()" );

	wrapper.html( "<div></div><link></link>" );
	assert.equal( wrapper.children( "link" ).length, 1, "Link elements are insertable with .html()" );
} );

QUnit.test( "html() object element #10324", function( assert ) {

	assert.expect( 1 );

	var object = jQuery( "<object id='object2'><param name='object2test' value='test'></param></object>?" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -959,7 +959,7 @@ QUnit.test( "before(no-op)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	expected = "This is a normal link: Try them out:GooglediveintomarkYahoo";
	jQuery( "#yahoo" ).before( manipulationFunctionReturningObj( [ jQuery( "#first" ), jQuery( "#mark, #google" ) ] ) );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert array of jQuery objects before" );
} );

QUnit.test( "before(no-op)", function( assert ) {

	assert.expect( 2 );

	var set;
	set = jQuery( "<div></div>" ).before( "<span>test</span>" );
	assert.equal( set[ 0 ].nodeName.toLowerCase(), "div", "Insert before a disconnected node should be a no-op" );
	assert.equal( set.length, 1, "Insert the element before the disconnected node. should be a no-op" );
} );

QUnit.test( "before and after w/ empty object (#10812)", function( assert ) {

	assert.expect( 1 );

	var res;
diff --git a/a.js b/b.js
@@ -1195,7 +1195,7 @@ function testReplaceWith( val, assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
diff --git a/a.js b/b.js
@@ -1208,7 +1208,7 @@ function testReplaceWith( val, assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with array of elements" );
	assert.ok( !jQuery( "#google" )[ 0 ], "Verify that original element is gone, after array of elements" );

	jQuery( "#groups" ).replaceWith( val( jQuery( "#mark, #first" ) ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with jQuery collection" );
	assert.ok( !jQuery( "#groups" )[ 0 ], "Verify that original element is gone, after jQuery collection" );

	jQuery( "#mark, #first" ).replaceWith( val( "<span class='replacement'></span><span class='replacement'></span>" ) );
	assert.equal( jQuery( "#qunit-fixture .replacement" ).length, 4, "Replace multiple elements (#12449)" );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), [], "Verify that original elements are gone, after replace multiple" );

	tmp = jQuery( "<b>content</b>" )[ 0 ];
	jQuery( "#anchor1" ).contents().replaceWith( val( tmp ) );
diff --git a/a.js b/b.js
@@ -1256,7 +1256,7 @@ function testReplaceWith( val, assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with array of elements" );
	assert.ok( !jQuery( "#google" )[ 0 ], "Verify that original element is gone, after array of elements" );

	jQuery( "#groups" ).replaceWith( val( jQuery( "#mark, #first" ) ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with jQuery collection" );
	assert.ok( !jQuery( "#groups" )[ 0 ], "Verify that original element is gone, after jQuery collection" );

	jQuery( "#mark, #first" ).replaceWith( val( "<span class='replacement'></span><span class='replacement'></span>" ) );
	assert.equal( jQuery( "#qunit-fixture .replacement" ).length, 4, "Replace multiple elements (#12449)" );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), [], "Verify that original elements are gone, after replace multiple" );

	tmp = jQuery( "<b>content</b>" )[ 0 ];
	jQuery( "#anchor1" ).contents().replaceWith( val( tmp ) );
	assert.deepEqual( jQuery( "#anchor1" ).contents().get(), [ tmp ], "Replace text node with element" );

	tmp = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( true, "Newly bound click run." );
	} );
	y = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( false, "Previously bound click run." );
	} );
	child = y.append( "<b>test</b>" ).find( "b" ).on( "click", function() {
		assert.ok( true, "Child bound click run." );
		return false;
	} );

	y.replaceWith( val( tmp ) );

	tmp.trigger( "click" );
	y.trigger( "click" ); // Shouldn't be run
	child.trigger( "click" ); // Shouldn't be run

	y = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( false, "Previously bound click run." );
	} );
	child2 = y.append( "<u>test</u>" ).find( "u" ).on( "click", function() {
		assert.ok( true, "Child 2 bound click run." );
		return false;
	} );

	y.replaceWith( val( child2 ) );

	child2.trigger( "click" );

	set = jQuery( "<div></div>" ).replaceWith( val( "<span>test</span>" ) );
	assert.equal( set[ 0 ].nodeName.toLowerCase(), "div", "No effect on a disconnected node." );
	assert.equal( set.length, 1, "No effect on a disconnected node." );
	assert.equal( set[ 0 ].childNodes.length, 0, "No effect on a disconnected node." );

	child = jQuery( "#qunit-fixture" ).children().first();
	$div = jQuery( "<div class='pathological'></div>" ).insertBefore( child );
	$div.replaceWith( $div );
	assert.deepEqual( jQuery( ".pathological", "#qunit-fixture" ).get(), $div.get(),
		"Self-replacement" );
	$div.replaceWith( child );
	assert.deepEqual( jQuery( "#qunit-fixture" ).children().first().get(), child.get(),
		"Replacement with following sibling (#13810)" );
	assert.deepEqual( jQuery( ".pathological", "#qunit-fixture" ).get(), [],
		"Replacement with following sibling (context removed)" );

	nonExistent = jQuery( "#does-not-exist" ).replaceWith( val( "<b>should not throw an error</b>" ) );
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ QUnit.test( "replaceAll(jQuery)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with array of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with array of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after array of elements" );
} );

QUnit.test( "replaceAll(jQuery)", function( assert ) {

	assert.expect( 3 );

	jQuery( "#mark, #first" ).replaceAll( "#yahoo" );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with set of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with set of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after set of elements" );
} );

QUnit.test( "jQuery.clone() (#8017)", function( assert ) {

	assert.expect( 2 );

	assert.ok( jQuery.clone && typeof jQuery.clone === "function", "jQuery.clone() utility exists and is a function." );
diff --git a/a.js b/b.js
@@ -1388,7 +1388,7 @@ QUnit.test( "jQuery.clone() (#8017)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with set of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with set of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after set of elements" );
} );

QUnit.test( "jQuery.clone() (#8017)", function( assert ) {

	assert.expect( 2 );

	assert.ok( jQuery.clone && typeof jQuery.clone === "function", "jQuery.clone() utility exists and is a function." );

	var main = jQuery( "#qunit-fixture" )[ 0 ],
		clone = jQuery.clone( main );

	assert.equal( main.childNodes.length, clone.childNodes.length, "Simple child length to ensure a large dom tree copies correctly" );
} );

QUnit.test( "append to multiple elements (#8070)", function( assert ) {

	assert.expect( 2 );

	var selects = jQuery( "<select class='test8070'></select><select class='test8070'></select>" ).appendTo( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -1543,7 +1543,7 @@ QUnit.test( "clone()", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	height = table[ 0 ].offsetHeight;
	table.prepend( "<tr><td>DATA</td></tr>" );
	assert.ok( table[ 0 ].offsetHeight - height >= 15, "prepended rows are visible" );
} );

QUnit.test( "clone()", function( assert ) {

	assert.expect( 45 );

	var div, clone, form, body;

	assert.equal( jQuery( "#en" ).text(), "This is a normal link: Yahoo", "Assert text for #en" );
	assert.equal( jQuery( "#first" ).append( jQuery( "#yahoo" ).clone() ).text(), "Try them out:Yahoo", "Check for clone" );
	assert.equal( jQuery( "#en" ).text(), "This is a normal link: Yahoo", "Reassert text for #en" );

	jQuery.each( "table thead tbody tfoot tr td div button ul ol li select option textarea iframe".split( " " ), function( i, nodeName ) {
		assert.equal( jQuery( "<" + nodeName + "/>" ).clone()[ 0 ].nodeName.toLowerCase(), nodeName, "Clone a " + nodeName );
	} );
	assert.equal( jQuery( "<input type='checkbox' />" ).clone()[ 0 ].nodeName.toLowerCase(), "input", "Clone a <input type='checkbox' />" );

	// Check cloning non-elements
	assert.equal( jQuery( "#nonnodes" ).contents().clone().length, 3, "Check node,textnode,comment clone works (some browsers delete comments on clone)" );

	// Verify that clones of clones can keep event listeners
	div = jQuery( "<div><ul><li>test</li></ul></div>" ).on( "click", function() {
		assert.ok( true, "Bound event still exists." );
	} );
	clone = div.clone( true ); div.remove();
	div = clone.clone( true ); clone.remove();

	assert.equal( div.length, 1, "One element cloned" );
	assert.equal( div[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	div.trigger( "click" );

	// Manually clean up detached elements
	div.remove();

	// Verify that cloned children can keep event listeners
	div = jQuery( "<div></div>" ).append( [ document.createElement( "table" ), document.createElement( "table" ) ] );
	div.find( "table" ).on( "click", function() {
		assert.ok( true, "Bound event still exists." );
	} );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	clone.find( "table" ).trigger( "click" );

	// Manually clean up detached elements
	div.remove();
	clone.remove();

	// Make sure that doing .clone() doesn't clone event listeners
	div = jQuery( "<div><ul><li>test</li></ul></div>" ).on( "click", function() {
		assert.ok( false, "Bound event still exists after .clone()." );
	} );
	clone = div.clone();

	clone.trigger( "click" );

	// Manually clean up detached elements
	clone.remove();
	div.remove();

	// Test both html() and clone() for <embed> and <object> types
	div = jQuery( "<div></div>" ).html( "<embed height='355' width='425' src='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'></embed>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone.html(), div.html(), "Element contents cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );

	// this is technically an invalid object, but because of the special
	// classid instantiation it is the only kind that IE has trouble with,
	// so let's test with it too.
	div = jQuery( "<div></div>" ).html( "<object height='355' width='425' classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'>  <param name='movie' value='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='wmode' value='transparent'> </object>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	div = div.find( "object" );
	clone = clone.find( "object" );

	// oldIE adds extra attributes and <param> elements, so just test for existence of the defined set
	jQuery.each( [ "height", "width", "classid" ], function( i, attr ) {
		assert.equal( clone.attr( attr ), div.attr( attr ), "<object> attribute cloned: " + attr );
	} );
	( function() {
		var params = {};

		clone.find( "param" ).each( function( index, param ) {
			params[ param.attributes.name.nodeValue.toLowerCase() ] =
				param.attributes.value.nodeValue.toLowerCase();
		} );

		div.find( "param" ).each( function( index, param ) {
			var key = param.attributes.name.nodeValue.toLowerCase();
			assert.equal( params[ key ], param.attributes.value.nodeValue.toLowerCase(), "<param> cloned: " + key );
		} );
	} )();

	// and here's a valid one.
	div = jQuery( "<div></div>" ).html( "<object height='355' width='425' type='application/x-shockwave-flash' data='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='movie' value='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='wmode' value='transparent'> </object>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone.html(), div.html(), "Element contents cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );

	div = jQuery( "<div></div>" ).data( { "a": true } );
	clone = div.clone( true );
	assert.equal( clone.data( "a" ), true, "Data cloned." );
	clone.data( "a", false );
	assert.equal( clone.data( "a" ), false, "Ensure cloned element data object was correctly modified" );
	assert.equal( div.data( "a" ), true, "Ensure cloned element data object is copied, not referenced" );

	// manually clean up detached elements
	div.remove();
	clone.remove();

	form = document.createElement( "form" );
	form.action = "/test/";

	div = document.createElement( "div" );
	div.appendChild( document.createTextNode( "test" ) );
	form.appendChild( div );

	assert.equal( jQuery( form ).clone().children().length, 1, "Make sure we just get the form back." );

	body = jQuery( "body" ).clone();
	assert.equal( body.children()[ 0 ].id, "qunit", "Make sure cloning body works" );
	body.remove();
} );

QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {

	assert.expect( 3 );

	var src = jQuery( "<script type='text/filler'>Lorem ipsum dolor sit amet</script><q><script type='text/filler'>consectetur adipiscing elit</script></q>" ),
diff --git a/a.js b/b.js
@@ -1556,7 +1556,7 @@ QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	body = jQuery( "body" ).clone();
	assert.equal( body.children()[ 0 ].id, "qunit", "Make sure cloning body works" );
	body.remove();
} );

QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {

	assert.expect( 3 );

	var src = jQuery( "<script type='text/filler'>Lorem ipsum dolor sit amet</script><q><script type='text/filler'>consectetur adipiscing elit</script></q>" ),
		dest = src.clone();

	assert.equal( dest[ 0 ].text, "Lorem ipsum dolor sit amet", "Cloning preserves script text" );
	assert.equal( dest.last().html(), src.last().html(), "Cloning preserves nested script text" );
	assert.ok( /^\s*<scr.pt\s+type=['"]?text\/filler['"]?\s*>consectetur adipiscing elit<\/scr.pt>\s*$/i.test( dest.last().html() ), "Cloning preserves nested script text" );
	dest.remove();
} );

QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {

	assert.expect( 5 );

	var clone, element;
diff --git a/a.js b/b.js
@@ -1581,7 +1581,7 @@ QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.equal( dest.last().html(), src.last().html(), "Cloning preserves nested script text" );
	assert.ok( /^\s*<scr.pt\s+type=['"]?text\/filler['"]?\s*>consectetur adipiscing elit<\/scr.pt>\s*$/i.test( dest.last().html() ), "Cloning preserves nested script text" );
	dest.remove();
} );

QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {

	assert.expect( 5 );

	var clone, element;

	element = jQuery( "<select><option>Foo</option><option value='selected' selected>Bar</option></select>" );

	assert.equal( element.clone().find( "option" ).filter( function() { return this.selected; } ).val(), "selected", "Selected option cloned correctly" );

	element = jQuery( "<input type='checkbox' value='foo'>" ).attr( "checked", "checked" );
	clone = element.clone();

	assert.equal( clone.is( ":checked" ), element.is( ":checked" ), "Checked input cloned correctly" );
	assert.equal( clone[ 0 ].defaultValue, "foo", "Checked input defaultValue cloned correctly" );

	element = jQuery( "<input type='text' value='foo'>" );
	clone = element.clone();
	assert.equal( clone[ 0 ].defaultValue, "foo", "Text input defaultValue cloned correctly" );

	element = jQuery( "<textarea>foo</textarea>" );
	clone = element.clone();
	assert.equal( clone[ 0 ].defaultValue, "foo", "Textarea defaultValue cloned correctly" );
} );

QUnit.test( "clone(multiple selected options) (Bug #8129)", function( assert ) {

	assert.expect( 1 );

	var element = jQuery( "<select><option>Foo</option><option selected>Bar</option><option selected>Baz</option></select>" );
diff --git a/a.js b/b.js
@@ -1630,14 +1630,14 @@ QUnit.test( "html(undefined)", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	assert.equal( $meter[ 0 ].nodeName, "meter", "Check if nodeName was not changed due to cloning" );
	assert.equal( $meter[ 0 ].nodeType, 1, "Check if nodeType is not changed due to cloning" );
} );

QUnit.test( "html(undefined)", function( assert ) {

	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).html( "<i>test</i>" ).html( undefined ).html().toLowerCase(), "<i>test</i>", ".html(undefined) is chainable (#5571)" );
} );

QUnit.test( "html() on empty set", function( assert ) {

	assert.expect( 1 );

	assert.strictEqual( jQuery().html(), undefined, ".html() returns undefined for empty sets (#11962)" );
} );

function childNodeNames( node ) {
	return jQuery.map( node.childNodes, function( child ) {
diff --git a/a.js b/b.js
@@ -1738,7 +1738,7 @@ jQuery( "#nonnodes" ).contents().html( valueObj( "<b>bold</b>" ) ).each( functio
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.equal( div.html( valueObj( tmp ) ).html().replace( />/g, "&gt;" ), tmp, "Escaped html, leading x" );
	tmp = " " + tmp.slice( 1 );
	assert.equal( div.html( valueObj( tmp ) ).html().replace( />/g, "&gt;" ), tmp, "Escaped html, leading space" );

	actual = []; expected = []; tmp = {};
	jQuery( "#nonnodes" ).contents().html( valueObj( "<b>bold</b>" ) ).each( function() {
		var html = jQuery( this ).html();
		tmp[ this.nodeType ] = true;
		expected.push( this.nodeType === 1 ? "<b>bold</b>" : undefined );
		actual.push( html ? html.toLowerCase() : html );
	} );
	assert.deepEqual( actual, expected, "Set containing element, text node, comment" );
	assert.ok( tmp[ 1 ], "element" );
	assert.ok( tmp[ 3 ], "text node" );
	assert.ok( tmp[ 8 ], "comment" );

	actual = []; expected = [];
	fixture.children( "div" ).html( valueObj( "<b>test</b>" ) ).each( function() {
		expected.push( "B" );
		actual.push( childNodeNames( this ) );
	} );
	assert.equal( expected.length, 7, "Expecting many parents" );
	assert.deepEqual( actual, expected, "Correct childNodes after setting HTML" );

	actual = []; expected = [];
	fixture.html( valueObj( "<style>.foobar{color:green;}</style>" ) ).each( function() {
		expected.push( "STYLE" );
		actual.push( childNodeNames( this ) );
	} );
	assert.equal( expected.length, 1, "Expecting one parent" );
	assert.deepEqual( actual, expected, "Found the inserted style element" );

	fixture.html( valueObj( "<select></select>" ) );
	jQuery( "#qunit-fixture select" ).html( valueObj( "<option>O1</option><option selected='selected'>O2</option><option>O3</option>" ) );
	assert.equal( jQuery( "#qunit-fixture select" ).val(), "O2", "Selected option correct" );

	tmp = fixture.html(
		valueObj( [
			"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: non-script' );</script>",
			"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: text/javascript' );</script>",
			"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: text/ecmascript' );</script>",
			"<script>QUnit.assert.ok( true, 'evaluated: no type' );</script>",
			"<div>",
				"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: inner non-script' );</script>",
				"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: inner text/javascript' );</script>",
				"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: inner text/ecmascript' );</script>",
				"<script>QUnit.assert.ok( true, 'evaluated: inner no type' );</script>",
			"</div>"
		].join( "" ) )
	).find( "script" );
	assert.equal( tmp.length, 8, "All script tags remain." );
	assert.equal( tmp[ 0 ].type, "something/else", "Non-evaluated type." );
	assert.equal( tmp[ 1 ].type, "text/javascript", "Evaluated type." );

	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "foo <form><script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script (#975)' );</script></form>" ) );

	jQuery.scriptorder = 0;
	fixture.html( valueObj( [
		"<script>",
diff --git a/a.js b/b.js
@@ -1888,7 +1888,7 @@ QUnit.test( "html(Function) with incoming value -- jQuery.contents()", function(
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		}
	} );
	assert.ok( pass, "Set HTML" );
} );

QUnit.test( "html(Function) with incoming value -- jQuery.contents()", function( assert ) {

	assert.expect( 14 );

	var actualhtml, j, $div, $div2, insert;

	j = jQuery( "#nonnodes" ).contents();
	actualhtml = j.map( function() {
		return jQuery( this ).html();
	} );

	j.html( function( i, val ) {
		assert.equal( val, actualhtml[ i ], "Make sure the incoming value is correct." );
		return "<b>bold</b>";
	} );

	// Handle the case where no comment is in the document
	if ( j.length === 2 ) {
		assert.equal( null, null, "Make sure the incoming value is correct." );
	}

	assert.equal( j.html().replace( / xmlns="[^"]+"/g, "" ).toLowerCase(), "<b>bold</b>", "Check node,textnode,comment with html()" );

	$div = jQuery( "<div></div>" );

	assert.equal( $div.html( function( i, val ) {
		assert.equal( val, "", "Make sure the incoming value is correct." );
		return 5;
	} ).html(), "5", "Setting a number as html" );

	assert.equal( $div.html( function( i, val ) {
		assert.equal( val, "5", "Make sure the incoming value is correct." );
		return 0;
	} ).html(), "0", "Setting a zero as html" );

	$div2 = jQuery( "<div></div>" );
	insert = "&lt;div&gt;hello1&lt;/div&gt;";
	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val, "", "Make sure the incoming value is correct." );
		return insert;
	} ).html().replace( />/g, "&gt;" ), insert, "Verify escaped insertion." );

	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val.replace( />/g, "&gt;" ), insert, "Make sure the incoming value is correct." );
		return "x" + insert;
	} ).html().replace( />/g, "&gt;" ), "x" + insert, "Verify escaped insertion." );

	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val.replace( />/g, "&gt;" ), "x" + insert, "Make sure the incoming value is correct." );
		return " " + insert;
	} ).html().replace( />/g, "&gt;" ), " " + insert, "Verify escaped insertion." );
} );

QUnit.test( "clone()/html() don't expose jQuery/Sizzle expandos (#12858)", function( assert ) {

	assert.expect( 2 );

	var $content = jQuery( "<div><b><i>text</i></b></div>" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -1975,7 +1975,7 @@ QUnit.test( "remove() event cleaning ", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	assert.ok( jQuery( "#nonnodes" ).contents().length >= 2, "Check node,textnode,comment remove works" );
	jQuery( "#nonnodes" ).contents().remove();
	assert.equal( jQuery( "#nonnodes" ).contents().length, 0, "Check node,textnode,comment remove works" );
} );

QUnit.test( "remove() event cleaning ", function( assert ) {
	assert.expect( 1 );

	var count, first, cleanUp;

	count = 0;
	first = jQuery( "#ap" ).children().first();
	cleanUp = first.on( "click", function() {
		count++;
	} ).remove().appendTo( "#qunit-fixture" ).trigger( "click" );

	assert.strictEqual( 0, count, "Event handler has been removed" );

	// Clean up detached data
	cleanUp.remove();
} );

QUnit.test( "remove() in document order #13779", function( assert ) {
	assert.expect( 1 );

	var last,
		cleanData = jQuery.cleanData;
diff --git a/a.js b/b.js
@@ -2336,7 +2336,7 @@ 	window.corsCallback = function( response ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	var done = assert.async(),
		timeout;

	Globals.register( "corsCallback" );
	window.corsCallback = function( response ) {
		assert.ok( typeof response.headers.origin === "string", "Origin header sent" );
		window.clearTimeout( timeout );
		done();
	};

	var src = baseURL + "mock.php?action=script&cors=1&callback=corsCallback";
	src = src.replace( "localhost", "127.0.0.1" );
	var html = "<script type=\"text/javascript\" src=\"" + src + "\" crossorigin=\"anonymous\"><\/script>";

	jQuery( document.body ).append( html );
	timeout = window.setTimeout( function() {
		assert.ok( false, "Origin header should have been sent" );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function( assert ) {

	assert.expect( 1 );

	try {
diff --git a/a.js b/b.js
@@ -2348,7 +2348,7 @@ QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function(
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		assert.ok( false, "Origin header should have been sent" );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function( assert ) {

	assert.expect( 1 );

	try {
		jQuery( "#no-clone-exception" ).clone();
		assert.ok( true, "cloned with no exceptions" );
	} catch ( e ) {
		assert.ok( false, e.message );
	}
} );

QUnit.test( "Cloned, detached HTML5 elems (#10667,10670)", function( assert ) {

	assert.expect( 7 );

	var $clone,
diff --git a/a.js b/b.js
@@ -2428,7 +2428,7 @@ QUnit.test( "Guard against exceptions when clearing safeChildNodes", function( a
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	// Unbind any remaining events
	$section.off( "click" );
	$clone.off( "click" );
} );

QUnit.test( "Guard against exceptions when clearing safeChildNodes", function( assert ) {

	assert.expect( 1 );

	var div;

	try {
		div = jQuery( "<div></div><hr/><code></code><b></b>" );
	} catch ( e ) {}

	assert.ok( div && div.jquery, "Created nodes safely, guarded against exceptions on safeChildNodes[ -1 ]" );
} );

QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( assert ) {

	assert.expect( 5 );

	assert.strictEqual( jQuery( "<div></div>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.clone" );
diff --git a/a.js b/b.js
@@ -2439,7 +2439,7 @@ QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( asse
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	} catch ( e ) {}

	assert.ok( div && div.jquery, "Created nodes safely, guarded against exceptions on safeChildNodes[ -1 ]" );
} );

QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( assert ) {

	assert.expect( 5 );

	assert.strictEqual( jQuery( "<div></div>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.clone" );
	assert.strictEqual( jQuery( "<div></div>" ).find( "p" ).end().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.fn.find" );
	assert.strictEqual( jQuery( "<div></div>" ).text( "test" ).addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.fn.text" );
	assert.strictEqual( jQuery( "<bdi></bdi>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after clone html5 element" );
	assert.strictEqual( jQuery( "<p></p>" ).appendTo( "<div></div>" ).end().length, jQuery( "<p>test</p>" ).appendTo( "<div></div>" ).end().length, "Elements created with createElement and with createDocumentFragment should be treated alike" );
} );

QUnit.test( "html() - script exceptions bubble (#11743)", function( assert ) {
	assert.expect( 2 );
	var done = assert.async(),
		onerror = window.onerror;

diff --git a/a.js b/b.js
@@ -2481,7 +2481,7 @@ QUnit.test( "checked state is cloned with clone()", function( assert ) {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	};

	jQuery( "#qunit-fixture" ).html( "<script>undefined();</script>" );
} );

QUnit.test( "checked state is cloned with clone()", function( assert ) {

	assert.expect( 2 );

	var elem = jQuery.parseHTML( "<input type='checkbox' checked='checked'/>" )[ 0 ];
	elem.checked = false;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, false, "Checked false state correctly cloned" );

	elem = jQuery.parseHTML( "<input type='checkbox'/>" )[ 0 ];
	elem.checked = true;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, true, "Checked true state correctly cloned" );
} );

QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div>a</div>" ).append( "&nbsp;", jQuery( "<span>b</span>" ), "&nbsp;", jQuery( "<span>c</span>" ) ),
diff --git a/a.js b/b.js
@@ -2497,7 +2497,7 @@ QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( asser
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	elem = jQuery.parseHTML( "<input type='checkbox'/>" )[ 0 ];
	elem.checked = true;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, true, "Checked true state correctly cloned" );
} );

QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div>a</div>" ).append( "&nbsp;", jQuery( "<span>b</span>" ), "&nbsp;", jQuery( "<span>c</span>" ) ),
		nbsp = String.fromCharCode( 160 );

	assert.equal( div.text(), "a" + nbsp + "b" + nbsp + "c", "Appending mixed jQuery with text nodes" );

	div = jQuery( "<div><div></div></div>" )
		.find( "div" )
		.after( "<p>a</p>", "<p>b</p>" )
		.parent();
	assert.equal( div.find( "*" ).length, 3, "added 2 paragraphs after inner div" );
} );

QUnit.test( "script evaluation (#11795)", function( assert ) {

	assert.expect( 13 );

	var scriptsIn, scriptsOut,
diff --git a/a.js b/b.js
@@ -2551,7 +2551,7 @@ 		notOk = function() {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		fixture = jQuery( "#qunit-fixture" ).empty(),
		objGlobal = ( function() {
			return this;
		} )(),
		isOk = objGlobal.ok,
		notOk = function() {
			var args = arguments;
			args[ 0 ] = !args[ 0 ];
			return isOk.apply( this, args );
		};

	objGlobal.ok = notOk;
	scriptsIn = jQuery( [
		"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: non-script' );</script>",
		"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: text/javascript' );</script>",
		"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: text/ecmascript' );</script>",
		"<script>QUnit.assert.ok( true, 'evaluated: no type' );</script>",
		"<div>",
			"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: inner non-script' );</script>",
			"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: inner text/javascript' );</script>",
			"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: inner text/ecmascript' );</script>",
			"<script>QUnit.assert.ok( true, 'evaluated: inner no type' );</script>",
		"</div>"
	].join( "" ) );
	scriptsIn.appendTo( jQuery( "<div class='detached'></div>" ) );
	objGlobal.ok = isOk;

	scriptsOut = fixture.append( scriptsIn ).find( "script" );
	assert.equal( scriptsOut[ 0 ].type, "something/else", "Non-evaluated type." );
	assert.equal( scriptsOut[ 1 ].type, "text/javascript", "Evaluated type." );
	assert.deepEqual( scriptsOut.get(), fixture.find( "script" ).get(), "All script tags remain." );

	objGlobal.ok = notOk;
	scriptsOut = scriptsOut.add( scriptsOut.clone() ).appendTo( fixture.find( "div" ) );
	assert.deepEqual( fixture.find( "div script" ).get(), scriptsOut.get(), "Scripts cloned without reevaluation" );
	fixture.append( scriptsOut.detach() );
	assert.deepEqual( fixture.children( "script" ).get(), scriptsOut.get(), "Scripts detached without reevaluation" );
	objGlobal.ok = isOk;

	if ( jQuery.ajax ) {
		Globals.register( "testBar" );
		jQuery( "#qunit-fixture" ).append( "<script src='" + url( "mock.php?action=testbar" ) + "'></script>" );
		assert.strictEqual( window.testBar, "bar", "Global script evaluation" );
	} else {
		assert.ok( true, "No jQuery.ajax" );
		assert.ok( true, "No jQuery.ajax" );
	}
} );

QUnit[ jQuery.ajax ? "test" : "skip" ]( "jQuery._evalUrl (#12838)", function( assert ) {

	assert.expect( 5 );

	var message, expectedArgument,
diff --git a/a.js b/b.js
@@ -2620,7 +2620,7 @@ setTimeout( function() {
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66

	assert.equal( invocations, 3, "htmlPrefilter invoked for all DOM manipulations" );
	assert.equal( fixture.html(), "A-B-C-D-E-F-", "htmlPrefilter modified HTML" );

	// Allow asynchronous script execution to generate assertions
	setTimeout( function() {
		jQuery.htmlPrefilter = htmlPrefilter;
		done();
	}, 100 );
} );

QUnit.test( "insertAfter, insertBefore, etc do not work when destination is original element. Element is removed (#4087)", function( assert ) {

	assert.expect( 10 );

	var elems;
diff --git a/a.js b/b.js
@@ -2654,7 +2654,7 @@ QUnit.test( "insertAfter, insertBefore, etc do not work when destination is orig
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		jQuery.htmlPrefilter = htmlPrefilter;
		done();
	}, 100 );
} );

QUnit.test( "insertAfter, insertBefore, etc do not work when destination is original element. Element is removed (#4087)", function( assert ) {

	assert.expect( 10 );

	var elems;

	jQuery.each( [
		"appendTo",
		"prependTo",
		"insertBefore",
		"insertAfter",
		"replaceAll"
	], function( index, name ) {
		elems = jQuery( [
			"<ul id='test4087-complex'><li class='test4087'><div>c1</div>h1</li><li><div>c2</div>h2</li></ul>",
			"<div id='test4087-simple'><div class='test4087-1'>1<div class='test4087-2'>2</div><div class='test4087-3'>3</div></div></div>",
			"<div id='test4087-multiple'><div class='test4087-multiple'>1</div><div class='test4087-multiple'>2</div></div>"
		].join( "" ) ).appendTo( "#qunit-fixture" );

		// complex case based on https://jsfiddle.net/pbramos/gZ7vB/
		jQuery( "#test4087-complex div" )[ name ]( "#test4087-complex li:last-child div:last-child" );
		assert.equal( jQuery( "#test4087-complex li:last-child div" ).length, name === "replaceAll" ? 1 : 2, name + " a node to itself, complex case." );

		// simple case
		jQuery( ".test4087-1" )[ name ]( ".test4087-1" );
		assert.equal( jQuery( ".test4087-1" ).length, 1, name + " a node to itself, simple case." );

		// clean for next test
		jQuery( "#test4087-complex" ).remove();
		jQuery( "#test4087-simple" ).remove();
		jQuery( "#test4087-multiple" ).remove();
	} );
} );

QUnit.test( "Index for function argument should be received (#13094)", function( assert ) {
	assert.expect( 2 );

	var i = 0;

diff --git a/a.js b/b.js
@@ -2676,7 +2676,7 @@ QUnit.test( "Make sure jQuery.fn.remove can work on elements in documentFragment
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
		assert.equal( index, i++, "Index should be correct" );
	} );

} );

QUnit.test( "Make sure jQuery.fn.remove can work on elements in documentFragment", function( assert ) {
	assert.expect( 1 );

	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) );

	jQuery( div ).remove();

	assert.equal( fragment.childNodes.length, 0, "div element was removed from documentFragment" );
} );

QUnit.test( "Make sure specific elements with content created correctly (#13232)", function( assert ) {
	assert.expect( 20 );

	var results = [],
		args = [],
diff --git a/a.js b/b.js
@@ -2711,7 +2711,7 @@ QUnit.test( "Make sure specific elements with content created correctly (#13232)
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	jQuery( div ).remove();

	assert.equal( fragment.childNodes.length, 0, "div element was removed from documentFragment" );
} );

QUnit.test( "Make sure specific elements with content created correctly (#13232)", function( assert ) {
	assert.expect( 20 );

	var results = [],
		args = [],
		elems = {
			thead: "<tr><td>thead</td></tr>",
			tbody: "<tr><td>tbody</td></tr>",
			tfoot: "<tr><td>tfoot</td></tr>",
			colgroup: "<col span='5'></col>",
			caption: "caption",
			tr: "<td>tr</td>",
			th: "th",
			td: "<div>td</div>",
			optgroup: "<option>optgroup</option>",
			option: "option"
		};

	jQuery.each( elems, function( name, value ) {
		var html = "<" + name + ">" + value + "</" + name + ">";
		assert.strictEqual(
			jQuery.parseHTML( "<" + name + ">" + value + "</" + name + ">" )[ 0 ].nodeName.toLowerCase(),
			name,
			name + " is created correctly"
		);

		results.push( name );
		args.push( html );
	} );

	jQuery.fn.append.apply( jQuery( "<div></div>" ), args ).children().each( function( i ) {
		assert.strictEqual( this.nodeName.toLowerCase(), results[ i ] );
	} );
} );

QUnit.test( "Validate creation of multiple quantities of certain elements (#13818)", function( assert ) {
	assert.expect( 22 );

	var tags = [ "thead", "tbody", "tfoot", "colgroup", "col", "caption", "tr", "th", "td", "optgroup", "option" ];

diff --git a/a.js b/b.js
@@ -3008,3 +3008,19 @@ QUnit.test( "Works with invalid attempts to close the table wrapper", function(
A blob:8262516a9ef8cc9a2a1a36dfff44a5b3b13b8a66
	if ( !oldIos ) {
		test( "<noembed><noembed/><img src=url404 onerror=xss(12)>" );
	}
} );

QUnit.test( "Works with invalid attempts to close the table wrapper", function( assert ) {
	assert.expect( 3 );

	// This test case attempts to close the tags which wrap input
	// based on matching done in wrapMap which should be ignored.
	var elem = jQuery( "<td></td></tr></tbody></table><td></td>" );
	assert.strictEqual( elem.length, 2, "Two elements created" );
	assert.strictEqual( elem[ 0 ].nodeName.toLowerCase(), "td", "First element is td" );
	assert.strictEqual( elem[ 1 ].nodeName.toLowerCase(), "td", "Second element is td" );
} );

diff --git a/a.js b/b.js
@@ -386,7 +386,7 @@ require( [ parentUrl + "test/data/testrunner.js" ], function() {
A blob:c9b9c45a061a9d82c4268bd55ea50e3e67c62c9d
			QUnit.skip( "jQuery ready tests skipped in async mode", function() {} );
		} );
	}

	// Get testSubproject from testrunner first
	require( [ parentUrl + "test/data/testrunner.js" ], function() {
		var i = 0,
			tests = [
				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"unit/basic.js",

				"unit/core.js",
				"unit/callbacks.js",
				"unit/deferred.js",
				"unit/deprecated.js",
				"unit/support.js",
				"unit/data.js",
				"unit/queue.js",
				"unit/attributes.js",
				"unit/event.js",
				"unit/selector.js",
				"unit/traversing.js",
				"unit/manipulation.js",
				"unit/wrap.js",
				"unit/css.js",
				"unit/serialize.js",
				"unit/ajax.js",
				"unit/effects.js",
				"unit/offset.js",
				"unit/dimensions.js",
				"unit/animation.js",
				"unit/tween.js"
			];

		// Ensure load order (to preserve test numbers)
		( function loadDep() {
			var dep = tests[ i++ ];

			if ( dep ) {
				if ( !QUnit.basicTests || i === 1 ) {
					require( [ parentUrl + "test/" + dep ], loadDep );

				// When running basic tests, replace other modules with dummies to avoid overloading
				// impaired clients.
				} else {
					QUnit.module( dep.replace( /^.*\/|\.js$/g, "" ) );
					loadDep();
				}

			} else {
				if ( window.__karma__ && window.__karma__.start ) {
					window.__karma__.start();
				} else {
					QUnit.load();
				}

				/**
				 * Run in noConflict mode
				 */
				jQuery.noConflict();

				// Load the TestSwarm listener if swarmURL is in the address.
				if ( QUnit.isSwarm ) {
					require( [ "http://swarm.jquery.org/js/inject.js?" + ( new Date() ).getTime() ],
					function() {
						QUnit.start();
					} );
				} else {
diff --git a/a.js b/b.js
@@ -4,6 +4,7 @@
A blob:c82a08c545489cc30c951e0133ebbc7e50990429
import jQuery from "./core.js";
import access from "./core/access.js";
import nodeName from "./core/nodeName.js";
import rcssNum from "./var/rcssNum.js";
import isIE from "./var/isIE.js";
import rnumnonpx from "./css/var/rnumnonpx.js";
import cssExpand from "./css/var/cssExpand.js";
import isAutoPx from "./css/isAutoPx.js";
import cssCamelCase from "./css/cssCamelCase.js";
import getStyles from "./css/var/getStyles.js";
diff --git a/a.js b/b.js
@@ -24,7 +25,6 @@
A blob:c82a08c545489cc30c951e0133ebbc7e50990429

var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
diff --git a/a.js b/b.js
@@ -220,15 +220,15 @@ style: function( elem, name, value, extra ) {
A blob:c82a08c545489cc30c951e0133ebbc7e50990429
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = cssCamelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

diff --git a/a.js b/b.js
@@ -239,7 +239,7 @@ style: function( elem, name, value, extra ) {
A blob:c82a08c545489cc30c951e0133ebbc7e50990429
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = cssCamelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If the value is a number, add `px` for certain CSS properties
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( isAutoPx( origName ) ? "px" : "" );
			}

			// Support: IE <=9 - 11+
			// background-* props of a cloned element affect the source element (#8908)
			if ( isIE && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

diff --git a/a.js b/b.js
@@ -1,9 +1,12 @@
A blob:59a639f688abd7ebce3c426e98a77a6f970b6b4a
import jQuery from "../core.js";
import isAttached from "../core/isAttached.js";
import getStyles from "./var/getStyles.js";

function curCSS( elem, name, computed ) {
	var ret;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for `.css('--customProperty')` (gh-3144)
diff --git a/a.js b/b.js
@@ -11,6 +14,17 @@ function curCSS( elem, name, computed ) {
A blob:59a639f688abd7ebce3c426e98a77a6f970b6b4a
import jQuery from "../core.js";
import isAttached from "../core/isAttached.js";
import getStyles from "./var/getStyles.js";

function curCSS( elem, name, computed ) {
	var ret;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for `.css('--customProperty')` (gh-3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}
	}
diff --git a/a.js b/b.js
@@ -5,8 +5,9 @@
A blob:f7e8d9b60735847f5cd09c72d2111c41758a6086
import jQuery from "./core.js";
import nodeName from "./core/nodeName.js";
import document from "./var/document.js";
import documentElement from "./var/documentElement.js";
import indexOf from "./var/indexOf.js";
import pop from "./var/pop.js";
import push from "./var/push.js";
import whitespace from "./selector/var/whitespace.js";
import rbuggyQSA from "./selector/rbuggyQSA.js";
import isIE from "./var/isIE.js";

// The following utils are attached directly to the jQuery object.
import "./selector/contains.js";
diff --git a/a.js b/b.js
@@ -71,7 +72,6 @@
A blob:f7e8d9b60735847f5cd09c72d2111c41758a6086

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
diff --git a/a.js b/b.js
@@ -282,7 +282,8 @@ function createCache() {
A blob:f7e8d9b60735847f5cd09c72d2111c41758a6086
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
diff --git a/a.js b/b.js
@@ -432,7 +433,7 @@ function setDocument( node ) {
A blob:f7e8d9b60735847f5cd09c72d2111c41758a6086

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+
	// IE sometimes throws a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 ) {
		return;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: IE 9 - 11+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+
	// IE sometimes throws a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
diff --git a/a.js b/b.js
@@ -843,7 +844,8 @@ find.matchesSelector = function( elem, expr ) {
A blob:f7e8d9b60735847f5cd09c72d2111c41758a6086

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			return matches.call( elem, expr );
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	find: {
		ID: function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		},

		TAG: function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
			} else {
				return context.querySelectorAll( tag );
			}
		},

		CLASS: function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					selectorError( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				selectorError( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		ID: function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		},

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?

				function() {
					return true;
				} :

				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = jQuery.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					selectorError( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),
diff --git a/a.js b/b.js
@@ -1348,7 +1350,8 @@ function matcherFromTokens( tokens ) {
A blob:f7e8d9b60735847f5cd09c72d2111c41758a6086
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

diff --git a/a.js b/b.js
@@ -1,5 +1,5 @@
A blob:7a621073322658add2eaf3ac49f0191c9ed08ab6
import isIE from "../var/isIE.js";
import whitespace from "./var/whitespace.js";

var rbuggyQSA = isIE && new RegExp(

	// Support: IE 9 - 11+
diff --git a/a.js b/b.js
@@ -33,7 +33,7 @@ QUnit.test( "css(String|Hash)", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
if ( jQuery.css ) {

QUnit.module( "css", { afterEach: moduleTeardown } );

QUnit.test( "css(String|Hash)", function( assert ) {
	assert.expect( 42 );

	assert.equal( jQuery( "#qunit-fixture" ).css( "display" ), "block", "Check for css property \"display\"" );

	var $child, div, div2, width, height, child, prctval, checkval, old;

	$child = jQuery( "#nothiddendivchild" ).css( { "width": "20%", "height": "20%" } );
	assert.notEqual( $child.css( "width" ), "20px", "Retrieving a width percentage on the child of a hidden div returns percentage" );
	assert.notEqual( $child.css( "height" ), "20px", "Retrieving a height percentage on the child of a hidden div returns percentage" );

	div = jQuery( "<div></div>" );

	// These should be "auto" (or some better value)
	// temporarily provide "0px" for backwards compat
	assert.equal( div.css( "width" ), "0px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "0px", "Height on disconnected node." );

	div.css( { "width": 4, "height": 4 } );

	assert.equal( div.css( "width" ), "4px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "4px", "Height on disconnected node." );

	div2 = jQuery( "<div style='display:none;'><input type='text' style='height:20px;'/><textarea style='height:20px;'></textarea><div style='height:20px;'></div></div>" ).appendTo( "body" );

	assert.equal( div2.find( "input" ).css( "height" ), "20px", "Height on hidden input." );
	assert.equal( div2.find( "textarea" ).css( "height" ), "20px", "Height on hidden textarea." );
	assert.equal( div2.find( "div" ).css( "height" ), "20px", "Height on hidden div." );

	div2.remove();

	// handle negative numbers by setting to zero #11604
	jQuery( "#nothiddendiv" ).css( { "width": 1, "height": 1 } );

	width = parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) );
	height = parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) );
diff --git a/a.js b/b.js
@@ -113,7 +113,7 @@ QUnit.test( "css(String|Hash)", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
if ( jQuery.css ) {

QUnit.module( "css", { afterEach: moduleTeardown } );

QUnit.test( "css(String|Hash)", function( assert ) {
	assert.expect( 42 );

	assert.equal( jQuery( "#qunit-fixture" ).css( "display" ), "block", "Check for css property \"display\"" );

	var $child, div, div2, width, height, child, prctval, checkval, old;

	$child = jQuery( "#nothiddendivchild" ).css( { "width": "20%", "height": "20%" } );
	assert.notEqual( $child.css( "width" ), "20px", "Retrieving a width percentage on the child of a hidden div returns percentage" );
	assert.notEqual( $child.css( "height" ), "20px", "Retrieving a height percentage on the child of a hidden div returns percentage" );

	div = jQuery( "<div></div>" );

	// These should be "auto" (or some better value)
	// temporarily provide "0px" for backwards compat
	assert.equal( div.css( "width" ), "0px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "0px", "Height on disconnected node." );

	div.css( { "width": 4, "height": 4 } );

	assert.equal( div.css( "width" ), "4px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "4px", "Height on disconnected node." );

	div2 = jQuery( "<div style='display:none;'><input type='text' style='height:20px;'/><textarea style='height:20px;'></textarea><div style='height:20px;'></div></div>" ).appendTo( "body" );

	assert.equal( div2.find( "input" ).css( "height" ), "20px", "Height on hidden input." );
	assert.equal( div2.find( "textarea" ).css( "height" ), "20px", "Height on hidden textarea." );
	assert.equal( div2.find( "div" ).css( "height" ), "20px", "Height on hidden div." );

	div2.remove();

	// handle negative numbers by setting to zero #11604
	jQuery( "#nothiddendiv" ).css( { "width": 1, "height": 1 } );

	width = parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) );
	height = parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) );
	jQuery( "#nothiddendiv" ).css( { "overflow":"hidden", "width": -1, "height": -1 } );
	assert.equal( parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) ), 0, "Test negative width set to 0" );
	assert.equal( parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) ), 0, "Test negative height set to 0" );

	assert.equal( jQuery( "<div style='display: none;'></div>" ).css( "display" ), "none", "Styles on disconnected nodes" );

	jQuery( "#floatTest" ).css( { "float": "right" } );
	assert.equal( jQuery( "#floatTest" ).css( "float" ), "right", "Modified CSS float using \"float\": Assert float is right" );
	jQuery( "#floatTest" ).css( { "font-size": "30px" } );
	assert.equal( jQuery( "#floatTest" ).css( "font-size" ), "30px", "Modified CSS font-size: Assert font-size is 30px" );
	jQuery.each( "0,0.25,0.5,0.75,1".split( "," ), function( i, n ) {
		jQuery( "#foo" ).css( { "opacity": n } );

		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a String" );
		jQuery( "#foo" ).css( { "opacity": parseFloat( n ) } );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a Number" );
	} );
	jQuery( "#foo" ).css( { "opacity": "" } );
	assert.equal( jQuery( "#foo" ).css( "opacity" ), "1", "Assert opacity is 1 when set to an empty String" );

	assert.equal( jQuery( "#empty" ).css( "opacity" ), "0", "Assert opacity is accessible" );
	jQuery( "#empty" ).css( { "opacity": "1" } );
	assert.equal( jQuery( "#empty" ).css( "opacity" ), "1", "Assert opacity is taken from style attribute when set" );

	div = jQuery( "#nothiddendiv" );
	child = jQuery( "#nothiddendivchild" );

	assert.equal( parseInt( div.css( "fontSize" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( div.css( "font-size" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( child.css( "fontSize" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( child.css( "font-size" ), 10 ), 16, "Verify fontSize px set." );

	child.css( "height", "100%" );
	assert.equal( child[ 0 ].style.height, "100%", "Make sure the height is being set correctly." );

	child.attr( "class", "em" );
	assert.equal( parseInt( child.css( "fontSize" ), 10 ), 32, "Verify fontSize em set." );

	// Have to verify this as the result depends upon the browser's CSS
	// support for font-size percentages
	child.attr( "class", "prct" );
	prctval = parseInt( child.css( "fontSize" ), 10 );
	checkval = 0;
	if ( prctval === 16 || prctval === 24 ) {
		checkval = prctval;
	}

	assert.equal( prctval, checkval, "Verify fontSize % set." );

	assert.equal( typeof child.css( "width" ), "string", "Make sure that a string width is returned from css('width')." );

	old = child[ 0 ].style.height;

	// Test NaN
	child.css( "height", parseFloat( "zoo" ) );
	assert.equal( child[ 0 ].style.height, old, "Make sure height isn't changed on NaN." );

	// Test null
	child.css( "height", null );
	assert.equal( child[ 0 ].style.height, old, "Make sure height isn't changed on null." );

	old = child[ 0 ].style.fontSize;

	// Test NaN
	child.css( "font-size", parseFloat( "zoo" ) );
	assert.equal( child[ 0 ].style.fontSize, old, "Make sure font-size isn't changed on NaN." );

	// Test null
	child.css( "font-size", null );
	assert.equal( child[ 0 ].style.fontSize, old, "Make sure font-size isn't changed on null." );

	assert.strictEqual( child.css( "x-fake" ), undefined, "Make sure undefined is returned from css(nonexistent)." );

	div = jQuery( "<div></div>" ).css( { position: "absolute", "z-index": 1000 } ).appendTo( "#qunit-fixture" );
	assert.strictEqual( div.css( "z-index" ), "1000",
		"Make sure that a string z-index is returned from css('z-index') (#14432)." );
} );

QUnit.test( "css() explicit and relative values", function( assert ) {
	assert.expect( 29 );
diff --git a/a.js b/b.js
@@ -325,11 +325,11 @@ QUnit.test( "css(String, Object)", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	$el.css( "right", "-=25em" );
	assert.equal( Math.round( parseFloat( $el.css( "right" ) ) ), 100,
		"Constraints do not interfere with unit conversion" );
} );

QUnit.test( "css(String, Object)", function( assert ) {
	assert.expect( 19 );
	var j, div, display, ret, success;

	jQuery( "#floatTest" ).css( "float", "left" );
	assert.equal( jQuery( "#floatTest" ).css( "float" ), "left", "Modified CSS float using \"float\": Assert float is left" );
	jQuery( "#floatTest" ).css( "font-size", "20px" );
	assert.equal( jQuery( "#floatTest" ).css( "font-size" ), "20px", "Modified CSS font-size: Assert font-size is 20px" );

	jQuery.each( "0,0.25,0.5,0.75,1".split( "," ), function( i, n ) {
		jQuery( "#foo" ).css( "opacity", n );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a String" );
		jQuery( "#foo" ).css( "opacity", parseFloat( n ) );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a Number" );
	} );
	jQuery( "#foo" ).css( "opacity", "" );
	assert.equal( jQuery( "#foo" ).css( "opacity" ), "1", "Assert opacity is 1 when set to an empty String" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
	j.css( "overflow", "visible" );
	assert.equal( j.css( "overflow" ), "visible", "Check node,textnode,comment css works" );
	assert.equal( jQuery( "#t2037 .hidden" ).css( "display" ), "none", "Make sure browser thinks it is hidden" );

	div = jQuery( "#nothiddendiv" );
	display = div.css( "display" );
	ret = div.css( "display", undefined );

	assert.equal( ret, div, "Make sure setting undefined returns the original set." );
	assert.equal( div.css( "display" ), display, "Make sure that the display wasn't changed." );

	success = true;
	try {
		jQuery( "#foo" ).css( "backgroundColor", "rgba(0, 0, 0, 0.1)" );
	}
	catch ( e ) {
		success = false;
	}
	assert.ok( success, "Setting RGBA values does not throw Error (#5509)" );

	jQuery( "#foo" ).css( "font", "7px/21px sans-serif" );
	assert.strictEqual( jQuery( "#foo" ).css( "line-height" ), "21px",
		"Set font shorthand property (#14759)" );
} );

QUnit.test( "css(String, Object) with negative values", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -699,7 +699,7 @@ QUnit.test( "show/hide detached nodes", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	// Make sure that showing or hiding a text node doesn't cause an error
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

QUnit.test( "show/hide detached nodes", function( assert ) {
	assert.expect( 19 );

	var div, span, tr;

	div = jQuery( "<div>" ).hide();
	assert.equal( div.css( "display" ), "none", "hide() updates inline style of a detached div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A hidden-while-detached div is hidden after attachment" );
	div.show();
	assert.equal( div.css( "display" ), "block",
		"A hidden-while-detached div can be shown after attachment" );

	div = jQuery( "<div class='hidden'>" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached div can be hidden by the CSS cascade" );

	div = jQuery( "<div><div class='hidden'></div></div>" ).children( "div" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached div inside a visible div can be hidden by the CSS cascade" );

	span = jQuery( "<span class='hidden'></span>" );
	span.show().appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "none",
		"A shown-while-detached span can be hidden by the CSS cascade" );

	div = jQuery( "div.hidden" );
	div.detach().show();
	assert.ok( !div[ 0 ].style.display,
		"show() does not update inline style of a cascade-hidden-before-detach div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached cascade-hidden div is hidden after attachment" );
	div.remove();

	span = jQuery( "<span class='hidden'></span>" );
	span.appendTo( "#qunit-fixture" ).detach().show().appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "none",
		"A shown-while-detached cascade-hidden span is hidden after attachment" );
	span.remove();

	div = jQuery( document.createElement( "div" ) );
	div.show().appendTo( "#qunit-fixture" );
	assert.ok( !div[ 0 ].style.display, "A shown-while-detached div has no inline style" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached div has default display after attachment" );
	div.remove();

	div = jQuery( "<div style='display: none'>" );
	div.show();
	assert.equal( div[ 0 ].style.display, "",
		"show() updates inline style of a detached inline-hidden div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached inline-hidden div has default display after attachment" );

	div = jQuery( "<div><div style='display: none'></div></div>" ).children( "div" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached inline-hidden div inside a visible div has default display " +
		"after attachment" );

	span = jQuery( "<span style='display: none'></span>" );
	span.show();
	assert.equal( span[ 0 ].style.display, "",
		"show() updates inline style of a detached inline-hidden span" );
	span.appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "inline",
		"A shown-while-detached inline-hidden span has default display after attachment" );

	div = jQuery( "<div style='display: inline'></div>" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "inline",
		"show() does not update inline style of a detached inline-visible div" );
	div.remove();

	tr = jQuery( "<tr></tr>" );
	jQuery( "#table" ).append( tr );
	tr.detach().hide().show();

	assert.ok( !tr[ 0 ].style.display, "Not-hidden detached tr elements have no inline style" );
	tr.remove();

	span = jQuery( "<span></span>" ).hide().show();
	assert.ok( !span[ 0 ].style.display, "Not-hidden detached span elements have no inline style" );
	span.remove();
} );

// Support: IE 11+
// IE doesn't support Shadow DOM.
QUnit.testUnlessIE(
	"show/hide shadow child nodes", function( assert ) {

	assert.expect( 28 );
	jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );
	var shadowHost = document.querySelector( "#shadowHost" );
	var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
	shadowRoot.innerHTML = "" +
		"<style>.hidden{display: none;}</style>" +
		"<div class='hidden' id='shadowdiv'>" +
		"	<p class='hidden' id='shadowp'>" +
		"		<a href='#' class='hidden' id='shadowa'></a>" +
		"	</p>" +
		"	<code class='hidden' id='shadowcode'></code>" +
		"	<pre class='hidden' id='shadowpre'></pre>" +
		"	<span class='hidden' id='shadowspan'></span>" +
		"</div>" +
		"<table class='hidden' id='shadowtable'>" +
		"	<thead class='hidden' id='shadowthead'>" +
		"		<tr class='hidden' id='shadowtr'>" +
		"			<th class='hidden' id='shadowth'></th>" +
		"		</tr>" +
		"	</thead>" +
		"	<tbody class='hidden' id='shadowtbody'>" +
		"		<tr class='hidden'>" +
		"			<td class='hidden' id='shadowtd'></td>" +
		"		</tr>" +
		"	</tbody>" +
		"</table>" +
		"<ul class='hidden' id='shadowul'>" +
		"	<li class='hidden' id='shadowli'></li>" +
		"</ul>";

	var test = {
		"div": "block",
		"p": "block",
		"a": "inline",
		"code": "inline",
		"pre": "block",
		"span": "inline",
		"table": "table",
		"thead": "table-header-group",
		"tbody": "table-row-group",
		"tr": "table-row",
		"th": "table-cell",
		"td": "table-cell",
		"ul": "block",
		"li": "list-item"
	};

	jQuery.each( test, function( selector, expected ) {
		var shadowChild = shadowRoot.querySelector( "#shadow" + selector );
		var $shadowChild = jQuery( shadowChild );
		assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
		$shadowChild.show();
		assert.strictEqual( $shadowChild.css( "display" ), expected, "Show using correct display type for " + selector );
	} );
} );

QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
	assert.expect( 3 );

	var div = jQuery( "<div style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is hidden by default" );
diff --git a/a.js b/b.js
@@ -712,7 +712,7 @@ QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
		$shadowChild.show();
		assert.strictEqual( $shadowChild.css( "display" ), expected, "Show using correct display type for " + selector );
	} );
} );

QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
	assert.expect( 3 );

	var div = jQuery( "<div style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is hidden by default" );
	div.hide();
	assert.ok( !jQuery._data( div, "olddisplay" ), "olddisplay is undefined after hiding an already-hidden element" );
	div.show();
	assert.equal( div.css( "display" ), "block", "Show a double-hidden element" );

	div.remove();
} );

QUnit.test( "show() after hide() should always set display to initial value (#14750)", function( assert ) {
	assert.expect( 1 );

	var div = jQuery( "<div></div>" ),
		fixture = jQuery( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -988,7 +988,7 @@ QUnit.test( "show/hide 3.0, inline hidden", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
			assert.equal( this.style.display, expected, name + sequence.join( "" ) + " inline" );
		}
	} );
} );

QUnit.test( "show/hide 3.0, inline hidden", function( assert ) {

	assert.expect( 84 );

	var i,
		$elems = jQuery( "<div></div>" )
			.appendTo( "#qunit-fixture" )
			.html( "<span data-expected-display='inline' style='display:none'></span>" +
				"<span class='list-item' data-expected-display='list-item' style='display:none'></span>" +
				"<div data-expected-display='block' style='display:none'></div>" +
				"<div class='list-item' data-expected-display='list-item' style='display:none'></div>" +
				"<ul>" +
					"<li data-expected-display='list-item' style='display:none'></li>" +
					"<li class='block' data-expected-display='block' style='display:none'></li>" +
					"<li class='inline' data-expected-display='inline' style='display:none'></li>" +
				"</ul>" )
			.find( "[data-expected-display]" );

	$elems.each( function() {
		var $elem = jQuery( this ),
			name = this.nodeName,
			expected = this.getAttribute( "data-expected-display" ),
			sequence = [];

		if ( this.className ) {
			name += "." + this.className;
		}
		if ( this.getAttribute( "style" ) ) {
			name += "[style='" + this.getAttribute( "style" ) + "']";
		}
		name += " ";

		for ( i = 0; i < 3; i++ ) {
			sequence.push( ".hide()" );
			$elem.hide();
			assert.equal( $elem.css( "display" ), "none",
				name + sequence.join( "" ) + " computed" );
			assert.equal( this.style.display, "none", name + sequence.join( "" ) + " inline" );

			sequence.push( ".show()" );
			$elem.show();
			assert.equal( $elem.css( "display" ), expected,
				name + sequence.join( "" ) + " computed" );
			assert.equal( this.style.display, "", name + sequence.join( "" ) + " inline" );
		}
	} );
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle ? "test" : "skip" ]( "toggle()", function( assert ) {
	assert.expect( 9 );
	var div, oldHide,
		x = jQuery( "#foo" );

	assert.ok( x.is( ":visible" ), "is visible" );
	x.toggle();
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle();
	assert.ok( x.is( ":visible" ), "is visible again" );

	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible" );
	x.toggle( false );
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible again" );

	div = jQuery( "<div style='display:none'><div></div></div>" ).appendTo( "#qunit-fixture" );
	x = div.find( "div" );
	assert.strictEqual( x.toggle().css( "display" ), "none", "is hidden" );
	assert.strictEqual( x.toggle().css( "display" ), "block", "is visible" );

	// Ensure hide() is called when toggled (#12148)
	oldHide = jQuery.fn.hide;
	jQuery.fn.hide = function() {
		assert.ok( true, name + " method called on toggle" );
		return oldHide.apply( this, arguments );
diff --git a/a.js b/b.js
@@ -1048,7 +1048,7 @@ 	jQuery.fn.hide = function() {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	assert.strictEqual( x.toggle().css( "display" ), "none", "is hidden" );
	assert.strictEqual( x.toggle().css( "display" ), "block", "is visible" );

	// Ensure hide() is called when toggled (#12148)
	oldHide = jQuery.fn.hide;
	jQuery.fn.hide = function() {
		assert.ok( true, name + " method called on toggle" );
		return oldHide.apply( this, arguments );
	};
	x.toggle( name === "show" );
	jQuery.fn.hide = oldHide;
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle ? "test" : "skip" ]( "detached toggle()", function( assert ) {
	assert.expect( 6 );
	var detached = jQuery( "<p><a></a><p>" ).find( "*" ).addBack(),
		hiddenDetached = jQuery( "<p><a></a></p>" ).find( "*" ).addBack().css( "display", "none" ),
		cascadeHiddenDetached = jQuery( "<p><a></a></p>" ).find( "*" ).addBack().addClass( "hidden" );

	detached.toggle();
	detached.appendTo( "#qunit-fixture" );
	assert.equal( detached[ 0 ].style.display, "none", "detached element" );
	assert.equal( detached[ 1 ].style.display, "none", "element in detached tree" );

	hiddenDetached.toggle();
	hiddenDetached.appendTo( "#qunit-fixture" );
	assert.equal( hiddenDetached[ 0 ].style.display, "", "detached, hidden element" );
	assert.equal( hiddenDetached[ 1 ].style.display, "", "hidden element in detached tree" );

	cascadeHiddenDetached.toggle();
	cascadeHiddenDetached.appendTo( "#qunit-fixture" );
	assert.equal( cascadeHiddenDetached[ 0 ].style.display, "none",
		"detached, cascade-hidden element" );
	assert.equal( cascadeHiddenDetached[ 1 ].style.display, "none",
		"cascade-hidden element in detached tree" );
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle && !QUnit.isIE ? "test" : "skip" ](
	"shadow toggle()", function( assert ) {

	assert.expect( 4 );

	jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );
	var shadowHost = document.querySelector( "#shadowHost" );
	var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
	shadowRoot.innerHTML = "" +
		"<style>.hidden{display: none;}</style>" +
		"<div id='shadowHiddenChild' class='hidden'></div>" +
		"<div id='shadowChild'></div>";
	var shadowChild = shadowRoot.querySelector( "#shadowChild" );
	var shadowHiddenChild = shadowRoot.querySelector( "#shadowHiddenChild" );

	var $shadowChild = jQuery( shadowChild );
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );

	$shadowChild = jQuery( shadowHiddenChild );
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
} );

QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	jQuery.css( $checkedtest[ 0 ], "height" );
diff --git a/a.js b/b.js
@@ -1060,7 +1060,7 @@ QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)"
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
} );

QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	jQuery.css( $checkedtest[ 0 ], "height" );

	assert.ok( jQuery( "input[type='radio']", $checkedtest ).first().attr( "checked" ), "Check first radio still checked." );
	assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
	assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
	assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
} );

QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert ) {
	assert.expect( 1 );
	var result = true;

	try {
diff --git a/a.js b/b.js
@@ -1099,18 +1099,18 @@ QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert )
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
	assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
	assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
} );

QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert ) {
	assert.expect( 1 );
	var result = true;

	try {
		jQuery( "#foo" ).css( { "width": "0%" } ).css( "width" );
	} catch ( e ) {
		result = false;
	}

	assert.ok( result, "elem.runtimeStyle does not throw exception" );
} );

QUnit.test( "computed margins (trac-3333; gh-2237)", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "#foo" ),
		$child = jQuery( "#en" );

	$div.css( {
		"width": "1px",
		"marginRight": 0
	} );
	assert.equal( $div.css( "marginRight" ), "0px",
		"marginRight correctly calculated with a width and display block" );

	$div.css( {
		position: "absolute",
		top: 0,
		left: 0,
		width: "100px"
	} );
	$child.css( {
		width: "50px",
		margin: "auto"
	} );
	assert.equal( $child.css( "marginLeft" ), "25px", "auto margins are computed to pixels" );
} );

QUnit.test( "box model properties incorrectly returning % instead of px, see #10639 and #12088", function( assert ) {
	assert.expect( 2 );

	var container = jQuery( "<div></div>" ).width( 400 ).appendTo( "#qunit-fixture" ),
		el = jQuery( "<div></div>" ).css( { "width": "50%", "marginRight": "50%" } ).appendTo( container ),
		el2 = jQuery( "<div></div>" ).css( { "width": "50%", "minWidth": "300px", "marginLeft": "25%" } ).appendTo( container );

	assert.equal( el.css( "marginRight" ), "200px", "css('marginRight') returning % instead of px, see #10639" );
	assert.equal( el2.css( "marginLeft" ), "100px", "css('marginLeft') returning incorrect pixel value, see #12088" );
} );

QUnit.test( "widows & orphans #8936", function( assert ) {

	var $p = jQuery( "<p>" ).appendTo( "#qunit-fixture" );

	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1127,15 +1127,15 @@ QUnit.test( "widows & orphans #8936", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

	assert.equal( el.css( "marginRight" ), "200px", "css('marginRight') returning % instead of px, see #10639" );
	assert.equal( el2.css( "marginLeft" ), "100px", "css('marginLeft') returning incorrect pixel value, see #12088" );
} );

QUnit.test( "widows & orphans #8936", function( assert ) {

	var $p = jQuery( "<p>" ).appendTo( "#qunit-fixture" );

	assert.expect( 2 );

	$p.css( {
		"widows": 3,
		"orphans": 3
	} );

	assert.equal( $p.css( "widows" ) || jQuery.style( $p[ 0 ], "widows" ), 3, "widows correctly set to 3" );
	assert.equal( $p.css( "orphans" ) || jQuery.style( $p[ 0 ], "orphans" ), 3, "orphans correctly set to 3" );

	$p.remove();
} );

QUnit.test( "can't get css for disconnected in IE<9, see #10254 and #8388", function( assert ) {
	assert.expect( 2 );
	var span, div;

	span = jQuery( "<span></span>" ).css( "background-image", "url(" + baseURL + "1x1.jpg)" );
	assert.notEqual( span.css( "background-image" ), null, "can't get background-image in IE<9, see #10254" );

	div = jQuery( "<div></div>" ).css( "top", 10 );
	assert.equal( div.css( "top" ), "10px", "can't get top in IE<9, see #8388" );
} );

QUnit.test( "Ensure styles are retrieving from parsed html on document fragments", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1148,7 +1148,7 @@ QUnit.test( "Ensure styles are retrieving from parsed html on document fragments
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

	div = jQuery( "<div></div>" ).css( "top", 10 );
	assert.equal( div.css( "top" ), "10px", "can't get top in IE<9, see #8388" );
} );

QUnit.test( "Ensure styles are retrieving from parsed html on document fragments", function( assert ) {
	assert.expect( 1 );

	var $span = jQuery(
		jQuery.parseHTML( "<span style=\"font-family: Cuprum,sans-serif; font-size: 14px; color: #999999;\">some text</span>" )
	);

	assert.equal( $span.css( "font-size" ), "14px", "Font-size retrievable on parsed HTML node" );
} );

QUnit.test( "can't get background-position in IE<9, see #10796", function( assert ) {
	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ),
		units = [
			"0 0",
			"12px 12px",
diff --git a/a.js b/b.js
@@ -1167,22 +1167,22 @@ QUnit.test( "can't get background-position in IE<9, see #10796", function( asser
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	);

	assert.equal( $span.css( "font-size" ), "14px", "Font-size retrievable on parsed HTML node" );
} );

QUnit.test( "can't get background-position in IE<9, see #10796", function( assert ) {
	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ),
		units = [
			"0 0",
			"12px 12px",
			"13px 12em",
			"12em 13px",
			"12em center",
			"+12em center",
			"12.2em center",
			"center center"
		],
		l = units.length,
		i = 0;

	assert.expect( l );

	for ( ; i < l; i++ ) {
		div.css( "background-position", units [ i ] );
		assert.ok( div.css( "background-position" ), "can't get background-position in IE<9, see #10796" );
	}
} );

if ( jQuery.fn.offset ) {
	QUnit.test( "percentage properties for left and top should be transformed to pixels, see #9505", function( assert ) {
		assert.expect( 2 );
		var parent = jQuery( "<div style='position:relative;width:200px;height:200px;margin:0;padding:0;border-width:0'></div>" ).appendTo( "#qunit-fixture" ),
			div = jQuery( "<div style='position: absolute; width: 20px; height: 20px; top:50%; left:50%'></div>" ).appendTo( parent );

		assert.equal( div.css( "top" ), "100px", "position properties not transformed to pixels, see #9505" );
		assert.equal( div.css( "left" ), "100px", "position properties not transformed to pixels, see #9505" );
	} );
}

QUnit.test( "Do not append px (#9548, #12990, #2792)", function( assert ) {
	assert.expect( 4 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -1335,16 +1335,16 @@ QUnit.test( "Append px to whitelisted properties", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	$div.css( "letter-spacing", "2px" );
	$div.css( "letter-spacing", 3 );
	assert.equal( $div.css( "letter-spacing" ), "2px", "Do not append px to 'letter-spacing'" );
} );

QUnit.test( "Append px to whitelisted properties", function( assert ) {
	var prop,
		$div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		whitelist = {
			margin: "marginTop",
			marginTop: undefined,
			marginRight: undefined,
			marginBottom: undefined,
			marginLeft: undefined,
			padding: "paddingTop",
			paddingTop: undefined,
			paddingRight: undefined,
			paddingBottom: undefined,
			paddingLeft: undefined,
			top: undefined,
			right: undefined,
			bottom: undefined,
			left: undefined,
			width: undefined,
			height: undefined,
			minWidth: undefined,
			minHeight: undefined,
			maxWidth: undefined,
			maxHeight: undefined,
			border: "borderTopWidth",
			borderWidth: "borderTopWidth",
			borderTop: "borderTopWidth",
			borderTopWidth: undefined,
			borderRight: "borderRightWidth",
			borderRightWidth: undefined,
			borderBottom: "borderBottomWidth",
			borderBottomWidth: undefined,
			borderLeft: "borderLeftWidth",
			borderLeftWidth: undefined
		};

	assert.expect( ( Object.keys( whitelist ).length ) * 2 );

	for ( prop in whitelist ) {
		var propToCheck = whitelist[ prop ] || prop,
			kebabProp = prop.replace( /[A-Z]/g, function( match ) {
				return "-" + match.toLowerCase();
			} ),
			kebabPropToCheck = propToCheck.replace( /[A-Z]/g, function( match ) {
				return "-" + match.toLowerCase();
			} );
		$div.css( prop, 3 )
			.css( "position", "absolute" )
			.css( "border-style", "solid" );
		assert.equal( $div.css( propToCheck ), "3px", "Append px to '" + prop + "'" );
		$div.css( kebabProp, 3 )
			.css( "position", "absolute" )
			.css( "border-style", "solid" );
		assert.equal( $div.css( kebabPropToCheck ), "3px", "Append px to '" + kebabProp + "'" );
	}
} );

QUnit.test( "css('width') and css('height') should respect box-sizing, see #11004", function( assert ) {
	assert.expect( 4 );

	var el_dis = jQuery( "<div style='width:300px;height:300px;margin:2px;padding:2px;box-sizing:border-box;'>test</div>" ),
		el = el_dis.clone().appendTo( "#qunit-fixture" );

	assert.equal( el.css( "width" ), el.css( "width", el.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "width" ), el_dis.css( "width", el_dis.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing for disconnected element, see #11004" );
	assert.equal( el.css( "height" ), el.css( "height", el.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "height" ), el_dis.css( "height", el_dis.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing for disconnected element, see #11004" );
} );

QUnit.test( "table rows width/height should be unaffected by inline styles", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1368,7 +1368,7 @@ QUnit.test( "table rows width/height should be unaffected by inline styles", fun
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	assert.equal( el_dis.css( "width" ), el_dis.css( "width", el_dis.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing for disconnected element, see #11004" );
	assert.equal( el.css( "height" ), el.css( "height", el.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "height" ), el_dis.css( "height", el_dis.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing for disconnected element, see #11004" );
} );

QUnit.test( "table rows width/height should be unaffected by inline styles", function( assert ) {
	assert.expect( 2 );

	var table = jQuery(
		"<table>\n" +
		"  <tr id=\"row\" style=\"height: 1px; width: 1px;\">\n" +
		"    <td>\n" +
		"      <div style=\"height: 100px; width: 100px;\"></div>\n" +
		"    </div>\n" +
		"  </tr>\n" +
		"</table>"
	);
	var tr = table.find( "tr" );

	table.appendTo( "#qunit-fixture" );

	assert.ok( parseInt( tr.css( "width" ) ) > 10, "tr width unaffected by inline style" );
	assert.ok( parseInt( tr.css( "height" ) ) > 10, "tr height unaffected by inline style" );
} );

testIframe(
	"css('width') should work correctly before document ready (#14084)",
	"css/cssWidthBeforeDocReady.html",
	function( assert, jQuery, window, document, cssWidthBeforeDocReady ) {
		assert.expect( 1 );
		assert.strictEqual( cssWidthBeforeDocReady, "100px", "elem.css('width') works correctly before document ready" );
diff --git a/a.js b/b.js
@@ -1409,13 +1409,13 @@ function( assert, jQuery, window, document, widthBeforeSet, widthAfterSet ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
);

testIframe(
	"css('width') should work correctly with browser zooming",
	"css/cssWidthBrowserZoom.html",
	function( assert, jQuery, window, document, widthBeforeSet, widthAfterSet ) {
		assert.expect( 2 );
		assert.strictEqual( widthBeforeSet, "100px", "elem.css('width') works correctly with browser zoom" );
		assert.strictEqual( widthAfterSet, "100px", "elem.css('width', val) works correctly with browser zoom" );
	}
);

QUnit.testUnlessIE( "css('width') and css('height') should return fractional values for nodes in the document", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "<div class='test-div'></div>" ).appendTo( "#qunit-fixture" );
	jQuery( "<style>.test-div { width: 33.3px; height: 88.8px; }</style>" ).appendTo( "#qunit-fixture" );

	assert.equal( Number( el.css( "width" ).replace( /px$/, "" ) ).toFixed( 1 ), "33.3",
		"css('width') should return fractional values" );
	assert.equal( Number( el.css( "height" ).replace( /px$/, "" ) ).toFixed( 1 ), "88.8",
		"css('height') should return fractional values" );
} );

QUnit.testUnlessIE( "css('width') and css('height') should return fractional values for disconnected nodes", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "<div style='width: 33.3px; height: 88.8px;'></div>" );

	assert.equal( Number( el.css( "width" ).replace( /px$/, "" ) ).toFixed( 1 ), "33.3",
		"css('width') should return fractional values" );
	assert.equal( Number( el.css( "height" ).replace( /px$/, "" ) ).toFixed( 1 ), "88.8",
		"css('height') should return fractional values" );
} );

QUnit.test( "certain css values of 'normal' should be convertable to a number, see #8627", function( assert ) {
	assert.expect( 3 );

	var el = jQuery( "<div style='letter-spacing:normal;font-weight:normal;'>test</div>" ).appendTo( "#qunit-fixture" );

	assert.ok( !isNaN( parseFloat( el.css( "letterSpacing" ) ) ), "css('letterSpacing') not convertable to number, see #8627" );
	assert.ok( !isNaN( parseFloat( el.css( "fontWeight" ) ) ), "css('fontWeight') not convertable to number, see #8627" );
	assert.equal( typeof el.css( "fontWeight" ), "string", ".css() returns a string" );
} );

QUnit.test( "cssHooks - expand", function( assert ) {
diff --git a/a.js b/b.js
@@ -1459,7 +1459,7 @@ QUnit.test( "cssHooks - expand", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
	assert.ok( !isNaN( parseFloat( el.css( "letterSpacing" ) ) ), "css('letterSpacing') not convertable to number, see #8627" );
	assert.ok( !isNaN( parseFloat( el.css( "fontWeight" ) ) ), "css('fontWeight') not convertable to number, see #8627" );
	assert.equal( typeof el.css( "fontWeight" ), "string", ".css() returns a string" );
} );

QUnit.test( "cssHooks - expand", function( assert ) {
	assert.expect( 15 );
	var result,
		properties = {
			margin: [ "marginTop", "marginRight", "marginBottom", "marginLeft" ],
			borderWidth: [ "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth" ],
			padding: [ "paddingTop", "paddingRight", "paddingBottom", "paddingLeft" ]
		};

	jQuery.each( properties, function( property, keys ) {
		var hook = jQuery.cssHooks[ property ],
			expected = {};
		jQuery.each( keys, function( _, key ) {
			expected[ key ] = 10;
		} );
		result = hook.expand( 10 );
		assert.deepEqual( result, expected, property + " expands properly with a number" );

		jQuery.each( keys, function( _, key ) {
			expected[ key ] = "10px";
		} );
		result = hook.expand( "10px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px'" );

		expected[ keys[ 1 ] ] = expected[ keys[ 3 ] ] = "20px";
		result = hook.expand( "10px 20px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px'" );

		expected[ keys[ 2 ] ] = "30px";
		result = hook.expand( "10px 20px 30px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px 30px'" );

		expected[ keys[ 3 ] ] = "40px";
		result = hook.expand( "10px 20px 30px 40px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px 30px 40px'" );

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -1487,8 +1487,8 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
diff --git a/a.js b/b.js
@@ -1507,9 +1507,9 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( "display", "block" );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );

	assert.ok( jQuery( "#siblingspan" ).is( ":visible" ), "Span with no content is visible" );
	$div = jQuery( "<div><span></span></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( $div.find( ":visible" ).length, 1, "Span with no content is visible" );
	$div.css( { width: 0, height: 0, overflow: "hidden" } );
	assert.ok( $div.is( ":visible" ), "Div with width and height of 0 is still visible (gh-2227)" );

	$br = jQuery( "<br/>" ).appendTo( "#qunit-fixture" );
	assert.ok( $br.is( ":visible" ), "br element is visible" );

	$table = jQuery( "#table" );
	$table.html( "<tr><td style='display:none'>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 1, "hidden cell is not perceived as visible (#4512). Works on table elements" );
	$table.css( "display", "none" ).html( "<tr><td>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 0, "hidden cell children not perceived as visible (#4512)" );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Is Visible", "#qunit-fixture div:visible:lt(2)", [ "foo", "nothiddendiv" ] );
	} else {
diff --git a/a.js b/b.js
@@ -1524,7 +1524,7 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( "display", "block" );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );

	assert.ok( jQuery( "#siblingspan" ).is( ":visible" ), "Span with no content is visible" );
	$div = jQuery( "<div><span></span></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( $div.find( ":visible" ).length, 1, "Span with no content is visible" );
	$div.css( { width: 0, height: 0, overflow: "hidden" } );
	assert.ok( $div.is( ":visible" ), "Div with width and height of 0 is still visible (gh-2227)" );

	$br = jQuery( "<br/>" ).appendTo( "#qunit-fixture" );
	assert.ok( $br.is( ":visible" ), "br element is visible" );

	$table = jQuery( "#table" );
	$table.html( "<tr><td style='display:none'>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 1, "hidden cell is not perceived as visible (#4512). Works on table elements" );
	$table.css( "display", "none" ).html( "<tr><td>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 0, "hidden cell children not perceived as visible (#4512)" );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Is Visible", "#qunit-fixture div:visible:lt(2)", [ "foo", "nothiddendiv" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Is Not Hidden", "#qunit-fixture:hidden", [] );
	assert.t( "Is Hidden", "#form input:hidden", [ "hidden1", "hidden2" ] );

	$a = jQuery( "<a href='#'><h1>Header</h1></a>" ).appendTo( "#qunit-fixture" );
	assert.ok( $a.is( ":visible" ), "Anchor tag with flow content is visible (gh-2227)" );
} );

QUnit.test( "Keep the last style if the new one isn't recognized by the browser (#14836)", function( assert ) {
	assert.expect( 1 );

	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", "fake value" );
	assert.equal( el.css( "position" ), "absolute", "The old style is kept when setting an unrecognized value" );
diff --git a/a.js b/b.js
@@ -1551,7 +1551,7 @@ QUnit.test( "Reset the style if set to an empty string", function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", " " );
	assert.equal( el.css( "position" ), "absolute", "The old style is kept when setting to a space" );
} );

QUnit.test( "Reset the style if set to an empty string", function( assert ) {
	assert.expect( 1 );
	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", "" );

	// Some browsers return an empty string; others "static". Both those cases mean the style
	// was reset successfully so accept them both.
	assert.equal( el.css( "position" ) || "static", "static",
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
diff --git a/a.js b/b.js
@@ -1626,7 +1626,7 @@ function( assert ) {
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
				name: "backgroundAttachment",
				value: [ "fixed" ]
			}, {
				name: "backgroundColor",
				value: [ "rgb(255, 0, 0)", "rgb(255,0,0)", "#ff0000" ]
			}, {

				// Firefox returns auto's value
				name: "backgroundImage",
				value: [ "url('test.png')", "url(" + baseURL + "test.png)", "url(\"" + baseURL + "test.png\")" ]
			}, {
				name: "backgroundPosition",
				value: [ "5% 5%" ]
			}, {

				// Firefox returns no-repeat
				name: "backgroundRepeat",
				value: [ "repeat-y" ]
			}, {
				name: "backgroundClip",
				value: [ "padding-box" ]
			}, {
				name: "backgroundOrigin",
				value: [ "content-box" ]
			}, {
				name: "backgroundSize",
				value: [ "80px 60px" ]
		} ];

		jQuery.each( styles, function( index, style ) {
			var $clone, $clonedChildren,
				$source = jQuery( "#firstp" ),
				source = $source[ 0 ],
				$children = $source.children();

			if ( source.style[ style.name ] === undefined ) {
				assert.ok( true, style.name +  ": style isn't supported and therefore not an issue" );
				assert.ok( true );

				return true;
			}

			$source.css( style.name, style.value[ 0 ] );
			$children.css( style.name, style.value[ 0 ] );

			$clone = $source.clone();
			$clonedChildren = $clone.children();

			$clone.css( style.name, "" );
			$clonedChildren.css( style.name, "" );

			window.setTimeout( function() {
				assert.notEqual( $clone.css( style.name ), style.value[ 0 ], "Cloned css was changed" );

				assert.ok( jQuery.inArray( $source.css( style.name ) !== -1, style.value ),
					"Clearing clone.css() doesn't affect source.css(): " + style.name +
					"; result: " + $source.css( style.name ) +
					"; expected: " + style.value.join( "," ) );

				assert.ok( jQuery.inArray( $children.css( style.name ) !== -1, style.value ),
					"Clearing clonedChildren.css() doesn't affect children.css(): " + style.name +
					"; result: " + $children.css( style.name ) +
					"; expected: " + style.value.join( "," ) );
			}, 100 );
		} );

		window.setTimeout( done, 1000 );
	}
);

QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert ) {
	assert.expect( 1 );

	var $elem = jQuery( "<div></div>" );

diff --git a/a.js b/b.js
@@ -1635,7 +1635,7 @@ QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0

		window.setTimeout( done, 1000 );
	}
);

QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert ) {
	assert.expect( 1 );

	var $elem = jQuery( "<div></div>" );

	$elem.css( "order", 2 );
	assert.equal( $elem.css( "order" ), "2", "2 on order" );
} );

QUnit.test( "Do not throw on frame elements from css method (#15098)", function( assert ) {
	assert.expect( 1 );

	var frameWin, frameDoc,
		frameElement = document.createElement( "iframe" ),
diff --git a/a.js b/b.js
@@ -1738,9 +1738,16 @@ jQuery( "#qunit-fixture" ).append(
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
} )();

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "css(--customProperty)", function( assert ) {

	jQuery( "#qunit-fixture" ).append(
		"<style>\n" +
		"    .test__customProperties {\n" +
		"        --prop1:val1;\n" +
		"        --prop2: val2;\n" +
		"        --prop3:val3 ;\n" +
		"        --prop4:\"val4\";\n" +
		"        --prop5:'val5';\n" +
		"    }\n" +
		"</style>"
	);

diff --git a/a.js b/b.js
@@ -1749,7 +1756,7 @@ jQuery( "#qunit-fixture" ).append(
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
} )();

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "css(--customProperty)", function( assert ) {

	jQuery( "#qunit-fixture" ).append(
		"<style>\n" +
		"    .test__customProperties {\n" +
		"        --prop1:val1;\n" +
		"        --prop2: val2;\n" +
		"        --prop3:val3 ;\n" +
		"        --prop4:\"val4\";\n" +
		"        --prop5:'val5';\n" +
		"    }\n" +
		"</style>"
	);

	var div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		$elem = jQuery( "<div>" ).addClass( "test__customProperties" )
			.appendTo( "#qunit-fixture" ),
		webkitOrBlink = /\bsafari\b/i.test( navigator.userAgent ),
		expected = 10;

	if ( webkitOrBlink ) {
		expected -= 2;
	}
diff --git a/a.js b/b.js
@@ -1777,16 +1784,24 @@ jQuery( "#qunit-fixture" ).append(
A blob:8ade482ffa29182616e290fd6d8b2bf3d6fda4e0
} )();

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "css(--customProperty)", function( assert ) {

	jQuery( "#qunit-fixture" ).append(
		"<style>\n" +
		"    .test__customProperties {\n" +
		"        --prop1:val1;\n" +
		"        --prop2: val2;\n" +
		"        --prop3:val3 ;\n" +
		"        --prop4:\"val4\";\n" +
		"        --prop5:'val5';\n" +
		"    }\n" +
		"</style>"
	);

	var div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		$elem = jQuery( "<div>" ).addClass( "test__customProperties" )
			.appendTo( "#qunit-fixture" ),
		webkitOrBlink = /\bsafari\b/i.test( navigator.userAgent ),
		expected = 10;

	if ( webkitOrBlink ) {
		expected -= 2;
	}
	assert.expect( expected );

	div.css( "--color", "blue" );
	assert.equal( div.css( "--color" ), "blue", "Modified CSS custom property using string" );

	div.css( "--color", "yellow" );
	assert.equal( div.css( "--color" ), "yellow", "Overwrite CSS custom property" );

	div.css( { "--color": "red" } );
	assert.equal( div.css( "--color" ), "red", "Modified CSS custom property using object" );

	div.css( { "--mixedCase": "green" } );
	div.css( { "--mixed-case": "red" } );
	assert.equal( div.css( "--mixedCase" ), "green",
		"Modified CSS custom property with mixed case" );

	div.css( { "--theme-dark": "purple" } );
	div.css( { "--themeDark": "red" } );
	assert.equal( div.css( "--theme-dark" ), "purple",
		"Modified CSS custom property with dashed name" );

	assert.equal( $elem.css( "--prop1" ), "val1", "Basic CSS custom property" );

	assert.equal( $elem.css( "--prop2" ), " val2", "Preceding whitespace maintained" );
	assert.equal( $elem.css( "--prop3" ), "val3 ", "Following whitespace maintained" );

	// Support: Chrome <=49 - 73+, Safari <=9.1 - 12.1+
	// Chrome treats single quotes as double ones.
	// Safari treats double quotes as single ones.
	if ( !webkitOrBlink ) {
		assert.equal( $elem.css( "--prop4" ), "\"val4\"", "Works with double quotes" );
		assert.equal( $elem.css( "--prop5" ), "'val5'", "Works with single quotes" );
	}
} );

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "Don't append px to CSS vars", function( assert ) {
diff --git a/a.js b/b.js
@@ -25,9 +25,7 @@
A blob:f86bd9ab0c70dc5d31c97d6deb683887661b3db4
import "./selector.js";
import "./event.js";

var

	// Support: IE <=10 - 11+
	// In IE using regex groups here causes severe slowdowns.
	rnoInnerhtml = /<script|<style|<link/i,

	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
diff --git a/a.js b/b.js
@@ -122,7 +120,7 @@ function domManip( collection, args, callback, ignored ) {
A blob:f86bd9ab0c70dc5d31c97d6deb683887661b3db4

		dataUser.set( dest, udataCur );
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = typeof value === "function";

	if ( valueIsFunction ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			args[ 0 ] = value.call( this, index, self.html() );
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
diff --git a/a.js b/b.js
@@ -161,7 +159,7 @@ function domManip( collection, args, callback, ignored ) {
A blob:f86bd9ab0c70dc5d31c97d6deb683887661b3db4

		dataUser.set( dest, udataCur );
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = typeof value === "function";

	if ( valueIsFunction ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			args[ 0 ] = value.call( this, index, self.html() );
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce,
									crossOrigin: node.crossOrigin
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
diff --git a/a.js b/b.js
@@ -39,9 +39,9 @@ QUnit.test( "text()", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	functionReturningObj( value );
		Returns a function that returns the value
*/

QUnit.test( "text()", function( assert ) {

	assert.expect( 5 );

	var expected, frag, $newLineTest;

	expected = "This link has class=\"blog\": Simon Willison's Weblog";
	assert.equal( jQuery( "#sap" ).text(), expected, "Check for merged text of more then one element." );

	// Check serialization of text values
	assert.equal( jQuery( document.createTextNode( "foo" ) ).text(), "foo", "Text node was retrieved from .text()." );
	assert.notEqual( jQuery( document ).text(), "", "Retrieving text for the document retrieves all text (#10724)." );

	// Retrieve from document fragments #10864
	frag = document.createDocumentFragment();
	frag.appendChild( document.createTextNode( "foo" ) );

	assert.equal( jQuery( frag ).text(), "foo", "Document Fragment Text node was retrieved from .text()." );
diff --git a/a.js b/b.js
@@ -49,7 +49,7 @@ QUnit.test( "text()", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	functionReturningObj( value );
		Returns a function that returns the value
*/

QUnit.test( "text()", function( assert ) {

	assert.expect( 5 );

	var expected, frag, $newLineTest;

	expected = "This link has class=\"blog\": Simon Willison's Weblog";
	assert.equal( jQuery( "#sap" ).text(), expected, "Check for merged text of more then one element." );

	// Check serialization of text values
	assert.equal( jQuery( document.createTextNode( "foo" ) ).text(), "foo", "Text node was retrieved from .text()." );
	assert.notEqual( jQuery( document ).text(), "", "Retrieving text for the document retrieves all text (#10724)." );

	// Retrieve from document fragments #10864
	frag = document.createDocumentFragment();
	frag.appendChild( document.createTextNode( "foo" ) );

	assert.equal( jQuery( frag ).text(), "foo", "Document Fragment Text node was retrieved from .text()." );

	$newLineTest = jQuery( "<div>test<br/>testy</div>" ).appendTo( "#moretests" );
	$newLineTest.find( "br" ).replaceWith( "\n" );
	assert.equal( $newLineTest.text(), "test\ntesty", "text() does not remove new lines (#11153)" );

	$newLineTest.remove();
} );

diff --git a/a.js b/b.js
@@ -58,7 +58,7 @@ QUnit.test( "text(undefined)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.equal( $newLineTest.text(), "test\ntesty", "text() does not remove new lines (#11153)" );

	$newLineTest.remove();
} );

QUnit.test( "text(undefined)", function( assert ) {

	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).text( "<div" ).text( undefined )[ 0 ].innerHTML, "&lt;div", ".text(undefined) is chainable (#5571)" );
} );

function testText( valueObj, assert ) {

diff --git a/a.js b/b.js
@@ -78,16 +78,16 @@ function testText( valueObj, assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).text( "<div" ).text( undefined )[ 0 ].innerHTML, "&lt;div", ".text(undefined) is chainable (#5571)" );
} );

function testText( valueObj, assert ) {

	assert.expect( 6 );

	var val, j, expected, $multipleElements, $parentDiv, $childDiv;

	val = valueObj( "<div><b>Hello</b> cruel world!</div>" );
	assert.equal( jQuery( "#foo" ).text( val )[ 0 ].innerHTML.replace( />/g, "&gt;" ), "&lt;div&gt;&lt;b&gt;Hello&lt;/b&gt; cruel world!&lt;/div&gt;", "Check escaped text" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
	j.text( valueObj( "hi!" ) );
	assert.equal( jQuery( j[ 0 ] ).text(), "hi!", "Check node,textnode,comment with text()" );
	assert.equal( j[ 1 ].nodeValue, " there ", "Check node,textnode,comment with text()" );

	assert.equal( j[ 2 ].nodeType, 8, "Check node,textnode,comment with text()" );

	// Update multiple elements #11809
	expected = "New";

	$multipleElements = jQuery( "<div>Hello</div>" ).add( "<div>World</div>" );
	$multipleElements.text( expected );

	assert.equal( $multipleElements.eq( 0 ).text(), expected, "text() updates multiple elements (#11809)" );
	assert.equal( $multipleElements.eq( 1 ).text(), expected, "text() updates multiple elements (#11809)" );

	// Prevent memory leaks #11809
	$childDiv = jQuery( "<div></div>" );
	$childDiv.data( "leak", true );
	$parentDiv = jQuery( "<div></div>" );
	$parentDiv.append( $childDiv );
diff --git a/a.js b/b.js
@@ -187,7 +187,7 @@ function testAppendForObject( valueObj, isFragment, assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	} );

	assert.equal( jQuery( "#sap" ).text(), "foobar", "Check for merged text of more then one element." );
} );

function testAppendForObject( valueObj, isFragment, assert ) {
	var $base,
		type = isFragment ? " (DocumentFragment)" : " (Element)",
		text = "This link has class=\"blog\": Simon Willison's Weblog",
		el = document.getElementById( "sap" ).cloneNode( true ),
		first = document.getElementById( "first" ),
		yahoo = document.getElementById( "yahoo" );

	if ( isFragment ) {
		$base = document.createDocumentFragment();
		jQuery( el ).contents().each( function() {
			$base.appendChild( this );
		} );
		$base = jQuery( $base );
	} else {
		$base = jQuery( el );
	}

	assert.equal( $base.clone().append( valueObj( first.cloneNode( true ) ) ).text(),
		text + "Try them out:",
		"Check for appending of element" + type
	);

	assert.equal( $base.clone().append( valueObj( [ first.cloneNode( true ), yahoo.cloneNode( true ) ] ) ).text(),
		text + "Try them out:Yahoo",
		"Check for appending of array of elements" + type
	);

	assert.equal( $base.clone().append( valueObj( jQuery( "#yahoo, #first" ).clone() ) ).text(),
		text + "YahooTry them out:",
		"Check for appending of jQuery object" + type
	);

	assert.equal( $base.clone().append( valueObj( 5 ) ).text(),
		text + "5",
		"Check for appending a number" + type
	);

	assert.equal( $base.clone().append( valueObj( [ jQuery( "#first" ).clone(), jQuery( "#yahoo, #google" ).clone() ] ) ).text(),
		text + "Try them out:GoogleYahoo",
		"Check for appending of array of jQuery objects"
	);

	assert.equal( $base.clone().append( valueObj( " text with spaces " ) ).text(),
		text + " text with spaces ",
		"Check for appending text with spaces" + type
	);

	assert.equal( $base.clone().append( valueObj( [] ) ).text(),
		text,
		"Check for appending an empty array" + type
	);

	assert.equal( $base.clone().append( valueObj( "" ) ).text(),
		text,
		"Check for appending an empty string" + type
	);

	assert.equal( $base.clone().append( valueObj( document.getElementsByTagName( "foo" ) ) ).text(),
		text,
		"Check for appending an empty nodelist" + type
	);

	assert.equal( $base.clone().append( "<span></span>", "<span></span>", "<span></span>" ).children().length,
		$base.children().length + 3,
		"Make sure that multiple arguments works." + type
	);

	assert.equal( $base.clone().append( valueObj( document.getElementById( "form" ).cloneNode( true ) ) ).children( "form" ).length,
		1,
		"Check for appending a form (#910)" + type
	);
}

function testAppend( valueObj, assert ) {
diff --git a/a.js b/b.js
@@ -272,7 +272,7 @@ jQuery( "#form" )
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	} );

	jQuery( "#table colgroup" ).append( valueObj( "<col></col>" ) );
	assert.equal( jQuery( "#table colgroup col" ).length, 1, "Append col" );

	jQuery( "#form" )
		.append( valueObj( "<select id='appendSelect1'></select>" ) )
		.append( valueObj( "<select id='appendSelect2'><option>Test</option></select>" ) );
	assert.t( "Append Select", "#appendSelect1, #appendSelect2", [ "appendSelect1", "appendSelect2" ] );

	assert.equal( "Two nodes", jQuery( "<div></div>" ).append( "Two", " nodes" ).text(), "Appending two text nodes (#4011)" );
	assert.equal( jQuery( "<div></div>" ).append( "1", "", 3 ).text(), "13", "If median is false-like value, subsequent arguments should not be ignored" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
diff --git a/a.js b/b.js
@@ -310,7 +310,7 @@ QUnit.test( "append(Function)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

QUnit.test( "append(String|Element|Array<Element>|jQuery)", function( assert ) {
	testAppend( manipulationBareObj, assert );
} );

QUnit.test( "append(Function)", function( assert ) {
	testAppend( manipulationFunctionReturningObj, assert );
} );

QUnit.test( "append(param) to object, see #11280", function( assert ) {

	assert.expect( 5 );

	var object = jQuery( document.createElement( "object" ) ).appendTo( document.body );
diff --git a/a.js b/b.js
@@ -402,7 +402,7 @@ jQuery( "#sap" ).append( function( i, val ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
QUnit.test( "append(Function) returns Number", function( assert ) {

	assert.expect( 2 );
	var old = jQuery( "#sap" ).html();

	jQuery( "#sap" ).append( function( i, val ) {
		assert.equal( val, old, "Make sure the incoming value is correct." );
		return 5;
	} );
	assert.ok( jQuery( "#sap" )[ 0 ].innerHTML.match( /5$/ ), "Check for appending a number" );
} );

QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {

	assert.expect( 5 );

	var xmlDoc1 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state x='100' y='100' initial='actions' id='provisioning'></state><state x='100' y='100' id='error'></state><state x='100' y='100' id='finished' final='true'></state></scxml>" ),
diff --git a/a.js b/b.js
@@ -430,7 +430,7 @@ QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		return 5;
	} );
	assert.ok( jQuery( "#sap" )[ 0 ].innerHTML.match( /5$/ ), "Check for appending a number" );
} );

QUnit.test( "XML DOM manipulation (#9960)", function( assert ) {

	assert.expect( 5 );

	var xmlDoc1 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state x='100' y='100' initial='actions' id='provisioning'></state><state x='100' y='100' id='error'></state><state x='100' y='100' id='finished' final='true'></state></scxml>" ),
		xmlDoc2 = jQuery.parseXML( "<scxml xmlns='http://www.w3.org/2005/07/scxml' version='1.0'><state id='provisioning3'></state></scxml>" ),
		xml1 = jQuery( xmlDoc1 ),
		xml2 = jQuery( xmlDoc2 ),
		scxml1 = jQuery( "scxml", xml1 ),
		scxml2 = jQuery( "scxml", xml2 ),
		state = scxml2.find( "state" );

	scxml1.append( state );
	assert.strictEqual( scxml1[ 0 ].lastChild, state[ 0 ], "append" );

	scxml1.prepend( state );
	assert.strictEqual( scxml1[ 0 ].firstChild, state[ 0 ], "prepend" );

	scxml1.find( "#finished" ).after( state );
	assert.strictEqual( scxml1[ 0 ].lastChild, state[ 0 ], "after" );

	scxml1.find( "#provisioning" ).before( state );
	assert.strictEqual( scxml1[ 0 ].firstChild, state[ 0 ], "before" );

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;
diff --git a/a.js b/b.js
@@ -445,7 +445,7 @@ QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;

	jQuery( "#qunit-fixture" ).append( "<article style='font-size:10px'><section><aside>HTML5 elements</aside></section></article>" );

	article = jQuery( "article" );
	aside = jQuery( "aside" );

	assert.equal( article.get( 0 ).style.fontSize, "10px", "HTML5 elements are styleable" );
	assert.equal( aside.length, 1, "HTML5 elements do not collapse their children" );
} );

QUnit[ jQuery.fn.css ? "test" : "skip" ]( "HTML5 Elements inherit styles from style rules (Bug #10501)", function( assert ) {

	assert.expect( 1 );

	jQuery( "#qunit-fixture" ).append( "<article id='article'></article>" );
diff --git a/a.js b/b.js
@@ -456,7 +456,7 @@ QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	scxml2.replaceWith( scxml1 );
	assert.deepEqual( jQuery( "state", xml2 ).get(), scxml1.find( "state" ).get(), "replaceWith" );
} );

QUnit.test( "append HTML5 sectioning elements (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	var article, aside;

	jQuery( "#qunit-fixture" ).append( "<article style='font-size:10px'><section><aside>HTML5 elements</aside></section></article>" );

	article = jQuery( "article" );
	aside = jQuery( "aside" );

	assert.equal( article.get( 0 ).style.fontSize, "10px", "HTML5 elements are styleable" );
	assert.equal( aside.length, 1, "HTML5 elements do not collapse their children" );
} );

QUnit[ jQuery.fn.css ? "test" : "skip" ]( "HTML5 Elements inherit styles from style rules (Bug #10501)", function( assert ) {

	assert.expect( 1 );

	jQuery( "#qunit-fixture" ).append( "<article id='article'></article>" );
	jQuery( "#article" ).append( "<section>This section should have a pink background.</section>" );

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
diff --git a/a.js b/b.js
@@ -465,7 +465,7 @@ QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	// In IE, the missing background color will claim its value is "transparent"
	assert.notEqual( jQuery( "section" ).css( "background-color" ), "transparent", "HTML5 elements inherit styles" );
} );

QUnit.test( "html(String) with HTML5 (Bug #6485)", function( assert ) {

	assert.expect( 2 );

	jQuery( "#qunit-fixture" ).html( "<article><section><aside>HTML5 elements</aside></section></article>" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().length, 1, "Make sure HTML5 article elements can hold children. innerHTML shortcut path" );
	assert.equal( jQuery( "#qunit-fixture" ).children().children().children().length, 1, "Make sure nested HTML5 elements can hold children." );
} );

QUnit.test( "html(String) tag-hyphenated elements (Bug #1987)", function( assert ) {

	assert.expect( 27 );

	jQuery.each( "thead tbody tfoot colgroup caption tr th td".split( " " ), function( i, name ) {
diff --git a/a.js b/b.js
@@ -561,7 +561,7 @@ QUnit.test( "IE8 serialization bug", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		assert.equal( child.nodeName.toUpperCase(), "DIV",
			method + "(): Self-closing tag name terminated by " + description );
	}
} );

QUnit.test( "IE8 serialization bug", function( assert ) {

	assert.expect( 2 );
	var wrapper = jQuery( "<div></div>" );

	wrapper.html( "<div></div><article></article>" );
	assert.equal( wrapper.children( "article" ).length, 1, "HTML5 elements are insertable with .html()" );

	wrapper.html( "<div></div><link></link>" );
	assert.equal( wrapper.children( "link" ).length, 1, "Link elements are insertable with .html()" );
} );

QUnit.test( "html() object element #10324", function( assert ) {

	assert.expect( 1 );

	var object = jQuery( "<object id='object2'><param name='object2test' value='test'></param></object>?" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -959,7 +959,7 @@ QUnit.test( "before(no-op)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	expected = "This is a normal link: Try them out:GooglediveintomarkYahoo";
	jQuery( "#yahoo" ).before( manipulationFunctionReturningObj( [ jQuery( "#first" ), jQuery( "#mark, #google" ) ] ) );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert array of jQuery objects before" );
} );

QUnit.test( "before(no-op)", function( assert ) {

	assert.expect( 2 );

	var set;
	set = jQuery( "<div></div>" ).before( "<span>test</span>" );
	assert.equal( set[ 0 ].nodeName.toLowerCase(), "div", "Insert before a disconnected node should be a no-op" );
	assert.equal( set.length, 1, "Insert the element before the disconnected node. should be a no-op" );
} );

QUnit.test( "before and after w/ empty object (#10812)", function( assert ) {

	assert.expect( 1 );

	var res;
diff --git a/a.js b/b.js
@@ -1195,7 +1195,7 @@ function testReplaceWith( val, assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
diff --git a/a.js b/b.js
@@ -1208,7 +1208,7 @@ function testReplaceWith( val, assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with array of elements" );
	assert.ok( !jQuery( "#google" )[ 0 ], "Verify that original element is gone, after array of elements" );

	jQuery( "#groups" ).replaceWith( val( jQuery( "#mark, #first" ) ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with jQuery collection" );
	assert.ok( !jQuery( "#groups" )[ 0 ], "Verify that original element is gone, after jQuery collection" );

	jQuery( "#mark, #first" ).replaceWith( val( "<span class='replacement'></span><span class='replacement'></span>" ) );
	assert.equal( jQuery( "#qunit-fixture .replacement" ).length, 4, "Replace multiple elements (#12449)" );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), [], "Verify that original elements are gone, after replace multiple" );

	tmp = jQuery( "<b>content</b>" )[ 0 ];
	jQuery( "#anchor1" ).contents().replaceWith( val( tmp ) );
diff --git a/a.js b/b.js
@@ -1256,7 +1256,7 @@ function testReplaceWith( val, assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	var expected = "This is a normal link: YahoodiveintomarkTry them out:";
	jQuery( "#mark, #first" ).insertAfter( "#yahoo" );
	assert.equal( jQuery( "#en" ).text(), expected, "Insert jQuery after" );
} );

function testReplaceWith( val, assert ) {

	var tmp, y, child, child2, set, nonExistent, $div,
		expected = 29;

	assert.expect( expected );

	jQuery( "#yahoo" ).replaceWith( val( "<b id='replace'>buga</b>" ) );
	assert.ok( jQuery( "#replace" )[ 0 ], "Replace element with element from string" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after string" );

	jQuery( "#anchor2" ).replaceWith( val( document.getElementById( "first" ) ) );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with element" );
	assert.ok( !jQuery( "#anchor2" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#qunit-fixture" ).append( "<div id='bar'><div id='baz'></div></div>" );
	jQuery( "#baz" ).replaceWith( val( "Baz" ) );
	assert.equal( jQuery( "#bar" ).text(), "Baz", "Replace element with text" );
	assert.ok( !jQuery( "#baz" )[ 0 ], "Verify that original element is gone, after element" );

	jQuery( "#bar" ).replaceWith( "<div id='yahoo'></div>", "...", "<div id='baz'></div>" );
	assert.deepEqual( jQuery( "#yahoo, #baz" ).get(), q( "yahoo", "baz" ),  "Replace element with multiple arguments (#13722)" );
	assert.strictEqual( jQuery( "#yahoo" )[ 0 ].nextSibling, jQuery( "#baz" )[ 0 ].previousSibling, "Argument order preserved" );
	assert.deepEqual( jQuery( "#bar" ).get(), [], "Verify that original element is gone, after multiple arguments" );

	jQuery( "#google" ).replaceWith( val( [ document.getElementById( "first" ), document.getElementById( "mark" ) ] ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with array of elements" );
	assert.ok( !jQuery( "#google" )[ 0 ], "Verify that original element is gone, after array of elements" );

	jQuery( "#groups" ).replaceWith( val( jQuery( "#mark, #first" ) ) );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), q( "first", "mark" ),  "Replace element with jQuery collection" );
	assert.ok( !jQuery( "#groups" )[ 0 ], "Verify that original element is gone, after jQuery collection" );

	jQuery( "#mark, #first" ).replaceWith( val( "<span class='replacement'></span><span class='replacement'></span>" ) );
	assert.equal( jQuery( "#qunit-fixture .replacement" ).length, 4, "Replace multiple elements (#12449)" );
	assert.deepEqual( jQuery( "#mark, #first" ).get(), [], "Verify that original elements are gone, after replace multiple" );

	tmp = jQuery( "<b>content</b>" )[ 0 ];
	jQuery( "#anchor1" ).contents().replaceWith( val( tmp ) );
	assert.deepEqual( jQuery( "#anchor1" ).contents().get(), [ tmp ], "Replace text node with element" );

	tmp = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( true, "Newly bound click run." );
	} );
	y = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( false, "Previously bound click run." );
	} );
	child = y.append( "<b>test</b>" ).find( "b" ).on( "click", function() {
		assert.ok( true, "Child bound click run." );
		return false;
	} );

	y.replaceWith( val( tmp ) );

	tmp.trigger( "click" );
	y.trigger( "click" ); // Shouldn't be run
	child.trigger( "click" ); // Shouldn't be run

	y = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ).on( "click", function() {
		assert.ok( false, "Previously bound click run." );
	} );
	child2 = y.append( "<u>test</u>" ).find( "u" ).on( "click", function() {
		assert.ok( true, "Child 2 bound click run." );
		return false;
	} );

	y.replaceWith( val( child2 ) );

	child2.trigger( "click" );

	set = jQuery( "<div></div>" ).replaceWith( val( "<span>test</span>" ) );
	assert.equal( set[ 0 ].nodeName.toLowerCase(), "div", "No effect on a disconnected node." );
	assert.equal( set.length, 1, "No effect on a disconnected node." );
	assert.equal( set[ 0 ].childNodes.length, 0, "No effect on a disconnected node." );

	child = jQuery( "#qunit-fixture" ).children().first();
	$div = jQuery( "<div class='pathological'></div>" ).insertBefore( child );
	$div.replaceWith( $div );
	assert.deepEqual( jQuery( ".pathological", "#qunit-fixture" ).get(), $div.get(),
		"Self-replacement" );
	$div.replaceWith( child );
	assert.deepEqual( jQuery( "#qunit-fixture" ).children().first().get(), child.get(),
		"Replacement with following sibling (#13810)" );
	assert.deepEqual( jQuery( ".pathological", "#qunit-fixture" ).get(), [],
		"Replacement with following sibling (context removed)" );

	nonExistent = jQuery( "#does-not-exist" ).replaceWith( val( "<b>should not throw an error</b>" ) );
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ QUnit.test( "replaceAll(jQuery)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with array of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with array of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after array of elements" );
} );

QUnit.test( "replaceAll(jQuery)", function( assert ) {

	assert.expect( 3 );

	jQuery( "#mark, #first" ).replaceAll( "#yahoo" );
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with set of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with set of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after set of elements" );
} );

QUnit.test( "jQuery.clone() (#8017)", function( assert ) {

	assert.expect( 2 );

	assert.ok( jQuery.clone && typeof jQuery.clone === "function", "jQuery.clone() utility exists and is a function." );
diff --git a/a.js b/b.js
@@ -1388,7 +1388,7 @@ QUnit.test( "jQuery.clone() (#8017)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.ok( jQuery( "#first" )[ 0 ], "Replace element with set of elements" );
	assert.ok( jQuery( "#mark" )[ 0 ], "Replace element with set of elements" );
	assert.ok( !jQuery( "#yahoo" )[ 0 ], "Verify that original element is gone, after set of elements" );
} );

QUnit.test( "jQuery.clone() (#8017)", function( assert ) {

	assert.expect( 2 );

	assert.ok( jQuery.clone && typeof jQuery.clone === "function", "jQuery.clone() utility exists and is a function." );

	var main = jQuery( "#qunit-fixture" )[ 0 ],
		clone = jQuery.clone( main );

	assert.equal( main.childNodes.length, clone.childNodes.length, "Simple child length to ensure a large dom tree copies correctly" );
} );

QUnit.test( "append to multiple elements (#8070)", function( assert ) {

	assert.expect( 2 );

	var selects = jQuery( "<select class='test8070'></select><select class='test8070'></select>" ).appendTo( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -1543,7 +1543,7 @@ QUnit.test( "clone()", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	height = table[ 0 ].offsetHeight;
	table.prepend( "<tr><td>DATA</td></tr>" );
	assert.ok( table[ 0 ].offsetHeight - height >= 15, "prepended rows are visible" );
} );

QUnit.test( "clone()", function( assert ) {

	assert.expect( 45 );

	var div, clone, form, body;

	assert.equal( jQuery( "#en" ).text(), "This is a normal link: Yahoo", "Assert text for #en" );
	assert.equal( jQuery( "#first" ).append( jQuery( "#yahoo" ).clone() ).text(), "Try them out:Yahoo", "Check for clone" );
	assert.equal( jQuery( "#en" ).text(), "This is a normal link: Yahoo", "Reassert text for #en" );

	jQuery.each( "table thead tbody tfoot tr td div button ul ol li select option textarea iframe".split( " " ), function( i, nodeName ) {
		assert.equal( jQuery( "<" + nodeName + "/>" ).clone()[ 0 ].nodeName.toLowerCase(), nodeName, "Clone a " + nodeName );
	} );
	assert.equal( jQuery( "<input type='checkbox' />" ).clone()[ 0 ].nodeName.toLowerCase(), "input", "Clone a <input type='checkbox' />" );

	// Check cloning non-elements
	assert.equal( jQuery( "#nonnodes" ).contents().clone().length, 3, "Check node,textnode,comment clone works (some browsers delete comments on clone)" );

	// Verify that clones of clones can keep event listeners
	div = jQuery( "<div><ul><li>test</li></ul></div>" ).on( "click", function() {
		assert.ok( true, "Bound event still exists." );
	} );
	clone = div.clone( true ); div.remove();
	div = clone.clone( true ); clone.remove();

	assert.equal( div.length, 1, "One element cloned" );
	assert.equal( div[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	div.trigger( "click" );

	// Manually clean up detached elements
	div.remove();

	// Verify that cloned children can keep event listeners
	div = jQuery( "<div></div>" ).append( [ document.createElement( "table" ), document.createElement( "table" ) ] );
	div.find( "table" ).on( "click", function() {
		assert.ok( true, "Bound event still exists." );
	} );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	clone.find( "table" ).trigger( "click" );

	// Manually clean up detached elements
	div.remove();
	clone.remove();

	// Make sure that doing .clone() doesn't clone event listeners
	div = jQuery( "<div><ul><li>test</li></ul></div>" ).on( "click", function() {
		assert.ok( false, "Bound event still exists after .clone()." );
	} );
	clone = div.clone();

	clone.trigger( "click" );

	// Manually clean up detached elements
	clone.remove();
	div.remove();

	// Test both html() and clone() for <embed> and <object> types
	div = jQuery( "<div></div>" ).html( "<embed height='355' width='425' src='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'></embed>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone.html(), div.html(), "Element contents cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );

	// this is technically an invalid object, but because of the special
	// classid instantiation it is the only kind that IE has trouble with,
	// so let's test with it too.
	div = jQuery( "<div></div>" ).html( "<object height='355' width='425' classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'>  <param name='movie' value='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='wmode' value='transparent'> </object>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );
	div = div.find( "object" );
	clone = clone.find( "object" );

	// oldIE adds extra attributes and <param> elements, so just test for existence of the defined set
	jQuery.each( [ "height", "width", "classid" ], function( i, attr ) {
		assert.equal( clone.attr( attr ), div.attr( attr ), "<object> attribute cloned: " + attr );
	} );
	( function() {
		var params = {};

		clone.find( "param" ).each( function( index, param ) {
			params[ param.attributes.name.nodeValue.toLowerCase() ] =
				param.attributes.value.nodeValue.toLowerCase();
		} );

		div.find( "param" ).each( function( index, param ) {
			var key = param.attributes.name.nodeValue.toLowerCase();
			assert.equal( params[ key ], param.attributes.value.nodeValue.toLowerCase(), "<param> cloned: " + key );
		} );
	} )();

	// and here's a valid one.
	div = jQuery( "<div></div>" ).html( "<object height='355' width='425' type='application/x-shockwave-flash' data='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='movie' value='https://www.youtube.com/v/3KANI2dpXLw&amp;hl=en'>  <param name='wmode' value='transparent'> </object>" );

	clone = div.clone( true );
	assert.equal( clone.length, 1, "One element cloned" );
	assert.equal( clone.html(), div.html(), "Element contents cloned" );
	assert.equal( clone[ 0 ].nodeName.toUpperCase(), "DIV", "DIV element cloned" );

	div = jQuery( "<div></div>" ).data( { "a": true } );
	clone = div.clone( true );
	assert.equal( clone.data( "a" ), true, "Data cloned." );
	clone.data( "a", false );
	assert.equal( clone.data( "a" ), false, "Ensure cloned element data object was correctly modified" );
	assert.equal( div.data( "a" ), true, "Ensure cloned element data object is copied, not referenced" );

	// manually clean up detached elements
	div.remove();
	clone.remove();

	form = document.createElement( "form" );
	form.action = "/test/";

	div = document.createElement( "div" );
	div.appendChild( document.createTextNode( "test" ) );
	form.appendChild( div );

	assert.equal( jQuery( form ).clone().children().length, 1, "Make sure we just get the form back." );

	body = jQuery( "body" ).clone();
	assert.equal( body.children()[ 0 ].id, "qunit", "Make sure cloning body works" );
	body.remove();
} );

QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {

	assert.expect( 3 );

	var src = jQuery( "<script type='text/filler'>Lorem ipsum dolor sit amet</script><q><script type='text/filler'>consectetur adipiscing elit</script></q>" ),
diff --git a/a.js b/b.js
@@ -1556,7 +1556,7 @@ QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	body = jQuery( "body" ).clone();
	assert.equal( body.children()[ 0 ].id, "qunit", "Make sure cloning body works" );
	body.remove();
} );

QUnit.test( "clone(script type=non-javascript) (#11359)", function( assert ) {

	assert.expect( 3 );

	var src = jQuery( "<script type='text/filler'>Lorem ipsum dolor sit amet</script><q><script type='text/filler'>consectetur adipiscing elit</script></q>" ),
		dest = src.clone();

	assert.equal( dest[ 0 ].text, "Lorem ipsum dolor sit amet", "Cloning preserves script text" );
	assert.equal( dest.last().html(), src.last().html(), "Cloning preserves nested script text" );
	assert.ok( /^\s*<scr.pt\s+type=['"]?text\/filler['"]?\s*>consectetur adipiscing elit<\/scr.pt>\s*$/i.test( dest.last().html() ), "Cloning preserves nested script text" );
	dest.remove();
} );

QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {

	assert.expect( 5 );

	var clone, element;
diff --git a/a.js b/b.js
@@ -1581,7 +1581,7 @@ QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.equal( dest.last().html(), src.last().html(), "Cloning preserves nested script text" );
	assert.ok( /^\s*<scr.pt\s+type=['"]?text\/filler['"]?\s*>consectetur adipiscing elit<\/scr.pt>\s*$/i.test( dest.last().html() ), "Cloning preserves nested script text" );
	dest.remove();
} );

QUnit.test( "clone(form element) (Bug #3879, #6655)", function( assert ) {

	assert.expect( 5 );

	var clone, element;

	element = jQuery( "<select><option>Foo</option><option value='selected' selected>Bar</option></select>" );

	assert.equal( element.clone().find( "option" ).filter( function() { return this.selected; } ).val(), "selected", "Selected option cloned correctly" );

	element = jQuery( "<input type='checkbox' value='foo'>" ).attr( "checked", "checked" );
	clone = element.clone();

	assert.equal( clone.is( ":checked" ), element.is( ":checked" ), "Checked input cloned correctly" );
	assert.equal( clone[ 0 ].defaultValue, "foo", "Checked input defaultValue cloned correctly" );

	element = jQuery( "<input type='text' value='foo'>" );
	clone = element.clone();
	assert.equal( clone[ 0 ].defaultValue, "foo", "Text input defaultValue cloned correctly" );

	element = jQuery( "<textarea>foo</textarea>" );
	clone = element.clone();
	assert.equal( clone[ 0 ].defaultValue, "foo", "Textarea defaultValue cloned correctly" );
} );

QUnit.test( "clone(multiple selected options) (Bug #8129)", function( assert ) {

	assert.expect( 1 );

	var element = jQuery( "<select><option>Foo</option><option selected>Bar</option><option selected>Baz</option></select>" );
diff --git a/a.js b/b.js
@@ -1630,14 +1630,14 @@ QUnit.test( "html(undefined)", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	assert.equal( $meter[ 0 ].nodeName, "meter", "Check if nodeName was not changed due to cloning" );
	assert.equal( $meter[ 0 ].nodeType, 1, "Check if nodeType is not changed due to cloning" );
} );

QUnit.test( "html(undefined)", function( assert ) {

	assert.expect( 1 );

	assert.equal( jQuery( "#foo" ).html( "<i>test</i>" ).html( undefined ).html().toLowerCase(), "<i>test</i>", ".html(undefined) is chainable (#5571)" );
} );

QUnit.test( "html() on empty set", function( assert ) {

	assert.expect( 1 );

	assert.strictEqual( jQuery().html(), undefined, ".html() returns undefined for empty sets (#11962)" );
} );

function childNodeNames( node ) {
	return jQuery.map( node.childNodes, function( child ) {
diff --git a/a.js b/b.js
@@ -1738,7 +1738,7 @@ jQuery( "#nonnodes" ).contents().html( valueObj( "<b>bold</b>" ) ).each( functio
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.equal( div.html( valueObj( tmp ) ).html().replace( />/g, "&gt;" ), tmp, "Escaped html, leading x" );
	tmp = " " + tmp.slice( 1 );
	assert.equal( div.html( valueObj( tmp ) ).html().replace( />/g, "&gt;" ), tmp, "Escaped html, leading space" );

	actual = []; expected = []; tmp = {};
	jQuery( "#nonnodes" ).contents().html( valueObj( "<b>bold</b>" ) ).each( function() {
		var html = jQuery( this ).html();
		tmp[ this.nodeType ] = true;
		expected.push( this.nodeType === 1 ? "<b>bold</b>" : undefined );
		actual.push( html ? html.toLowerCase() : html );
	} );
	assert.deepEqual( actual, expected, "Set containing element, text node, comment" );
	assert.ok( tmp[ 1 ], "element" );
	assert.ok( tmp[ 3 ], "text node" );
	assert.ok( tmp[ 8 ], "comment" );

	actual = []; expected = [];
	fixture.children( "div" ).html( valueObj( "<b>test</b>" ) ).each( function() {
		expected.push( "B" );
		actual.push( childNodeNames( this ) );
	} );
	assert.equal( expected.length, 7, "Expecting many parents" );
	assert.deepEqual( actual, expected, "Correct childNodes after setting HTML" );

	actual = []; expected = [];
	fixture.html( valueObj( "<style>.foobar{color:green;}</style>" ) ).each( function() {
		expected.push( "STYLE" );
		actual.push( childNodeNames( this ) );
	} );
	assert.equal( expected.length, 1, "Expecting one parent" );
	assert.deepEqual( actual, expected, "Found the inserted style element" );

	fixture.html( valueObj( "<select></select>" ) );
	jQuery( "#qunit-fixture select" ).html( valueObj( "<option>O1</option><option selected='selected'>O2</option><option>O3</option>" ) );
	assert.equal( jQuery( "#qunit-fixture select" ).val(), "O2", "Selected option correct" );

	tmp = fixture.html(
		valueObj( [
			"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: non-script' );</script>",
			"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: text/javascript' );</script>",
			"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: text/ecmascript' );</script>",
			"<script>QUnit.assert.ok( true, 'evaluated: no type' );</script>",
			"<div>",
				"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: inner non-script' );</script>",
				"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: inner text/javascript' );</script>",
				"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: inner text/ecmascript' );</script>",
				"<script>QUnit.assert.ok( true, 'evaluated: inner no type' );</script>",
			"</div>"
		].join( "" ) )
	).find( "script" );
	assert.equal( tmp.length, 8, "All script tags remain." );
	assert.equal( tmp[ 0 ].type, "something/else", "Non-evaluated type." );
	assert.equal( tmp[ 1 ].type, "text/javascript", "Evaluated type." );

	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "<script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script' );</script>" ) );
	fixture.html( valueObj( "foo <form><script type='text/javascript'>QUnit.assert.ok( true, 'Injection of identical script (#975)' );</script></form>" ) );

	jQuery.scriptorder = 0;
	fixture.html( valueObj( [
		"<script>",
diff --git a/a.js b/b.js
@@ -1888,7 +1888,7 @@ QUnit.test( "html(Function) with incoming value -- jQuery.contents()", function(
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		}
	} );
	assert.ok( pass, "Set HTML" );
} );

QUnit.test( "html(Function) with incoming value -- jQuery.contents()", function( assert ) {

	assert.expect( 14 );

	var actualhtml, j, $div, $div2, insert;

	j = jQuery( "#nonnodes" ).contents();
	actualhtml = j.map( function() {
		return jQuery( this ).html();
	} );

	j.html( function( i, val ) {
		assert.equal( val, actualhtml[ i ], "Make sure the incoming value is correct." );
		return "<b>bold</b>";
	} );

	// Handle the case where no comment is in the document
	if ( j.length === 2 ) {
		assert.equal( null, null, "Make sure the incoming value is correct." );
	}

	assert.equal( j.html().replace( / xmlns="[^"]+"/g, "" ).toLowerCase(), "<b>bold</b>", "Check node,textnode,comment with html()" );

	$div = jQuery( "<div></div>" );

	assert.equal( $div.html( function( i, val ) {
		assert.equal( val, "", "Make sure the incoming value is correct." );
		return 5;
	} ).html(), "5", "Setting a number as html" );

	assert.equal( $div.html( function( i, val ) {
		assert.equal( val, "5", "Make sure the incoming value is correct." );
		return 0;
	} ).html(), "0", "Setting a zero as html" );

	$div2 = jQuery( "<div></div>" );
	insert = "&lt;div&gt;hello1&lt;/div&gt;";
	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val, "", "Make sure the incoming value is correct." );
		return insert;
	} ).html().replace( />/g, "&gt;" ), insert, "Verify escaped insertion." );

	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val.replace( />/g, "&gt;" ), insert, "Make sure the incoming value is correct." );
		return "x" + insert;
	} ).html().replace( />/g, "&gt;" ), "x" + insert, "Verify escaped insertion." );

	assert.equal( $div2.html( function( i, val ) {
		assert.equal( val.replace( />/g, "&gt;" ), "x" + insert, "Make sure the incoming value is correct." );
		return " " + insert;
	} ).html().replace( />/g, "&gt;" ), " " + insert, "Verify escaped insertion." );
} );

QUnit.test( "clone()/html() don't expose jQuery/Sizzle expandos (#12858)", function( assert ) {

	assert.expect( 2 );

	var $content = jQuery( "<div><b><i>text</i></b></div>" ).appendTo( "#qunit-fixture" ),
diff --git a/a.js b/b.js
@@ -1975,7 +1975,7 @@ QUnit.test( "remove() event cleaning ", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	assert.ok( jQuery( "#nonnodes" ).contents().length >= 2, "Check node,textnode,comment remove works" );
	jQuery( "#nonnodes" ).contents().remove();
	assert.equal( jQuery( "#nonnodes" ).contents().length, 0, "Check node,textnode,comment remove works" );
} );

QUnit.test( "remove() event cleaning ", function( assert ) {
	assert.expect( 1 );

	var count, first, cleanUp;

	count = 0;
	first = jQuery( "#ap" ).children().first();
	cleanUp = first.on( "click", function() {
		count++;
	} ).remove().appendTo( "#qunit-fixture" ).trigger( "click" );

	assert.strictEqual( 0, count, "Event handler has been removed" );

	// Clean up detached data
	cleanUp.remove();
} );

QUnit.test( "remove() in document order #13779", function( assert ) {
	assert.expect( 1 );

	var last,
		cleanData = jQuery.cleanData;
diff --git a/a.js b/b.js
@@ -2233,19 +2233,31 @@ jQuery( [
A blob:131109448be5c649507aa0013b2a4ce898753ccf

QUnit.test( "domManip executes scripts containing html comments or CDATA (trac-9221)", function( assert ) {

	assert.expect( 3 );

	jQuery( [
		"<script type='text/javascript'>",
		"<!--",
		"QUnit.assert.ok( true, '<!-- handled' );",
		"//-->",
		"</script>"
	].join( "\n" ) ).appendTo( "#qunit-fixture" );

	jQuery( [
		"<script type='text/javascript'>",
		"<![CDATA[",
		"QUnit.assert.ok( true, '<![CDATA[ handled' );",
		"//]]>",
		"</script>"
	].join( "\n" ) ).appendTo( "#qunit-fixture" );

	jQuery( [
		"<script type='text/javascript'>",
		"<!--//--><![CDATA[//><!--",
		"QUnit.assert.ok( true, '<!--//--><![CDATA[//><!-- (Drupal case) handled' );",
		"//--><!]]>",
		"</script>"
	].join( "\n" ) ).appendTo( "#qunit-fixture" );
} );

diff --git a/a.js b/b.js
@@ -2324,7 +2336,7 @@ 	window.corsCallback = function( response ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	var done = assert.async(),
		timeout;

	Globals.register( "corsCallback" );
	window.corsCallback = function( response ) {
		assert.ok( typeof response.headers.origin === "string", "Origin header sent" );
		window.clearTimeout( timeout );
		done();
	};

	var src = baseURL + "mock.php?action=script&cors=1&callback=corsCallback";
	src = src.replace( "localhost", "127.0.0.1" );
	var html = "<script type=\"text/javascript\" src=\"" + src + "\" crossorigin=\"anonymous\"><\/script>";

	jQuery( document.body ).append( html );
	timeout = window.setTimeout( function() {
		assert.ok( false, "Origin header should have been sent" );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function( assert ) {

	assert.expect( 1 );

	try {
diff --git a/a.js b/b.js
@@ -2336,7 +2348,7 @@ QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function(
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		assert.ok( false, "Origin header should have been sent" );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.clone - no exceptions for object elements #9587", function( assert ) {

	assert.expect( 1 );

	try {
		jQuery( "#no-clone-exception" ).clone();
		assert.ok( true, "cloned with no exceptions" );
	} catch ( e ) {
		assert.ok( false, e.message );
	}
} );

QUnit.test( "Cloned, detached HTML5 elems (#10667,10670)", function( assert ) {

	assert.expect( 7 );

	var $clone,
diff --git a/a.js b/b.js
@@ -2416,7 +2428,7 @@ QUnit.test( "Guard against exceptions when clearing safeChildNodes", function( a
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	// Unbind any remaining events
	$section.off( "click" );
	$clone.off( "click" );
} );

QUnit.test( "Guard against exceptions when clearing safeChildNodes", function( assert ) {

	assert.expect( 1 );

	var div;

	try {
		div = jQuery( "<div></div><hr/><code></code><b></b>" );
	} catch ( e ) {}

	assert.ok( div && div.jquery, "Created nodes safely, guarded against exceptions on safeChildNodes[ -1 ]" );
} );

QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( assert ) {

	assert.expect( 5 );

	assert.strictEqual( jQuery( "<div></div>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.clone" );
diff --git a/a.js b/b.js
@@ -2427,7 +2439,7 @@ QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( asse
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	} catch ( e ) {}

	assert.ok( div && div.jquery, "Created nodes safely, guarded against exceptions on safeChildNodes[ -1 ]" );
} );

QUnit.test( "Ensure oldIE creates a new set on appendTo (#8894)", function( assert ) {

	assert.expect( 5 );

	assert.strictEqual( jQuery( "<div></div>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.clone" );
	assert.strictEqual( jQuery( "<div></div>" ).find( "p" ).end().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.fn.find" );
	assert.strictEqual( jQuery( "<div></div>" ).text( "test" ).addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after jQuery.fn.text" );
	assert.strictEqual( jQuery( "<bdi></bdi>" ).clone().addClass( "test" ).appendTo( "<div></div>" ).end().end().hasClass( "test" ), false, "Check jQuery.fn.appendTo after clone html5 element" );
	assert.strictEqual( jQuery( "<p></p>" ).appendTo( "<div></div>" ).end().length, jQuery( "<p>test</p>" ).appendTo( "<div></div>" ).end().length, "Elements created with createElement and with createDocumentFragment should be treated alike" );
} );

QUnit.test( "html() - script exceptions bubble (#11743)", function( assert ) {
	assert.expect( 2 );
	var done = assert.async(),
		onerror = window.onerror;

diff --git a/a.js b/b.js
@@ -2469,7 +2481,7 @@ QUnit.test( "checked state is cloned with clone()", function( assert ) {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	};

	jQuery( "#qunit-fixture" ).html( "<script>undefined();</script>" );
} );

QUnit.test( "checked state is cloned with clone()", function( assert ) {

	assert.expect( 2 );

	var elem = jQuery.parseHTML( "<input type='checkbox' checked='checked'/>" )[ 0 ];
	elem.checked = false;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, false, "Checked false state correctly cloned" );

	elem = jQuery.parseHTML( "<input type='checkbox'/>" )[ 0 ];
	elem.checked = true;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, true, "Checked true state correctly cloned" );
} );

QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div>a</div>" ).append( "&nbsp;", jQuery( "<span>b</span>" ), "&nbsp;", jQuery( "<span>c</span>" ) ),
diff --git a/a.js b/b.js
@@ -2485,7 +2497,7 @@ QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( asser
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	elem = jQuery.parseHTML( "<input type='checkbox'/>" )[ 0 ];
	elem.checked = true;
	assert.equal( jQuery( elem ).clone().attr( "id", "clone" )[ 0 ].checked, true, "Checked true state correctly cloned" );
} );

QUnit.test( "manipulate mixed jQuery and text (#12384, #12346)", function( assert ) {

	assert.expect( 2 );

	var div = jQuery( "<div>a</div>" ).append( "&nbsp;", jQuery( "<span>b</span>" ), "&nbsp;", jQuery( "<span>c</span>" ) ),
		nbsp = String.fromCharCode( 160 );

	assert.equal( div.text(), "a" + nbsp + "b" + nbsp + "c", "Appending mixed jQuery with text nodes" );

	div = jQuery( "<div><div></div></div>" )
		.find( "div" )
		.after( "<p>a</p>", "<p>b</p>" )
		.parent();
	assert.equal( div.find( "*" ).length, 3, "added 2 paragraphs after inner div" );
} );

QUnit.test( "script evaluation (#11795)", function( assert ) {

	assert.expect( 13 );

	var scriptsIn, scriptsOut,
diff --git a/a.js b/b.js
@@ -2539,7 +2551,7 @@ 		notOk = function() {
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		fixture = jQuery( "#qunit-fixture" ).empty(),
		objGlobal = ( function() {
			return this;
		} )(),
		isOk = objGlobal.ok,
		notOk = function() {
			var args = arguments;
			args[ 0 ] = !args[ 0 ];
			return isOk.apply( this, args );
		};

	objGlobal.ok = notOk;
	scriptsIn = jQuery( [
		"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: non-script' );</script>",
		"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: text/javascript' );</script>",
		"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: text/ecmascript' );</script>",
		"<script>QUnit.assert.ok( true, 'evaluated: no type' );</script>",
		"<div>",
			"<script type='something/else'>QUnit.assert.ok( false, 'evaluated: inner non-script' );</script>",
			"<script type='text/javascript'>QUnit.assert.ok( true, 'evaluated: inner text/javascript' );</script>",
			"<script type='text/ecmascript'>QUnit.assert.ok( true, 'evaluated: inner text/ecmascript' );</script>",
			"<script>QUnit.assert.ok( true, 'evaluated: inner no type' );</script>",
		"</div>"
	].join( "" ) );
	scriptsIn.appendTo( jQuery( "<div class='detached'></div>" ) );
	objGlobal.ok = isOk;

	scriptsOut = fixture.append( scriptsIn ).find( "script" );
	assert.equal( scriptsOut[ 0 ].type, "something/else", "Non-evaluated type." );
	assert.equal( scriptsOut[ 1 ].type, "text/javascript", "Evaluated type." );
	assert.deepEqual( scriptsOut.get(), fixture.find( "script" ).get(), "All script tags remain." );

	objGlobal.ok = notOk;
	scriptsOut = scriptsOut.add( scriptsOut.clone() ).appendTo( fixture.find( "div" ) );
	assert.deepEqual( fixture.find( "div script" ).get(), scriptsOut.get(), "Scripts cloned without reevaluation" );
	fixture.append( scriptsOut.detach() );
	assert.deepEqual( fixture.children( "script" ).get(), scriptsOut.get(), "Scripts detached without reevaluation" );
	objGlobal.ok = isOk;

	if ( jQuery.ajax ) {
		Globals.register( "testBar" );
		jQuery( "#qunit-fixture" ).append( "<script src='" + url( "mock.php?action=testbar" ) + "'></script>" );
		assert.strictEqual( window.testBar, "bar", "Global script evaluation" );
	} else {
		assert.ok( true, "No jQuery.ajax" );
		assert.ok( true, "No jQuery.ajax" );
	}
} );

QUnit[ jQuery.ajax ? "test" : "skip" ]( "jQuery._evalUrl (#12838)", function( assert ) {

	assert.expect( 5 );

	var message, expectedArgument,
diff --git a/a.js b/b.js
@@ -2608,7 +2620,7 @@ setTimeout( function() {
A blob:131109448be5c649507aa0013b2a4ce898753ccf

	assert.equal( invocations, 3, "htmlPrefilter invoked for all DOM manipulations" );
	assert.equal( fixture.html(), "A-B-C-D-E-F-", "htmlPrefilter modified HTML" );

	// Allow asynchronous script execution to generate assertions
	setTimeout( function() {
		jQuery.htmlPrefilter = htmlPrefilter;
		done();
	}, 100 );
} );

QUnit.test( "insertAfter, insertBefore, etc do not work when destination is original element. Element is removed (#4087)", function( assert ) {

	assert.expect( 10 );

	var elems;
diff --git a/a.js b/b.js
@@ -2642,7 +2654,7 @@ QUnit.test( "insertAfter, insertBefore, etc do not work when destination is orig
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		jQuery.htmlPrefilter = htmlPrefilter;
		done();
	}, 100 );
} );

QUnit.test( "insertAfter, insertBefore, etc do not work when destination is original element. Element is removed (#4087)", function( assert ) {

	assert.expect( 10 );

	var elems;

	jQuery.each( [
		"appendTo",
		"prependTo",
		"insertBefore",
		"insertAfter",
		"replaceAll"
	], function( index, name ) {
		elems = jQuery( [
			"<ul id='test4087-complex'><li class='test4087'><div>c1</div>h1</li><li><div>c2</div>h2</li></ul>",
			"<div id='test4087-simple'><div class='test4087-1'>1<div class='test4087-2'>2</div><div class='test4087-3'>3</div></div></div>",
			"<div id='test4087-multiple'><div class='test4087-multiple'>1</div><div class='test4087-multiple'>2</div></div>"
		].join( "" ) ).appendTo( "#qunit-fixture" );

		// complex case based on https://jsfiddle.net/pbramos/gZ7vB/
		jQuery( "#test4087-complex div" )[ name ]( "#test4087-complex li:last-child div:last-child" );
		assert.equal( jQuery( "#test4087-complex li:last-child div" ).length, name === "replaceAll" ? 1 : 2, name + " a node to itself, complex case." );

		// simple case
		jQuery( ".test4087-1" )[ name ]( ".test4087-1" );
		assert.equal( jQuery( ".test4087-1" ).length, 1, name + " a node to itself, simple case." );

		// clean for next test
		jQuery( "#test4087-complex" ).remove();
		jQuery( "#test4087-simple" ).remove();
		jQuery( "#test4087-multiple" ).remove();
	} );
} );

QUnit.test( "Index for function argument should be received (#13094)", function( assert ) {
	assert.expect( 2 );

	var i = 0;

diff --git a/a.js b/b.js
@@ -2664,7 +2676,7 @@ QUnit.test( "Make sure jQuery.fn.remove can work on elements in documentFragment
A blob:131109448be5c649507aa0013b2a4ce898753ccf
		assert.equal( index, i++, "Index should be correct" );
	} );

} );

QUnit.test( "Make sure jQuery.fn.remove can work on elements in documentFragment", function( assert ) {
	assert.expect( 1 );

	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) );

	jQuery( div ).remove();

	assert.equal( fragment.childNodes.length, 0, "div element was removed from documentFragment" );
} );

QUnit.test( "Make sure specific elements with content created correctly (#13232)", function( assert ) {
	assert.expect( 20 );

	var results = [],
		args = [],
diff --git a/a.js b/b.js
@@ -2699,7 +2711,7 @@ QUnit.test( "Make sure specific elements with content created correctly (#13232)
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	jQuery( div ).remove();

	assert.equal( fragment.childNodes.length, 0, "div element was removed from documentFragment" );
} );

QUnit.test( "Make sure specific elements with content created correctly (#13232)", function( assert ) {
	assert.expect( 20 );

	var results = [],
		args = [],
		elems = {
			thead: "<tr><td>thead</td></tr>",
			tbody: "<tr><td>tbody</td></tr>",
			tfoot: "<tr><td>tfoot</td></tr>",
			colgroup: "<col span='5'></col>",
			caption: "caption",
			tr: "<td>tr</td>",
			th: "th",
			td: "<div>td</div>",
			optgroup: "<option>optgroup</option>",
			option: "option"
		};

	jQuery.each( elems, function( name, value ) {
		var html = "<" + name + ">" + value + "</" + name + ">";
		assert.strictEqual(
			jQuery.parseHTML( "<" + name + ">" + value + "</" + name + ">" )[ 0 ].nodeName.toLowerCase(),
			name,
			name + " is created correctly"
		);

		results.push( name );
		args.push( html );
	} );

	jQuery.fn.append.apply( jQuery( "<div></div>" ), args ).children().each( function( i ) {
		assert.strictEqual( this.nodeName.toLowerCase(), results[ i ] );
	} );
} );

QUnit.test( "Validate creation of multiple quantities of certain elements (#13818)", function( assert ) {
	assert.expect( 22 );

	var tags = [ "thead", "tbody", "tfoot", "colgroup", "col", "caption", "tr", "th", "td", "optgroup", "option" ];

diff --git a/a.js b/b.js
@@ -2996,3 +3008,19 @@ QUnit.test( "Works with invalid attempts to close the table wrapper", function(
A blob:131109448be5c649507aa0013b2a4ce898753ccf
	if ( !oldIos ) {
		test( "<noembed><noembed/><img src=url404 onerror=xss(12)>" );
	}
} );

QUnit.test( "Works with invalid attempts to close the table wrapper", function( assert ) {
	assert.expect( 3 );

	// This test case attempts to close the tags which wrap input
	// based on matching done in wrapMap which should be ignored.
	var elem = jQuery( "<td></td></tr></tbody></table><td></td>" );
	assert.strictEqual( elem.length, 2, "Two elements created" );
	assert.strictEqual( elem[ 0 ].nodeName.toLowerCase(), "td", "First element is td" );
	assert.strictEqual( elem[ 1 ].nodeName.toLowerCase(), "td", "Second element is td" );
} );

diff --git a/a.js b/b.js
@@ -33,7 +33,7 @@ QUnit.test( "css(String|Hash)", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
if ( jQuery.css ) {

QUnit.module( "css", { afterEach: moduleTeardown } );

QUnit.test( "css(String|Hash)", function( assert ) {
	assert.expect( 42 );

	assert.equal( jQuery( "#qunit-fixture" ).css( "display" ), "block", "Check for css property \"display\"" );

	var $child, div, div2, width, height, child, prctval, checkval, old;

	$child = jQuery( "#nothiddendivchild" ).css( { "width": "20%", "height": "20%" } );
	assert.notEqual( $child.css( "width" ), "20px", "Retrieving a width percentage on the child of a hidden div returns percentage" );
	assert.notEqual( $child.css( "height" ), "20px", "Retrieving a height percentage on the child of a hidden div returns percentage" );

	div = jQuery( "<div></div>" );

	// These should be "auto" (or some better value)
	// temporarily provide "0px" for backwards compat
	assert.equal( div.css( "width" ), "0px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "0px", "Height on disconnected node." );

	div.css( { "width": 4, "height": 4 } );

	assert.equal( div.css( "width" ), "4px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "4px", "Height on disconnected node." );

	div2 = jQuery( "<div style='display:none;'><input type='text' style='height:20px;'/><textarea style='height:20px;'></textarea><div style='height:20px;'></div></div>" ).appendTo( "body" );

	assert.equal( div2.find( "input" ).css( "height" ), "20px", "Height on hidden input." );
	assert.equal( div2.find( "textarea" ).css( "height" ), "20px", "Height on hidden textarea." );
	assert.equal( div2.find( "div" ).css( "height" ), "20px", "Height on hidden div." );

	div2.remove();

	// handle negative numbers by setting to zero #11604
	jQuery( "#nothiddendiv" ).css( { "width": 1, "height": 1 } );

	width = parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) );
	height = parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) );
diff --git a/a.js b/b.js
@@ -113,7 +113,7 @@ QUnit.test( "css(String|Hash)", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
if ( jQuery.css ) {

QUnit.module( "css", { afterEach: moduleTeardown } );

QUnit.test( "css(String|Hash)", function( assert ) {
	assert.expect( 42 );

	assert.equal( jQuery( "#qunit-fixture" ).css( "display" ), "block", "Check for css property \"display\"" );

	var $child, div, div2, width, height, child, prctval, checkval, old;

	$child = jQuery( "#nothiddendivchild" ).css( { "width": "20%", "height": "20%" } );
	assert.notEqual( $child.css( "width" ), "20px", "Retrieving a width percentage on the child of a hidden div returns percentage" );
	assert.notEqual( $child.css( "height" ), "20px", "Retrieving a height percentage on the child of a hidden div returns percentage" );

	div = jQuery( "<div></div>" );

	// These should be "auto" (or some better value)
	// temporarily provide "0px" for backwards compat
	assert.equal( div.css( "width" ), "0px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "0px", "Height on disconnected node." );

	div.css( { "width": 4, "height": 4 } );

	assert.equal( div.css( "width" ), "4px", "Width on disconnected node." );
	assert.equal( div.css( "height" ), "4px", "Height on disconnected node." );

	div2 = jQuery( "<div style='display:none;'><input type='text' style='height:20px;'/><textarea style='height:20px;'></textarea><div style='height:20px;'></div></div>" ).appendTo( "body" );

	assert.equal( div2.find( "input" ).css( "height" ), "20px", "Height on hidden input." );
	assert.equal( div2.find( "textarea" ).css( "height" ), "20px", "Height on hidden textarea." );
	assert.equal( div2.find( "div" ).css( "height" ), "20px", "Height on hidden div." );

	div2.remove();

	// handle negative numbers by setting to zero #11604
	jQuery( "#nothiddendiv" ).css( { "width": 1, "height": 1 } );

	width = parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) );
	height = parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) );
	jQuery( "#nothiddendiv" ).css( { "overflow":"hidden", "width": -1, "height": -1 } );
	assert.equal( parseFloat( jQuery( "#nothiddendiv" ).css( "width" ) ), 0, "Test negative width set to 0" );
	assert.equal( parseFloat( jQuery( "#nothiddendiv" ).css( "height" ) ), 0, "Test negative height set to 0" );

	assert.equal( jQuery( "<div style='display: none;'></div>" ).css( "display" ), "none", "Styles on disconnected nodes" );

	jQuery( "#floatTest" ).css( { "float": "right" } );
	assert.equal( jQuery( "#floatTest" ).css( "float" ), "right", "Modified CSS float using \"float\": Assert float is right" );
	jQuery( "#floatTest" ).css( { "font-size": "30px" } );
	assert.equal( jQuery( "#floatTest" ).css( "font-size" ), "30px", "Modified CSS font-size: Assert font-size is 30px" );
	jQuery.each( "0,0.25,0.5,0.75,1".split( "," ), function( i, n ) {
		jQuery( "#foo" ).css( { "opacity": n } );

		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a String" );
		jQuery( "#foo" ).css( { "opacity": parseFloat( n ) } );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a Number" );
	} );
	jQuery( "#foo" ).css( { "opacity": "" } );
	assert.equal( jQuery( "#foo" ).css( "opacity" ), "1", "Assert opacity is 1 when set to an empty String" );

	assert.equal( jQuery( "#empty" ).css( "opacity" ), "0", "Assert opacity is accessible" );
	jQuery( "#empty" ).css( { "opacity": "1" } );
	assert.equal( jQuery( "#empty" ).css( "opacity" ), "1", "Assert opacity is taken from style attribute when set" );

	div = jQuery( "#nothiddendiv" );
	child = jQuery( "#nothiddendivchild" );

	assert.equal( parseInt( div.css( "fontSize" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( div.css( "font-size" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( child.css( "fontSize" ), 10 ), 16, "Verify fontSize px set." );
	assert.equal( parseInt( child.css( "font-size" ), 10 ), 16, "Verify fontSize px set." );

	child.css( "height", "100%" );
	assert.equal( child[ 0 ].style.height, "100%", "Make sure the height is being set correctly." );

	child.attr( "class", "em" );
	assert.equal( parseInt( child.css( "fontSize" ), 10 ), 32, "Verify fontSize em set." );

	// Have to verify this as the result depends upon the browser's CSS
	// support for font-size percentages
	child.attr( "class", "prct" );
	prctval = parseInt( child.css( "fontSize" ), 10 );
	checkval = 0;
	if ( prctval === 16 || prctval === 24 ) {
		checkval = prctval;
	}

	assert.equal( prctval, checkval, "Verify fontSize % set." );

	assert.equal( typeof child.css( "width" ), "string", "Make sure that a string width is returned from css('width')." );

	old = child[ 0 ].style.height;

	// Test NaN
	child.css( "height", parseFloat( "zoo" ) );
	assert.equal( child[ 0 ].style.height, old, "Make sure height isn't changed on NaN." );

	// Test null
	child.css( "height", null );
	assert.equal( child[ 0 ].style.height, old, "Make sure height isn't changed on null." );

	old = child[ 0 ].style.fontSize;

	// Test NaN
	child.css( "font-size", parseFloat( "zoo" ) );
	assert.equal( child[ 0 ].style.fontSize, old, "Make sure font-size isn't changed on NaN." );

	// Test null
	child.css( "font-size", null );
	assert.equal( child[ 0 ].style.fontSize, old, "Make sure font-size isn't changed on null." );

	assert.strictEqual( child.css( "x-fake" ), undefined, "Make sure undefined is returned from css(nonexistent)." );

	div = jQuery( "<div></div>" ).css( { position: "absolute", "z-index": 1000 } ).appendTo( "#qunit-fixture" );
	assert.strictEqual( div.css( "z-index" ), "1000",
		"Make sure that a string z-index is returned from css('z-index') (#14432)." );
} );

QUnit.test( "css() explicit and relative values", function( assert ) {
	assert.expect( 29 );
diff --git a/a.js b/b.js
@@ -325,11 +325,11 @@ QUnit.test( "css(String, Object)", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	$el.css( "right", "-=25em" );
	assert.equal( Math.round( parseFloat( $el.css( "right" ) ) ), 100,
		"Constraints do not interfere with unit conversion" );
} );

QUnit.test( "css(String, Object)", function( assert ) {
	assert.expect( 19 );
	var j, div, display, ret, success;

	jQuery( "#floatTest" ).css( "float", "left" );
	assert.equal( jQuery( "#floatTest" ).css( "float" ), "left", "Modified CSS float using \"float\": Assert float is left" );
	jQuery( "#floatTest" ).css( "font-size", "20px" );
	assert.equal( jQuery( "#floatTest" ).css( "font-size" ), "20px", "Modified CSS font-size: Assert font-size is 20px" );

	jQuery.each( "0,0.25,0.5,0.75,1".split( "," ), function( i, n ) {
		jQuery( "#foo" ).css( "opacity", n );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a String" );
		jQuery( "#foo" ).css( "opacity", parseFloat( n ) );
		assert.equal( jQuery( "#foo" ).css( "opacity" ), parseFloat( n ), "Assert opacity is " + parseFloat( n ) + " as a Number" );
	} );
	jQuery( "#foo" ).css( "opacity", "" );
	assert.equal( jQuery( "#foo" ).css( "opacity" ), "1", "Assert opacity is 1 when set to an empty String" );

	// using contents will get comments regular, text, and comment nodes
	j = jQuery( "#nonnodes" ).contents();
	j.css( "overflow", "visible" );
	assert.equal( j.css( "overflow" ), "visible", "Check node,textnode,comment css works" );
	assert.equal( jQuery( "#t2037 .hidden" ).css( "display" ), "none", "Make sure browser thinks it is hidden" );

	div = jQuery( "#nothiddendiv" );
	display = div.css( "display" );
	ret = div.css( "display", undefined );

	assert.equal( ret, div, "Make sure setting undefined returns the original set." );
	assert.equal( div.css( "display" ), display, "Make sure that the display wasn't changed." );

	success = true;
	try {
		jQuery( "#foo" ).css( "backgroundColor", "rgba(0, 0, 0, 0.1)" );
	}
	catch ( e ) {
		success = false;
	}
	assert.ok( success, "Setting RGBA values does not throw Error (#5509)" );

	jQuery( "#foo" ).css( "font", "7px/21px sans-serif" );
	assert.strictEqual( jQuery( "#foo" ).css( "line-height" ), "21px",
		"Set font shorthand property (#14759)" );
} );

QUnit.test( "css(String, Object) with negative values", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -699,7 +699,7 @@ QUnit.test( "show/hide detached nodes", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	// Make sure that showing or hiding a text node doesn't cause an error
	jQuery( "<div>test</div> text <span>test</span>" ).show().remove();
	jQuery( "<div>test</div> text <span>test</span>" ).hide().remove();
} );

QUnit.test( "show/hide detached nodes", function( assert ) {
	assert.expect( 19 );

	var div, span, tr;

	div = jQuery( "<div>" ).hide();
	assert.equal( div.css( "display" ), "none", "hide() updates inline style of a detached div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A hidden-while-detached div is hidden after attachment" );
	div.show();
	assert.equal( div.css( "display" ), "block",
		"A hidden-while-detached div can be shown after attachment" );

	div = jQuery( "<div class='hidden'>" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached div can be hidden by the CSS cascade" );

	div = jQuery( "<div><div class='hidden'></div></div>" ).children( "div" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached div inside a visible div can be hidden by the CSS cascade" );

	span = jQuery( "<span class='hidden'></span>" );
	span.show().appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "none",
		"A shown-while-detached span can be hidden by the CSS cascade" );

	div = jQuery( "div.hidden" );
	div.detach().show();
	assert.ok( !div[ 0 ].style.display,
		"show() does not update inline style of a cascade-hidden-before-detach div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none",
		"A shown-while-detached cascade-hidden div is hidden after attachment" );
	div.remove();

	span = jQuery( "<span class='hidden'></span>" );
	span.appendTo( "#qunit-fixture" ).detach().show().appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "none",
		"A shown-while-detached cascade-hidden span is hidden after attachment" );
	span.remove();

	div = jQuery( document.createElement( "div" ) );
	div.show().appendTo( "#qunit-fixture" );
	assert.ok( !div[ 0 ].style.display, "A shown-while-detached div has no inline style" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached div has default display after attachment" );
	div.remove();

	div = jQuery( "<div style='display: none'>" );
	div.show();
	assert.equal( div[ 0 ].style.display, "",
		"show() updates inline style of a detached inline-hidden div" );
	div.appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached inline-hidden div has default display after attachment" );

	div = jQuery( "<div><div style='display: none'></div></div>" ).children( "div" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "block",
		"A shown-while-detached inline-hidden div inside a visible div has default display " +
		"after attachment" );

	span = jQuery( "<span style='display: none'></span>" );
	span.show();
	assert.equal( span[ 0 ].style.display, "",
		"show() updates inline style of a detached inline-hidden span" );
	span.appendTo( "#qunit-fixture" );
	assert.equal( span.css( "display" ), "inline",
		"A shown-while-detached inline-hidden span has default display after attachment" );

	div = jQuery( "<div style='display: inline'></div>" );
	div.show().appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "inline",
		"show() does not update inline style of a detached inline-visible div" );
	div.remove();

	tr = jQuery( "<tr></tr>" );
	jQuery( "#table" ).append( tr );
	tr.detach().hide().show();

	assert.ok( !tr[ 0 ].style.display, "Not-hidden detached tr elements have no inline style" );
	tr.remove();

	span = jQuery( "<span></span>" ).hide().show();
	assert.ok( !span[ 0 ].style.display, "Not-hidden detached span elements have no inline style" );
	span.remove();
} );

// Support: IE 11+
// IE doesn't support Shadow DOM.
QUnit.testUnlessIE(
	"show/hide shadow child nodes", function( assert ) {

	assert.expect( 28 );
	jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );
	var shadowHost = document.querySelector( "#shadowHost" );
	var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
	shadowRoot.innerHTML = "" +
		"<style>.hidden{display: none;}</style>" +
		"<div class='hidden' id='shadowdiv'>" +
		"	<p class='hidden' id='shadowp'>" +
		"		<a href='#' class='hidden' id='shadowa'></a>" +
		"	</p>" +
		"	<code class='hidden' id='shadowcode'></code>" +
		"	<pre class='hidden' id='shadowpre'></pre>" +
		"	<span class='hidden' id='shadowspan'></span>" +
		"</div>" +
		"<table class='hidden' id='shadowtable'>" +
		"	<thead class='hidden' id='shadowthead'>" +
		"		<tr class='hidden' id='shadowtr'>" +
		"			<th class='hidden' id='shadowth'></th>" +
		"		</tr>" +
		"	</thead>" +
		"	<tbody class='hidden' id='shadowtbody'>" +
		"		<tr class='hidden'>" +
		"			<td class='hidden' id='shadowtd'></td>" +
		"		</tr>" +
		"	</tbody>" +
		"</table>" +
		"<ul class='hidden' id='shadowul'>" +
		"	<li class='hidden' id='shadowli'></li>" +
		"</ul>";

	var test = {
		"div": "block",
		"p": "block",
		"a": "inline",
		"code": "inline",
		"pre": "block",
		"span": "inline",
		"table": "table",
		"thead": "table-header-group",
		"tbody": "table-row-group",
		"tr": "table-row",
		"th": "table-cell",
		"td": "table-cell",
		"ul": "block",
		"li": "list-item"
	};

	jQuery.each( test, function( selector, expected ) {
		var shadowChild = shadowRoot.querySelector( "#shadow" + selector );
		var $shadowChild = jQuery( shadowChild );
		assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
		$shadowChild.show();
		assert.strictEqual( $shadowChild.css( "display" ), expected, "Show using correct display type for " + selector );
	} );
} );

QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
	assert.expect( 3 );

	var div = jQuery( "<div style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is hidden by default" );
diff --git a/a.js b/b.js
@@ -712,7 +712,7 @@ QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
		$shadowChild.show();
		assert.strictEqual( $shadowChild.css( "display" ), expected, "Show using correct display type for " + selector );
	} );
} );

QUnit.test( "hide hidden elements (bug #7141)", function( assert ) {
	assert.expect( 3 );

	var div = jQuery( "<div style='display:none'></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( div.css( "display" ), "none", "Element is hidden by default" );
	div.hide();
	assert.ok( !jQuery._data( div, "olddisplay" ), "olddisplay is undefined after hiding an already-hidden element" );
	div.show();
	assert.equal( div.css( "display" ), "block", "Show a double-hidden element" );

	div.remove();
} );

QUnit.test( "show() after hide() should always set display to initial value (#14750)", function( assert ) {
	assert.expect( 1 );

	var div = jQuery( "<div></div>" ),
		fixture = jQuery( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -988,7 +988,7 @@ QUnit.test( "show/hide 3.0, inline hidden", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
			assert.equal( this.style.display, expected, name + sequence.join( "" ) + " inline" );
		}
	} );
} );

QUnit.test( "show/hide 3.0, inline hidden", function( assert ) {

	assert.expect( 84 );

	var i,
		$elems = jQuery( "<div></div>" )
			.appendTo( "#qunit-fixture" )
			.html( "<span data-expected-display='inline' style='display:none'></span>" +
				"<span class='list-item' data-expected-display='list-item' style='display:none'></span>" +
				"<div data-expected-display='block' style='display:none'></div>" +
				"<div class='list-item' data-expected-display='list-item' style='display:none'></div>" +
				"<ul>" +
					"<li data-expected-display='list-item' style='display:none'></li>" +
					"<li class='block' data-expected-display='block' style='display:none'></li>" +
					"<li class='inline' data-expected-display='inline' style='display:none'></li>" +
				"</ul>" )
			.find( "[data-expected-display]" );

	$elems.each( function() {
		var $elem = jQuery( this ),
			name = this.nodeName,
			expected = this.getAttribute( "data-expected-display" ),
			sequence = [];

		if ( this.className ) {
			name += "." + this.className;
		}
		if ( this.getAttribute( "style" ) ) {
			name += "[style='" + this.getAttribute( "style" ) + "']";
		}
		name += " ";

		for ( i = 0; i < 3; i++ ) {
			sequence.push( ".hide()" );
			$elem.hide();
			assert.equal( $elem.css( "display" ), "none",
				name + sequence.join( "" ) + " computed" );
			assert.equal( this.style.display, "none", name + sequence.join( "" ) + " inline" );

			sequence.push( ".show()" );
			$elem.show();
			assert.equal( $elem.css( "display" ), expected,
				name + sequence.join( "" ) + " computed" );
			assert.equal( this.style.display, "", name + sequence.join( "" ) + " inline" );
		}
	} );
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle ? "test" : "skip" ]( "toggle()", function( assert ) {
	assert.expect( 9 );
	var div, oldHide,
		x = jQuery( "#foo" );

	assert.ok( x.is( ":visible" ), "is visible" );
	x.toggle();
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle();
	assert.ok( x.is( ":visible" ), "is visible again" );

	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible" );
	x.toggle( false );
	assert.ok( x.is( ":hidden" ), "is hidden" );
	x.toggle( true );
	assert.ok( x.is( ":visible" ), "is visible again" );

	div = jQuery( "<div style='display:none'><div></div></div>" ).appendTo( "#qunit-fixture" );
	x = div.find( "div" );
	assert.strictEqual( x.toggle().css( "display" ), "none", "is hidden" );
	assert.strictEqual( x.toggle().css( "display" ), "block", "is visible" );

	// Ensure hide() is called when toggled (#12148)
	oldHide = jQuery.fn.hide;
	jQuery.fn.hide = function() {
		assert.ok( true, name + " method called on toggle" );
		return oldHide.apply( this, arguments );
diff --git a/a.js b/b.js
@@ -1048,7 +1048,7 @@ 	jQuery.fn.hide = function() {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	assert.strictEqual( x.toggle().css( "display" ), "none", "is hidden" );
	assert.strictEqual( x.toggle().css( "display" ), "block", "is visible" );

	// Ensure hide() is called when toggled (#12148)
	oldHide = jQuery.fn.hide;
	jQuery.fn.hide = function() {
		assert.ok( true, name + " method called on toggle" );
		return oldHide.apply( this, arguments );
	};
	x.toggle( name === "show" );
	jQuery.fn.hide = oldHide;
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle ? "test" : "skip" ]( "detached toggle()", function( assert ) {
	assert.expect( 6 );
	var detached = jQuery( "<p><a></a><p>" ).find( "*" ).addBack(),
		hiddenDetached = jQuery( "<p><a></a></p>" ).find( "*" ).addBack().css( "display", "none" ),
		cascadeHiddenDetached = jQuery( "<p><a></a></p>" ).find( "*" ).addBack().addClass( "hidden" );

	detached.toggle();
	detached.appendTo( "#qunit-fixture" );
	assert.equal( detached[ 0 ].style.display, "none", "detached element" );
	assert.equal( detached[ 1 ].style.display, "none", "element in detached tree" );

	hiddenDetached.toggle();
	hiddenDetached.appendTo( "#qunit-fixture" );
	assert.equal( hiddenDetached[ 0 ].style.display, "", "detached, hidden element" );
	assert.equal( hiddenDetached[ 1 ].style.display, "", "hidden element in detached tree" );

	cascadeHiddenDetached.toggle();
	cascadeHiddenDetached.appendTo( "#qunit-fixture" );
	assert.equal( cascadeHiddenDetached[ 0 ].style.display, "none",
		"detached, cascade-hidden element" );
	assert.equal( cascadeHiddenDetached[ 1 ].style.display, "none",
		"cascade-hidden element in detached tree" );
} );

QUnit[ QUnit.jQuerySelectors && jQuery.fn.toggle && !QUnit.isIE ? "test" : "skip" ](
	"shadow toggle()", function( assert ) {

	assert.expect( 4 );

	jQuery( "<div id='shadowHost'></div>" ).appendTo( "#qunit-fixture" );
	var shadowHost = document.querySelector( "#shadowHost" );
	var shadowRoot = shadowHost.attachShadow( { mode: "open" } );
	shadowRoot.innerHTML = "" +
		"<style>.hidden{display: none;}</style>" +
		"<div id='shadowHiddenChild' class='hidden'></div>" +
		"<div id='shadowChild'></div>";
	var shadowChild = shadowRoot.querySelector( "#shadowChild" );
	var shadowHiddenChild = shadowRoot.querySelector( "#shadowHiddenChild" );

	var $shadowChild = jQuery( shadowChild );
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );

	$shadowChild = jQuery( shadowHiddenChild );
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
} );

QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	jQuery.css( $checkedtest[ 0 ], "height" );
diff --git a/a.js b/b.js
@@ -1060,7 +1060,7 @@ QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)"
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	assert.strictEqual( $shadowChild.css( "display" ), "none", "is hidden" );
	$shadowChild.toggle();
	assert.strictEqual( $shadowChild.css( "display" ), "block", "is visible" );
} );

QUnit.test( "jQuery.css(elem, 'height') doesn't clear radio buttons (bug #1095)", function( assert ) {
	assert.expect( 4 );

	var $checkedtest = jQuery( "#checkedtest" );
	jQuery.css( $checkedtest[ 0 ], "height" );

	assert.ok( jQuery( "input[type='radio']", $checkedtest ).first().attr( "checked" ), "Check first radio still checked." );
	assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
	assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
	assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
} );

QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert ) {
	assert.expect( 1 );
	var result = true;

	try {
diff --git a/a.js b/b.js
@@ -1099,18 +1099,18 @@ QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert )
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	assert.ok( !jQuery( "input[type='radio']", $checkedtest ).last().attr( "checked" ), "Check last radio still NOT checked." );
	assert.ok( jQuery( "input[type='checkbox']", $checkedtest ).first().attr( "checked" ), "Check first checkbox still checked." );
	assert.ok( !jQuery( "input[type='checkbox']", $checkedtest ).last().attr( "checked" ), "Check last checkbox still NOT checked." );
} );

QUnit.test( "internal ref to elem.runtimeStyle (bug #7608)", function( assert ) {
	assert.expect( 1 );
	var result = true;

	try {
		jQuery( "#foo" ).css( { "width": "0%" } ).css( "width" );
	} catch ( e ) {
		result = false;
	}

	assert.ok( result, "elem.runtimeStyle does not throw exception" );
} );

QUnit.test( "computed margins (trac-3333; gh-2237)", function( assert ) {
	assert.expect( 2 );

	var $div = jQuery( "#foo" ),
		$child = jQuery( "#en" );

	$div.css( {
		"width": "1px",
		"marginRight": 0
	} );
	assert.equal( $div.css( "marginRight" ), "0px",
		"marginRight correctly calculated with a width and display block" );

	$div.css( {
		position: "absolute",
		top: 0,
		left: 0,
		width: "100px"
	} );
	$child.css( {
		width: "50px",
		margin: "auto"
	} );
	assert.equal( $child.css( "marginLeft" ), "25px", "auto margins are computed to pixels" );
} );

QUnit.test( "box model properties incorrectly returning % instead of px, see #10639 and #12088", function( assert ) {
	assert.expect( 2 );

	var container = jQuery( "<div></div>" ).width( 400 ).appendTo( "#qunit-fixture" ),
		el = jQuery( "<div></div>" ).css( { "width": "50%", "marginRight": "50%" } ).appendTo( container ),
		el2 = jQuery( "<div></div>" ).css( { "width": "50%", "minWidth": "300px", "marginLeft": "25%" } ).appendTo( container );

	assert.equal( el.css( "marginRight" ), "200px", "css('marginRight') returning % instead of px, see #10639" );
	assert.equal( el2.css( "marginLeft" ), "100px", "css('marginLeft') returning incorrect pixel value, see #12088" );
} );

QUnit.test( "widows & orphans #8936", function( assert ) {

	var $p = jQuery( "<p>" ).appendTo( "#qunit-fixture" );

	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1127,15 +1127,15 @@ QUnit.test( "widows & orphans #8936", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

	assert.equal( el.css( "marginRight" ), "200px", "css('marginRight') returning % instead of px, see #10639" );
	assert.equal( el2.css( "marginLeft" ), "100px", "css('marginLeft') returning incorrect pixel value, see #12088" );
} );

QUnit.test( "widows & orphans #8936", function( assert ) {

	var $p = jQuery( "<p>" ).appendTo( "#qunit-fixture" );

	assert.expect( 2 );

	$p.css( {
		"widows": 3,
		"orphans": 3
	} );

	assert.equal( $p.css( "widows" ) || jQuery.style( $p[ 0 ], "widows" ), 3, "widows correctly set to 3" );
	assert.equal( $p.css( "orphans" ) || jQuery.style( $p[ 0 ], "orphans" ), 3, "orphans correctly set to 3" );

	$p.remove();
} );

QUnit.test( "can't get css for disconnected in IE<9, see #10254 and #8388", function( assert ) {
	assert.expect( 2 );
	var span, div;

	span = jQuery( "<span></span>" ).css( "background-image", "url(" + baseURL + "1x1.jpg)" );
	assert.notEqual( span.css( "background-image" ), null, "can't get background-image in IE<9, see #10254" );

	div = jQuery( "<div></div>" ).css( "top", 10 );
	assert.equal( div.css( "top" ), "10px", "can't get top in IE<9, see #8388" );
} );

QUnit.test( "Ensure styles are retrieving from parsed html on document fragments", function( assert ) {
	assert.expect( 1 );
diff --git a/a.js b/b.js
@@ -1148,7 +1148,7 @@ QUnit.test( "Ensure styles are retrieving from parsed html on document fragments
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

	div = jQuery( "<div></div>" ).css( "top", 10 );
	assert.equal( div.css( "top" ), "10px", "can't get top in IE<9, see #8388" );
} );

QUnit.test( "Ensure styles are retrieving from parsed html on document fragments", function( assert ) {
	assert.expect( 1 );

	var $span = jQuery(
		jQuery.parseHTML( "<span style=\"font-family: Cuprum,sans-serif; font-size: 14px; color: #999999;\">some text</span>" )
	);

	assert.equal( $span.css( "font-size" ), "14px", "Font-size retrievable on parsed HTML node" );
} );

QUnit.test( "can't get background-position in IE<9, see #10796", function( assert ) {
	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ),
		units = [
			"0 0",
			"12px 12px",
diff --git a/a.js b/b.js
@@ -1167,22 +1167,22 @@ QUnit.test( "can't get background-position in IE<9, see #10796", function( asser
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	);

	assert.equal( $span.css( "font-size" ), "14px", "Font-size retrievable on parsed HTML node" );
} );

QUnit.test( "can't get background-position in IE<9, see #10796", function( assert ) {
	var div = jQuery( "<div></div>" ).appendTo( "#qunit-fixture" ),
		units = [
			"0 0",
			"12px 12px",
			"13px 12em",
			"12em 13px",
			"12em center",
			"+12em center",
			"12.2em center",
			"center center"
		],
		l = units.length,
		i = 0;

	assert.expect( l );

	for ( ; i < l; i++ ) {
		div.css( "background-position", units [ i ] );
		assert.ok( div.css( "background-position" ), "can't get background-position in IE<9, see #10796" );
	}
} );

if ( jQuery.fn.offset ) {
	QUnit.test( "percentage properties for left and top should be transformed to pixels, see #9505", function( assert ) {
		assert.expect( 2 );
		var parent = jQuery( "<div style='position:relative;width:200px;height:200px;margin:0;padding:0;border-width:0'></div>" ).appendTo( "#qunit-fixture" ),
			div = jQuery( "<div style='position: absolute; width: 20px; height: 20px; top:50%; left:50%'></div>" ).appendTo( parent );

		assert.equal( div.css( "top" ), "100px", "position properties not transformed to pixels, see #9505" );
		assert.equal( div.css( "left" ), "100px", "position properties not transformed to pixels, see #9505" );
	} );
}

QUnit.test( "Do not append px (#9548, #12990, #2792)", function( assert ) {
	assert.expect( 4 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -1335,16 +1335,16 @@ QUnit.test( "Append px to whitelisted properties", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	$div.css( "letter-spacing", "2px" );
	$div.css( "letter-spacing", 3 );
	assert.equal( $div.css( "letter-spacing" ), "2px", "Do not append px to 'letter-spacing'" );
} );

QUnit.test( "Append px to whitelisted properties", function( assert ) {
	var prop,
		$div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		whitelist = {
			margin: "marginTop",
			marginTop: undefined,
			marginRight: undefined,
			marginBottom: undefined,
			marginLeft: undefined,
			padding: "paddingTop",
			paddingTop: undefined,
			paddingRight: undefined,
			paddingBottom: undefined,
			paddingLeft: undefined,
			top: undefined,
			right: undefined,
			bottom: undefined,
			left: undefined,
			width: undefined,
			height: undefined,
			minWidth: undefined,
			minHeight: undefined,
			maxWidth: undefined,
			maxHeight: undefined,
			border: "borderTopWidth",
			borderWidth: "borderTopWidth",
			borderTop: "borderTopWidth",
			borderTopWidth: undefined,
			borderRight: "borderRightWidth",
			borderRightWidth: undefined,
			borderBottom: "borderBottomWidth",
			borderBottomWidth: undefined,
			borderLeft: "borderLeftWidth",
			borderLeftWidth: undefined
		};

	assert.expect( ( Object.keys( whitelist ).length ) * 2 );

	for ( prop in whitelist ) {
		var propToCheck = whitelist[ prop ] || prop,
			kebabProp = prop.replace( /[A-Z]/g, function( match ) {
				return "-" + match.toLowerCase();
			} ),
			kebabPropToCheck = propToCheck.replace( /[A-Z]/g, function( match ) {
				return "-" + match.toLowerCase();
			} );
		$div.css( prop, 3 )
			.css( "position", "absolute" )
			.css( "border-style", "solid" );
		assert.equal( $div.css( propToCheck ), "3px", "Append px to '" + prop + "'" );
		$div.css( kebabProp, 3 )
			.css( "position", "absolute" )
			.css( "border-style", "solid" );
		assert.equal( $div.css( kebabPropToCheck ), "3px", "Append px to '" + kebabProp + "'" );
	}
} );

QUnit.test( "css('width') and css('height') should respect box-sizing, see #11004", function( assert ) {
	assert.expect( 4 );

	var el_dis = jQuery( "<div style='width:300px;height:300px;margin:2px;padding:2px;box-sizing:border-box;'>test</div>" ),
		el = el_dis.clone().appendTo( "#qunit-fixture" );

	assert.equal( el.css( "width" ), el.css( "width", el.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "width" ), el_dis.css( "width", el_dis.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing for disconnected element, see #11004" );
	assert.equal( el.css( "height" ), el.css( "height", el.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "height" ), el_dis.css( "height", el_dis.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing for disconnected element, see #11004" );
} );

QUnit.test( "table rows width/height should be unaffected by inline styles", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -1368,7 +1368,7 @@ QUnit.test( "table rows width/height should be unaffected by inline styles", fun
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	assert.equal( el_dis.css( "width" ), el_dis.css( "width", el_dis.css( "width" ) ).css( "width" ), "css('width') is not respecting box-sizing for disconnected element, see #11004" );
	assert.equal( el.css( "height" ), el.css( "height", el.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing, see #11004" );
	assert.equal( el_dis.css( "height" ), el_dis.css( "height", el_dis.css( "height" ) ).css( "height" ), "css('height') is not respecting box-sizing for disconnected element, see #11004" );
} );

QUnit.test( "table rows width/height should be unaffected by inline styles", function( assert ) {
	assert.expect( 2 );

	var table = jQuery(
		"<table>\n" +
		"  <tr id=\"row\" style=\"height: 1px; width: 1px;\">\n" +
		"    <td>\n" +
		"      <div style=\"height: 100px; width: 100px;\"></div>\n" +
		"    </div>\n" +
		"  </tr>\n" +
		"</table>"
	);
	var tr = table.find( "tr" );

	table.appendTo( "#qunit-fixture" );

	assert.ok( parseInt( tr.css( "width" ) ) > 10, "tr width unaffected by inline style" );
	assert.ok( parseInt( tr.css( "height" ) ) > 10, "tr height unaffected by inline style" );
} );

testIframe(
	"css('width') should work correctly before document ready (#14084)",
	"css/cssWidthBeforeDocReady.html",
	function( assert, jQuery, window, document, cssWidthBeforeDocReady ) {
		assert.expect( 1 );
		assert.strictEqual( cssWidthBeforeDocReady, "100px", "elem.css('width') works correctly before document ready" );
diff --git a/a.js b/b.js
@@ -1409,13 +1409,13 @@ function( assert, jQuery, window, document, widthBeforeSet, widthAfterSet ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
);

testIframe(
	"css('width') should work correctly with browser zooming",
	"css/cssWidthBrowserZoom.html",
	function( assert, jQuery, window, document, widthBeforeSet, widthAfterSet ) {
		assert.expect( 2 );
		assert.strictEqual( widthBeforeSet, "100px", "elem.css('width') works correctly with browser zoom" );
		assert.strictEqual( widthAfterSet, "100px", "elem.css('width', val) works correctly with browser zoom" );
	}
);

QUnit.testUnlessIE( "css('width') and css('height') should return fractional values for nodes in the document", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "<div class='test-div'></div>" ).appendTo( "#qunit-fixture" );
	jQuery( "<style>.test-div { width: 33.3px; height: 88.8px; }</style>" ).appendTo( "#qunit-fixture" );

	assert.equal( Number( el.css( "width" ).replace( /px$/, "" ) ).toFixed( 1 ), "33.3",
		"css('width') should return fractional values" );
	assert.equal( Number( el.css( "height" ).replace( /px$/, "" ) ).toFixed( 1 ), "88.8",
		"css('height') should return fractional values" );
} );

QUnit.testUnlessIE( "css('width') and css('height') should return fractional values for disconnected nodes", function( assert ) {
	assert.expect( 2 );

	var el = jQuery( "<div style='width: 33.3px; height: 88.8px;'></div>" );

	assert.equal( Number( el.css( "width" ).replace( /px$/, "" ) ).toFixed( 1 ), "33.3",
		"css('width') should return fractional values" );
	assert.equal( Number( el.css( "height" ).replace( /px$/, "" ) ).toFixed( 1 ), "88.8",
		"css('height') should return fractional values" );
} );

QUnit.test( "certain css values of 'normal' should be convertable to a number, see #8627", function( assert ) {
	assert.expect( 3 );

	var el = jQuery( "<div style='letter-spacing:normal;font-weight:normal;'>test</div>" ).appendTo( "#qunit-fixture" );

	assert.ok( !isNaN( parseFloat( el.css( "letterSpacing" ) ) ), "css('letterSpacing') not convertable to number, see #8627" );
	assert.ok( !isNaN( parseFloat( el.css( "fontWeight" ) ) ), "css('fontWeight') not convertable to number, see #8627" );
	assert.equal( typeof el.css( "fontWeight" ), "string", ".css() returns a string" );
} );

QUnit.test( "cssHooks - expand", function( assert ) {
diff --git a/a.js b/b.js
@@ -1459,7 +1459,7 @@ QUnit.test( "cssHooks - expand", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
	assert.ok( !isNaN( parseFloat( el.css( "letterSpacing" ) ) ), "css('letterSpacing') not convertable to number, see #8627" );
	assert.ok( !isNaN( parseFloat( el.css( "fontWeight" ) ) ), "css('fontWeight') not convertable to number, see #8627" );
	assert.equal( typeof el.css( "fontWeight" ), "string", ".css() returns a string" );
} );

QUnit.test( "cssHooks - expand", function( assert ) {
	assert.expect( 15 );
	var result,
		properties = {
			margin: [ "marginTop", "marginRight", "marginBottom", "marginLeft" ],
			borderWidth: [ "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth" ],
			padding: [ "paddingTop", "paddingRight", "paddingBottom", "paddingLeft" ]
		};

	jQuery.each( properties, function( property, keys ) {
		var hook = jQuery.cssHooks[ property ],
			expected = {};
		jQuery.each( keys, function( _, key ) {
			expected[ key ] = 10;
		} );
		result = hook.expand( 10 );
		assert.deepEqual( result, expected, property + " expands properly with a number" );

		jQuery.each( keys, function( _, key ) {
			expected[ key ] = "10px";
		} );
		result = hook.expand( "10px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px'" );

		expected[ keys[ 1 ] ] = expected[ keys[ 3 ] ] = "20px";
		result = hook.expand( "10px 20px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px'" );

		expected[ keys[ 2 ] ] = "30px";
		result = hook.expand( "10px 20px 30px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px 30px'" );

		expected[ keys[ 3 ] ] = "40px";
		result = hook.expand( "10px 20px 30px 40px" );
		assert.deepEqual( result, expected, property + " expands properly with '10px 20px 30px 40px'" );

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );
diff --git a/a.js b/b.js
@@ -1487,8 +1487,8 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
diff --git a/a.js b/b.js
@@ -1507,9 +1507,9 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( "display", "block" );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );

	assert.ok( jQuery( "#siblingspan" ).is( ":visible" ), "Span with no content is visible" );
	$div = jQuery( "<div><span></span></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( $div.find( ":visible" ).length, 1, "Span with no content is visible" );
	$div.css( { width: 0, height: 0, overflow: "hidden" } );
	assert.ok( $div.is( ":visible" ), "Div with width and height of 0 is still visible (gh-2227)" );

	$br = jQuery( "<br/>" ).appendTo( "#qunit-fixture" );
	assert.ok( $br.is( ":visible" ), "br element is visible" );

	$table = jQuery( "#table" );
	$table.html( "<tr><td style='display:none'>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 1, "hidden cell is not perceived as visible (#4512). Works on table elements" );
	$table.css( "display", "none" ).html( "<tr><td>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 0, "hidden cell children not perceived as visible (#4512)" );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Is Visible", "#qunit-fixture div:visible:lt(2)", [ "foo", "nothiddendiv" ] );
	} else {
diff --git a/a.js b/b.js
@@ -1524,7 +1524,7 @@ QUnit.test( "css opacity consistency across browsers (#12685)", function( assert
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

	} );

} );

QUnit.test( "css opacity consistency across browsers (#12685)", function( assert ) {
	assert.expect( 3 );

	var el,
		fixture = jQuery( "#qunit-fixture" );

	// Append style element
	jQuery( "<style>.opacity_t12685 { opacity: 0.1; }</style>" ).appendTo( fixture );

	el = jQuery( "<div class='opacity_t12685'></div>" ).appendTo( fixture );

	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "opacity from style sheet" );
	el.css( "opacity", 0.3 );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 30, "override opacity" );
	el.css( "opacity", "" );
	assert.equal( Math.round( el.css( "opacity" ) * 100 ), 10, "remove opacity override" );
} );

QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( ":visible/:hidden selectors", function( assert ) {
	assert.expect( 18 );

	var $div, $table, $a, $br;

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( { display: "none" } );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( { "display": "block" } );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );
	assert.ok( !jQuery( window ).is( ":visible" ), "Calling is(':visible') on window does not throw an exception (#10267)." );
	assert.ok( !jQuery( document ).is( ":visible" ), "Calling is(':visible') on document does not throw an exception (#10267)." );

	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modifying CSS display: Assert element is visible" );
	jQuery( "#nothiddendiv" ).css( "display", "none" );
	assert.ok( !jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is hidden" );
	jQuery( "#nothiddendiv" ).css( "display", "block" );
	assert.ok( jQuery( "#nothiddendiv" ).is( ":visible" ), "Modified CSS display: Assert element is visible" );

	assert.ok( jQuery( "#siblingspan" ).is( ":visible" ), "Span with no content is visible" );
	$div = jQuery( "<div><span></span></div>" ).appendTo( "#qunit-fixture" );
	assert.equal( $div.find( ":visible" ).length, 1, "Span with no content is visible" );
	$div.css( { width: 0, height: 0, overflow: "hidden" } );
	assert.ok( $div.is( ":visible" ), "Div with width and height of 0 is still visible (gh-2227)" );

	$br = jQuery( "<br/>" ).appendTo( "#qunit-fixture" );
	assert.ok( $br.is( ":visible" ), "br element is visible" );

	$table = jQuery( "#table" );
	$table.html( "<tr><td style='display:none'>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 1, "hidden cell is not perceived as visible (#4512). Works on table elements" );
	$table.css( "display", "none" ).html( "<tr><td>cell</td><td>cell</td></tr>" );
	assert.equal( jQuery( "#table td:visible" ).length, 0, "hidden cell children not perceived as visible (#4512)" );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Is Visible", "#qunit-fixture div:visible:lt(2)", [ "foo", "nothiddendiv" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Is Not Hidden", "#qunit-fixture:hidden", [] );
	assert.t( "Is Hidden", "#form input:hidden", [ "hidden1", "hidden2" ] );

	$a = jQuery( "<a href='#'><h1>Header</h1></a>" ).appendTo( "#qunit-fixture" );
	assert.ok( $a.is( ":visible" ), "Anchor tag with flow content is visible (gh-2227)" );
} );

QUnit.test( "Keep the last style if the new one isn't recognized by the browser (#14836)", function( assert ) {
	assert.expect( 1 );

	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", "fake value" );
	assert.equal( el.css( "position" ), "absolute", "The old style is kept when setting an unrecognized value" );
diff --git a/a.js b/b.js
@@ -1551,46 +1551,38 @@ QUnit.test( "Reset the style if set to an empty string", function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", " " );
	assert.equal( el.css( "position" ), "absolute", "The old style is kept when setting to a space" );
} );

QUnit.test( "Reset the style if set to an empty string", function( assert ) {
	assert.expect( 1 );
	var el = jQuery( "<div></div>" ).css( "position", "absolute" ).css( "position", "" );

	// Some browsers return an empty string; others "static". Both those cases mean the style
	// was reset successfully so accept them both.
	assert.equal( el.css( "position" ) || "static", "static",
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
				name: "backgroundAttachment",
				value: [ "fixed" ],
				expected: [ "scroll" ]
			}, {
				name: "backgroundColor",
				value: [ "rgb(255, 0, 0)", "rgb(255,0,0)", "#ff0000" ],
				expected: [ "transparent" ]
			}, {

				// Firefox returns auto's value
				name: "backgroundImage",
				value: [ "url('test.png')", "url(" + baseURL + "test.png)", "url(\"" + baseURL + "test.png\")" ],
				expected: [ "none", "url(\"https://static.jquery.com/files/rocker/images/logo_jquery_215x53.gif\")" ]
			}, {
				name: "backgroundPosition",
				value: [ "5% 5%" ],
				expected: [ "0% 0%", "-1000px 0px", "-1000px 0%" ]
			}, {

				// Firefox returns no-repeat
				name: "backgroundRepeat",
				value: [ "repeat-y" ],
				expected: [ "repeat", "no-repeat" ]
			}, {
				name: "backgroundClip",
				value: [ "padding-box" ],
				expected: [ "border-box" ]
			}, {
				name: "backgroundOrigin",
				value: [ "content-box" ],
				expected: [ "padding-box" ]
			}, {
				name: "backgroundSize",
				value: [ "80px 60px" ],
				expected: [ "auto auto" ]
		} ];

		jQuery.each( styles, function( index, style ) {
			var $clone, $clonedChildren,
diff --git a/a.js b/b.js
@@ -1599,8 +1591,6 @@ function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
				name: "backgroundAttachment",
				value: [ "fixed" ],
				expected: [ "scroll" ]
			}, {
				name: "backgroundColor",
				value: [ "rgb(255, 0, 0)", "rgb(255,0,0)", "#ff0000" ],
				expected: [ "transparent" ]
			}, {

				// Firefox returns auto's value
				name: "backgroundImage",
				value: [ "url('test.png')", "url(" + baseURL + "test.png)", "url(\"" + baseURL + "test.png\")" ],
				expected: [ "none", "url(\"https://static.jquery.com/files/rocker/images/logo_jquery_215x53.gif\")" ]
			}, {
				name: "backgroundPosition",
				value: [ "5% 5%" ],
				expected: [ "0% 0%", "-1000px 0px", "-1000px 0%" ]
			}, {

				// Firefox returns no-repeat
				name: "backgroundRepeat",
				value: [ "repeat-y" ],
				expected: [ "repeat", "no-repeat" ]
			}, {
				name: "backgroundClip",
				value: [ "padding-box" ],
				expected: [ "border-box" ]
			}, {
				name: "backgroundOrigin",
				value: [ "content-box" ],
				expected: [ "padding-box" ]
			}, {
				name: "backgroundSize",
				value: [ "80px 60px" ],
				expected: [ "auto auto" ]
		} ];

		jQuery.each( styles, function( index, style ) {
			var $clone, $clonedChildren,
				$source = jQuery( "#firstp" ),
				source = $source[ 0 ],
				$children = $source.children();

			style.expected = style.expected.concat( [ "", "auto" ] );

			if ( source.style[ style.name ] === undefined ) {
				assert.ok( true, style.name +  ": style isn't supported and therefore not an issue" );
				assert.ok( true );

diff --git a/a.js b/b.js
@@ -1636,7 +1626,7 @@ function( assert ) {
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
		"The style can be reset by setting to an empty string" );
} );

QUnit.test(
	"Clearing a Cloned Element's Style Shouldn't Clear the Original Element's Style (#8908)",
	function( assert ) {
		assert.expect( 24 );
		var done = assert.async();
		var styles = [ {
				name: "backgroundAttachment",
				value: [ "fixed" ],
				expected: [ "scroll" ]
			}, {
				name: "backgroundColor",
				value: [ "rgb(255, 0, 0)", "rgb(255,0,0)", "#ff0000" ],
				expected: [ "transparent" ]
			}, {

				// Firefox returns auto's value
				name: "backgroundImage",
				value: [ "url('test.png')", "url(" + baseURL + "test.png)", "url(\"" + baseURL + "test.png\")" ],
				expected: [ "none", "url(\"https://static.jquery.com/files/rocker/images/logo_jquery_215x53.gif\")" ]
			}, {
				name: "backgroundPosition",
				value: [ "5% 5%" ],
				expected: [ "0% 0%", "-1000px 0px", "-1000px 0%" ]
			}, {

				// Firefox returns no-repeat
				name: "backgroundRepeat",
				value: [ "repeat-y" ],
				expected: [ "repeat", "no-repeat" ]
			}, {
				name: "backgroundClip",
				value: [ "padding-box" ],
				expected: [ "border-box" ]
			}, {
				name: "backgroundOrigin",
				value: [ "content-box" ],
				expected: [ "padding-box" ]
			}, {
				name: "backgroundSize",
				value: [ "80px 60px" ],
				expected: [ "auto auto" ]
		} ];

		jQuery.each( styles, function( index, style ) {
			var $clone, $clonedChildren,
				$source = jQuery( "#firstp" ),
				source = $source[ 0 ],
				$children = $source.children();

			style.expected = style.expected.concat( [ "", "auto" ] );

			if ( source.style[ style.name ] === undefined ) {
				assert.ok( true, style.name +  ": style isn't supported and therefore not an issue" );
				assert.ok( true );

				return true;
			}

			$source.css( style.name, style.value[ 0 ] );
			$children.css( style.name, style.value[ 0 ] );

			$clone = $source.clone();
			$clonedChildren = $clone.children();

			$clone.css( style.name, "" );
			$clonedChildren.css( style.name, "" );

			window.setTimeout( function() {
				assert.notEqual( $clone.css( style.name ), style.value[ 0 ], "Cloned css was changed" );

				assert.ok( jQuery.inArray( $source.css( style.name ) !== -1, style.value ),
					"Clearing clone.css() doesn't affect source.css(): " + style.name +
					"; result: " + $source.css( style.name ) +
					"; expected: " + style.value.join( "," ) );

				assert.ok( jQuery.inArray( $children.css( style.name ) !== -1, style.value ),
					"Clearing clonedChildren.css() doesn't affect children.css(): " + style.name +
					"; result: " + $children.css( style.name ) +
					"; expected: " + style.value.join( "," ) );
			}, 100 );
		} );

		window.setTimeout( done, 1000 );
	}
);

QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert ) {
	assert.expect( 1 );

	var $elem = jQuery( "<div></div>" );

diff --git a/a.js b/b.js
@@ -1645,7 +1635,7 @@ QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963

		window.setTimeout( done, 1000 );
	}
);

QUnit.test( "Don't append px to CSS \"order\" value (#14049)", function( assert ) {
	assert.expect( 1 );

	var $elem = jQuery( "<div></div>" );

	$elem.css( "order", 2 );
	assert.equal( $elem.css( "order" ), "2", "2 on order" );
} );

QUnit.test( "Do not throw on frame elements from css method (#15098)", function( assert ) {
	assert.expect( 1 );

	var frameWin, frameDoc,
		frameElement = document.createElement( "iframe" ),
diff --git a/a.js b/b.js
@@ -1748,9 +1738,16 @@ jQuery( "#qunit-fixture" ).append(
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
} )();

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "css(--customProperty)", function( assert ) {

	jQuery( "#qunit-fixture" ).append(
		"<style>\n" +
		"    .test__customProperties {\n" +
		"        --prop1:val1;\n" +
		"        --prop2: val2;\n" +
		"        --prop3:val3 ;\n" +
		"        --prop4:\"val4\";\n" +
		"        --prop5:'val5';\n" +
		"    }\n" +
		"</style>"
	);

diff --git a/a.js b/b.js
@@ -1759,7 +1756,7 @@ jQuery( "#qunit-fixture" ).append(
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
} )();

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "css(--customProperty)", function( assert ) {

	jQuery( "#qunit-fixture" ).append(
		"<style>\n" +
		"    .test__customProperties {\n" +
		"        --prop1:val1;\n" +
		"        --prop2: val2;\n" +
		"        --prop3:val3 ;\n" +
		"        --prop4:\"val4\";\n" +
		"        --prop5:'val5';\n" +
		"    }\n" +
		"</style>"
	);

	var div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		$elem = jQuery( "<div>" ).addClass( "test__customProperties" )
			.appendTo( "#qunit-fixture" ),
		webkitOrBlink = /\bsafari\b/i.test( navigator.userAgent ),
		expected = 10;

	if ( webkitOrBlink ) {
		expected -= 2;
	}
diff --git a/a.js b/b.js
@@ -1787,16 +1784,24 @@ jQuery( "#qunit-fixture" ).append(
A blob:6d2983f87e9dc7b8a094024d1fc60dab6e653963
} )();

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "css(--customProperty)", function( assert ) {

	jQuery( "#qunit-fixture" ).append(
		"<style>\n" +
		"    .test__customProperties {\n" +
		"        --prop1:val1;\n" +
		"        --prop2: val2;\n" +
		"        --prop3:val3 ;\n" +
		"        --prop4:\"val4\";\n" +
		"        --prop5:'val5';\n" +
		"    }\n" +
		"</style>"
	);

	var div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		$elem = jQuery( "<div>" ).addClass( "test__customProperties" )
			.appendTo( "#qunit-fixture" ),
		webkitOrBlink = /\bsafari\b/i.test( navigator.userAgent ),
		expected = 10;

	if ( webkitOrBlink ) {
		expected -= 2;
	}
	assert.expect( expected );

	div.css( "--color", "blue" );
	assert.equal( div.css( "--color" ), "blue", "Modified CSS custom property using string" );

	div.css( "--color", "yellow" );
	assert.equal( div.css( "--color" ), "yellow", "Overwrite CSS custom property" );

	div.css( { "--color": "red" } );
	assert.equal( div.css( "--color" ), "red", "Modified CSS custom property using object" );

	div.css( { "--mixedCase": "green" } );
	div.css( { "--mixed-case": "red" } );
	assert.equal( div.css( "--mixedCase" ), "green",
		"Modified CSS custom property with mixed case" );

	div.css( { "--theme-dark": "purple" } );
	div.css( { "--themeDark": "red" } );
	assert.equal( div.css( "--theme-dark" ), "purple",
		"Modified CSS custom property with dashed name" );

	assert.equal( $elem.css( "--prop1" ), "val1", "Basic CSS custom property" );

	assert.equal( $elem.css( "--prop2" ), " val2", "Preceding whitespace maintained" );
	assert.equal( $elem.css( "--prop3" ), "val3 ", "Following whitespace maintained" );

	// Support: Chrome <=49 - 73+, Safari <=9.1 - 12.1+
	// Chrome treats single quotes as double ones.
	// Safari treats double quotes as single ones.
	if ( !webkitOrBlink ) {
		assert.equal( $elem.css( "--prop4" ), "\"val4\"", "Works with double quotes" );
		assert.equal( $elem.css( "--prop5" ), "'val5'", "Works with single quotes" );
	}
} );

// IE doesn't support CSS variables.
QUnit.testUnlessIE( "Don't append px to CSS vars", function( assert ) {
diff --git a/a.js b/b.js
@@ -369,15 +369,15 @@ handlers: function( event, handlers ) {
A blob:48ee8d174b39bf0ee17d4b88d97457662855bc11
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: Firefox <=42 - 66+
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11+
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
diff --git a/a.js b/b.js
@@ -746,10 +746,10 @@ stopImmediatePropagation: function() {
A blob:48ee8d174b39bf0ee17d4b88d97457662855bc11

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur as it's already being fired
		// in leverageNative.
		_default: function() {
			return true;
		},

		delegateType: delegateType
	};
diff --git a/a.js b/b.js
@@ -8,7 +8,7 @@ beforeEach: function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
QUnit.module( "event", {
	beforeEach: function() {
		document.body.focus();
	},
	afterEach: moduleTeardown
} );

QUnit.test( "null or undefined handler", function( assert ) {
	assert.expect( 4 );

	// Supports Fixes bug #7229
	try {
		jQuery( "#firstp" ).on( "click", null );
		assert.ok( true, "Passing a null handler will not throw an exception" );
	} catch ( e ) {}
diff --git a/a.js b/b.js
@@ -484,7 +484,7 @@ 		neverCallMe = function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
QUnit.test( "trigger() works with events that were previously stopped", function( assert ) {
	assert.expect( 0 );

	var $button = jQuery( "#button" ),
		$parent = $button.parent(),
		neverCallMe = function() {
			assert.ok( false, "propagation should have been stopped" );
		};

	$parent[ 0 ].addEventListener( "click", neverCallMe );
	$button.on( "click", neverCallMe );

	var clickEvent =  jQuery.Event( "click" );
	clickEvent.stopPropagation();
	$button.trigger( clickEvent );

	$parent[ 0 ].removeEventListener( "click", neverCallMe );
	$button.off( "click", neverCallMe );
} );


QUnit.test( "on(), iframes", function( assert ) {
	assert.expect( 1 );

	// events don't work with iframes, see #939 - this test fails in IE because of contentDocument
	var doc = jQuery( "#loadediframe" ).contents();

	jQuery( "div", doc ).on( "click", function() {
		assert.ok( true, "Binding to element inside iframe" );
diff --git a/a.js b/b.js
@@ -552,7 +552,7 @@ jQuery( "#nonnodes" ).contents().on( "tester", function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac

	// Try triggering the custom event (0)
	firstp.trigger( "custom" );

	// using contents will get comments regular, text, and comment nodes
	jQuery( "#nonnodes" ).contents().on( "tester", function() {
		assert.equal( this.nodeType, 1, "Check node,textnode,comment on just does real nodes" );
	} ).trigger( "tester" );

	// Make sure events stick with appendTo'd elements (which are cloned) #2027
	jQuery( "<a href='#fail' class='test'>test</a>" ).on( "click", function() { return false; } ).appendTo( "#qunit-fixture" );
	assert.ok( jQuery( "a.test" ).eq( 0 ).triggerHandler( "click" ) === false, "Handler is bound to appendTo'd elements" );
} );

diff --git a/a.js b/b.js
@@ -589,7 +589,7 @@ jQuery( "#firstp" ).on( "click.test.abc", function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac

	jQuery( "#firstp" ).on( "click.test", function() {
		check( "click.test", "Normal click triggered" );
	} );

	jQuery( "#firstp" ).on( "click.test.abc", function() {
		check( "click.test.abc", "Namespaced click triggered" );
	} );

	// Those would not trigger/off (#5303)
	jQuery( "#firstp" ).trigger( "click.a.test" );
	jQuery( "#firstp" ).off( "click.a.test" );

	// Trigger both bound fn (1)
diff --git a/a.js b/b.js
@@ -812,7 +812,7 @@ QUnit.test( "off(type)", function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	assert.equal( obj && obj[ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ][ "events" ], undefined, "Make sure events object is removed" );
} );

QUnit.test( "off(type)", function( assert ) {
	assert.expect( 1 );

	var message, func,
		$elem = jQuery( "#firstp" );

	function error() {
		assert.ok( false, message );
	}

	message = "unbind passing function";
	$elem.on( "error1", error ).off( "error1", error ).triggerHandler( "error1" );

	message = "unbind all from event";
	$elem.on( "error1", error ).off( "error1" ).triggerHandler( "error1" );

	message = "unbind all";
	$elem.on( "error1", error ).off().triggerHandler( "error1" );

	message = "unbind many with function";
	$elem.on( "error1 error2", error )
		.off( "error1 error2", error )
		.trigger( "error1" ).triggerHandler( "error2" );

	message = "unbind many"; // #3538
	$elem.on( "error1 error2", error )
		.off( "error1 error2" )
		.trigger( "error1" ).triggerHandler( "error2" );

diff --git a/a.js b/b.js
@@ -1041,7 +1041,7 @@ 	$elem[ 0 ].click = function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	// Triggers handlers and native
	// Trigger 5
	$elem.on( "click", handler ).trigger( "click", [ 1, "2", "abc" ] );

	// Simulate a "native" click
	$elem[ 0 ].click = function() {
		assert.ok( false, "Native call was triggered" );
	};

	// Trigger only the handlers (no native)
	// Triggers 5
	assert.equal( $elem.triggerHandler( "click", [ 1, "2", "abc" ] ), "test", "Verify handler response" );

	pass = true;
	try {
		elem2 = jQuery( "#form input" ).eq( 0 );
		elem2.get( 0 ).style.display = "none";
		elem2.trigger( "focus" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger focus on hidden element" );

	pass = true;
	try {
		jQuery( "#qunit-fixture table" ).eq( 0 ).on( "test:test", function() {} ).trigger( "test:test" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger on a table with a colon in the even type, see #3533" );

	form = jQuery( "<form action=''></form>" ).appendTo( "body" );

	// Make sure it can be prevented locally
diff --git a/a.js b/b.js
@@ -1069,7 +1069,7 @@ jQuery( document ).on( "submit", function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	// Trigger 1
	form.trigger( "submit" );

	form.off( "submit" );

	jQuery( document ).on( "submit", function() {
		assert.ok( true, "Make sure bubble works up to document." );
		return false;
	} );

	// Trigger 1
	form.trigger( "submit" );

	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
diff --git a/a.js b/b.js
@@ -1105,7 +1105,7 @@ QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
		$fixture = jQuery( "#qunit-fixture" ),
		$wrapperDiv = jQuery( "<div></div>" ).appendTo( $fixture );

	function noSubmit( e ) {
		e.preventDefault();
	}
	function delegatedSubmit() {
		assert.ok( true, "Make sure submit event bubbles up." );
		return false;
	}

	// Attach a delegated submit handler to the parent element
	$fixture.on( "submit", "form", delegatedSubmit );

	// Trigger form submission to introduce the _submit_attached property
	$testForm.on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Copy the form via .clone() and .html()
	$formByClone = $testForm.clone( true, true ).removeAttr( "id" );
	$formByHTML = jQuery( jQuery.parseHTML( $fixture.html() ) ).filter( "#testForm" ).removeAttr( "id" );
	$wrapperDiv.append( $formByClone, $formByHTML );

	// Check submit bubbling on the copied forms
	$wrapperDiv.find( "form" ).on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "submit", "form", delegatedSubmit );
	$testForm.off( "submit", noSubmit );
} );

QUnit.test( "change event bubbles on copied forms (#11796)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$form = jQuery( "#form" ),
diff --git a/a.js b/b.js
@@ -1227,7 +1227,7 @@ QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "change", "form", delegatedChange );
} );

QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
	assert.expect( 28 );

	var event,
		$parent = jQuery( "<div id='par'></div>" ).appendTo( "body" ),
		$child = jQuery( "<p id='child'>foo</p>" ).appendTo( $parent );

	$parent.get( 0 ).style.display = "none";

	event = jQuery.Event( "noNew" );
	assert.ok( event !== window, "Instantiate jQuery.Event without the 'new' keyword" );
	assert.equal( event.type, "noNew", "Verify its type" );

	assert.equal( event.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
	assert.equal( event.isPropagationStopped(), false, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

	event.preventDefault();
	assert.equal( event.isDefaultPrevented(), true, "Verify isDefaultPrevented" );
	event.stopPropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );

	event.isPropagationStopped = function() { return false; };
	event.stopImmediatePropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), true, "Verify isPropagationStopped" );

	$parent.on( "foo", function( e ) {

		// Tries bubbling
		assert.equal( e.type, "foo", "Verify event type when passed passing an event object" );
		assert.equal( e.target.id, "child", "Verify event.target when passed passing an event object" );
		assert.equal( e.currentTarget.id, "par", "Verify event.currentTarget when passed passing an event object" );
		assert.equal( e.secret, "boo!", "Verify event object's custom attribute when passed passing an event object" );
	} );

	// test with an event object
	event = new jQuery.Event( "foo" );
	event.secret = "boo!";
	$child.trigger( event );

	// test with a literal object
	$child.trigger( { "type": "foo", "secret": "boo!" } );

	$parent.off();

	function error() {
		assert.ok( false, "This assertion shouldn't be reached" );
	}

	$parent.on( "foo", error );

	$child.on( "foo", function( e, a, b, c ) {
		assert.equal( arguments.length, 4, "Check arguments length" );
		assert.equal( a, 1, "Check first custom argument" );
		assert.equal( b, 2, "Check second custom argument" );
		assert.equal( c, 3, "Check third custom argument" );

		assert.equal( e.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
		assert.equal( e.isPropagationStopped(), false, "Verify isPropagationStopped" );
		assert.equal( e.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

		// Skips both errors
		e.stopImmediatePropagation();

		return "result";
	} );

	// We should add this back in when we want to test the order
	// in which event handlers are iterated.
	//$child.on("foo", error );

	event = new jQuery.Event( "foo" );
	$child.trigger( event, [ 1, 2, 3 ] ).off();
	assert.equal( event.result, "result", "Check event.result attribute" );

	// Will error if it bubbles
	$child.triggerHandler( "foo" );

	$child.off();
	$parent.off().remove();

	// Ensure triggerHandler doesn't molest its event object (#xxx)
	event = jQuery.Event( "zowie" );
	jQuery( document ).triggerHandler( event );
	assert.equal( event.type, "zowie", "Verify its type" );
	assert.equal( event.isPropagationStopped(), false, "propagation not stopped" );
	assert.equal( event.isDefaultPrevented(), false, "default not prevented" );
} );

QUnit.test( ".trigger() bubbling on disconnected elements (#10489)", function( assert ) {
	assert.expect( 2 );

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
diff --git a/a.js b/b.js
@@ -1251,7 +1251,7 @@ jQuery( "<div><p>hi</p></div>" )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
	} );

	jQuery( "<div><p>hi</p></div>" )
		.on( "click", function() {
			assert.ok( true, "click fired on div" );
		} )
		.find( "p" )
			.on( "click", function() {
				assert.ok( true, "click fired on p" );
			} )
			.trigger( "click" )
			.off( "click" )
		.end()
		.off( "click" )
		.remove();

	jQuery( window ).off( "click" );
} );

QUnit.test( ".trigger() doesn't bubble load event (#10717)", function( assert ) {
	assert.expect( 1 );

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
diff --git a/a.js b/b.js
@@ -1269,7 +1269,7 @@ jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
	} );

	jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
		.appendTo( "body" )
		.on( "load", function() {
			assert.ok( true, "load fired on img" );
		} )
		.trigger( "load" )
		.remove();

	jQuery( window ).off( "load" );
} );

QUnit.test( "Delegated events in SVG (#10791; #13180)", function( assert ) {
	assert.expect( 2 );

	var useElem, e,
		svg = jQuery(
diff --git a/a.js b/b.js
@@ -1295,7 +1295,7 @@ jQuery( "#qunit-fixture" )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
			"<rect id='svg-by-id' x='10' y='20' width='100' height='60' r='10' rx='10' ry='10'></rect>" +
			"<use id='use' xlink:href='#ref'></use>" +
			"</svg>"
		);

	jQuery( "#qunit-fixture" )
		.append( svg )
		.on( "click", "#svg-by-id", function() {
			assert.ok( true, "delegated id selector" );
		} )
		.on( "click", "[class~='svg-by-class']", function() {
			assert.ok( true, "delegated class selector" );
		} )
		.find( "#svg-by-id, [class~='svg-by-class']" )
			.trigger( "click" )
		.end();

	// Fire a native click on an SVGElementInstance (the instance tree of an SVG <use>)
	// to confirm that it doesn't break our event delegation handling (#13180)
	useElem = svg.find( "#use" )[ 0 ];
	if ( document.createEvent && useElem && useElem.instanceRoot ) {
		e = document.createEvent( "MouseEvents" );
		e.initEvent( "click", true, true );
diff --git a/a.js b/b.js
@@ -1321,7 +1321,7 @@ QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( ass
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	}

	jQuery( "#qunit-fixture" ).off( "click" );
} );

QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( assert ) {
	assert.expect( 3 );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", ":not", function() {} );
	}, "malformed selector throws on attach" );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", "nonexistent:not", function() {} );
	}, "short-circuitable malformed selector throws on attach" );

	jQuery( "#foo > :first-child" ).trigger( "click" );
	assert.ok( true, "malformed selector does not throw on event" );
} );

QUnit.test( "Delegated events in forms (#10844; #11145; #8165; #11382, #11764)", function( assert ) {
	assert.expect( 5 );

	// Alias names like "id" cause havoc
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ jQuery( "body" )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form.append( "<input type='text' name='disabled' value='differently abled' />" );
	jQuery( "body" )
		.on( "submit", "#myform", function() {
			assert.ok( true, "delegated id selector with aliased disabled" );
		} )
		.find( "#myform" )
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form
		.append( "<button id='nestyDisabledBtn'><span>Zing</span></button>" )
		.on( "click", "#nestyDisabledBtn", function() {
			assert.ok( true, "click on enabled/disabled button with nesty elements" );
		} )
		.on( "mouseover", "#nestyDisabledBtn", function() {
			assert.ok( true, "mouse on enabled/disabled button with nesty elements" );
		} )
		.find( "span" )
			.trigger( "click" )		// yep
			.trigger( "mouseover" )	// yep
		.end()
		.find( "#nestyDisabledBtn" ).prop( "disabled", true ).end()
		.find( "span" )
			.trigger( "click" )		// nope
			.trigger( "mouseover" )	// yep
		.end()
		.off( "click" );

	form.remove();
} );

QUnit.test( "Submit event can be stopped (#11049)", function( assert ) {
	assert.expect( 1 );

	// Since we manually bubble in IE, make sure inner handlers get a chance to cancel
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1450,7 +1450,7 @@ 			handler = function( event ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
QUnit.test( "jQuery.Event( type, props )", function( assert ) {

	assert.expect( 6 );

	var event = jQuery.Event( "keydown", { keyCode: 64 } ),
			handler = function( event ) {
				assert.ok( "keyCode" in event, "Special property 'keyCode' exists" );
				assert.equal( event.keyCode, 64, "event.keyCode has explicit value '64'" );
			};

	// Supports jQuery.Event implementation
	assert.equal( event.type, "keydown", "Verify type" );

	// ensure "type" in props won't clobber the one set by constructor
	assert.equal( jQuery.inArray( "type", jQuery.event.props ), -1, "'type' property not in props (#10375)" );

	assert.ok( "keyCode" in event, "Special 'keyCode' property exists" );

	assert.strictEqual( jQuery.isPlainObject( event ), false, "Instances of $.Event should not be identified as a plain object." );
diff --git a/a.js b/b.js
@@ -1844,7 +1844,7 @@ function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
diff --git a/a.js b/b.js
@@ -1859,7 +1859,7 @@ function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
diff --git a/a.js b/b.js
@@ -1879,7 +1879,7 @@ function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
			.find( "#ul0" )
				.on( "click", "li:first>a", function() {
					assert.ok( this.id === "a0_0", "first li under #u10 was clicked" );
				} )
			.end()
			.find( "a" ).trigger( "click" ).end()
			.find( "#ul0" ).off();
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	markup.remove();
} );

QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

diff --git a/a.js b/b.js
@@ -1893,7 +1893,7 @@ jQuery( "#foo" ).on( "click", "toString", function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

	jQuery( "#foo" ).on( "click", "toString", function() {
		matched++;
	} );

	jQuery( "#anchor2" ).trigger( "click" );

	assert.equal( matched, 0, "Nothing matched 'toString'" );
} );

QUnit.test( "delegated event with intermediate DOM manipulation (#13208)", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" ).on( "click", "[id=sap]", function() {} );
	jQuery( "#sap" ).on( "click", "[id=anchor2]", function() {
diff --git a/a.js b/b.js
@@ -2187,7 +2187,7 @@ jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		order = 0;

	// focus the element so DOM focus won't fire
	input[ 0 ].focus();

	jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
		assert.equal( 1, order++, "focusin on the body second" );
	} );

	input.on( "focusin.focusinBubblesTest", function() {
		assert.equal( 0, order++, "focusin on the element first" );
	} );

// Removed since DOM focus is unreliable on test swarm
	// DOM focus method
//	input[0].focus();

	// To make the next focus test work, we need to take focus off the input.
	// This will fire another focusin event, so set order to reflect that.
//	order = 1;
//	jQuery("#text1")[0].focus();

	// jQuery trigger, which calls DOM focus
	order = 0;
	input.trigger( "focus" );

	input.remove();
	jQuery( "body" ).off( "focusin.focusinBubblesTest" );
} );

QUnit.test( "custom events with colons (#3533, #8272)", function( assert ) {
	assert.expect( 1 );

	var tab = jQuery( "<table><tr><td>trigger</td></tr></table>" ).appendTo( "body" );
	try {
diff --git a/a.js b/b.js
@@ -2370,7 +2370,7 @@ jQuery( "<p>Gut Feeling</p>" )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		.off( ".Devo" )
		.trigger( "gutfeeling" )
		.remove();

	// Ensure .one() events are removed after their maiden voyage
	jQuery( "<p>Gut Feeling</p>" )
		.one( "gutfeeling", jQuery.noop )
		.trigger( "gutfeeling" )	// This one should
		.trigger( "gutfeeling" )	// This one should not
		.remove();

	delete jQuery.event.special[ "gutfeeling" ];
} );

QUnit.test( ".on and .off, selective mixed removal (#10705)", function( assert ) {
	assert.expect( 7 );

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
diff --git a/a.js b/b.js
@@ -2392,7 +2392,7 @@ jQuery( "<p>Strange Pursuit</p>" )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
	};

	jQuery( "<p>Strange Pursuit</p>" )
		.on( "click", timingx )
		.on( "click.duty", timingx )
		.on( "click.now", timingx )
		.on( "devo", timingx )
		.on( "future", timingx )
		.trigger( "click" )		// 3
		.trigger( "devo" )		// 1
		.off( ".duty devo " )	// trailing space
		.trigger( "future" )	// 1
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
diff --git a/a.js b/b.js
@@ -2408,7 +2408,7 @@ QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
		data = "bar",
		map = {
			"foo": function( event ) {
				assert.equal( event.data, "bar", "event.data correctly relayed with null selector" );
				$p.remove();
			}
		};

	$p.on( map, null, data ).trigger( "foo" );
} );

QUnit.test( "clone() delegated events (#11076)", function( assert ) {
	assert.expect( 3 );

	var counter = { "center": 0, "fold": 0, "centerfold": 0 },
		clicked = function() {
diff --git a/a.js b/b.js
@@ -2745,7 +2745,7 @@ QUnit.test( "trigger click on checkbox, fires change event", function( assert )
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	$fixture.remove();

	jQuery.removeEvent = originRemoveEvent;
} );

QUnit.test( "trigger click on checkbox, fires change event", function( assert ) {
	assert.expect( 1 );

	var check = jQuery( "#check2" );
	var done = assert.async();

	check.on( "change", function() {

		// get it?
		check.off( "change" );
		assert.ok( true, "Change event fired as a result of triggered click" );
		done();
	} ).trigger( "click" );
} );

QUnit.test( "Namespace preserved when passed an Event (#12739)", function( assert ) {
	assert.expect( 4 );

	var markup = jQuery(
			"<div id='parent'><div id='child'></div></div>"
diff --git a/a.js b/b.js
@@ -2833,7 +2833,7 @@ QUnit.test( "make sure events cloned correctly", function( assert ) {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
	markup.remove();

	assert.equal( triggered, 3, "foo.bar triggered" );
} );

QUnit.test( "make sure events cloned correctly", function( assert ) {
	assert.expect( 18 );

	var clone,
		fixture = jQuery( "#qunit-fixture" ),
		checkbox = jQuery( "#check1" ),
		p = jQuery( "#firstp" );

	fixture.on( "click change", function( event, result ) {
		assert.ok( result,  event.type + " on original element is fired" );

	} ).on( "click", "#firstp", function( event, result ) {
		assert.ok( result, "Click on original child element though delegation is fired" );

	} ).on( "change", "#check1", function( event, result ) {
		assert.ok( result, "Change on original child element though delegation is fired" );
	} );

	p.on( "click", function() {
		assert.ok( true, "Click on original child element is fired" );
	} );

	checkbox.on( "change", function() {
		assert.ok( true, "Change on original child element is fired" );
	} );

	fixture.clone().trigger( "click" ).trigger( "change" ); // 0 events should be fired

	clone = fixture.clone( true );

	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone = fixture.clone( true, true );
	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire

	fixture.off();
	p.off();
	checkbox.off();

	p.trigger( "click" ); // 0 should be fired
	checkbox.trigger( "change" ); // 0 should be fired

	clone.find( "p" ).eq( 0 ).trigger( "click", true );  // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};
diff --git a/a.js b/b.js
@@ -2848,7 +2848,7 @@ QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#1336
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};

	try {
		jQuery( "<p>" ).trigger( "foo.bar" );
	} catch ( e ) {
		errored = true;
	}
	assert.equal( errored, false, "trigger() did not throw exception" );
	delete String.prototype.namespace;
} );

QUnit.test( "Inline event result is returned (#13993)", function( assert ) {
	assert.expect( 1 );

	var result = jQuery( "<p onclick='return 42'>hello</p>" ).triggerHandler( "click" );

diff --git a/a.js b/b.js
@@ -3137,7 +3137,7 @@ setTimeout( function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		input[ 0 ].focus();

		// then lose it
		inputExternal[ 0 ].focus();

		setTimeout( function() {

			// DOM focus is unreliable in TestSwarm
			if ( QUnit.isSwarm && !focus ) {
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
			}

			// cleanup
			parent.off();
			input.off();

			done();
		}, 50 );
	}, 50 );
} );

QUnit.test( "focus-blur order (#12868)", function( assert ) {
	assert.expect( 5 );

	var order,
		$text = jQuery( "#text1" ),
diff --git a/a.js b/b.js
@@ -3325,6 +3325,22 @@ setTimeout( function() {
A blob:edd9ecaead8a8796e2ce8bb2a60f5aa25a3577ac
		}
	} );

	select.trigger( "focus" );

	setTimeout( function() {
		assert.strictEqual( document.activeElement, button[ 0 ], "Focus redirect worked" );
		jQuery( document ).off( ".focusTests" );
		done();
	} );
} );

// TODO replace with an adaptation of
// https://github.com/jquery/jquery/pull/1367/files#diff-a215316abbaabdf71857809e8673ea28R2464
( function() {
	supportjQuery.each(
diff --git a/a.js b/b.js
@@ -7,6 +7,10 @@
A blob:165d33187f82c5d18c4773608705df295d09160e
var fs = require( "fs" );
var getRawBody = require( "raw-body" );

var cspLog = "";
/**
 * Keep in sync with /test/mock.php
 */
var mocks = {
	contentType: function( req, resp ) {
		resp.writeHead( 200, {
			"content-type": req.query.contentType
diff --git a/a.js b/b.js
@@ -73,7 +77,7 @@ script: function( req, resp ) {
A blob:165d33187f82c5d18c4773608705df295d09160e
	},
	atom: function( req, resp, next ) {
		resp.writeHead( 200, { "content-type": "atom+xml" } );
		resp.end( "<root><element /></root>" );
	},
	script: function( req, resp ) {
		if ( req.query.header === "ecma" ) {
			resp.writeHead( 200, { "content-type": "application/ecmascript" } );
		} else if ( "header" in req.query ) {
			resp.writeHead( 200, { "content-type": "text/javascript" } );
		} else {
			resp.writeHead( 200, { "content-type": "text/html" } );
		}

		if ( req.query.cors ) {
			resp.writeHead( 200, { "access-control-allow-origin": "*" } );
		}

		if ( req.query.callback ) {
			resp.end( req.query.callback + "(" + JSON.stringify( {
				headers: req.headers
			} ) + ")" );
		} else {
			resp.end( "QUnit.assert.ok( true, \"mock executed\" );" );
diff --git a/a.js b/b.js
@@ -126,14 +130,14 @@ jsonp: function( req, resp, next ) {
A blob:165d33187f82c5d18c4773608705df295d09160e
			resp.end( JSON.stringify(
				{ data: { lang: "en", length: 25 } }
			) );
		}
	},
	jsonp: function( req, resp, next ) {
		var callback;
		if ( Array.isArray( req.query.callback ) ) {
			callback = Promise.resolve( req.query.callback[ req.query.callback.length - 1 ] );
		} else if ( req.query.callback ) {
			callback = Promise.resolve( req.query.callback );
		} else if ( req.method === "GET" ) {
			callback = Promise.resolve( req.url.match( /^.+\/([^\/?]+)\?.+$/ )[ 1 ] );
		} else {
			callback = getBody( req ).then( function( body ) {
				return body.trim().replace( "callback=", "" );
			} );
		}
		var json = req.query.array ?
			JSON.stringify(
				[ { name: "John", age: 21 }, { name: "Peter", age: 25 } ]
			) :
			JSON.stringify(
				{ data: { lang: "en", length: 25 } }
			);
		callback.then( function( cb ) {
			resp.end( cb + "(" + json + ")" );
		}, next );
	},
	xmlOverJsonp: function( req, resp ) {
		var callback = req.query.callback;
		var body = fs.readFileSync( __dirname + "/data/with_fries.xml" ).toString();
		resp.writeHead( 200 );
		resp.end( callback + "(" + JSON.stringify( body ) + ")\n" );
	},
	error: function( req, resp ) {
		if ( req.query.json ) {
			resp.writeHead( 400, { "content-type": "application/json" } );
diff --git a/a.js b/b.js
@@ -218,7 +222,7 @@ testHTML: function( req, resp ) {
A blob:165d33187f82c5d18c4773608705df295d09160e
	},
	status: function( req, resp, next ) {
		resp.writeHead( Number( req.query.code ) );
		resp.end();
	},
	testHTML: function( req, resp ) {
		resp.writeHead( 200, { "Content-Type": "text/html" } );
		var body = fs.readFileSync( __dirname + "/data/test.include.html" ).toString();
		body = body.replace( /{{baseURL}}/g, req.query.baseURL );
		resp.end( body );
	},
	cspFrame: function( req, resp ) {
		resp.writeHead( 200, {
			"Content-Type": "text/html",
			"Content-Security-Policy": "default-src 'self'; report-uri /base/test/data/mock.php?action=cspLog"
		} );
		var body = fs.readFileSync( __dirname + "/data/csp.include.html" ).toString();
		resp.end( body );
	},
diff --git a/a.js b/b.js
@@ -252,14 +256,31 @@ cspClean: function( req, resp ) {
A blob:165d33187f82c5d18c4773608705df295d09160e
	cspLog: function( req, resp ) {
		cspLog = "error";
		resp.writeHead( 200 );
		resp.end();
	},
	cspClean: function( req, resp ) {
		cspLog = "";
		resp.writeHead( 200 );
		resp.end();
	},
	errorWithScript: function( req, resp ) {
		if ( req.query.withScriptContentType ) {
			resp.writeHead( 404, { "Content-Type": "application/javascript" } );
		} else {
			resp.writeHead( 404 );
		}
		if ( req.query.callback ) {
			resp.end( req.query.callback + "( {\"status\": 404, \"msg\": \"Not Found\"} )" );
		} else {
			resp.end( "QUnit.assert.ok( false, \"Mock return erroneously executed\" );" );
		}
	}
diff --git a/a.js b/b.js
@@ -55,10 +55,10 @@ QUnit.test( "element", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		}
	}
	assert.ok( good, "Select all elements, no comment nodes" );
} );

QUnit.test( "element", function( assert ) {
	assert.expect( 37 );

	var i, lengthtest, siblingTest, html;
	var fixture = document.getElementById( "qunit-fixture" );

	assert.deepEqual( jQuery( "p", fixture ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a Node context." );
	assert.deepEqual( jQuery( "p", "#qunit-fixture" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a selector context." );
	assert.deepEqual( jQuery( "p", jQuery( "#qunit-fixture" ) ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a jQuery object context." );
	assert.deepEqual( jQuery( "#qunit-fixture" ).find( "p" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a context via .find()." );

	assert.ok( jQuery( "#length" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );
	assert.ok( jQuery( "#lengthtest input" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );

	// #7533
	assert.equal( jQuery( "<div id=\"A'B~C.D[E]\"><p>foo</p></div>" ).find( "p" ).length, 1, "Find where context root is a node and has an ID with CSS3 meta characters" );

	assert.equal( jQuery( "" ).length, 0, "Empty selector returns an empty array" );
	assert.deepEqual( jQuery( "div", document.createTextNode( "" ) ).get(), [],
diff --git a/a.js b/b.js
@@ -142,7 +142,8 @@ QUnit.test( "element", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		}
	}
	assert.ok( good, "Select all elements, no comment nodes" );
} );

QUnit.test( "element", function( assert ) {
	assert.expect( 37 );

	var i, lengthtest, siblingTest, html;
	var fixture = document.getElementById( "qunit-fixture" );

	assert.deepEqual( jQuery( "p", fixture ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a Node context." );
	assert.deepEqual( jQuery( "p", "#qunit-fixture" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a selector context." );
	assert.deepEqual( jQuery( "p", jQuery( "#qunit-fixture" ) ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a jQuery object context." );
	assert.deepEqual( jQuery( "#qunit-fixture" ).find( "p" ).get(), q( "firstp", "ap", "sndp", "en", "sap", "first" ), "Finding elements with a context via .find()." );

	assert.ok( jQuery( "#length" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );
	assert.ok( jQuery( "#lengthtest input" ).length, "<input name=\"length\"> cannot be found under IE, see #945" );

	// #7533
	assert.equal( jQuery( "<div id=\"A'B~C.D[E]\"><p>foo</p></div>" ).find( "p" ).length, 1, "Find where context root is a node and has an ID with CSS3 meta characters" );

	assert.equal( jQuery( "" ).length, 0, "Empty selector returns an empty array" );
	assert.deepEqual( jQuery( "div", document.createTextNode( "" ) ).get(), [],
		"Text element as context fails silently" );

	assert.t( "Element Selector", "html", [ "html" ] );
	assert.t( "Element Selector", "body", [ "body" ] );
	assert.t( "Element Selector", "#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	assert.t( "Leading space", " #qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading tab", "\t#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading carriage return", "\r#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading line feed", "\n#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Leading form feed", "\f#qunit-fixture p", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing space", "#qunit-fixture p ", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing tab", "#qunit-fixture p\t", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing carriage return", "#qunit-fixture p\r",
		[ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing line feed", "#qunit-fixture p\n", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Trailing form feed", "#qunit-fixture p\f", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	assert.deepEqual(
		jQuery( jQuery( "div ol" ) ).filter( "#qunit-fixture *" ).get(),
		q( "empty", "listWithTabIndex" ),
		"Parent Element"
	);
	assert.deepEqual(
		jQuery( jQuery( "div\tol" ) ).filter( "#qunit-fixture *" ).get(),
		q( "empty", "listWithTabIndex" ),
		"Parent Element (non-space descendant combinator)"
	);

	// Check for unique-ness and sort order
	assert.deepEqual( jQuery( "p, div p" ), jQuery( "p" ), "Check for duplicates: p, div p" );

	jQuery( "<h1 id='h1'></h1><h2 id='h2'></h2><h2 id='h2-2'></h2>" ).prependTo( "#qunit-fixture" );
	assert.t( "Checking sort order", "#qunit-fixture h2, #qunit-fixture h1", [ "h1", "h2", "h2-2" ] );

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Checking sort order", "#qunit-fixture h2:first, #qunit-fixture h1:first", [ "h1", "h2" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Checking sort order", "#qunit-fixture p, #qunit-fixture p a",
		[ "firstp", "simon1", "ap", "google", "groups", "anchor1", "mark", "sndp", "en", "yahoo",
			"sap", "anchor2", "simon", "first" ] );

	// Test Conflict ID
	lengthtest = document.getElementById( "lengthtest" );
	assert.deepEqual( jQuery( "#idTest", lengthtest ).get(), q( "idTest" ),
		"Finding element with id of ID." );
	assert.deepEqual( jQuery( "[name='id']", lengthtest ).get(), q( "idTest" ),
		"Finding element with id of ID." );
	assert.deepEqual( jQuery( "input[id='idTest']", lengthtest ).get(), q( "idTest" ),
		"Finding elements with id of ID." );

	if ( QUnit.jQuerySelectors ) {
		siblingTest = document.getElementById( "siblingTest" );
		assert.deepEqual( jQuery( "div em", siblingTest ).get(), [],
			"Element-rooted QSA does not select based on document context" );
		assert.deepEqual( jQuery( "div em, div em, div em:not(div em)", siblingTest ).get(), [],
			"Element-rooted QSA does not select based on document context" );
		assert.deepEqual( jQuery( "div em, em\\,", siblingTest ).get(), [],
			"Escaped commas do not get treated with an id in element-rooted QSA" );
	} else {
		assert.ok( "skip", "Element-rooted QSA behavior different in selector-native" );
		assert.ok( "skip", "Element-rooted QSA behavior different in selector-native" );
		assert.ok( "skip", "Element-rooted QSA behavior different in selector-native" );
	}

	html = "";
	for ( i = 0; i < 100; i++ ) {
		html = "<div>" + html + "</div>";
	}
	html = jQuery( html ).appendTo( document.body );
	assert.ok( !!jQuery( "body div div div" ).length,
		"No stack or performance problems with large amounts of descendants" );
	assert.ok( !!jQuery( "body>div div div" ).length,
		"No stack or performance problems with large amounts of descendants" );
	html.remove();

	// Real use case would be using .watch in browsers with window.watch (see Issue #157)
	q( "qunit-fixture" )[ 0 ].appendChild( document.createElement( "toString" ) ).id = "toString";
	assert.t( "Element name matches Object.prototype property", "toString#toString", [ "toString" ] );
} );

diff --git a/a.js b/b.js
@@ -169,7 +170,7 @@ QUnit.test( "XML Document Selectors", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	// Real use case would be using .watch in browsers with window.watch (see Issue #157)
	q( "qunit-fixture" )[ 0 ].appendChild( document.createElement( "toString" ) ).id = "toString";
	assert.t( "Element name matches Object.prototype property", "toString#toString", [ "toString" ] );
} );

QUnit.test( "XML Document Selectors", function( assert ) {
	assert.expect( 11 );

	var xml = createWithFriesXML();

	assert.equal( jQuery( "foo_bar", xml ).length, 1, "Element Selector with underscore" );
	assert.equal( jQuery( ".component", xml ).length, 1, "Class selector" );
	assert.equal( jQuery( "[class*=component]", xml ).length, 1, "Attribute selector for class" );
	assert.equal( jQuery( "property[name=prop2]", xml ).length, 1, "Attribute selector with name" );
	assert.equal( jQuery( "[name=prop2]", xml ).length, 1, "Attribute selector with name" );
	assert.equal( jQuery( "#seite1", xml ).length, 1, "Attribute selector with ID" );
	assert.equal( jQuery( "component#seite1", xml ).length, 1, "Attribute selector with ID" );
	assert.equal( jQuery( "component", xml ).filter( "#seite1" ).length, 1,
		"Attribute selector filter with ID" );
	assert.equal( jQuery( "meta property thing", xml ).length, 2,
		"Descendent selector and dir caching" );
	if ( QUnit.jQuerySelectors ) {
		assert.ok( jQuery( xml.lastChild ).is( "soap\\:Envelope" ), "Check for namespaced element" );

		xml = jQuery.parseXML( "<?xml version='1.0' encoding='UTF-8'?><root><elem id='1'/></root>" );

		assert.equal( jQuery( "elem:not(:has(*))", xml ).length, 1,
			"Non-qSA path correctly handles numeric ids (jQuery #14142)" );
	} else {
		assert.ok( "skip", "namespaced elements not matching correctly in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}
diff --git a/a.js b/b.js
@@ -214,7 +215,7 @@ QUnit.test( "broken selectors throw", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		assert.ok( "skip", "namespaced elements not matching correctly in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}
} );

QUnit.test( "broken selectors throw", function( assert ) {
	assert.expect( 33 );

	function broken( name, selector ) {
		assert.throws( function() {
			jQuery( selector );
		}, name + ": " + selector );
	}

	broken( "Broken Selector", "[" );
	broken( "Broken Selector", "(" );
	broken( "Broken Selector", "{" );
	broken( "Broken Selector", "<" );
	broken( "Broken Selector", "()" );
	broken( "Broken Selector", "<>" );
	broken( "Broken Selector", "{}" );
	broken( "Broken Selector", "," );
	broken( "Broken Selector", ",a" );
	broken( "Broken Selector", "a," );
	broken( "Post-comma invalid selector", "*,:x" );
	broken( "Identifier with bad escape", "foo\\\fbaz" );
	broken( "Broken Selector", "[id=012345678901234567890123456789" );
	broken( "Doesn't exist", ":visble" );
	broken( "Nth-child", ":nth-child" );
	broken( "Nth-child", ":nth-child(-)" );
	broken( "Nth-child", ":nth-child(asdf)", [] );
	broken( "Nth-child", ":nth-child(2n+-0)" );
	broken( "Nth-child", ":nth-child(2+0)" );
	broken( "Nth-child", ":nth-child(- 1n)" );
	broken( "Nth-child", ":nth-child(-1 n)" );
	broken( "First-child", ":first-child(n)" );
	broken( "Last-child", ":last-child(n)" );
	broken( "Only-child", ":only-child(n)" );
	broken( "Nth-last-last-child", ":nth-last-last-child(1)" );
	broken( "First-last-child", ":first-last-child" );
	broken( "Last-last-child", ":last-last-child" );
	broken( "Only-last-child", ":only-last-child" );

	// Make sure attribute value quoting works correctly. See: #6093
	jQuery( "<input type='hidden' value='2' name='foo.baz' id='attrbad1'/>" +
		"<input type='hidden' value='2' name='foo[baz]' id='attrbad2'/>" )
		.appendTo( "#qunit-fixture" );

diff --git a/a.js b/b.js
@@ -267,7 +268,7 @@ QUnit.test( "id", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	broken( "Attribute equals unquoted non-identifier", "input[name=foo[baz]]" );
	broken( "Attribute equals bad string", "input[name=''double-quoted'']" );
	broken( "Attribute equals bad string", "input[name='apostrophe'd']" );
} );

QUnit.test( "id", function( assert ) {
	assert.expect( 34 );

	var fiddle, a;

	assert.t( "ID Selector", "#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "body#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "ul#first", [] );
	assert.t( "ID selector with existing ID descendant", "#firstp #simon1", [ "simon1" ] );
	assert.t( "ID selector with non-existent descendant", "#firstp #foobar", [] );
	assert.t( "ID selector using UTF8", "#Taibei", [ "Taibei" ] );
	assert.t( "Multiple ID selectors using UTF8", "#Taibei, #", [ "Taibei", "" ] );
	assert.t( "Descendant ID selector using UTF8", "div #", [ "" ] );
	assert.t( "Child ID selector using UTF8", "form > #", [ "" ] );

	assert.t( "Escaped ID", "#foo\\:bar", [ "foo:bar" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Escaped ID with descendant", "#foo\\:bar span:not(:input)", [ "foo_descendant" ] );
	} else {
		assert.ok( "skip", ":input not supported in selector-native" );
	}

	assert.t( "Escaped ID", "#test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Descendant escaped ID", "div #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Descendant escaped ID", "div #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Child escaped ID", "form > #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Child escaped ID", "form > #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );

	fiddle = jQuery( "<div id='fiddle\\Foo'><span id='fiddleSpan'></span></div>" )
		.appendTo( "#qunit-fixture" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "> span", jQuery( "#fiddle\\\\Foo" )[ 0 ] ).get(),
			q( [ "fiddleSpan" ] ), "Escaped ID as context" );
	} else {
		assert.ok( "skip", "leading > not supported in selector-native" );
	}

	fiddle.remove();

	assert.t( "ID Selector, child ID present", "#form > #radio1", [ "radio1" ] ); // bug #267
	assert.t( "ID Selector, not an ancestor ID", "#form #first", [] );
	assert.t( "ID Selector, not a child ID", "#form > #option1a", [] );

	assert.t( "All Children of ID", "#foo > *", [ "sndp", "en", "sap" ] );
diff --git a/a.js b/b.js
@@ -288,7 +289,7 @@ QUnit.test( "id", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	broken( "Attribute equals unquoted non-identifier", "input[name=foo[baz]]" );
	broken( "Attribute equals bad string", "input[name=''double-quoted'']" );
	broken( "Attribute equals bad string", "input[name='apostrophe'd']" );
} );

QUnit.test( "id", function( assert ) {
	assert.expect( 34 );

	var fiddle, a;

	assert.t( "ID Selector", "#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "body#body", [ "body" ] );
	assert.t( "ID Selector w/ Element", "ul#first", [] );
	assert.t( "ID selector with existing ID descendant", "#firstp #simon1", [ "simon1" ] );
	assert.t( "ID selector with non-existent descendant", "#firstp #foobar", [] );
	assert.t( "ID selector using UTF8", "#Taibei", [ "Taibei" ] );
	assert.t( "Multiple ID selectors using UTF8", "#Taibei, #", [ "Taibei", "" ] );
	assert.t( "Descendant ID selector using UTF8", "div #", [ "" ] );
	assert.t( "Child ID selector using UTF8", "form > #", [ "" ] );

	assert.t( "Escaped ID", "#foo\\:bar", [ "foo:bar" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Escaped ID with descendant", "#foo\\:bar span:not(:input)", [ "foo_descendant" ] );
	} else {
		assert.ok( "skip", ":input not supported in selector-native" );
	}

	assert.t( "Escaped ID", "#test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Descendant escaped ID", "div #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Descendant escaped ID", "div #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );
	assert.t( "Child escaped ID", "form > #foo\\:bar", [ "foo:bar" ] );
	assert.t( "Child escaped ID", "form > #test\\.foo\\[5\\]bar", [ "test.foo[5]bar" ] );

	fiddle = jQuery( "<div id='fiddle\\Foo'><span id='fiddleSpan'></span></div>" )
		.appendTo( "#qunit-fixture" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "> span", jQuery( "#fiddle\\\\Foo" )[ 0 ] ).get(),
			q( [ "fiddleSpan" ] ), "Escaped ID as context" );
	} else {
		assert.ok( "skip", "leading > not supported in selector-native" );
	}

	fiddle.remove();

	assert.t( "ID Selector, child ID present", "#form > #radio1", [ "radio1" ] ); // bug #267
	assert.t( "ID Selector, not an ancestor ID", "#form #first", [] );
	assert.t( "ID Selector, not a child ID", "#form > #option1a", [] );

	assert.t( "All Children of ID", "#foo > *", [ "sndp", "en", "sap" ] );
	assert.t( "All Children of ID with no children", "#firstUL > *", [] );

	assert.equal( jQuery( "#tName1" )[ 0 ].id, "tName1",
		"ID selector with same value for a name attribute" );
	assert.t( "ID selector non-existing but name attribute on an A tag", "#tName2", [] );
	assert.t( "Leading ID selector non-existing but name attribute on an A tag", "#tName2 span", [] );
	assert.t( "Leading ID selector existing, retrieving the child", "#tName1 span", [ "tName1-span" ] );
	assert.equal( jQuery( "div > div #tName1" )[ 0 ].id, jQuery( "#tName1-span" )[ 0 ].parentNode.id,
		"Ending with ID" );

	a = jQuery( "<a id='backslash\\foo'></a>" ).appendTo( "#qunit-fixture" );
	assert.t( "ID Selector contains backslash", "#backslash\\\\foo", [ "backslash\\foo" ] );
	a.remove();

	assert.t( "ID Selector on Form with an input that has a name of 'id'", "#lengthtest", [ "lengthtest" ] );

	assert.t( "ID selector with non-existent ancestor", "#asdfasdf #foobar", [] ); // bug #986

	assert.deepEqual( jQuery( "div#form", document.body ).get(), [],
		"ID selector within the context of another element" );

diff --git a/a.js b/b.js
@@ -485,7 +486,7 @@ QUnit.test( "child and adjacent", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	assert.equal( fixture.find( "h2, div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "p" ).length, 2, "has to find two <p>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
} );

QUnit.test( "child and adjacent", function( assert ) {
	assert.expect( 43 );

	var siblingFirst, en, nothiddendiv;

	assert.t( "Child", "p > a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus leading whitespace", "p> a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus trailing whitespace", "p >a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus whitespace", "p>a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child w/ Class", "p > a.blog", [ "mark", "simon" ] );
	assert.t( "All Children", "code > *", [ "anchor1", "anchor2" ] );
	assert.selectInFixture( "All Grandchildren", "p > * > *", [ "anchor1", "anchor2" ] );

	assert.t( "Rooted tag adjacent", "#qunit-fixture a + a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus whitespace", "#qunit-fixture a+a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus leading whitespace", "#qunit-fixture a +a",
		[ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus trailing whitespace", "#qunit-fixture a+ a",
		[ "groups", "tName2ID" ] );

	assert.t( "Tag adjacent", "p + p", [ "ap", "en", "sap" ] );
	assert.t( "#id adjacent", "#firstp + p", [ "ap" ] );
	assert.t( "Tag#id adjacent", "p#firstp + p", [ "ap" ] );
	assert.t( "Tag[attr] adjacent", "p[lang=en] + p", [ "sap" ] );
	assert.t( "Tag.class adjacent", "a.GROUPS + code + a", [ "mark" ] );
	assert.t( "Comma, Child, and Adjacent", "#qunit-fixture a + a, code > a",
		[ "groups", "anchor1", "anchor2", "tName2ID" ] );

	assert.t( "Element Preceded By", "#qunit-fixture p ~ div",
		[ "foo", "nothiddendiv", "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#first ~ div",
		[ "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#groups ~ a", [ "mark" ] );
	assert.t( "Element Preceded By", "#length ~ input", [ "idTest" ] );
	assert.t( "Element Preceded By", "#siblingfirst ~ em", [ "siblingnext", "siblingthird" ] );
	assert.t( "Element Preceded By (multiple)", "#siblingTest em ~ em ~ em ~ span", [ "siblingspan" ] );

	siblingFirst = document.getElementById( "siblingfirst" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "+ em", siblingFirst ).get(), q( "siblingnext" ),
			"Element Directly Preceded By with a context." );
		assert.deepEqual( jQuery( "~ em", siblingFirst ).get(), q( "siblingnext", "siblingthird" ),
			"Element Preceded By with a context." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading ~ not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.deepEqual( jQuery( "~ em:first", siblingFirst ).get(), q( "siblingnext" ),
			"Element Preceded By positional with a context." );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	if ( QUnit.jQuerySelectors ) {
		en = document.getElementById( "en" );
		assert.deepEqual( jQuery( "+ p, a", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, beginning with sibling test." );
		assert.deepEqual( jQuery( "a, + p", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, containing sibling test." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading + not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Element Preceded By, Containing", "#liveHandlerOrder ~ div em:contains('1')", [ "siblingfirst" ] );
		assert.t( "Combinators are not skipped when mixing general and specific", "#siblingTest > em:contains('x') + em ~ span", [] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.equal( jQuery( "#listWithTabIndex li:eq(2) ~ li" ).length, 1, "Find by general sibling combinator (#8310)" );

		nothiddendiv = document.getElementById( "nothiddendiv" );
		assert.deepEqual( jQuery( "> :first", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
diff --git a/a.js b/b.js
@@ -505,9 +506,9 @@ QUnit.test( "child and adjacent", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	assert.equal( fixture.find( "h2, div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "p" ).length, 2, "has to find two <p>" );
	assert.equal( fixture.find( "h2 , div p" ).filter( "h2" ).length, 1, "has to find one <h2>" );
} );

QUnit.test( "child and adjacent", function( assert ) {
	assert.expect( 43 );

	var siblingFirst, en, nothiddendiv;

	assert.t( "Child", "p > a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus leading whitespace", "p> a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus trailing whitespace", "p >a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child minus whitespace", "p>a", [ "simon1", "google", "groups", "mark", "yahoo", "simon" ] );
	assert.t( "Child w/ Class", "p > a.blog", [ "mark", "simon" ] );
	assert.t( "All Children", "code > *", [ "anchor1", "anchor2" ] );
	assert.selectInFixture( "All Grandchildren", "p > * > *", [ "anchor1", "anchor2" ] );

	assert.t( "Rooted tag adjacent", "#qunit-fixture a + a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus whitespace", "#qunit-fixture a+a", [ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus leading whitespace", "#qunit-fixture a +a",
		[ "groups", "tName2ID" ] );
	assert.t( "Rooted tag adjacent minus trailing whitespace", "#qunit-fixture a+ a",
		[ "groups", "tName2ID" ] );

	assert.t( "Tag adjacent", "p + p", [ "ap", "en", "sap" ] );
	assert.t( "#id adjacent", "#firstp + p", [ "ap" ] );
	assert.t( "Tag#id adjacent", "p#firstp + p", [ "ap" ] );
	assert.t( "Tag[attr] adjacent", "p[lang=en] + p", [ "sap" ] );
	assert.t( "Tag.class adjacent", "a.GROUPS + code + a", [ "mark" ] );
	assert.t( "Comma, Child, and Adjacent", "#qunit-fixture a + a, code > a",
		[ "groups", "anchor1", "anchor2", "tName2ID" ] );

	assert.t( "Element Preceded By", "#qunit-fixture p ~ div",
		[ "foo", "nothiddendiv", "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#first ~ div",
		[ "moretests", "tabindex-tests", "liveHandlerOrder", "siblingTest", "fx-test-group" ] );
	assert.t( "Element Preceded By", "#groups ~ a", [ "mark" ] );
	assert.t( "Element Preceded By", "#length ~ input", [ "idTest" ] );
	assert.t( "Element Preceded By", "#siblingfirst ~ em", [ "siblingnext", "siblingthird" ] );
	assert.t( "Element Preceded By (multiple)", "#siblingTest em ~ em ~ em ~ span", [ "siblingspan" ] );

	siblingFirst = document.getElementById( "siblingfirst" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "+ em", siblingFirst ).get(), q( "siblingnext" ),
			"Element Directly Preceded By with a context." );
		assert.deepEqual( jQuery( "~ em", siblingFirst ).get(), q( "siblingnext", "siblingthird" ),
			"Element Preceded By with a context." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading ~ not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.deepEqual( jQuery( "~ em:first", siblingFirst ).get(), q( "siblingnext" ),
			"Element Preceded By positional with a context." );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	if ( QUnit.jQuerySelectors ) {
		en = document.getElementById( "en" );
		assert.deepEqual( jQuery( "+ p, a", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, beginning with sibling test." );
		assert.deepEqual( jQuery( "a, + p", en ).get(), q( "yahoo", "sap" ),
			"Compound selector with context, containing sibling test." );
	} else {
		assert.ok( "skip", "leading + not supported in selector-native" );
		assert.ok( "skip", "leading + not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Element Preceded By, Containing", "#liveHandlerOrder ~ div em:contains('1')", [ "siblingfirst" ] );
		assert.t( "Combinators are not skipped when mixing general and specific", "#siblingTest > em:contains('x') + em ~ span", [] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.equal( jQuery( "#listWithTabIndex li:eq(2) ~ li" ).length, 1, "Find by general sibling combinator (#8310)" );

		nothiddendiv = document.getElementById( "nothiddendiv" );
		assert.deepEqual( jQuery( "> :first", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
		assert.deepEqual( jQuery( "> :eq(0)", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
		assert.deepEqual( jQuery( "> *:first", nothiddendiv ).get(), q( "nothiddendivchild" ),
			"Verify child context positional selector" );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( "Multiple combinators selects all levels", "#siblingTest em *", [ "siblingchild", "siblinggrandchild", "siblinggreatgrandchild" ] );
	assert.t( "Multiple combinators selects all levels", "#siblingTest > em *", [ "siblingchild", "siblinggrandchild", "siblinggreatgrandchild" ] );
	assert.t( "Multiple sibling combinators doesn't miss general siblings", "#siblingTest > em:first-child + em ~ span", [ "siblingspan" ] );

	assert.equal( jQuery( "#listWithTabIndex" ).length, 1, "Parent div for next test is found via ID (#8310)" );
	assert.equal( jQuery( "#__sizzle__" ).length, 0, "Make sure the temporary id assigned by sizzle is cleared out (#8310)" );
	assert.equal( jQuery( "#listWithTabIndex" ).length, 1, "Parent div for previous test is still found via ID (#8310)" );

	assert.t( "Verify deep class selector", "div.blah > p > a", [] );
	assert.t( "No element deep selector", "div.foo > span > a", [] );
	assert.t( "Non-existent ancestors", ".fototab > .thumbnails > a", [] );
diff --git a/a.js b/b.js
@@ -555,7 +556,7 @@ QUnit.test( "attributes - equals", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	assert.t( "On implicit element", "#qunit-fixture [title]", [ "google" ] );
	assert.t( "Boolean", "#select2 option[selected]", [ "option2d" ] );
	assert.t( "For attribute on label", "form label[for]", [ "label-for" ] );
} );

QUnit.test( "attributes - equals", function( assert ) {
	assert.expect( 20 );

	var withScript;

	assert.t( "Identifier", "#qunit-fixture a[rel=bookmark]", [ "simon1" ] );
	assert.t( "Identifier with underscore", "input[id=types_all]", [ "types_all" ] );
	assert.t( "String", "#qunit-fixture a[rel='bookmark']", [ "simon1" ] );
	assert.t( "String (whitespace ignored)", "#qunit-fixture a[ rel = 'bookmark' ]", [ "simon1" ] );
	assert.t( "Non-identifier string", "#qunit-fixture a[href='https://www.google.com/']", [ "google" ] );
	assert.t( "Empty string", "#select1 option[value='']", [ "option1a" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Number",
			"#qunit-fixture option[value=1]",
			[ "option1b", "option2b", "option3b", "option4b", "option5c" ] );
		assert.t( "negative number",
			"#qunit-fixture li[tabIndex=-1]", [ "foodWithNegativeTabIndex" ] );
	} else {
		assert.ok( "skip", "Number value not supported in selector-native" );
		assert.ok( "skip", "Negative number value not supported in selector-native" );
	}

	assert.t( "Non-ASCII identifier", "span[lang=]", [ "" ] );

	assert.t( "input[type=text]", "#form input[type=text]", [ "text1", "text2", "hidden2", "name" ] );
	assert.t( "input[type=search]", "#form input[type=search]", [ "search" ] );

	withScript = supportjQuery( "<div><span><script src=''></script></span></div>" );
	assert.ok( withScript.find( "#moretests script[src]" ).has( "script" ), "script[src] (jQuery #13777)" );

	assert.t( "Boolean attribute equals name", "#select2 option[selected='selected']", [ "option2d" ] );
	assert.t( "for Attribute in form", "#form [for=action]", [ "label-for" ] );
	assert.t( "Grouped Form Elements - name", "input[name='foo[bar]']", [ "hidden2" ] );
diff --git a/a.js b/b.js
@@ -642,7 +643,7 @@ QUnit.test( "attributes - special characters", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		"#names-group span[id|='name-is']",
		[ "name-is-example", "name-is-div" ] );
	assert.t( "string ending with hyphen", "#names-group span[id|='name-is-']", [] );
} );

QUnit.test( "attributes - special characters", function( assert ) {
	assert.expect( 16 );

	var attrbad;
	var div = document.createElement( "div" );

	// trac-3279
	div.innerHTML = "<div id='foo' xml:test='something'></div>";
	assert.deepEqual( jQuery( "[xml\\:test]", div ).get(),
		[ div.firstChild ],
		"attribute name containing colon" );
diff --git a/a.js b/b.js
@@ -741,7 +742,7 @@ QUnit.test( "attributes - others", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	assert.deepEqual( jQuery( attrbad ).filter( "input[data-attr='\\01D306A']" ).get(),
		q( "attrbad_unicode" ),
		"Long numeric escape (non-BMP)" );
} );

QUnit.test( "attributes - others", function( assert ) {
	assert.expect( 14 );

	var div = document.getElementById( "foo" );

	assert.t( "Find elements with a tabindex attribute", "[tabindex]", [ "listWithTabIndex", "foodWithNegativeTabIndex", "linkWithTabIndex", "linkWithNegativeTabIndex", "linkWithNoHrefWithTabIndex", "linkWithNoHrefWithNegativeTabIndex" ] );

	assert.t( "Selector list with multiple quoted attribute-equals",
		"#form input[type='radio'], #form input[type='hidden']",
		[ "radio1", "radio2", "hidden1" ] );
	assert.t( "Selector list with differently-quoted attribute-equals",
		"#form input[type='radio'], #form input[type=\"hidden\"]",
		[ "radio1", "radio2", "hidden1" ] );
	assert.t( "Selector list with quoted and unquoted attribute-equals",
		"#form input[type='radio'], #form input[type=hidden]",
		[ "radio1", "radio2", "hidden1" ] );

	assert.t( "Object.prototype property \"constructor\" (negative)", "[constructor]", [] );
	assert.t( "Gecko Object.prototype property \"watch\" (negative)", "[watch]", [] );
	div.setAttribute( "constructor", "foo" );
	div.setAttribute( "watch", "bar" );
	assert.t( "Object.prototype property \"constructor\"", "[constructor='foo']", [ "foo" ] );
	assert.t( "Gecko Object.prototype property \"watch\"", "[watch='bar']", [ "foo" ] );

	// #11115
	assert.ok( jQuery( "<input type='checkbox' checked='checked'/>" ).prop( "checked", false ).is( "[checked]" ),
		"[checked] selects by attribute (positive)"
	);
	assert.ok( !jQuery( "<input type='checkbox'/>" ).prop( "checked", true ).is( "[checked]" ),
diff --git a/a.js b/b.js
@@ -1137,14 +1138,14 @@ QUnit.test( "pseudo - :not", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit.test( "pseudo - :not", function( assert ) {
	assert.expect( 43 );

	assert.t( "Not", "a.blog:not(.link)", [ "mark" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Not - multiple", "#form option:not(:contains(Nothing),#option1b,:selected)", [ "option1c", "option1d", "option2b", "option2c", "option3d", "option3e", "option4e", "option5b", "option5c" ] );
		assert.t( "Not - recursive", "#form option:not(:not(:selected))[id^='option3']", [ "option3b", "option3c" ] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":selected not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( ":not() with :first", "#foo p:not(:first) .link", [ "simon" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( ":not() failing interior", "#qunit-fixture p:not(.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not() failing interior", "#qunit-fixture p:not(#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
diff --git a/a.js b/b.js
@@ -1156,15 +1157,15 @@ QUnit.test( "pseudo - :not", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit.test( "pseudo - :not", function( assert ) {
	assert.expect( 43 );

	assert.t( "Not", "a.blog:not(.link)", [ "mark" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Not - multiple", "#form option:not(:contains(Nothing),#option1b,:selected)", [ "option1c", "option1d", "option2b", "option2c", "option3d", "option3e", "option4e", "option5b", "option5c" ] );
		assert.t( "Not - recursive", "#form option:not(:not(:selected))[id^='option3']", [ "option3b", "option3c" ] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":selected not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( ":not() with :first", "#foo p:not(:first) .link", [ "simon" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( ":not() failing interior", "#qunit-fixture p:not(.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not() failing interior", "#qunit-fixture p:not(#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	assert.t( ":not Multiple", "#qunit-fixture p:not(a)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( a )", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( p )", [] );
	assert.t( ":not Multiple", "p:not(p)", [] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b, div)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "p:not(a,p)", [] );
		assert.t( ":not Multiple", "p:not(p,a)", [] );
		assert.t( ":not Multiple", "p:not(a,p,b)", [] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
diff --git a/a.js b/b.js
@@ -1189,11 +1190,11 @@ QUnit.test( "pseudo - :not", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit.test( "pseudo - :not", function( assert ) {
	assert.expect( 43 );

	assert.t( "Not", "a.blog:not(.link)", [ "mark" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Not - multiple", "#form option:not(:contains(Nothing),#option1b,:selected)", [ "option1c", "option1d", "option2b", "option2c", "option3d", "option3e", "option4e", "option5b", "option5c" ] );
		assert.t( "Not - recursive", "#form option:not(:not(:selected))[id^='option3']", [ "option3b", "option3c" ] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":selected not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( ":not() with :first", "#foo p:not(:first) .link", [ "simon" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( ":not() failing interior", "#qunit-fixture p:not(.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not() failing interior", "#qunit-fixture p:not(#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	assert.t( ":not Multiple", "#qunit-fixture p:not(a)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( a )", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( p )", [] );
	assert.t( ":not Multiple", "p:not(p)", [] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b, div)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "p:not(a,p)", [] );
		assert.t( ":not Multiple", "p:not(p,a)", [] );
		assert.t( ":not Multiple", "p:not(a,p,b)", [] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( ":not Multiple", ":input:not(:image,:input,:submit)", [] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(:has(a), :nth-child(1))", [ "first" ] );
	} else {
		assert.ok( "skip", ":image, :input, :submit not supported in selector-native" );
		assert.ok( "skip", ":has not supported in selector-native" );
	}

	assert.t( "No element not selector", ".container div:not(.excluded) div", [] );

	assert.t( ":not() Existing attribute", "#form select:not([multiple])", [ "select1", "select2", "select5" ] );
	assert.t( ":not() Equals attribute", "#form select:not([name=select1])", [ "select2", "select3", "select4", "select5" ] );
	assert.t( ":not() Equals quoted attribute", "#form select:not([name='select1'])", [ "select2", "select3", "select4", "select5" ] );

	assert.t( ":not() Multiple Class", "#foo a:not(.blog)", [ "yahoo", "anchor2" ] );
	assert.t( ":not() Multiple Class", "#foo a:not(.link)", [ "yahoo", "anchor2" ] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not() Multiple Class", "#foo a:not(.blog.link)", [ "yahoo", "anchor2" ] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
diff --git a/a.js b/b.js
@@ -1283,7 +1284,7 @@ QUnit.test( "pseudo - :not", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit.test( "pseudo - :not", function( assert ) {
	assert.expect( 43 );

	assert.t( "Not", "a.blog:not(.link)", [ "mark" ] );

	if ( QUnit.jQuerySelectors ) {
		assert.t( "Not - multiple", "#form option:not(:contains(Nothing),#option1b,:selected)", [ "option1c", "option1d", "option2b", "option2c", "option3d", "option3e", "option4e", "option5b", "option5c" ] );
		assert.t( "Not - recursive", "#form option:not(:not(:selected))[id^='option3']", [ "option3b", "option3c" ] );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
		assert.ok( "skip", ":selected not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( ":not() with :first", "#foo p:not(:first) .link", [ "simon" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	assert.t( ":not() failing interior", "#qunit-fixture p:not(.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not() failing interior", "#qunit-fixture p:not(#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p.foo)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(div#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not() failing interior", "#qunit-fixture p:not(p#blargh)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	assert.t( ":not Multiple", "#qunit-fixture p:not(a)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( a )", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
	assert.t( ":not Multiple", "#qunit-fixture p:not( p )", [] );
	assert.t( ":not Multiple", "p:not(p)", [] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(a, b, div)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );
		assert.t( ":not Multiple", "p:not(a,p)", [] );
		assert.t( ":not Multiple", "p:not(p,a)", [] );
		assert.t( ":not Multiple", "p:not(a,p,b)", [] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( ":not Multiple", ":input:not(:image,:input,:submit)", [] );
		assert.t( ":not Multiple", "#qunit-fixture p:not(:has(a), :nth-child(1))", [ "first" ] );
	} else {
		assert.ok( "skip", ":image, :input, :submit not supported in selector-native" );
		assert.ok( "skip", ":has not supported in selector-native" );
	}

	assert.t( "No element not selector", ".container div:not(.excluded) div", [] );

	assert.t( ":not() Existing attribute", "#form select:not([multiple])", [ "select1", "select2", "select5" ] );
	assert.t( ":not() Equals attribute", "#form select:not([name=select1])", [ "select2", "select3", "select4", "select5" ] );
	assert.t( ":not() Equals quoted attribute", "#form select:not([name='select1'])", [ "select2", "select3", "select4", "select5" ] );

	assert.t( ":not() Multiple Class", "#foo a:not(.blog)", [ "yahoo", "anchor2" ] );
	assert.t( ":not() Multiple Class", "#foo a:not(.link)", [ "yahoo", "anchor2" ] );

	if ( QUnit.jQuerySelectors || this.safari ) {
		assert.t( ":not() Multiple Class", "#foo a:not(.blog.link)", [ "yahoo", "anchor2" ] );
	} else {
		// Support: Chrome 75+, Firefox 67+
		// Chrome/Firefox don't support `:not(complex selector)`.
		assert.ok( "skip", ":not(complex selector) not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.t( ":not chaining (compound)", "#qunit-fixture div[id]:not(:has(div, span)):not(:has(*))", [ "nothiddendivchild", "divWithNoTabIndex", "fx-tests" ] );
		assert.t( ":not chaining (with attribute)", "#qunit-fixture form[id]:not([action$='formaction']):not(:button)", [ "lengthtest", "name-tests", "testForm", "disabled-tests" ] );
		assert.t( ":not chaining (colon in attribute)", "#qunit-fixture form[id]:not([action='form:action']):not(:button)", [ "form", "lengthtest", "name-tests", "testForm", "disabled-tests" ] );
		assert.t( ":not chaining (colon in attribute and nested chaining)", "#qunit-fixture form[id]:not([action='form:action']:button):not(:input)", [ "form", "lengthtest", "name-tests", "testForm", "disabled-tests" ] );
		assert.t( ":not chaining", "#form select:not(.select1):contains(Nothing) > option:not(option)", [] );
	} else {
		assert.ok( "skip", ":has not supported in selector-native" );
		assert.ok( "skip", ":button not supported in selector-native" );
		assert.ok( "skip", ":button not supported in selector-native" );
		assert.ok( "skip", ":button not supported in selector-native" );
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "positional :not()", "#foo p:not(:last)", [ "sndp", "en" ] );
		assert.t( "positional :not() prefix", "#foo p:not(:last) a", [ "yahoo" ] );
		assert.t( "compound positional :not()", "#foo p:not(:first, :last)", [ "en" ] );
		assert.t( "compound positional :not()", "#foo p:not(:first, :even)", [ "en" ] );
		assert.t( "compound positional :not()", "#foo p:not(:first, :odd)", [ "sap" ] );
		assert.t( "reordered compound positional :not()", "#foo p:not(:odd, :first)", [ "sap" ] );

		assert.t( "positional :not() with pre-filter", "#foo p:not([id]:first)", [ "en", "sap" ] );
		assert.t( "positional :not() with post-filter", "#foo p:not(:first[id])", [ "en", "sap" ] );
		assert.t( "positional :not() with pre-filter", "#foo p:not([lang]:first)", [ "sndp", "sap" ] );
		assert.t( "positional :not() with post-filter", "#foo p:not(:first[lang])", [ "sndp", "en", "sap" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );

		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}
} );

QUnit[ QUnit.jQuerySelectorsPos ? "test" : "skip" ]( "pseudo - position", function( assert ) {
	assert.expect( 34 );

	assert.t( "First element", "#qunit-fixture p:first", [ "firstp" ] );
	assert.t( "First element(case-insensitive)", "#qunit-fixture p:fiRst", [ "firstp" ] );
	assert.t( "nth Element", "#qunit-fixture p:nth(1)", [ "ap" ] );
	assert.t( "First Element", "#qunit-fixture p:first", [ "firstp" ] );
	assert.t( "Last Element", "p:last", [ "first" ] );
	assert.t( "Even Elements", "#qunit-fixture p:even", [ "firstp", "sndp", "sap" ] );
	assert.t( "Odd Elements", "#qunit-fixture p:odd", [ "ap", "en", "first" ] );
	assert.t( "Position Equals", "#qunit-fixture p:eq(1)", [ "ap" ] );
	assert.t( "Position Equals (negative)", "#qunit-fixture p:eq(-1)", [ "first" ] );
	assert.t( "Position Greater Than", "#qunit-fixture p:gt(0)", [ "ap", "sndp", "en", "sap", "first" ] );
	assert.t( "Position Less Than", "#qunit-fixture p:lt(3)", [ "firstp", "ap", "sndp" ] );
	assert.t( "Position Less Than Big Number", "#qunit-fixture p:lt(9007199254740991)", [ "firstp", "ap", "sndp", "en", "sap", "first" ] );

	assert.t( "Check position filtering", "div#nothiddendiv:eq(0)", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div#nothiddendiv:last", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div#nothiddendiv:not(:gt(0))", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "#foo > :not(:first)", [ "en", "sap" ] );
	assert.t( "Check position filtering", "#qunit-fixture select > :not(:gt(2))", [ "option1a", "option1b", "option1c" ] );
	assert.t( "Check position filtering", "#qunit-fixture select:lt(2) :not(:first)", [ "option1b", "option1c", "option1d", "option2a", "option2b", "option2c", "option2d" ] );
	assert.t( "Check position filtering", "div.nothiddendiv:eq(0)", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div.nothiddendiv:last", [ "nothiddendiv" ] );
	assert.t( "Check position filtering", "div.nothiddendiv:not(:lt(0))", [ "nothiddendiv" ] );

	assert.t( "Check element position", "#qunit-fixture div div:eq(0)", [ "nothiddendivchild" ] );
	assert.t( "Check element position", "#select1 option:eq(3)", [ "option1d" ] );
	assert.t( "Check element position", "#qunit-fixture div div:eq(10)", [ "no-clone-exception" ] );
	assert.t( "Check element position", "#qunit-fixture div div:first", [ "nothiddendivchild" ] );
	assert.t( "Check element position", "#qunit-fixture div > div:first", [ "nothiddendivchild" ] );
	assert.t( "Check element position", "#qunit-fixture div:first a:first", [ "yahoo" ] );
	assert.t( "Check element position", "#qunit-fixture div:first > p:first", [ "sndp" ] );
	assert.t( "Check element position", "div#nothiddendiv:first > div:first", [ "nothiddendivchild" ] );
	assert.t( "Chained pseudo after a pos pseudo", "#listWithTabIndex li:eq(0):contains(Rice)", [ "foodWithNegativeTabIndex" ] );

	assert.t( "Check sort order with POS and comma", "#qunit-fixture em>em>em>em:first-child,div>em:first", [ "siblingfirst", "siblinggreatgrandchild" ] );

	assert.t( "Isolated position", "#qunit-fixture :last", [ "last" ] );

	assert.deepEqual(
		jQuery( "#qunit-fixture > p" ).filter( "*:lt(2) + *" ).get(),
		q( "ap" ),
		"Seeded pos with trailing relative" );

	// jQuery #12526
	var context = jQuery( "#qunit-fixture" ).append( "<div id='jquery12526'></div>" )[ 0 ];
	assert.deepEqual( jQuery( ":last", context ).get(), q( "jquery12526" ),
		"Post-manipulation positional" );
} );
diff --git a/a.js b/b.js
@@ -1654,7 +1655,7 @@ QUnit.test( "context", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		docElem.setAttribute( "xml:lang", docXmlLang );
	}
	docElem.lang = docLang;
} );

QUnit.test( "context", function( assert ) {
	assert.expect( 21 );

	var context,
		selector = ".blog",
		expected = q( "mark", "simon" ),
		iframe = document.getElementById( "iframe" ),
		iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

	assert.deepEqual( jQuery( selector, document ).get(), expected, "explicit document context" );
	assert.deepEqual( jQuery( selector ).get(), expected, "unspecified context becomes document" );
	assert.deepEqual( jQuery( selector, undefined ).get(), expected,
		"undefined context becomes document" );
	assert.deepEqual( jQuery( selector, null ).get(), expected, "null context becomes document" );

	iframeDoc.open();
	iframeDoc.write( "<body><p id='foo'>bar</p></body>" );
	iframeDoc.close();
	expected = [ iframeDoc.getElementById( "foo" ) ];
	assert.deepEqual( jQuery( "p", iframeDoc ).get(), expected, "Other document context (simple)" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "p:contains(ar)", iframeDoc ).get(), expected,
			"Other document context (complex)" );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	assert.deepEqual( jQuery( "span", iframeDoc ).get(), [],
		"Other document context (simple, no results)" );
	assert.deepEqual( jQuery( "* span", iframeDoc ).get(), [],
		"Other document context (complex, no results)" );

	context = document.getElementById( "nothiddendiv" );
	assert.deepEqual( jQuery( "*", context ).get(), q( "nothiddendivchild" ), "<div> context" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "* > *", context ).get(), [], "<div> context (no results)" );
	} else {
		assert.ok( "skip", "The whole selector not required to be under context in selector-native" );
	}

	context.removeAttribute( "id" );
	assert.deepEqual( jQuery( "*", context ).get(), q( "nothiddendivchild" ), "no-id element context" );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual( jQuery( "* > *", context ).get(), [], "no-id element context (no results)" );
	} else {
		assert.ok( "skip", ":contains not supported in selector-native" );
	}

	assert.strictEqual( context.getAttribute( "id" ) || "", "", "id not added by no-id selection" );

	context = document.getElementById( "lengthtest" );
	assert.deepEqual( jQuery( "input", context ).get(), q( "length", "idTest" ), "<form> context" );
	assert.deepEqual( jQuery( "select", context ).get(), [], "<form> context (no results)" );

	context = document.getElementById( "Taibei" );
	expected = q( "Taibei-child" );
	assert.deepEqual( jQuery( "span[id]", context ).get(), expected, "context with non-ASCII id" );
	assert.deepEqual( jQuery( "#Taibei span[id]", context.parentNode ).get(), expected,
		"context with non-ASCII id selector prefix" );

	context = document.createDocumentFragment();

	// Capture *independent* expected nodes before they're detached from the page
	expected = q( "siblingnext", "siblingspan" );
	context.appendChild( document.getElementById( "siblingTest" ) );

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual(
			jQuery( "em:nth-child(2)", context ).get(),
			expected.slice( 0, 1 ),
			"DocumentFragment context"
		);
		assert.deepEqual( jQuery( "span", context ).get(), expected.slice( 1 ),
			"DocumentFragment context by tag name" );
		assert.deepEqual( jQuery( "p", context ).get(), [], "DocumentFragment context (no results)" );
	} else {
		assert.ok( "skip", "selection on document fragments not supported in selector-native" );
		assert.ok( "skip", "selection on document fragments not supported in selector-native" );
		assert.ok( "skip", "selection on document fragments not supported in selector-native" );
	}

	if ( QUnit.jQuerySelectors ) {
		assert.deepEqual(
			jQuery( "em + :not(:has(*)):not(:empty), foo", context.firstChild ).get(),
			expected.slice( 0, 1 ),
			"Non-qSA path correctly sets detached context for sibling selectors (jQuery #14351)"
		);
	} else {
		assert.ok( "skip", ":has not supported in selector-native" );
	}
diff --git a/a.js b/b.js
@@ -1705,7 +1706,7 @@ QUnit.test( "caching does not introduce bugs", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
		assert.ok( true, "Mutation observer didn't fire during selection" );
		done();
	} );
} );

QUnit.test( "caching does not introduce bugs", function( assert ) {
	assert.expect( 3 );

	var sap = document.getElementById( "sap" );

	jQuery( ":not(code)", document.getElementById( "ap" ) );
	assert.deepEqual(
		jQuery( ":not(code)", document.getElementById( "foo" ) ).get(),
		q( "sndp", "en", "yahoo", "sap", "anchor2", "simon" ),
		"Reusing selector with new context"
	);

	if ( QUnit.jQuerySelectorsPos ) {
		assert.t( "Deep ancestry caching in post-positional element matcher (jQuery #14657)",
			"#qunit-fixture a:lt(3):parent",
			[ "simon1", "google", "groups" ] );
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
diff --git a/a.js b/b.js
@@ -1836,9 +1837,9 @@ function( assert, jQuery, window, document ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
} );

testIframe(
	"attributes - jQuery.attr",
	"selector/html5_selector.html",
	function( assert, jQuery, window, document ) {
		assert.expect( 38 );

		/**
		 * Returns an array of elements with the given IDs
		 * q & t are added here for the iFrame's context
		 */
		function q() {
			var r = [],
				i = 0;

			for ( ; i < arguments.length; i++ ) {
				r.push( document.getElementById( arguments[ i ] ) );
			}
			return r;
		}

		/**
		 * Asserts that a select matches the given IDs
		 * @example t("Check for something", "//[a]", ["foo", "bar"]);
		 * @param {String} message - Assertion name
		 * @param {String} selector - jQuery selector
		 * @param {Array} expectedIds - Array of ids to construct what is expected
		 */
		function t( message, selector, expectedIds ) {
			var elems = jQuery( selector ).get();

			assert.deepEqual( elems, q.apply( q, expectedIds ), message + " (" + selector + ")" );
		}

		// ====== All known boolean attributes, including html5 booleans ======
		// autobuffer, autofocus, autoplay, async, checked,
		// compact, controls, declare, defer, disabled,
		// formnovalidate, hidden, indeterminate (property only),
		// ismap, itemscope, loop, multiple, muted, nohref, noresize,
		// noshade, nowrap, novalidate, open, pubdate, readonly, required,
		// reversed, scoped, seamless, selected, truespeed, visible (skipping visible attribute, which is on a barprop object)

		t( "Attribute Exists", "[autobuffer]",     [ "video1" ] );
		t( "Attribute Exists", "[autofocus]",      [ "text1" ] );
		t( "Attribute Exists", "[autoplay]",       [ "video1" ] );
		t( "Attribute Exists", "[async]",          [ "script1" ] );
		t( "Attribute Exists", "[checked]",        [ "check1" ] );
		t( "Attribute Exists", "[compact]",        [ "dl" ] );
		t( "Attribute Exists", "[controls]",       [ "video1" ] );
		t( "Attribute Exists", "[declare]",        [ "object1" ] );
		t( "Attribute Exists", "[defer]",          [ "script1" ] );
		t( "Attribute Exists", "[disabled]",       [ "check1" ] );
		t( "Attribute Exists", "[formnovalidate]", [ "form1" ] );
		t( "Attribute Exists", "[hidden]",         [ "div1" ] );
		t( "Attribute Exists", "[indeterminate]",  [] );
		t( "Attribute Exists", "[ismap]",          [ "img1" ] );
		t( "Attribute Exists", "[itemscope]",      [ "div1" ] );
		t( "Attribute Exists", "[loop]",           [ "video1" ] );
		t( "Attribute Exists", "[multiple]",       [ "select1" ] );
		t( "Attribute Exists", "[muted]",          [ "audio1" ] );
		t( "Attribute Exists", "[nohref]",         [ "area1" ] );
		t( "Attribute Exists", "[noresize]",       [ "textarea1" ] );
		t( "Attribute Exists", "[noshade]",        [ "hr1" ] );
		t( "Attribute Exists", "[nowrap]",         [ "td1", "div1" ] );
		t( "Attribute Exists", "[novalidate]",     [ "form1" ] );
		t( "Attribute Exists", "[open]",           [ "details1" ] );
		t( "Attribute Exists", "[pubdate]",        [ "article1" ] );
		t( "Attribute Exists", "[readonly]",       [ "text1" ] );
		t( "Attribute Exists", "[required]",       [ "text1" ] );
		t( "Attribute Exists", "[reversed]",       [ "ol1" ] );
		t( "Attribute Exists", "[scoped]",         [ "style1" ] );
		t( "Attribute Exists", "[seamless]",       [ "iframe1" ] );
		t( "Attribute Exists", "[selected]",       [ "option1" ] );
		t( "Attribute Exists", "[truespeed]",      [ "marquee1" ] );

		// Enumerated attributes (these are not boolean content attributes)
		jQuery.expandedEach = jQuery.each;
		jQuery.expandedEach( [ "draggable", "contenteditable", "aria-disabled" ], function( i, val ) {
			t( "Enumerated attribute", "[" + val + "]", [ "div1" ] );
		} );
		t( "Enumerated attribute", "[spellcheck]", [ "span1" ] );

		t( "tabindex selector does not retrieve all elements in IE6/7 (#8473)",
			"form, [tabindex]", [ "form1", "text1" ] );
		t( "Improperly named form elements do not interfere with form selections (#9570)", "form[name='formName']", [ "form1" ] );
	}
);

QUnit.test( "jQuery.contains", function( assert ) {
diff --git a/a.js b/b.js
@@ -1894,9 +1895,7 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
diff --git a/a.js b/b.js
@@ -1958,8 +1957,12 @@ QUnit.test( "jQuery.uniqueSort", function( assert ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
	assert.ok( jQuery.contains( svg, svg.firstChild.firstChild ), "root granchild" );
	assert.ok( !jQuery.contains( svg.firstChild.firstChild, svg.firstChild ),
		"parent (negative)" );
} );

QUnit.test( "jQuery.uniqueSort", function( assert ) {
	assert.expect( 14 );

	function Arrayish( arr ) {
		var i = this.length = arr.length;
		while ( i-- ) {
			this[ i ] = arr[ i ];
		}
	}
	Arrayish.prototype = {
		slice: [].slice,
		sort: [].sort,
		splice: [].splice
	};

	var i, tests,
		detached = [],
		body = document.body,
		fixture = document.getElementById( "qunit-fixture" ),
		detached1 = document.createElement( "p" ),
		detached2 = document.createElement( "ul" ),
		detachedChild = detached1.appendChild( document.createElement( "a" ) ),
		detachedGrandchild = detachedChild.appendChild( document.createElement( "b" ) );

	for ( i = 0; i < 12; i++ ) {
		detached.push( document.createElement( "li" ) );
		detached[ i ].id = "detached" + i;
		detached2.appendChild( document.createElement( "li" ) ).id = "detachedChild" + i;
	}

	tests = {
		"Empty": {
			input: [],
			expected: []
		},
		"Single-element": {
			input: [ fixture ],
			expected: [ fixture ]
		},
		"No duplicates": {
			input: [ fixture, body ],
			expected: [ body, fixture ]
		},
		"Duplicates": {
			input: [ body, fixture, fixture, body ],
			expected: [ body, fixture ]
		},
		"Detached": {
			input: detached.slice( 0 ),
			expected: detached.slice( 0 )
		},
		"Detached children": {
			input: [
				detached2.childNodes[ 3 ],
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 1 ]
			],
			expected: [
				detached2.childNodes[ 0 ],
				detached2.childNodes[ 1 ],
				detached2.childNodes[ 2 ],
				detached2.childNodes[ 3 ]
			]
		},
		"Attached/detached mixture": {
			input: [ detached1, fixture, detached2, document, detachedChild, body, detachedGrandchild ],
			expected: [ document, body, fixture ],
			length: 3
		}
	};

	jQuery.each( tests, function( label, test ) {
		var length = test.length || test.input.length;
		assert.deepEqual( jQuery.uniqueSort( test.input ).slice( 0, length ), test.expected, label + " (array)" );
		assert.deepEqual( jQuery.uniqueSort( new Arrayish( test.input ) ).slice( 0, length ), test.expected, label + " (quasi-array)" );
	} );
} );

testIframe(
diff --git a/a.js b/b.js
@@ -1987,7 +1990,7 @@ function( assert, jQuery, window, document ) {
A blob:b11b801c6b78470d056d675d5017bea64611675e
);

testIframe(
	"jQuery selector cache collides with multiple jQueries on a page",
	"selector/cache.html",
	function( assert, jQuery, window, document ) {
		var $cached = window.$cached;

		assert.expect( 4 );
		assert.notStrictEqual( jQuery, $cached, "Loaded two engines" );
		assert.deepEqual( $cached( ".test a" ).get(), [ document.getElementById( "collision" ) ], "Select collision anchor with first sizzle" );
		assert.equal( jQuery( ".evil a" ).length, 0, "Select nothing with second sizzle" );
		assert.equal( jQuery( ".evil a" ).length, 0, "Select nothing again with second sizzle" );
	}
);

QUnit.test( "Iframe dispatch should not affect jQuery (#13936)", function( assert ) {
	assert.expect( 1 );
	var loaded = false,
		thrown = false,
		iframe = document.getElementById( "iframe" ),
diff --git a/a.js b/b.js
@@ -12,11 +12,18 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}
diff --git a/a.js b/b.js
@@ -77,6 +84,9 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
diff --git a/a.js b/b.js
@@ -114,9 +124,14 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
diff --git a/a.js b/b.js
@@ -217,15 +232,19 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -240,7 +259,7 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -331,11 +350,18 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
diff --git a/a.js b/b.js
@@ -343,16 +369,16 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
diff --git a/a.js b/b.js
@@ -375,7 +401,7 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"npmcopy",
		"qunit_fixture",
		"babel:tests"
	] );

	grunt.registerTask( "test", [
		"test:prepare",
		"test:fast",
		"test:slow"
	] );

	grunt.registerTask( "dev", [
		"build:*:*",
		"newer:eslint:dev",
		"newer:uglify",
		"remove_map_comment",
		"dist:*",
		"qunit_fixture",
diff --git a/a.js b/b.js
@@ -384,14 +410,14 @@ module.exports = function( grunt ) {
A blob:4afbec9212cc1cd5bd82738ae01eae55b4ab6f4d
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		npmcopy: {
			all: {
				options: {
					destPrefix: "external"
				},
				files: {
					"npo/npo.js": "native-promise-only/lib/npo.src.js",

					"qunit/qunit.js": "qunit/qunit/qunit.js",
					"qunit/qunit.css": "qunit/qunit/qunit.css",
					"qunit/LICENSE.txt": "qunit/LICENSE.txt",

					"requirejs/require.js": "requirejs/require.js",

					"sinon/sinon.js": "sinon/pkg/sinon.js",
					"sinon/LICENSE.txt": "sinon/LICENSE"
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"external/sinon/sinon.js",
					"external/npo/npo.js",
					"external/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "external/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"npmcopy",
		"qunit_fixture",
		"babel:tests"
	] );

	grunt.registerTask( "test", [
		"test:prepare",
		"test:fast",
		"test:slow"
	] );

	grunt.registerTask( "dev", [
		"build:*:*",
		"newer:eslint:dev",
		"newer:uglify",
		"remove_map_comment",
		"dist:*",
		"qunit_fixture",
		"compare_size"
	] );

	grunt.registerTask( "default", [
		"eslint:dev",
		"build:*:*",
		"amd",
		"uglify",
		"remove_map_comment",
		"dist:*",
		"test:prepare",
		"eslint:dist",
		"test:fast",
		"compare_size"
	] );
};
diff --git a/a.js b/b.js
@@ -12,11 +12,18 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}
diff --git a/a.js b/b.js
@@ -71,6 +78,28 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
diff --git a/a.js b/b.js
@@ -95,9 +124,14 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
diff --git a/a.js b/b.js
@@ -162,9 +196,9 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

diff --git a/a.js b/b.js
@@ -188,7 +222,7 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
diff --git a/a.js b/b.js
@@ -198,15 +232,19 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -221,7 +259,7 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

diff --git a/a.js b/b.js
@@ -312,11 +350,18 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
diff --git a/a.js b/b.js
@@ -324,16 +369,16 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
diff --git a/a.js b/b.js
@@ -343,6 +388,7 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"qunit_fixture",
		"babel:tests"
	] );

diff --git a/a.js b/b.js
@@ -355,7 +401,7 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"qunit_fixture",
		"babel:tests"
	] );

	grunt.registerTask( "test", [
		"test:prepare",
		"test:fast",
		"test:slow"
	] );

	grunt.registerTask( "dev", [
		"build:*:*",
		"newer:eslint:dev",
		"newer:uglify",
		"remove_map_comment",
		"dist:*",
		"qunit_fixture",
diff --git a/a.js b/b.js
@@ -364,14 +410,14 @@ module.exports = function( grunt ) {
A blob:5021c59e9e8e082f313d0a8b9f184344285521fd
"use strict";

module.exports = function( grunt ) {
	function readOptionalJSON( filepath ) {
		var stripJSONComments = require( "strip-json-comments" ),
			data = {};
		try {
			data = JSON.parse( stripJSONComments(
				fs.readFileSync( filepath, { encoding: "utf8" } )
			) );
		} catch ( e ) {}
		return data;
	}

	var fs = require( "fs" ),
		gzip = require( "gzip-js" ),
		isTravis = process.env.TRAVIS,
		travisBrowsers = process.env.BROWSERS && process.env.BROWSERS.split( "," ),
		CLIEngine = require( "eslint" ).CLIEngine;

	if ( !grunt.option( "filename" ) ) {
		grunt.option( "filename", "jquery.js" );
	}

	grunt.initConfig( {
		pkg: grunt.file.readJSON( "package.json" ),
		dst: readOptionalJSON( "dist/.destination.json" ),
		compare_size: {
			files: [ "dist/jquery.js", "dist/jquery.min.js" ],
			options: {
				compress: {
					gz: function( contents ) {
						return gzip.zip( contents, {} ).length;
					}
				},
				cache: "build/.sizecache.json"
			}
		},
		babel: {
			options: {
				sourceMap: "inline",
				retainLines: true,
				plugins: [ "@babel/transform-for-of" ]
			},
			tests: {
				files: {
					"test/data/core/jquery-iterability-transpiled.js":
						"test/data/core/jquery-iterability-transpiled-es6.js"
				}
			}
		},
		build: {
			all: {
				dest: "dist/jquery.js",
				minimum: [
					"core",
					"selector"
				],

				// Exclude specified modules if the module matching the key is removed
				removeWith: {
					ajax: [ "manipulation/_evalUrl", "deprecated/ajax-event-alias" ],
					callbacks: [ "deferred" ],
					css: [ "effects", "dimensions", "offset" ],
					"css/showHide": [ "effects" ],
					deferred: {
						remove: [ "ajax", "effects", "queue", "core/ready" ],
						include: [ "core/ready-no-deferred" ]
					},
					event: [ "deprecated/ajax-event-alias", "deprecated/event" ]
				}
			}
		},
		jsonlint: {
			pkg: {
				src: [ "package.json" ]
			}
		},
		eslint: {
			options: {
				maxWarnings: 0
			},

			// We have to explicitly declare "src" property otherwise "newer"
			// task wouldn't work properly :/
			dist: {
				src: [ "dist/jquery.js", "dist/jquery.min.js" ]
			},
			dev: {
				src: [
					"src/**/*.js",
					"Gruntfile.js",
					"test/**/*.js",
					"build/**/*.js",

					// Ignore files from .eslintignore
					// See https://github.com/sindresorhus/grunt-eslint/issues/119
					...new CLIEngine()
						.getConfigForFile( "Gruntfile.js" )
						.ignorePatterns.map( ( p ) => `!${ p }` )
				]
			}
		},
		testswarm: {
			tests: [

				// A special module with basic tests, meant for not fully
				// supported environments like jsdom. We run it everywhere,
				// though, to make sure tests are not broken.
				"basic",

				"ajax",
				"animation",
				"attributes",
				"callbacks",
				"core",
				"css",
				"data",
				"deferred",
				"deprecated",
				"dimensions",
				"effects",
				"event",
				"manipulation",
				"offset",
				"queue",
				"selector",
				"serialize",
				"support",
				"traversing",
				"tween"
			]
		},
		karma: {
			options: {
				customContextFile: "test/karma.context.html",
				customDebugFile: "test/karma.debug.html",
				customLaunchers: {
					ChromeHeadlessNoSandbox: {
						base: "ChromeHeadless",
						flags: [ "--no-sandbox" ]
					}
				},
				frameworks: [ "qunit" ],
				middleware: [ "mockserver" ],
				plugins: [
					"karma-*",
					{
						"middleware:mockserver": [
							"factory",
							require( "./test/middleware-mockserver.js" )
						]
					}
				],
				client: {
					qunit: {

						// We're running `QUnit.start()` ourselves via `loadTests()`
						// in test/jquery.js
						autostart: false
					}
				},
				files: [
					"test/data/jquery-1.9.1.js",
					"node_modules/sinon/pkg/sinon.js",
					"node_modules/native-promise-only/lib/npo.src.js",
					"node_modules/requirejs/require.js",
					"test/data/testinit.js",

					"test/jquery.js",

					{
						pattern: "dist/jquery.*",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "src/**",
						type: "module",
						included: false,
						served: true,
						nocache: true
					},
					{
						pattern: "amd/**",
						included: false,
						served: true,
						nocache: true
					},
					{ pattern: "node_modules/**", included: false, served: true },
					{
						pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
						included: false,
						served: true,
						nocache: true
					}
				],
				reporters: [ "dots" ],
				autoWatch: false,
				concurrency: 3,
				captureTimeout: 20 * 1000,
				singleRun: true
			},
			main: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless", "FirefoxHeadless" ]
			},
			esmodules: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							esmodules: true
						}
					}
				}
			},
			amd: {
				browsers: isTravis && travisBrowsers || [ "ChromeHeadless" ],
				options: {
					client: {
						qunit: {

							// We're running `QUnit.start()` ourselves via `loadTests()`
							// in test/jquery.js
							autostart: false,

							amd: true
						}
					}
				}
			},

			jsdom: {
				options: {
					files: [
						"test/data/jquery-1.9.1.js",
						"test/data/testinit-jsdom.js",

						// We don't support various loading methods like esmodules,
						// choosing a version etc. for jsdom.
						"dist/jquery.js",

						// A partial replacement for testinit.js#loadTests()
						"test/data/testrunner.js",

						// jsdom only runs basic tests
						"test/unit/basic.js",

						{
							pattern: "test/**/*.@(js|css|jpg|html|xml|svg)",
							included: false,
							served: true
						}
					]
				},
				browsers: [ "jsdom" ]
			},

			// To debug tests with Karma:
			// 1. Run 'grunt karma:chrome-debug' or 'grunt karma:firefox-debug'
			//    (any karma subtask that has singleRun=false)
			// 2. Press "Debug" in the opened browser window to start
			//    the tests. Unlike the other karma tasks, the debug task will
			//    keep the browser window open.
			"chrome-debug": {
				browsers: [ "Chrome" ],
				singleRun: false
			},
			"firefox-debug": {
				browsers: [ "Firefox" ],
				singleRun: false
			},
			"ie-debug": {
				browsers: [ "IE" ],
				singleRun: false
			}
		},
		watch: {
			files: [ "<%= eslint.dev.src %>" ],
			tasks: [ "dev" ]
		},
		uglify: {
			all: {
				files: {
					"dist/<%= grunt.option('filename').replace('.js', '.min.js') %>":
						"dist/<%= grunt.option('filename') %>"
				},
				options: {
					preserveComments: false,
					sourceMap: true,
					sourceMapName:
						"dist/<%= grunt.option('filename').replace('.js', '.min.map') %>",
					report: "min",
					output: {
						"ascii_only": true
					},
					banner: "/*! jQuery v<%= pkg.version %> | " +
						"(c) OpenJS Foundation and other contributors | jquery.org/license */",
					compress: {
						"hoist_funs": false,
						loops: false
					}
				}
			}
		}
	} );

	// Load grunt tasks from NPM packages
	require( "load-grunt-tasks" )( grunt );

	// Integrate jQuery specific tasks
	grunt.loadTasks( "build/tasks" );

	grunt.registerTask( "lint", [
		"jsonlint",

		// Running the full eslint task without breaking it down to targets
		// would run the dist target first which would point to errors in the built
		// file, making it harder to fix them. We want to check the built file only
		// if we already know the source files pass the linter.
		"eslint:dev",
		"eslint:dist"
	] );

	grunt.registerTask( "lint:newer", [
		"newer:jsonlint",

		// Don't replace it with just the task; see the above comment.
		"newer:eslint:dev",
		"newer:eslint:dist"
	] );

	grunt.registerTask( "test:fast", "node_smoke_tests" );
	grunt.registerTask( "test:slow", [
		"promises_aplus_tests",
		"karma:jsdom"
	] );

	grunt.registerTask( "test:prepare", [
		"qunit_fixture",
		"babel:tests"
	] );

	grunt.registerTask( "test", [
		"test:prepare",
		"test:fast",
		"test:slow"
	] );

	grunt.registerTask( "dev", [
		"build:*:*",
		"newer:eslint:dev",
		"newer:uglify",
		"remove_map_comment",
		"dist:*",
		"qunit_fixture",
		"compare_size"
	] );

	grunt.registerTask( "default", [
		"eslint:dev",
		"build:*:*",
		"amd",
		"uglify",
		"remove_map_comment",
		"dist:*",
		"test:prepare",
		"eslint:dist",
		"test:fast",
		"compare_size"
	] );
};
diff --git a/a.js b/b.js
@@ -47,10 +47,10 @@ module.exports = function( Release ) {
A blob:0fea98711d7b464e1a4b12e79dd7481238a70cbd
"use strict";

var fs = require( "fs" );

module.exports = function( Release ) {

	const distFiles = [
		"dist/jquery.js",
		"dist/jquery.min.js",
		"dist/jquery.min.map",
		"dist/jquery.slim.js",
		"dist/jquery.slim.min.js",
		"dist/jquery.slim.min.map"
	];
	const filesToCommit = [
		...distFiles,
		"src/core.js"
	];
	const cdn = require( "./release/cdn" );
	const dist = require( "./release/dist" );

	const npmTags = Release.npmTags;

	function setSrcVersion( filepath ) {
		var contents = fs.readFileSync( filepath, "utf8" );
		contents = contents.replace( /@VERSION/g, Release.newVersion );
		fs.writeFileSync( filepath, contents, "utf8" );
	}

	Release.define( {
		npmPublish: true,
		issueTracker: "github",

		/**
		 * Set the version in the src folder for distributing ES modules
		 * and in the amd folder for AMD.
		 */
		_setSrcVersion: function() {
			setSrcVersion( `${ __dirname }/../src/core.js` );
			setSrcVersion( `${ __dirname }/../amd/core.js` );
		},

		/**
		 * Generates any release artifacts that should be included in the release.
		 * The callback must be invoked with an array of files that should be
		 * committed before creating the tag.
		 * @param {Function} callback
		 */
		generateArtifacts: function( callback ) {
			Release.exec( "grunt", "Grunt command failed" );
			Release.exec(
				"grunt custom:slim --filename=jquery.slim.js && " +
					"grunt remove_map_comment --filename=jquery.slim.js",
				"Grunt custom failed"
			);
			cdn.makeReleaseCopies( Release );
			Release._setSrcVersion();
diff --git a/a.js b/b.js
@@ -47,10 +47,10 @@ module.exports = function( Release ) {
A blob:321f59ba7f53a619c1706beaa08ec5b4f4011bdf
"use strict";

var fs = require( "fs" );

module.exports = function( Release ) {

	const distFiles = [
		"dist/jquery.js",
		"dist/jquery.min.js",
		"dist/jquery.min.map",
		"dist/jquery.slim.js",
		"dist/jquery.slim.min.js",
		"dist/jquery.slim.min.map"
	];
	const filesToCommit = [
		...distFiles,
		"src/core.js"
	];
	const cdn = require( "./release/cdn" );
	const dist = require( "./release/dist" );

	const npmTags = Release.npmTags;

	function setSrcVersion( filepath ) {
		var contents = fs.readFileSync( filepath, "utf8" );
		contents = contents.replace( /@VERSION/g, Release.newVersion );
		fs.writeFileSync( filepath, contents, "utf8" );
	}

	Release.define( {
		npmPublish: true,
		issueTracker: "github",

		/**
		 * Set the version in the src folder for distributing ES modules
		 * and in the amd folder for AMD.
		 */
		_setSrcVersion: function() {
			setSrcVersion( `${ __dirname }/../src/core.js` );
			setSrcVersion( `${ __dirname }/../amd/core.js` );
		},

		/**
		 * Generates any release artifacts that should be included in the release.
		 * The callback must be invoked with an array of files that should be
		 * committed before creating the tag.
		 * @param {Function} callback
		 */
		generateArtifacts: function( callback ) {
			Release.exec( "grunt", "Grunt command failed" );
			Release.exec(
				"grunt custom:slim --filename=jquery.slim.js && " +
					"grunt remove_map_comment --filename=jquery.slim.js",
				"Grunt custom failed"
			);
			cdn.makeReleaseCopies( Release );
			Release._setSrcVersion();
diff --git a/a.js b/b.js
@@ -83,8 +83,7 @@ module.exports = function( Release ) {
A blob:321f59ba7f53a619c1706beaa08ec5b4f4011bdf
"use strict";

var fs = require( "fs" );

module.exports = function( Release ) {

	const distFiles = [
		"dist/jquery.js",
		"dist/jquery.min.js",
		"dist/jquery.min.map",
		"dist/jquery.slim.js",
		"dist/jquery.slim.min.js",
		"dist/jquery.slim.min.map"
	];
	const filesToCommit = [
		...distFiles,
		"src/core.js"
	];
	const cdn = require( "./release/cdn" );
	const dist = require( "./release/dist" );

	const npmTags = Release.npmTags;

	function setSrcVersion( filepath ) {
		var contents = fs.readFileSync( filepath, "utf8" );
		contents = contents.replace( /@VERSION/g, Release.newVersion );
		fs.writeFileSync( filepath, contents, "utf8" );
	}

	Release.define( {
		npmPublish: true,
		issueTracker: "github",

		/**
		 * Set the version in the src folder for distributing ES modules
		 * and in the amd folder for AMD.
		 */
		_setSrcVersion: function() {
			setSrcVersion( `${ __dirname }/../src/core.js` );
			setSrcVersion( `${ __dirname }/../amd/core.js` );
		},

		/**
		 * Generates any release artifacts that should be included in the release.
		 * The callback must be invoked with an array of files that should be
		 * committed before creating the tag.
		 * @param {Function} callback
		 */
		generateArtifacts: function( callback ) {
			Release.exec( "grunt", "Grunt command failed" );
			Release.exec(
				"grunt custom:slim --filename=jquery.slim.js && " +
					"grunt remove_map_comment --filename=jquery.slim.js",
				"Grunt custom failed"
			);
			cdn.makeReleaseCopies( Release );
			Release._setSrcVersion();
			callback( filesToCommit );
		},

		/**
		 * Acts as insertion point for restoring Release.dir.repo
		 * It was changed to reuse npm publish code in jquery-release
		 * for publishing the distribution repo instead
		 */
		npmTags: function() {

			// origRepo is not defined if dist was skipped
			Release.dir.repo = Release.dir.origRepo || Release.dir.repo;
			return npmTags();
		},

		/**
		 * Publish to distribution repo and npm
		 * @param {Function} callback
		 */
		dist: function( callback ) {
			cdn.makeArchives( Release, function() {
				dist( Release, distFiles, callback );
			} );
		}
	} );
};

module.exports.dependencies = [
	"archiver@1.3.0",
	"shelljs@0.7.7",
	"inquirer@7.0.4",
	"npm@4.4.1"
];

diff --git a/a.js b/b.js
@@ -33,6 +33,15 @@ support.reliableTrDimensions = function() {
A blob:9e6a915d2bbb5d55235f4df3a45f1db845c31485
// IE misreports `getComputedStyle` of table rows with width/height
// set in CSS while `offset*` properties report correct values.
// Support: Firefox 70+
// Only Firefox includes border widths
// in computed dimensions. (gh-4529)
support.reliableTrDimensions = function() {
	var table, tr, trStyle;
	if ( reliableTrDimensionsVal == null ) {
		table = document.createElement( "table" );
		tr = document.createElement( "tr" );

		table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
		tr.style.cssText = "border:1px solid";

		// Support: Chrome 86+
		// Height set through cssText does not get applied.
		// Computed height then comes back as 0.
		tr.style.height = "1px";
		div.style.height = "9px";

		documentElement
			.appendChild( table )
			.appendChild( tr )
			.appendChild( div );
diff --git a/a.js b/b.js
@@ -31,9 +31,9 @@ module.exports = function( Release, files, complete ) {
A blob:c8f7116bdad971988222e8daf06f10cd4606ca59
"use strict";

module.exports = function( Release, files, complete ) {

	const fs = require( "fs" ).promises;
	const shell = require( "shelljs" );
	const inquirer = require( "inquirer" );
	const pkg = require( `${ Release.dir.repo }/package.json` );
	const distRemote = Release.remote

		// For local and github dists
		.replace( /jquery(\.git|$)/, "jquery-dist$1" );

	// These files are included with the distribution
	const extras = [
		"amd",
		"src",
		"LICENSE.txt",
		"AUTHORS.txt",
		"package.json"
	];

	/**
	 * Clone the distribution repo
	 */
	function clone() {
		Release.chdir( Release.dir.base );
		Release.dir.dist = `${ Release.dir.base }/dist`;

		console.log( "Using distribution repo: ", distRemote );
		Release.exec( `git clone ${ distRemote } ${ Release.dir.dist }`,
			"Error cloning repo." );

		// Distribution always works on master
		Release.chdir( Release.dir.dist );
		Release.exec( "git checkout master", "Error checking out branch." );
		console.log();
	}

	/**
diff --git a/a.js b/b.js
@@ -140,8 +140,8 @@ module.exports = function( Release, files, complete ) {
A blob:c8f7116bdad971988222e8daf06f10cd4606ca59
"use strict";

module.exports = function( Release, files, complete ) {

	const fs = require( "fs" ).promises;
	const shell = require( "shelljs" );
	const inquirer = require( "inquirer" );
	const pkg = require( `${ Release.dir.repo }/package.json` );
	const distRemote = Release.remote

		// For local and github dists
		.replace( /jquery(\.git|$)/, "jquery-dist$1" );

	// These files are included with the distribution
	const extras = [
		"amd",
		"src",
		"LICENSE.txt",
		"AUTHORS.txt",
		"package.json"
	];

	/**
	 * Clone the distribution repo
	 */
	function clone() {
		Release.chdir( Release.dir.base );
		Release.dir.dist = `${ Release.dir.base }/dist`;

		console.log( "Using distribution repo: ", distRemote );
		Release.exec( `git clone ${ distRemote } ${ Release.dir.dist }`,
			"Error cloning repo." );

		// Distribution always works on master
		Release.chdir( Release.dir.dist );
		Release.exec( "git checkout master", "Error checking out branch." );
		console.log();
	}

	/**
	 * Generate bower file for jquery-dist
	 */
	function generateBower() {
		return JSON.stringify( {
			name: pkg.name,
			main: pkg.main,
			license: "MIT",
			ignore: [
				"package.json"
			],
			keywords: pkg.keywords
		}, null, 2 );
	}

	/**
	 * Replace the version in the README
	 * @param {string} readme
	 * @param {string} blogPostLink
	 */
	function editReadme( readme, blogPostLink ) {
		return readme
			.replace( /@VERSION/g, Release.newVersion )
			.replace( /@BLOG_POST_LINK/g, blogPostLink );
	}

	/**
	 * Copy necessary files over to the dist repo
	 */
	async function copy() {

		// Copy dist files
		const distFolder = `${ Release.dir.dist }/dist`;
		const readme = await fs.readFile(
			`${ Release.dir.repo }/build/fixtures/README.md`, "utf8" );
		const rmIgnore = [ ...files, "node_modules" ]
			.map( file => `${ Release.dir.dist }/${ file }` );

		shell.config.globOptions = {
			ignore: rmIgnore
		};

		const { blogPostLink } = await inquirer.prompt( [ {
			type: "input",
			name: "blogPostLink",
			message: "Enter URL of the blog post announcing the jQuery release...\n"
		} ] );

		// Remove extraneous files before copy
		shell.rm( "-rf", `${ Release.dir.dist }/**/*` );

		shell.mkdir( "-p", distFolder );
		files.forEach( function( file ) {
			shell.cp( "-f", `${ Release.dir.repo }/${ file }`, distFolder );
		} );

		// Copy other files
		extras.forEach( function( file ) {
			shell.cp( "-rf", `${ Release.dir.repo }/${ file }`, Release.dir.dist );
		} );

		// Remove the wrapper & the ESLint config from the dist repo
		shell.rm( "-f", `${ Release.dir.dist }/src/wrapper.js` );
		shell.rm( "-f", `${ Release.dir.dist }/src/.eslintrc.json` );

		// Write generated bower file
		await fs.writeFile( `${ Release.dir.dist }/bower.json`, generateBower() );

		await fs.writeFile( `${ Release.dir.dist }/README.md`,
			editReadme( readme, blogPostLink ) );

		console.log( "Files ready to add." );
	}

	/**
	 * Add, commit, and tag the dist files
	 */
	function commit() {
		console.log( "Adding files to dist..." );
		Release.exec( "git add -A", "Error adding files." );
		Release.exec(
			`git commit -m "Release ${ Release.newVersion }"`,
			"Error committing files."
		);
		console.log();

		console.log( "Tagging release on dist..." );
		Release.exec( `git tag ${ Release.newVersion }`,
			`Error tagging ${ Release.newVersion } on dist repo.` );
		Release.tagTime = Release.exec( "git log -1 --format=\"%ad\"",
			"Error getting tag timestamp." ).trim();
	}

	/**
	 * Push files to dist repo
	 */
	function push() {
		Release.chdir( Release.dir.dist );

		console.log( "Pushing release to dist repo..." );
		Release.exec(
			`git push ${
				Release.isTest ? " --dry-run" : ""
			} ${ distRemote } master --tags`,
			"Error pushing master and tags to git repo."
		);

		// Set repo for npm publish
		Release.dir.origRepo = Release.dir.repo;
diff --git a/a.js b/b.js
@@ -54,8 +54,8 @@ 	checkSupport = function( assert ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43
	return;
}

var supportsScroll, alwaysScrollable,
	forceScroll = supportjQuery( "<div></div>" ).css( { width: 2000, height: 2000 } ),
	checkSupport = function( assert ) {

		// Only run once
		checkSupport = false;

		// Append forceScroll to the body instead of #qunit-fixture because the latter is hidden
		forceScroll.appendTo( "body" );
		window.scrollTo( 200, 200 );
		supportsScroll = document.documentElement.scrollTop || document.body.scrollTop;
		forceScroll.detach();

		// Support: iOS <=7 - 12+
		// Hijack the iframe test infrastructure to detect viewport scrollability
		// for pages with position:fixed document element
		var done = assert.async();
		testIframe(
			null,
			"offset/boxes.html",
			function( assert, $, win, doc ) {
				var scrollTop = win.pageYOffset,
					scrollLeft = win.pageXOffset;
				doc.documentElement.style.position = "fixed";
				win.scrollTo( scrollLeft, scrollTop );
				alwaysScrollable = win.pageXOffset !== 0;
				done();
			},
			function mockQUnit_test( _, testCallback ) {
				setTimeout( function() {
					testCallback( assert );
				} );
			}
		);
	};

QUnit.module( "offset", { beforeEach: function( assert ) {
	if ( typeof checkSupport === "function" ) {
		checkSupport( assert );
	}

	// Force a scroll value on the main window to ensure incorrect results
	// if offset is using the scroll offset of the parent window
	forceScroll.appendTo( "body" );
	window.scrollTo( 1, 1 );
	forceScroll.detach();
}, afterEach: moduleTeardown } );

QUnit.test( "empty set", function( assert ) {
	assert.expect( 2 );
	assert.strictEqual( jQuery().offset(), undefined, "offset() returns undefined for empty set (#11962)" );
	assert.strictEqual( jQuery().position(), undefined, "position() returns undefined for empty set (#11962)" );
} );

QUnit.test( "disconnected element", function( assert ) {
	assert.expect( 4 );
diff --git a/a.js b/b.js
@@ -63,7 +63,7 @@ QUnit.test( "disconnected element", function( assert ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43
	assert.expect( 2 );
	assert.strictEqual( jQuery().offset(), undefined, "offset() returns undefined for empty set (#11962)" );
	assert.strictEqual( jQuery().position(), undefined, "position() returns undefined for empty set (#11962)" );
} );

QUnit.test( "disconnected element", function( assert ) {
	assert.expect( 4 );

	var result = jQuery( document.createElement( "div" ) ).offset();

	// These tests are solely for master/compat consistency
	// Retrieving offset on disconnected/hidden elements is not officially
	// valid input, but will return zeros for back-compat
	assert.equal( result.top, 0, "Retrieving offset on disconnected elements returns zeros (gh-2310)" );
	assert.equal( result.left, 0, "Retrieving offset on disconnected elements returns zeros (gh-2310)" );
diff --git a/a.js b/b.js
@@ -80,7 +80,7 @@ QUnit.test( "hidden (display: none) element", function( assert ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43
	assert.equal( result.left, 0, "Retrieving offset on disconnected elements returns zeros (gh-2310)" );
	assert.equal( Object.keys( result ).length, 2, "Retrieving offset on disconnected elements returns offset object (gh-3167)" );
	assert.equal( jQuery.isPlainObject( result ), true, "Retrieving offset on disconnected elements returns plain object (gh-3612)" );
} );

QUnit.test( "hidden (display: none) element", function( assert ) {
	assert.expect( 4 );

	var node = jQuery( "<div style='display: none'></div>" ).appendTo( "#qunit-fixture" ),
		result = node.offset();

	node.remove();

	// These tests are solely for master/compat consistency
	// Retrieving offset on disconnected/hidden elements is not officially
	// valid input, but will return zeros for back-compat
	assert.equal( result.top, 0, "Retrieving offset on hidden elements returns zeros (gh-2310)" );
	assert.equal( result.left, 0, "Retrieving offset on hidden elements returns zeros (gh-2310)" );
diff --git a/a.js b/b.js
@@ -187,7 +187,7 @@ testIframe( "absolute", "offset/absolute.html", function( assert, $ ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43
		assert.equal( jQuery( this.id, doc ).position().top,  this.top,  "jQuery('" + this.id + "').position().top" );
		assert.equal( jQuery( this.id, doc ).position().left, this.left, "jQuery('" + this.id + "').position().left" );
	} );
} );

testIframe( "absolute", "offset/absolute.html", function( assert, $ ) {
	assert.expect( 178 );

	var tests, offset;

	// get offset tests
	tests = [
		{ "id": "#absolute-1",     "top":  1, "left":  1 },
		{ "id": "#absolute-1-1",   "top":  5, "left":  5 },
		{ "id": "#absolute-1-1-1", "top":  9, "left":  9 },
		{ "id": "#absolute-2",     "top": 20, "left": 20 }
	];
	jQuery.each( tests, function() {
		assert.equal( $( this.id ).offset().top,  this.top,  "jQuery('" + this.id + "').offset().top" );
		assert.equal( $( this.id ).offset().left, this.left, "jQuery('" + this.id + "').offset().left" );
	} );

	// get position
	tests = [
		{ "id": "#absolute-1",     "top":  0, "left":  0 },
		{ "id": "#absolute-1-1",   "top":  1, "left":  1 },
		{ "id": "#absolute-1-1-1", "top":  1, "left":  1 },
		{ "id": "#absolute-2",     "top": 19, "left": 19 }
	];
	jQuery.each( tests, function() {
		assert.equal( $( this.id ).position().top,  this.top,  "jQuery('" + this.id + "').position().top" );
		assert.equal( $( this.id ).position().left, this.left, "jQuery('" + this.id + "').position().left" );
	} );

	// test #5781
	offset = $( "#positionTest" ).offset( { "top": 10, "left": 10 } ).offset();
	assert.equal( offset.top,  10, "Setting offset on element with position absolute but 'auto' values." );
	assert.equal( offset.left, 10, "Setting offset on element with position absolute but 'auto' values." );

diff --git a/a.js b/b.js
@@ -454,7 +454,7 @@ testIframe( "scroll", "offset/scroll.html", function( assert, $, win ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43

	assert.equal( $( "#th-1" ).offset().top, 10, "jQuery('#th-1').offset().top" );
	assert.equal( $( "#th-1" ).offset().left, 10, "jQuery('#th-1').offset().left" );
} );

testIframe( "scroll", "offset/scroll.html", function( assert, $, win ) {
	assert.expect( 26 );

	assert.equal( $( "#scroll-1" ).offset().top, 7, "jQuery('#scroll-1').offset().top" );
	assert.equal( $( "#scroll-1" ).offset().left, 7, "jQuery('#scroll-1').offset().left" );

	assert.equal( $( "#scroll-1-1" ).offset().top, 11, "jQuery('#scroll-1-1').offset().top" );
	assert.equal( $( "#scroll-1-1" ).offset().left, 11, "jQuery('#scroll-1-1').offset().left" );

	// These tests are solely for master/compat consistency
	// Retrieving offset on disconnected/hidden elements is not officially
	// valid input, but will return zeros for back-compat
	assert.equal( $( "#hidden" ).offset().top, 0, "Hidden elements do not subtract scroll" );
	assert.equal( $( "#hidden" ).offset().left, 0, "Hidden elements do not subtract scroll" );
diff --git a/a.js b/b.js
@@ -468,8 +468,8 @@ testIframe( "scroll", "offset/scroll.html", function( assert, $, win ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43

	assert.equal( $( "#th-1" ).offset().top, 10, "jQuery('#th-1').offset().top" );
	assert.equal( $( "#th-1" ).offset().left, 10, "jQuery('#th-1').offset().left" );
} );

testIframe( "scroll", "offset/scroll.html", function( assert, $, win ) {
	assert.expect( 26 );

	assert.equal( $( "#scroll-1" ).offset().top, 7, "jQuery('#scroll-1').offset().top" );
	assert.equal( $( "#scroll-1" ).offset().left, 7, "jQuery('#scroll-1').offset().left" );

	assert.equal( $( "#scroll-1-1" ).offset().top, 11, "jQuery('#scroll-1-1').offset().top" );
	assert.equal( $( "#scroll-1-1" ).offset().left, 11, "jQuery('#scroll-1-1').offset().left" );

	// These tests are solely for master/compat consistency
	// Retrieving offset on disconnected/hidden elements is not officially
	// valid input, but will return zeros for back-compat
	assert.equal( $( "#hidden" ).offset().top, 0, "Hidden elements do not subtract scroll" );
	assert.equal( $( "#hidden" ).offset().left, 0, "Hidden elements do not subtract scroll" );

	// scroll offset tests .scrollTop/Left
	assert.equal( $( "#scroll-1" ).scrollTop(), 5, "jQuery('#scroll-1').scrollTop()" );
	assert.equal( $( "#scroll-1" ).scrollLeft(), 5, "jQuery('#scroll-1').scrollLeft()" );

	assert.equal( $( "#scroll-1-1" ).scrollTop(), 0, "jQuery('#scroll-1-1').scrollTop()" );
	assert.equal( $( "#scroll-1-1" ).scrollLeft(), 0, "jQuery('#scroll-1-1').scrollLeft()" );

	// scroll method chaining
	assert.equal( $( "#scroll-1" ).scrollTop( undefined ).scrollTop(), 5, ".scrollTop(undefined) is chainable (#5571)" );
	assert.equal( $( "#scroll-1" ).scrollLeft( undefined ).scrollLeft(), 5, ".scrollLeft(undefined) is chainable (#5571)" );

	win.name = "test";

	if ( !window.supportsScroll ) {
diff --git a/a.js b/b.js
@@ -519,7 +519,7 @@ QUnit.test( "chaining", function( assert ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43
	assert.equal( $( "body" ).offset().left, 1, "jQuery('#body').offset().left" );
	assert.equal( $( "#firstElement" ).position().left, 5, "$('#firstElement').position().left" );
	assert.equal( $( "#firstElement" ).position().top, 5, "$('#firstElement').position().top" );
} );

QUnit.test( "chaining", function( assert ) {
	assert.expect( 3 );

	var coords = { "top":  1, "left":  1 };
	assert.equal( jQuery( "#absolute-1" ).offset( coords ).jquery, jQuery.fn.jquery, "offset(coords) returns jQuery object" );
	assert.equal( jQuery( "#non-existent" ).offset( coords ).jquery, jQuery.fn.jquery, "offset(coords) with empty jQuery set returns jQuery object" );
	assert.equal( jQuery( "#absolute-1" ).offset( undefined ).jquery, jQuery.fn.jquery, "offset(undefined) returns jQuery object (#5571)" );
} );

// Test complex content under a variety of <html>/<body> positioning styles
( function() {
diff --git a/a.js b/b.js
@@ -729,11 +729,11 @@ QUnit.test( "offsetParent", function( assert ) {
A blob:b3d2dd783fd44efd7384b6362df2d10806876a43
			} );
		} );
	} );
} )();

QUnit.test( "offsetParent", function( assert ) {
	assert.expect( 13 );

	var body, header, div, area;

	body = jQuery( "body" ).offsetParent();
	assert.equal( body.length, 1, "Only one offsetParent found." );
	assert.equal( body[ 0 ], document.documentElement, "The html element is the offsetParent of the body." );

	header = jQuery( "#qunit" ).offsetParent();
	assert.equal( header.length, 1, "Only one offsetParent found." );
	assert.equal( header[ 0 ], document.documentElement, "The html element is the offsetParent of #qunit." );

	jQuery( "#qunit-fixture" ).css( "position", "absolute" );
	div = jQuery( "#nothiddendivchild" ).offsetParent();
	assert.equal( div.length, 1, "Only one offsetParent found." );
	assert.equal( div[ 0 ], document.getElementById( "qunit-fixture" ), "The #qunit-fixture is the offsetParent of #nothiddendivchild." );
	jQuery( "#qunit-fixture" ).css( "position", "" );

	jQuery( "#nothiddendiv" ).css( "position", "relative" );

	div = jQuery( "#nothiddendivchild" ).offsetParent();
	assert.equal( div.length, 1, "Only one offsetParent found." );
	assert.equal( div[ 0 ], jQuery( "#nothiddendiv" )[ 0 ], "The div is the offsetParent." );

	div = jQuery( "body, #nothiddendivchild" ).offsetParent();
	assert.equal( div.length, 2, "Two offsetParent found." );
	assert.equal( div[ 0 ], document.documentElement, "The html element is the offsetParent of the body." );
	assert.equal( div[ 1 ], jQuery( "#nothiddendiv" )[ 0 ], "The div is the offsetParent." );

	area = jQuery( "<map name=\"imgmap\"><area shape=\"rect\" coords=\"0,0,200,50\"></map>" ).appendTo( "body" ).find( "area" );
	assert.equal( area.offsetParent()[ 0 ], document.documentElement, "The html element is the offsetParent of a map area." );
	area.remove();

	div = jQuery( "<div>" ).css( { "position": "absolute" } ).appendTo( "body" );
	assert.equal( div.offsetParent()[ 0 ], document.documentElement, "Absolutely positioned div returns html as offset parent, see #12139" );
	div.remove();
} );

QUnit.test( "fractions (see #7730 and #7885)", function( assert ) {
	assert.expect( 2 );

	jQuery( "body" ).append( "<div id='fractions'></div>" );

diff --git a/a.js b/b.js
@@ -19,22 +19,13 @@ function canUseScriptTag( s ) {
A blob:203ea08e0f1d460b63096e02af2d7b10b42eedb7
import jQuery from "../core.js";
import document from "../var/document.js";

import "../ajax.js";

function canUseScriptTag( s ) {

	// A script tag can only be used for async, cross domain or forced-by-attrs requests.
	// Sync requests remain handled differently to preserve strict script ordering.
	return s.crossDomain || s.scriptAttrs ||

		// When dealing with JSONP (`s.dataTypes` include "json" then)
		// don't use a script tag so that error responses still may have
		// `responseJSON` set. Continue using a script tag for JSONP requests that:
		//   * are cross-domain as AJAX requests won't work without a CORS setup
		//   * have `scriptAttrs` set as that's a script-only functionality
		// Note that this means JSONP requests violate strict CSP script-src settings.
		// A proper solution is to migrate from using JSONP to a CORS setup.
		( s.async && jQuery.inArray( "json", s.dataTypes ) < 0 );
}

// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
diff --git a/a.js b/b.js
@@ -71,13 +71,20 @@ ajaxTest( "jQuery.ajax() - success callbacks - (url, options) syntax", 8, functi
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - success callbacks - (url, options) syntax", 8, function( assert ) {
		return {
			setup: addGlobalEvents( "ajaxStart ajaxStop ajaxSend ajaxComplete ajaxSuccess", assert ),
			create: function( options ) {
				return jQuery.ajax( url( "name.html" ), options );
			},
			beforeSend: function() {
				assert.ok( true, "beforeSend" );
			},
			success: function() {
				assert.ok( true, "success" );
			},
			complete: function() {
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - execute js for crossOrigin when dataType option is provided", 3,
		function( assert ) {
			return {
				create: function( options ) {
					options.crossDomain = true;
					options.dataType = "script";
					return jQuery.ajax( url( "mock.php?action=script&header=ecma" ), options );
				},
				success: function() {
					assert.ok( true, "success" );
				},
diff --git a/a.js b/b.js
@@ -89,20 +96,13 @@ ajaxTest( "jQuery.ajax() - execute js for crossOrigin when dataType option is pr
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - execute js for crossOrigin when dataType option is provided", 3,
		function( assert ) {
			return {
				create: function( options ) {
					options.crossDomain = true;
					options.dataType = "script";
					return jQuery.ajax( url( "mock.php?action=script&header=ecma" ), options );
				},
				success: function() {
					assert.ok( true, "success" );
				},
				complete: function() {
					assert.ok( true, "complete" );
				}
			};
		}
	);

	ajaxTest( "jQuery.ajax() - custom attributes for script tag", 5,
		function( assert ) {
			return {
				create: function( options ) {
					var xhr;
					options.method = "POST";
					options.dataType = "script";
					options.scriptAttrs = { id: "jquery-ajax-test", async: "async" };
					xhr = jQuery.ajax( url( "mock.php?action=script" ), options );
					assert.equal( jQuery( "#jquery-ajax-test" ).attr( "async" ), "async", "attr value" );
					return xhr;
				},
				beforeSend: function( _jqXhr, settings ) {
					assert.strictEqual( settings.type, "GET", "Type changed to GET" );
				},
				success: function() {
					assert.ok( true, "success" );
				},
diff --git a/a.js b/b.js
@@ -114,22 +114,16 @@ ajaxTest( "jQuery.ajax() - custom attributes for script tag", 5,
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				}
			};
		}
	);

	ajaxTest( "jQuery.ajax() - custom attributes for script tag", 5,
		function( assert ) {
			return {
				create: function( options ) {
					var xhr;
					options.method = "POST";
					options.dataType = "script";
					options.scriptAttrs = { id: "jquery-ajax-test", async: "async" };
					xhr = jQuery.ajax( url( "mock.php?action=script" ), options );
					assert.equal( jQuery( "#jquery-ajax-test" ).attr( "async" ), "async", "attr value" );
					return xhr;
				},
				beforeSend: function( _jqXhr, settings ) {
					assert.strictEqual( settings.type, "GET", "Type changed to GET" );
				},
				success: function() {
					assert.ok( true, "success" );
				},
				complete: function() {
					assert.ok( true, "complete" );
				}
			};
		}
	);

	ajaxTest( "jQuery.ajax() - do not execute js (crossOrigin)", 2, function( assert ) {
		return {
			create: function( options ) {
				options.crossDomain = true;
				return jQuery.ajax( url( "mock.php?action=script&header" ), options );
			},
			success: function() {
				assert.ok( true, "success" );
			},
			fail: function() {
				assert.ok( false, "fail" );
			},
			complete: function() {
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - success callbacks (late binding)", 8, function( assert ) {
		return {
diff --git a/a.js b/b.js
@@ -619,7 +613,7 @@ ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				complete: callback( "complete" )
			} ]
		};
	} );

	ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
		function nocallback( msg ) {
			return function() {
				assert.equal( typeof this.url, "string", "context is settings on callback " + msg );
			};
		}
		return {
			url: url( "404.txt" ),
			beforeSend: nocallback( "beforeSend" ),
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
diff --git a/a.js b/b.js
@@ -635,7 +629,7 @@ ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function(
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
				holder = jQuery.event;
				delete jQuery.event;
			},
			complete: function() {
				assert.ok( true, "Call can be made without jQuery.event" );
				jQuery.event = holder;
			},
			success: true
		};
	} );

	ajaxTest( "#15160 - jQuery.ajax() - request manually aborted in ajaxSend", 3, function( assert ) {
		return {
			setup: function() {
				jQuery( document ).on( "ajaxSend", function( e, jqXHR ) {
					jqXHR.abort();
diff --git a/a.js b/b.js
@@ -1439,25 +1433,6 @@ ajaxTest( "jQuery.ajax() - malformed JSON", 2, function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( window[ "testBar" ], "bar", "Script results returned (GET, no callback)" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - malformed JSON", 2, function( assert ) {
		return {
			url: baseURL + "badjson.js",
			dataType: "json",
			error: function( xhr, msg, detailedMsg ) {
				assert.strictEqual( msg, "parsererror", "A parse error occurred." );
				assert.ok( /(invalid|error|exception)/i.test( detailedMsg ), "Detailed parsererror message provided" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - script by content-type", 2, function() {
		return [
			{
				url: baseURL + "mock.php?action=script",
				data: {
					"header": "script"
				},
				success: true
			},
			{
				url: baseURL + "mock.php?action=script",
				data: {
					"header": "ecma"
				},
				success: true
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - JSON by content-type", 5, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			data: {
diff --git a/a.js b/b.js
@@ -1659,12 +1634,25 @@ ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
			},
			error: true
		};
	} );

	ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
		return {
			url: "bogus.html",
			data: { devo: "A Beautiful World" },
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.deepEqual( s.data, { devo: "A Beautiful World" }, "data is not processed" );
				return false;
			},
			error: true
		};
	} );

		ajaxTest( "jQuery.ajax() - data - process string with GET", 2, function( assert ) {
		return {
			url: "bogus.html",
			data: "a=1&b=2",
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.equal( s.url, "bogus.html?a=1&b=2", "added data to url" );
				assert.equal( s.data, undefined, "removed data from settings" );
				return false;
			},
			error: true
		};
	} );

	var ifModifiedNow = new Date();

	jQuery.each(
		/* jQuery.each arguments start */
		{
			" (cache)": true,
			" (no cache)": false
		},
		function( label, cache ) {
			jQuery.each(
				{
					"If-Modified-Since": "mock.php?action=ims",
					"Etag": "mock.php?action=etag"
				},
				function( type, url ) {
					url = baseURL + url + "&ts=" + ifModifiedNow++;
					QUnit.test( "jQuery.ajax() - " + type + " support" + label, function( assert ) {
						assert.expect( 4 );
						var done = assert.async();
						jQuery.ajax( {
							url: url,
diff --git a/a.js b/b.js
@@ -1729,7 +1717,8 @@ QUnit.test( "jQuery.ajax() - statusText", function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.ok( true, "success" );
			}
		};
	} );

	QUnit.test( "jQuery.ajax() - statusText", function( assert ) {
		assert.expect( 3 );
		var done = assert.async();
		jQuery.ajax( url( "mock.php?action=status&code=200&text=Hello" ) ).done( function( _, statusText, jqXHR ) {
			assert.strictEqual( statusText, "success", "callback status text ok for success" );
			assert.ok( jqXHR.statusText === "Hello" || jqXHR.statusText === "OK", "jqXHR status text ok for success (" + jqXHR.statusText + ")" );
			jQuery.ajax( url( "mock.php?action=status&code=404&text=World" ) ).fail( function( jqXHR, statusText ) {
				assert.strictEqual( statusText, "error", "callback status text ok for error" );
				done();
			} );
diff --git a/a.js b/b.js
@@ -1906,7 +1895,7 @@ ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				}
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success callback.", 1, function( assert ) {
		return {
			url: url( "mock.php?action=echoData" ),
			error: function( _, __, error ) {
				assert.equal( typeof error === "object", true,  "Didn't get back error object for empty json response" );
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
diff --git a/a.js b/b.js
@@ -1932,7 +1921,7 @@ ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( ass
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
					beforeSend: function() {
						assert.ok( true, "beforeSend got called, canceling" );
						return false;
					},
					success: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					complete: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					error: function() {
						assert.ok( false, "request didn't get canceled" );
					}
				} );
			},
			fail: function( _, reason ) {
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
diff --git a/a.js b/b.js
@@ -1946,7 +1935,7 @@ ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, f
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
					return "value";
				}
			},
			success: function( result ) {
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
diff --git a/a.js b/b.js
@@ -1964,7 +1953,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -1978,7 +1967,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function() {
					assert.strictEqual( this.cache, false, "cache must be false on JSON request" );
					return false;
				},
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
diff --git a/a.js b/b.js
@@ -2017,7 +2006,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -2055,7 +2044,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function( jqXHR, s ) {
					s.callback = s.jsonpCallback;

					assert.ok( this.callback in window, "JSONP callback name is in the window" );
				},
				success: function() {
					var previous = this;

					assert.strictEqual(
						previous.jsonpCallback,
						undefined,
						"jsonpCallback option is set back to default in callbacks"
					);

					assert.ok(
						!( this.callback in window ),
						"JSONP callback name was removed from the window"
					);

					jQuery.ajax( {
						url: baseURL + "mock.php?action=jsonp",
						dataType: "jsonp",
						crossDomain: crossDomain,
						beforeSend: function() {
							assert.strictEqual( this.jsonpCallback, previous.callback, "JSONP callback name is re-used" );
							return false;
						}
					} );
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
diff --git a/a.js b/b.js
@@ -2089,7 +2078,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
diff --git a/a.js b/b.js
@@ -2099,7 +2088,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
diff --git a/a.js b/b.js
@@ -2113,7 +2102,7 @@ ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
				return string;
			},
			error: function( jqXHR ) {
				assert.strictEqual( jqXHR.responseText, "{ \"code\": 40, \"message\": \"Bad Request\" }", "Error body properly set" );
				assert.deepEqual( jqXHR.responseJSON, { code: 40, message: "Bad Request" }, "Error body properly parsed" );
			}
		};
	} );

	ajaxTest( "#11426 - jQuery.ajax() - loading binary data shouldn't throw an exception in IE", 1, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			success: function( data ) {
				assert.ok( data === undefined || /JFIF/.test( data ), "success callback reached" );
diff --git a/a.js b/b.js
@@ -2146,7 +2135,7 @@ ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception",
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
		s.xhrFields = { responseType: "arraybuffer" };
		s.responseFields.arraybuffer = "response";
		s.converters[ "binary arraybuffer" ] = true;
	} );

	ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception", 2, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			dataType: "arraybuffer",
			success: function( data, s, jqxhr ) {
				assert.ok( data instanceof window.ArrayBuffer, "correct data type" );
				assert.ok( jqxhr.response instanceof window.ArrayBuffer, "data in jQXHR" );
			}
		};
	} );
}

	QUnit.test( "#11743 - jQuery.ajax() - script, throws exception", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		var onerror = window.onerror;
		window.onerror = function() {
diff --git a/a.js b/b.js
@@ -2181,7 +2170,7 @@ 				options.success = function( msg ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
diff --git a/a.js b/b.js
@@ -2200,7 +2189,7 @@ 				options.success = function( msg ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
						var options = {};
						options[ globalOption ] = "POST";
						jQuery.ajaxSetup( options );
					},
					requests: [
						request( assert, "type" ),
						request( assert, "method" ),
						request( assert )
					]
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
diff --git a/a.js b/b.js
@@ -2218,7 +2207,7 @@ ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from aja
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
				var parsedXML = jQuery( jQuery.parseXML( "<tab title=\"Added\">blibli</tab>" ) ).find( "tab" );
				ajaxXML = jQuery( ajaxXML );
				try {
					ajaxXML.find( "infowindowtab" ).append( parsedXML );
				} catch ( e ) {
					assert.strictEqual( e, undefined, "error" );
					return;
				}
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
diff --git a/a.js b/b.js
@@ -2240,7 +2229,7 @@ ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3,
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
				"* testing": function() {
					throw "converter was called";
				}
			},
			success: function( data, status, jqXHR ) {
				assert.strictEqual( jqXHR.status, 204, "status code is 204" );
				assert.strictEqual( status, "nocontent", "status text is 'nocontent'" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
diff --git a/a.js b/b.js
@@ -2252,7 +2241,7 @@ ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
				assert.notStrictEqual( resp, undefined, "XML document exists" );
				assert.ok( "responseXML" in jqXHR, "jqXHR.responseXML exists" );
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
diff --git a/a.js b/b.js
@@ -2283,7 +2272,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
diff --git a/a.js b/b.js
@@ -2292,7 +2281,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
			}
		);
	}

	ajaxTest( "#14683 - jQuery.ajax() - Exceptions thrown synchronously by xhr.send should be caught", 4, function( assert ) {
		return [ {
			url: baseURL + "mock.php?action=echoData",
			method: "POST",
			data: {
diff --git a/a.js b/b.js
@@ -2515,7 +2504,7 @@ QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function(
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
			error: pass,
			success: fail
		} );
	} );

	QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			timeout: 50
		} );
		jQuery.ajax( {
			type: "GET",
			timeout: 15000,
			url: url( "mock.php?action=wait&wait=1" ),
			error: function() {
				assert.ok( false, "Check for local timeout failed" );
				done();
			},
			success: function() {
				assert.ok( true, "Check for local timeout" );
				done();
			}
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
diff --git a/a.js b/b.js
@@ -2532,7 +2521,7 @@ QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
		} );

		jQuery( document ).on( "ajaxStart ajaxStop", function() {
			assert.ok( false, "Global event triggered" );
		} );

		jQuery( "#qunit-fixture" ).append( "<script src='" + baseURL + "mock.php?action=script'></script>" );

		jQuery( document ).off( "ajaxStart ajaxStop" );
	} );

	QUnit.test(
		"jQuery#load() - always use GET method even if it overrided through ajaxSetup (#11264)",
		function( assert ) {
			assert.expect( 1 );
			var done = assert.async();

diff --git a/a.js b/b.js
@@ -2569,7 +2558,7 @@ QUnit.test(
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				done();
			} );
		}
	);

	QUnit.test(
		"jQuery#load() - should resolve with correct context",
		function( assert ) {
			assert.expect( 2 );
			var done = assert.async();
			var ps = jQuery( "<p></p><p></p>" );
			var i = 0;

			ps.appendTo( "#qunit-fixture" );

			ps.load( baseURL + "mock.php?action=echoMethod", function() {
				assert.strictEqual( this, ps[ i++ ] );

				if ( i === 2 ) {
					done();
				}
			} );
		}
	);

	QUnit.test(
		"#11402 - jQuery.domManip() - script in comments are properly evaluated",
		function( assert ) {
			assert.expect( 2 );
			jQuery( "#qunit-fixture" ).load( baseURL + "cleanScript.html", assert.async() );
		}
diff --git a/a.js b/b.js
@@ -2592,7 +2581,7 @@ QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
		}
	);

//----------- jQuery.get()

	QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on nodes", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();
		jQuery.get( url( "dashboard.xml" ), function( xml ) {
			var content = [];
			jQuery( "tab", xml ).each( function() {
				content.push( jQuery( this ).text() );
			} );
			assert.strictEqual( content[ 0 ], "blabla", "Check first tab" );
			assert.strictEqual( content[ 1 ], "blublu", "Check second tab" );
			done();
		} );
	} );

	QUnit.test( "#8277 - jQuery.get( String, Function ) - data in ajaxSettings", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			data: "helloworld"
diff --git a/a.js b/b.js
@@ -2683,7 +2672,7 @@ QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( asse
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				done();
			} );
		}
	);

	QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( assert ) {
		assert.expect( 1 );
		Globals.register( "testBar" );
		jQuery.getScript( url( "mock.php?action=testbar" ) ).done( assert.async() );
	} );

	QUnit.test( "#8082 - jQuery.getScript( String, Function ) - source as responseText", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();

		Globals.register( "testBar" );
diff --git a/a.js b/b.js
@@ -2770,7 +2759,7 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
		} );
		jQuery( "#first" ).load( baseURL + "name.html", undefined, assert.async() );
	} );

	// check if load can be called with only url
	QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html div.user", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 2, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
diff --git a/a.js b/b.js
@@ -2780,9 +2769,9 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	// Selector should include any valid non-HTML whitespace (#3003)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with non-HTML whitespace(#3003) )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #whitespace\\\\xA0 ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
diff --git a/a.js b/b.js
@@ -2913,7 +2902,7 @@ QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function(
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
			assert.ok( $node.find( "#query" ).text().match( /foo=3&bar=ok/ ), "Check if a string of data is passed correctly" );
			done();
		} );
	} );

	QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function( assert ) {
		assert.expect( 8 );
		var completeArgs = {},
			done = assert.async();

		jQuery.ajaxSetup( {
			success: function( _, status, jqXHR ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			},
			error: function( jqXHR, status ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			}
		} );

		jQuery.when.apply(
			jQuery,
			jQuery.map( [
				{
					type: "success",
					url: baseURL + "mock.php?action=echoQuery&arg=pop"
				},
				{
					type: "error",
					url: baseURL + "404.txt"
				}
			],
			function( options ) {
				return jQuery.Deferred( function( defer ) {
					jQuery( "#foo" ).load( options.url, function() {
						var args = arguments;
						assert.strictEqual( completeArgs[ options.url ].length, args.length, "same number of arguments (" + options.type + ")" );
						jQuery.each( completeArgs[ options.url ], function( i, value ) {
							assert.strictEqual( args[ i ], value, "argument #" + i + " is the same (" + options.type + ")" );
						} );
						defer.resolve();
					} );
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
diff --git a/a.js b/b.js
@@ -2928,7 +2917,7 @@ QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataTy
A blob:271496ce1e08fb1de7cfa7d2f25943be5789ed77
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
			dataType: "json"
		} );
		jQuery( document ).on( "ajaxComplete", function( e, xml, s ) {
			assert.strictEqual( s.dataType, "html", "Verify the load() dataType was html" );
			jQuery( document ).off( "ajaxComplete" );
			done();
		} );
		jQuery( "#first" ).load( baseURL + "test3.html" );
	} );

	QUnit.test( "#10524 - jQuery.fn.load() - data specified in ajaxSettings is merged in", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		var data = {
diff --git a/a.js b/b.js
@@ -353,8 +353,8 @@ when: function( singleValue ) {
A blob:d4eaf7a4bcf412b117f5218ddfa0472d44103fe2
		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
diff --git a/a.js b/b.js
@@ -362,30 +362,30 @@ 			updateFunc = function( i ) {
A blob:d4eaf7a4bcf412b117f5218ddfa0472d44103fe2

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				typeof( resolveValues[ i ] && resolveValues[ i ].then ) === "function" ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );

export default jQuery;
diff --git a/a.js b/b.js
@@ -7,6 +7,10 @@
A blob:863aaf6bd02e3a5fa12d5cbfcf012204136fea92
var fs = require( "fs" );
var getRawBody = require( "raw-body" );

var cspLog = "";
/**
 * Keep in sync with /test/mock.php
 */
var mocks = {
	contentType: function( req, resp ) {
		resp.writeHead( 200, {
			"content-type": req.query.contentType
diff --git a/a.js b/b.js
@@ -62,7 +66,7 @@ atom: function( req, resp, next ) {
A blob:863aaf6bd02e3a5fa12d5cbfcf012204136fea92
			} else {
				resp.end( "<error>ERROR</error>" );
			}
		}, next );
	},
	atom: function( req, resp, next ) {
		resp.writeHead( 200, { "content-type": "atom+xml" } );
		resp.end( "<root><element /></root>" );
	},
	script: function( req, resp ) {
		if ( req.query.header === "ecma" ) {
			resp.writeHead( 200, { "content-type": "application/ecmascript" } );
		} else if ( req.query.header ) {
			resp.writeHead( 200, { "content-type": "text/javascript" } );
		} else {
			resp.writeHead( 200, { "content-type": "text/html" } );
		}
diff --git a/a.js b/b.js
@@ -73,7 +77,7 @@ script: function( req, resp ) {
A blob:863aaf6bd02e3a5fa12d5cbfcf012204136fea92
	},
	atom: function( req, resp, next ) {
		resp.writeHead( 200, { "content-type": "atom+xml" } );
		resp.end( "<root><element /></root>" );
	},
	script: function( req, resp ) {
		if ( req.query.header === "ecma" ) {
			resp.writeHead( 200, { "content-type": "application/ecmascript" } );
		} else if ( req.query.header ) {
			resp.writeHead( 200, { "content-type": "text/javascript" } );
		} else {
			resp.writeHead( 200, { "content-type": "text/html" } );
		}

		if ( req.query.cors ) {
			resp.writeHead( 200, { "access-control-allow-origin": "*" } );
		}

		if ( req.query.callback ) {
			resp.end( req.query.callback + "(" + JSON.stringify( {
				headers: req.headers
			} ) + ")" );
		} else {
			resp.end( "QUnit.assert.ok( true, \"mock executed\" );" );
diff --git a/a.js b/b.js
@@ -126,14 +130,14 @@ jsonp: function( req, resp, next ) {
A blob:863aaf6bd02e3a5fa12d5cbfcf012204136fea92
			resp.end( JSON.stringify(
				{ data: { lang: "en", length: 25 } }
			) );
		}
	},
	jsonp: function( req, resp, next ) {
		var callback;
		if ( Array.isArray( req.query.callback ) ) {
			callback = Promise.resolve( req.query.callback[ req.query.callback.length - 1 ] );
		} else if ( req.query.callback ) {
			callback = Promise.resolve( req.query.callback );
		} else if ( req.method === "GET" ) {
			callback = Promise.resolve( req.url.match( /^.+\/([^\/?]+)\?.+$/ )[ 1 ] );
		} else {
			callback = getBody( req ).then( function( body ) {
				return body.trim().replace( "callback=", "" );
			} );
		}
		var json = req.query.array ?
			JSON.stringify(
				[ { name: "John", age: 21 }, { name: "Peter", age: 25 } ]
			) :
			JSON.stringify(
				{ data: { lang: "en", length: 25 } }
			);
		callback.then( function( cb ) {
			resp.end( cb + "(" + json + ")" );
		}, next );
	},
	xmlOverJsonp: function( req, resp ) {
		var callback = req.query.callback;
		var body = fs.readFileSync( __dirname + "/data/with_fries.xml" ).toString();
		resp.writeHead( 200 );
		resp.end( callback + "(" + JSON.stringify( body ) + ")\n" );
	},
	error: function( req, resp ) {
		if ( req.query.json ) {
			resp.writeHead( 400, { "content-type": "application/json" } );
diff --git a/a.js b/b.js
@@ -218,7 +222,7 @@ testHTML: function( req, resp ) {
A blob:863aaf6bd02e3a5fa12d5cbfcf012204136fea92
	},
	status: function( req, resp, next ) {
		resp.writeHead( Number( req.query.code ) );
		resp.end();
	},
	testHTML: function( req, resp ) {
		resp.writeHead( 200, { "Content-Type": "text/html" } );
		var body = fs.readFileSync( __dirname + "/data/test.include.html" ).toString();
		body = body.replace( /{{baseURL}}/g, req.query.baseURL );
		resp.end( body );
	},
	cspFrame: function( req, resp ) {
		resp.writeHead( 200, {
			"Content-Type": "text/html",
			"Content-Security-Policy": "default-src 'self'; report-uri /base/test/data/mock.php?action=cspLog"
		} );
		var body = fs.readFileSync( __dirname + "/data/csp.include.html" ).toString();
		resp.end( body );
	},
diff --git a/a.js b/b.js
@@ -252,14 +256,31 @@ cspClean: function( req, resp ) {
A blob:863aaf6bd02e3a5fa12d5cbfcf012204136fea92
	cspLog: function( req, resp ) {
		cspLog = "error";
		resp.writeHead( 200 );
		resp.end();
	},
	cspClean: function( req, resp ) {
		cspLog = "";
		resp.writeHead( 200 );
		resp.end();
	},
	errorWithScript: function( req, resp ) {
		if ( req.query.withScriptContentType ) {
			resp.writeHead( 404, { "Content-Type": "application/javascript" } );
		} else {
			resp.writeHead( 404 );
		}
		if ( req.query.callback ) {
			resp.end( req.query.callback + "( {\"status\": 404, \"msg\": \"Not Found\"} )" );
		} else {
			resp.end( "QUnit.assert.ok( false, \"Mock return erroneously executed\" );" );
		}
	}
diff --git a/a.js b/b.js
@@ -71,13 +71,20 @@ ajaxTest( "jQuery.ajax() - success callbacks - (url, options) syntax", 8, functi
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - success callbacks - (url, options) syntax", 8, function( assert ) {
		return {
			setup: addGlobalEvents( "ajaxStart ajaxStop ajaxSend ajaxComplete ajaxSuccess", assert ),
			create: function( options ) {
				return jQuery.ajax( url( "name.html" ), options );
			},
			beforeSend: function() {
				assert.ok( true, "beforeSend" );
			},
			success: function() {
				assert.ok( true, "success" );
			},
			complete: function() {
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - execute js for crossOrigin when dataType option is provided", 3,
		function( assert ) {
			return {
				create: function( options ) {
					options.crossDomain = true;
					options.dataType = "script";
					return jQuery.ajax( url( "mock.php?action=script&header=ecma" ), options );
				},
				success: function() {
					assert.ok( true, "success" );
				},
diff --git a/a.js b/b.js
@@ -89,20 +96,13 @@ ajaxTest( "jQuery.ajax() - execute js for crossOrigin when dataType option is pr
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - execute js for crossOrigin when dataType option is provided", 3,
		function( assert ) {
			return {
				create: function( options ) {
					options.crossDomain = true;
					options.dataType = "script";
					return jQuery.ajax( url( "mock.php?action=script&header=ecma" ), options );
				},
				success: function() {
					assert.ok( true, "success" );
				},
				complete: function() {
					assert.ok( true, "complete" );
				}
			};
		}
	);

	ajaxTest( "jQuery.ajax() - custom attributes for script tag", 5,
		function( assert ) {
			return {
				create: function( options ) {
					var xhr;
					options.method = "POST";
					options.dataType = "script";
					options.scriptAttrs = { id: "jquery-ajax-test", async: "async" };
					xhr = jQuery.ajax( url( "mock.php?action=script" ), options );
					assert.equal( jQuery( "#jquery-ajax-test" ).attr( "async" ), "async", "attr value" );
					return xhr;
				},
				beforeSend: function( _jqXhr, settings ) {
					assert.strictEqual( settings.type, "GET", "Type changed to GET" );
				},
				success: function() {
					assert.ok( true, "success" );
				},
diff --git a/a.js b/b.js
@@ -114,22 +114,16 @@ ajaxTest( "jQuery.ajax() - custom attributes for script tag", 5,
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				}
			};
		}
	);

	ajaxTest( "jQuery.ajax() - custom attributes for script tag", 5,
		function( assert ) {
			return {
				create: function( options ) {
					var xhr;
					options.method = "POST";
					options.dataType = "script";
					options.scriptAttrs = { id: "jquery-ajax-test", async: "async" };
					xhr = jQuery.ajax( url( "mock.php?action=script" ), options );
					assert.equal( jQuery( "#jquery-ajax-test" ).attr( "async" ), "async", "attr value" );
					return xhr;
				},
				beforeSend: function( _jqXhr, settings ) {
					assert.strictEqual( settings.type, "GET", "Type changed to GET" );
				},
				success: function() {
					assert.ok( true, "success" );
				},
				complete: function() {
					assert.ok( true, "complete" );
				}
			};
		}
	);

	ajaxTest( "jQuery.ajax() - do not execute js (crossOrigin)", 2, function( assert ) {
		return {
			create: function( options ) {
				options.crossDomain = true;
				return jQuery.ajax( url( "mock.php?action=script" ), options );
			},
			success: function() {
				assert.ok( true, "success" );
			},
			fail: function() {
				assert.ok( false, "fail" );
			},
			complete: function() {
				assert.ok( true, "complete" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - success callbacks (late binding)", 8, function( assert ) {
		return {
diff --git a/a.js b/b.js
@@ -619,7 +613,7 @@ ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				complete: callback( "complete" )
			} ]
		};
	} );

	ajaxTest( "jQuery.ajax() - events without context", 3, function( assert ) {
		function nocallback( msg ) {
			return function() {
				assert.equal( typeof this.url, "string", "context is settings on callback " + msg );
			};
		}
		return {
			url: url( "404.txt" ),
			beforeSend: nocallback( "beforeSend" ),
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
diff --git a/a.js b/b.js
@@ -635,7 +629,7 @@ ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function(
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
			error: nocallback( "error" ),
			complete:  nocallback( "complete" )
		};
	} );

	ajaxTest( "#15118 - jQuery.ajax() - function without jQuery.event", 1, function( assert ) {
		var holder;
		return {
			url: url( "mock.php?action=json" ),
			setup: function() {
				holder = jQuery.event;
				delete jQuery.event;
			},
			complete: function() {
				assert.ok( true, "Call can be made without jQuery.event" );
				jQuery.event = holder;
			},
			success: true
		};
	} );

	ajaxTest( "#15160 - jQuery.ajax() - request manually aborted in ajaxSend", 3, function( assert ) {
		return {
			setup: function() {
				jQuery( document ).on( "ajaxSend", function( e, jqXHR ) {
					jqXHR.abort();
diff --git a/a.js b/b.js
@@ -1439,25 +1433,6 @@ ajaxTest( "jQuery.ajax() - malformed JSON", 2, function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( window[ "testBar" ], "bar", "Script results returned (GET, no callback)" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - malformed JSON", 2, function( assert ) {
		return {
			url: baseURL + "badjson.js",
			dataType: "json",
			error: function( xhr, msg, detailedMsg ) {
				assert.strictEqual( msg, "parsererror", "A parse error occurred." );
				assert.ok( /(invalid|error|exception)/i.test( detailedMsg ), "Detailed parsererror message provided" );
			}
		};
	} );

	ajaxTest( "jQuery.ajax() - script by content-type", 2, function() {
		return [
			{
				url: baseURL + "mock.php?action=script",
				data: {
					"header": "script"
				},
				success: true
			},
			{
				url: baseURL + "mock.php?action=script",
				data: {
					"header": "ecma"
				},
				success: true
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - JSON by content-type", 5, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			data: {
diff --git a/a.js b/b.js
@@ -1659,12 +1634,25 @@ ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
			},
			error: true
		};
	} );

	ajaxTest( "jQuery.ajax() - data - no processing GET", 1, function( assert ) {
		return {
			url: "bogus.html",
			data: { devo: "A Beautiful World" },
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.deepEqual( s.data, { devo: "A Beautiful World" }, "data is not processed" );
				return false;
			},
			error: true
		};
	} );

		ajaxTest( "jQuery.ajax() - data - process string with GET", 2, function( assert ) {
		return {
			url: "bogus.html",
			data: "a=1&b=2",
			type: "get",
			contentType: "x-something-else",
			processData: false,
			beforeSend: function( _, s ) {
				assert.equal( s.url, "bogus.html?a=1&b=2", "added data to url" );
				assert.equal( s.data, undefined, "removed data from settings" );
				return false;
			},
			error: true
		};
	} );

	var ifModifiedNow = new Date();

	jQuery.each(
		/* jQuery.each arguments start */
		{
			" (cache)": true,
			" (no cache)": false
		},
		function( label, cache ) {
			jQuery.each(
				{
					"If-Modified-Since": "mock.php?action=ims",
					"Etag": "mock.php?action=etag"
				},
				function( type, url ) {
					url = baseURL + url + "&ts=" + ifModifiedNow++;
					QUnit.test( "jQuery.ajax() - " + type + " support" + label, function( assert ) {
						assert.expect( 4 );
						var done = assert.async();
						jQuery.ajax( {
							url: url,
diff --git a/a.js b/b.js
@@ -1729,7 +1717,8 @@ QUnit.test( "jQuery.ajax() - statusText", function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.ok( true, "success" );
			}
		};
	} );

	QUnit.test( "jQuery.ajax() - statusText", function( assert ) {
		assert.expect( 3 );
		var done = assert.async();
		jQuery.ajax( url( "mock.php?action=status&code=200&text=Hello" ) ).done( function( _, statusText, jqXHR ) {
			assert.strictEqual( statusText, "success", "callback status text ok for success" );
			assert.ok( jqXHR.statusText === "Hello" || jqXHR.statusText === "OK", "jqXHR status text ok for success (" + jqXHR.statusText + ")" );
			jQuery.ajax( url( "mock.php?action=status&code=404&text=World" ) ).fail( function( jqXHR, statusText ) {
				assert.strictEqual( statusText, "error", "callback status text ok for error" );
				done();
			} );
diff --git a/a.js b/b.js
@@ -1906,7 +1895,7 @@ ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				}
			}
		];
	} );

	ajaxTest( "jQuery.ajax() - empty json gets to error callback instead of success callback.", 1, function( assert ) {
		return {
			url: url( "mock.php?action=echoData" ),
			error: function( _, __, error ) {
				assert.equal( typeof error === "object", true,  "Didn't get back error object for empty json response" );
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
diff --git a/a.js b/b.js
@@ -1932,7 +1921,7 @@ ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( ass
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
			},
			dataType: "json"
		};
	} );

	ajaxTest( "#2688 - jQuery.ajax() - beforeSend, cancel request", 2, function( assert ) {
		return {
			create: function() {
				return jQuery.ajax( {
					url: url( "name.html" ),
					beforeSend: function() {
						assert.ok( true, "beforeSend got called, canceling" );
						return false;
					},
					success: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					complete: function() {
						assert.ok( false, "request didn't get canceled" );
					},
					error: function() {
						assert.ok( false, "request didn't get canceled" );
					}
				} );
			},
			fail: function( _, reason ) {
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
diff --git a/a.js b/b.js
@@ -1946,7 +1935,7 @@ ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, f
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( reason, "canceled", "canceled request must fail with 'canceled' status text" );
			}
		};
	} );

	ajaxTest( "#2806 - jQuery.ajax() - data option - evaluate function values", 1, function( assert ) {
		return {
			url: baseURL + "mock.php?action=echoQuery",
			data: {
				key: function() {
					return "value";
				}
			},
			success: function( result ) {
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
diff --git a/a.js b/b.js
@@ -1964,7 +1953,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -1978,7 +1967,7 @@ QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert )
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( result, "action=echoQuery&key=value" );
			}
		};
	} );

	QUnit.test( "#7531 - jQuery.ajax() - Location object as url", function( assert ) {
		assert.expect( 1 );

		var xhr,
			success = false;
		try {
			xhr = jQuery.ajax( {
				url: window.location
			} );
			success = true;
			xhr.abort();
		} catch ( e ) {

		}
		assert.ok( success, "document.location did not generate exception" );
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#7578 - jQuery.ajax() - JSONP - default for cache option" + label, 1, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function() {
					assert.strictEqual( this.cache, false, "cache must be false on JSON request" );
					return false;
				},
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
diff --git a/a.js b/b.js
@@ -2017,7 +2006,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
diff --git a/a.js b/b.js
@@ -2055,7 +2044,7 @@ ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5"
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				error: true
			};
		} );
	} );

	ajaxTest( "#8107 - jQuery.ajax() - multiple method signatures introduced in 1.5", 4, function( assert ) {
		return [
			{
				create: function() {
					return jQuery.ajax();
				},
				done: function() {
					assert.ok( true, "With no arguments" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html" );
				},
				done: function() {
					assert.ok( true, "With only string URL argument" );
				}
			},
			{
				create: function() {
					return jQuery.ajax( baseURL + "name.html", {} );
				},
				done: function() {
					assert.ok( true, "With string URL param and map" );
				}
			},
			{
				create: function( options ) {
					return jQuery.ajax( options );
				},
				url: baseURL + "name.html",
				success: function() {
					assert.ok( true, "With only map" );
				}
			}
		];
	} );

	jQuery.each( [ " - Same Domain", " - Cross Domain" ], function( crossDomain, label ) {
		ajaxTest( "#8205 - jQuery.ajax() - JSONP - re-use callbacks name" + label, 4, function( assert ) {
			return {
				url: baseURL + "mock.php?action=jsonp",
				dataType: "jsonp",
				crossDomain: crossDomain,
				beforeSend: function( jqXHR, s ) {
					s.callback = s.jsonpCallback;

					assert.ok( this.callback in window, "JSONP callback name is in the window" );
				},
				success: function() {
					var previous = this;

					assert.strictEqual(
						previous.jsonpCallback,
						undefined,
						"jsonpCallback option is set back to default in callbacks"
					);

					assert.ok(
						!( this.callback in window ),
						"JSONP callback name was removed from the window"
					);

					jQuery.ajax( {
						url: baseURL + "mock.php?action=jsonp",
						dataType: "jsonp",
						crossDomain: crossDomain,
						beforeSend: function() {
							assert.strictEqual( this.jsonpCallback, previous.callback, "JSONP callback name is re-used" );
							return false;
						}
					} );
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
diff --git a/a.js b/b.js
@@ -2089,7 +2078,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
diff --git a/a.js b/b.js
@@ -2099,7 +2088,7 @@ QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)",
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				}
			};
		} );
	} );

	QUnit.test( "#9887 - jQuery.ajax() - Context with circular references (#9887)", function( assert ) {
		assert.expect( 2 );

		var success = false,
			context = {};
		context.field = context;
		try {
			jQuery.ajax( "non-existing", {
				context: context,
				beforeSend: function() {
					assert.ok( this === context, "context was not deep extended" );
					return false;
				}
			} );
			success = true;
		} catch ( e ) {
			console.log( e );
		}
		assert.ok( success, "context with circular reference did not generate an exception" );
	} );

	jQuery.each( [ "as argument", "in settings object" ], function( inSetting, title ) {

		function request( assert, url, test ) {
			return {
				create: function() {
					return jQuery.ajax( inSetting ? { url: url } : url );
				},
				done: function() {
					assert.ok( true, ( test || url ) + " " + title );
				}
			};
		}

		ajaxTest( "#10093 - jQuery.ajax() - falsy url " + title, 4, function( assert ) {
			return [
				request( assert, "", "empty string" ),
				request( assert, false ),
				request( assert, null ),
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
diff --git a/a.js b/b.js
@@ -2113,7 +2102,7 @@ ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				request( assert, undefined )
			];
		} );
	} );

	ajaxTest( "#11151 - jQuery.ajax() - parse error body", 2, function( assert ) {
		return {
			url: url( "mock.php?action=error&json=1" ),
			dataFilter: function( string ) {
				assert.ok( false, "dataFilter called" );
				return string;
			},
			error: function( jqXHR ) {
				assert.strictEqual( jqXHR.responseText, "{ \"code\": 40, \"message\": \"Bad Request\" }", "Error body properly set" );
				assert.deepEqual( jqXHR.responseJSON, { code: 40, message: "Bad Request" }, "Error body properly parsed" );
			}
		};
	} );

	ajaxTest( "#11426 - jQuery.ajax() - loading binary data shouldn't throw an exception in IE", 1, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			success: function( data ) {
				assert.ok( data === undefined || /JFIF/.test( data ), "success callback reached" );
diff --git a/a.js b/b.js
@@ -2146,7 +2135,7 @@ ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception",
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
		s.xhrFields = { responseType: "arraybuffer" };
		s.responseFields.arraybuffer = "response";
		s.converters[ "binary arraybuffer" ] = true;
	} );

	ajaxTest( "gh-2498 - jQuery.ajax() - binary data shouldn't throw an exception", 2, function( assert ) {
		return {
			url: url( "1x1.jpg" ),
			dataType: "arraybuffer",
			success: function( data, s, jqxhr ) {
				assert.ok( data instanceof window.ArrayBuffer, "correct data type" );
				assert.ok( jqxhr.response instanceof window.ArrayBuffer, "data in jQXHR" );
			}
		};
	} );
}

	QUnit.test( "#11743 - jQuery.ajax() - script, throws exception", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		var onerror = window.onerror;
		window.onerror = function() {
diff --git a/a.js b/b.js
@@ -2181,7 +2170,7 @@ 				options.success = function( msg ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
diff --git a/a.js b/b.js
@@ -2200,7 +2189,7 @@ 				options.success = function( msg ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
						assert.strictEqual( msg, "hello", "Check for POST (no override)" );
					}
				};
			if ( option ) {
				options[ option ] = "GET";
				options.success = function( msg ) {
					assert.strictEqual( msg, "", "Check for no POST (overriding with " + option + ")" );
				};
			}
			return options;
		}

		ajaxTest(
			"#12004 - jQuery.ajax() - method is an alias of type - " +
			globalOption + " set globally", 3,
			function( assert ) {
				return {
					setup: function() {
						var options = {};
						options[ globalOption ] = "POST";
						jQuery.ajaxSetup( options );
					},
					requests: [
						request( assert, "type" ),
						request( assert, "method" ),
						request( assert )
					]
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
diff --git a/a.js b/b.js
@@ -2218,7 +2207,7 @@ ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from aja
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				};
			}
		);
	} );

	ajaxTest( "#13276 - jQuery.ajax() - compatibility between XML documents from ajax requests and parsed string", 1, function( assert ) {
		return {
			url: baseURL + "dashboard.xml",
			dataType: "xml",
			success: function( ajaxXML ) {
				var parsedXML = jQuery( jQuery.parseXML( "<tab title=\"Added\">blibli</tab>" ) ).find( "tab" );
				ajaxXML = jQuery( ajaxXML );
				try {
					ajaxXML.find( "infowindowtab" ).append( parsedXML );
				} catch ( e ) {
					assert.strictEqual( e, undefined, "error" );
					return;
				}
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
diff --git a/a.js b/b.js
@@ -2240,7 +2229,7 @@ ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3,
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( ajaxXML.find( "tab" ).length, 3, "Parsed node was added properly" );
			}
		};
	} );

	ajaxTest( "#13292 - jQuery.ajax() - converter is bypassed for 204 requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=status&code=204&text=No+Content",
			dataType: "testing",
			converters: {
				"* testing": function() {
					throw "converter was called";
				}
			},
			success: function( data, status, jqXHR ) {
				assert.strictEqual( jqXHR.status, 204, "status code is 204" );
				assert.strictEqual( status, "nocontent", "status text is 'nocontent'" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
diff --git a/a.js b/b.js
@@ -2252,7 +2241,7 @@ ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	ajaxTest( "#13388 - jQuery.ajax() - responseXML", 3, function( assert ) {
		return {
			url: url( "with_fries.xml" ),
			dataType: "xml",
			success: function( resp, _, jqXHR ) {
				assert.notStrictEqual( resp, undefined, "XML document exists" );
				assert.ok( "responseXML" in jqXHR, "jqXHR.responseXML exists" );
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
diff --git a/a.js b/b.js
@@ -2283,7 +2272,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
diff --git a/a.js b/b.js
@@ -2292,7 +2281,7 @@ ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3,
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				assert.strictEqual( resp, jqXHR.responseXML, "jqXHR.responseXML is set correctly" );
			}
		};
	} );

	ajaxTest( "#13922 - jQuery.ajax() - converter is bypassed for HEAD requests", 3, function( assert ) {
		return {
			url: baseURL + "mock.php?action=json",
			method: "HEAD",
			data: {
				header: "yes"
			},
			converters: {
				"text json": function() {
					throw "converter was called";
				}
			},
			success: function( data, status ) {
				assert.ok( true, "success" );
				assert.strictEqual( status, "nocontent", "data is undefined" );
				assert.strictEqual( data, undefined, "data is undefined" );
			},
			error: function( _, status, error ) {
				assert.ok( false, "error" );
				assert.strictEqual( status, "parsererror", "Parser Error" );
				assert.strictEqual( error, "converter was called", "Converter was called" );
			}
		};
	} );

	// Chrome 78 dropped support for synchronous XHR requests inside of
	// beforeunload, unload, pagehide, and visibilitychange event handlers.
	// See https://bugs.chromium.org/p/chromium/issues/detail?id=952452
	// Safari 13 did similar changes. The below check will catch them both.
	if ( !/safari/i.test( navigator.userAgent ) ) {
		testIframe(
			"#14379 - jQuery.ajax() on unload",
			"ajax/onunload.html",
			function( assert, jQuery, window, document, status ) {
				assert.expect( 1 );
				assert.strictEqual( status, "success", "Request completed" );
			}
		);
	}

	ajaxTest( "#14683 - jQuery.ajax() - Exceptions thrown synchronously by xhr.send should be caught", 4, function( assert ) {
		return [ {
			url: baseURL + "mock.php?action=echoData",
			method: "POST",
			data: {
diff --git a/a.js b/b.js
@@ -2515,7 +2504,7 @@ QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function(
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
			error: pass,
			success: fail
		} );
	} );

	QUnit.test( "jQuery.ajaxSetup({ timeout: Number }) with localtimeout", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			timeout: 50
		} );
		jQuery.ajax( {
			type: "GET",
			timeout: 15000,
			url: url( "mock.php?action=wait&wait=1" ),
			error: function() {
				assert.ok( false, "Check for local timeout failed" );
				done();
			},
			success: function() {
				assert.ok( true, "Check for local timeout" );
				done();
			}
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
diff --git a/a.js b/b.js
@@ -2532,7 +2521,7 @@ QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
		} );
	} );

//----------- jQuery.domManip()

	QUnit.test( "#11264 - jQuery.domManip() - no side effect because of ajaxSetup or global events", function( assert ) {
		assert.expect( 1 );

		jQuery.ajaxSetup( {
			type: "POST"
		} );

		jQuery( document ).on( "ajaxStart ajaxStop", function() {
			assert.ok( false, "Global event triggered" );
		} );

		jQuery( "#qunit-fixture" ).append( "<script src='" + baseURL + "mock.php?action=script'></script>" );

		jQuery( document ).off( "ajaxStart ajaxStop" );
	} );

	QUnit.test(
		"jQuery#load() - always use GET method even if it overrided through ajaxSetup (#11264)",
		function( assert ) {
			assert.expect( 1 );
			var done = assert.async();

diff --git a/a.js b/b.js
@@ -2569,7 +2558,7 @@ QUnit.test(
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				done();
			} );
		}
	);

	QUnit.test(
		"jQuery#load() - should resolve with correct context",
		function( assert ) {
			assert.expect( 2 );
			var done = assert.async();
			var ps = jQuery( "<p></p><p></p>" );
			var i = 0;

			ps.appendTo( "#qunit-fixture" );

			ps.load( baseURL + "mock.php?action=echoMethod", function() {
				assert.strictEqual( this, ps[ i++ ] );

				if ( i === 2 ) {
					done();
				}
			} );
		}
	);

	QUnit.test(
		"#11402 - jQuery.domManip() - script in comments are properly evaluated",
		function( assert ) {
			assert.expect( 2 );
			jQuery( "#qunit-fixture" ).load( baseURL + "cleanScript.html", assert.async() );
		}
diff --git a/a.js b/b.js
@@ -2592,7 +2581,7 @@ QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
		}
	);

//----------- jQuery.get()

	QUnit.test( "jQuery.get( String, Hash, Function ) - parse xml and use text() on nodes", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();
		jQuery.get( url( "dashboard.xml" ), function( xml ) {
			var content = [];
			jQuery( "tab", xml ).each( function() {
				content.push( jQuery( this ).text() );
			} );
			assert.strictEqual( content[ 0 ], "blabla", "Check first tab" );
			assert.strictEqual( content[ 1 ], "blublu", "Check second tab" );
			done();
		} );
	} );

	QUnit.test( "#8277 - jQuery.get( String, Function ) - data in ajaxSettings", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery.ajaxSetup( {
			data: "helloworld"
diff --git a/a.js b/b.js
@@ -2683,7 +2672,7 @@ QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( asse
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				done();
			} );
		}
	);

	QUnit.test( "jQuery.getScript( String, Function ) - no callback", function( assert ) {
		assert.expect( 1 );
		Globals.register( "testBar" );
		jQuery.getScript( url( "mock.php?action=testbar" ) ).done( assert.async() );
	} );

	QUnit.test( "#8082 - jQuery.getScript( String, Function ) - source as responseText", function( assert ) {
		assert.expect( 2 );
		var done = assert.async();

		Globals.register( "testBar" );
diff --git a/a.js b/b.js
@@ -2770,7 +2759,7 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
		} );
		jQuery( "#first" ).load( baseURL + "name.html", undefined, assert.async() );
	} );

	// check if load can be called with only url
	QUnit.test( "jQuery.fn.load( URL_SELECTOR )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html div.user", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 2, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
diff --git a/a.js b/b.js
@@ -2780,9 +2769,9 @@ QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with spaces )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #superuser ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
			done();
		} );
	} );

	// Selector should be trimmed to avoid leading spaces (#14773)
	// Selector should include any valid non-HTML whitespace (#3003)
	QUnit.test( "jQuery.fn.load( URL_SELECTOR with non-HTML whitespace(#3003) )", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();
		jQuery( "#first" ).load( baseURL + "test3.html   #whitespace\\\\xA0 ", function() {
			assert.strictEqual( jQuery( this ).children( "div" ).length, 1, "Verify that specific elements were injected" );
diff --git a/a.js b/b.js
@@ -2913,7 +2902,7 @@ QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function(
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
			assert.ok( $node.find( "#query" ).text().match( /foo=3&bar=ok/ ), "Check if a string of data is passed correctly" );
			done();
		} );
	} );

	QUnit.test( "jQuery.fn.load() - callbacks get the correct parameters", function( assert ) {
		assert.expect( 8 );
		var completeArgs = {},
			done = assert.async();

		jQuery.ajaxSetup( {
			success: function( _, status, jqXHR ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			},
			error: function( jqXHR, status ) {
				completeArgs[ this.url ] = [ jqXHR.responseText, status, jqXHR ];
			}
		} );

		jQuery.when.apply(
			jQuery,
			jQuery.map( [
				{
					type: "success",
					url: baseURL + "mock.php?action=echoQuery&arg=pop"
				},
				{
					type: "error",
					url: baseURL + "404.txt"
				}
			],
			function( options ) {
				return jQuery.Deferred( function( defer ) {
					jQuery( "#foo" ).load( options.url, function() {
						var args = arguments;
						assert.strictEqual( completeArgs[ options.url ].length, args.length, "same number of arguments (" + options.type + ")" );
						jQuery.each( completeArgs[ options.url ], function( i, value ) {
							assert.strictEqual( args[ i ], value, "argument #" + i + " is the same (" + options.type + ")" );
						} );
						defer.resolve();
					} );
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
diff --git a/a.js b/b.js
@@ -2928,7 +2917,7 @@ QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataTy
A blob:b3b78cc5f86e8a668cdc2213bf9b812f5543b976
				} );
			} )
		).always( done );
	} );

	QUnit.test( "#2046 - jQuery.fn.load( String, Function ) with ajaxSetup on dataType json", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		jQuery.ajaxSetup( {
			dataType: "json"
		} );
		jQuery( document ).on( "ajaxComplete", function( e, xml, s ) {
			assert.strictEqual( s.dataType, "html", "Verify the load() dataType was html" );
			jQuery( document ).off( "ajaxComplete" );
			done();
		} );
		jQuery( "#first" ).load( baseURL + "test3.html" );
	} );

	QUnit.test( "#10524 - jQuery.fn.load() - data specified in ajaxSettings is merged in", function( assert ) {
		assert.expect( 1 );
		var done = assert.async();

		var data = {
diff --git a/a.js b/b.js
@@ -4,6 +4,7 @@
A blob:126d12a17dd092d55b3fdbfcdce7e1dcae1dd960
import jQuery from "./core.js";
import access from "./core/access.js";
import nodeName from "./core/nodeName.js";
import rcssNum from "./var/rcssNum.js";
import isIE from "./var/isIE.js";
import rnumnonpx from "./css/var/rnumnonpx.js";
import cssExpand from "./css/var/cssExpand.js";
import isAutoPx from "./css/isAutoPx.js";
import cssCamelCase from "./css/cssCamelCase.js";
import getStyles from "./css/var/getStyles.js";
diff --git a/a.js b/b.js
@@ -12,6 +13,7 @@
A blob:126d12a17dd092d55b3fdbfcdce7e1dcae1dd960
import isAutoPx from "./css/isAutoPx.js";
import cssCamelCase from "./css/cssCamelCase.js";
import getStyles from "./css/var/getStyles.js";
import swap from "./css/var/swap.js";
import curCSS from "./css/curCSS.js";
import adjustCSS from "./css/adjustCSS.js";
import finalPropName from "./css/finalPropName.js";

import "./core/init.js";
import "./core/ready.js";
import "./selector.js"; // contains
diff --git a/a.js b/b.js
@@ -23,7 +25,6 @@
A blob:126d12a17dd092d55b3fdbfcdce7e1dcae1dd960

var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
diff --git a/a.js b/b.js
@@ -134,23 +135,24 @@ function getWidthOrHeight( elem, dimension, extra ) {
A blob:126d12a17dd092d55b3fdbfcdce7e1dcae1dd960
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = isIE || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	if ( ( isIE &&
		(

			// Support: IE 9 - 11+
			// Use offsetWidth/offsetHeight for when box sizing is unreliable.
			// In those cases, the computed value can be trusted to be border-box.
			isBorderBox ||

			// Support: IE 10 - 11+
			// IE misreports `getComputedStyle` of table rows with width/height
			// set in CSS while `offset*` properties report correct values.
			nodeName( elem, "tr" )
		) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

diff --git a/a.js b/b.js
@@ -218,15 +220,15 @@ style: function( elem, name, value, extra ) {
A blob:126d12a17dd092d55b3fdbfcdce7e1dcae1dd960
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = cssCamelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

diff --git a/a.js b/b.js
@@ -237,7 +239,7 @@ style: function( elem, name, value, extra ) {
A blob:126d12a17dd092d55b3fdbfcdce7e1dcae1dd960
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = cssCamelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If the value is a number, add `px` for certain CSS properties
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( isAutoPx( origName ) ? "px" : "" );
			}

			// Support: IE <=9 - 11+
			// background-* props of a cloned element affect the source element (#8908)
			if ( isIE && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

diff --git a/a.js b/b.js
@@ -38,7 +38,7 @@ function testWidth( val, assert ) {
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346

	fn( value, assert );
		Returns a function that returns the value
*/

function testWidth( val, assert ) {
	assert.expect( 9 );
	var $div, $empty;

	$div = jQuery( "#nothiddendiv" );
	$div.width( val( 30 ) );
	assert.equal( $div.width(), 30, "Test set to 30 correctly" );
	$div.css( "display", "none" );
	assert.equal( $div.width(), 30, "Test hidden div" );
	$div.css( "display", "" );
	$div.width( val( -1 ) ); // handle negative numbers by setting to 0 #11604
	assert.equal( $div.width(), 0, "Test negative width normalized to 0" );
	$div.css( "padding", "20px" );
	assert.equal( $div.width(), 0, "Test padding specified with pixels" );
	$div.css( "border", "2px solid #fff" );
diff --git a/a.js b/b.js
@@ -89,7 +89,7 @@ function testHeight( val, assert ) {
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	} );

	assert.equal( $div.width(), 31, "Make sure value was modified correctly." );
} );

function testHeight( val, assert ) {
	assert.expect( 9 );

	var $div, blah;

	$div = jQuery( "#nothiddendiv" );
	$div.height( val( 30 ) );
	assert.equal( $div.height(), 30, "Test set to 30 correctly" );
	$div.css( "display", "none" );
	assert.equal( $div.height(), 30, "Test hidden div" );
	$div.css( "display", "" );
	$div.height( val( -1 ) ); // handle negative numbers by setting to 0 #11604
	assert.equal( $div.height(), 0, "Test negative height normalized to 0" );
	$div.css( "padding", "20px" );
	assert.equal( $div.height(), 0, "Test padding specified with pixels" );
	$div.css( "border", "2px solid #fff" );
diff --git a/a.js b/b.js
@@ -279,7 +279,7 @@ QUnit.test( "outerHeight()", function( assert ) {
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	assert.equal( div.outerWidth(), 0, "Make sure that disconnected nodes are handled." );

	div.remove();
} );

QUnit.test( "outerHeight()", function( assert ) {
	assert.expect( 12 );

	var $div, div,
		$win = jQuery( window ),
		$doc = jQuery( document ),
		winheight = $win.prop( "innerHeight" );

	assert.equal( jQuery( window ).outerHeight(), winheight, "Test on window without margin option" );
	assert.equal( jQuery( window ).outerHeight( true ), winheight, "Test on window with margin option" );
	assert.equal( jQuery( document ).outerHeight(), $doc.height(), "Test on document without margin option" );
	assert.equal( jQuery( document ).outerHeight( true ), $doc.height(), "Test on document with margin option" );
	assert.strictEqual( jQuery().outerHeight(), undefined, "Test on empty set" );

	$div = jQuery( "#nothiddendiv" );
	$div.css( "height", 30 );

	assert.equal( $div.outerHeight(), 30, "Test with only height set" );
	$div.css( "padding", "20px" );
	assert.equal( $div.outerHeight(), 70, "Test with padding" );
	$div.css( "border", "2px solid #fff" );
	assert.equal( $div.outerHeight(), 74, "Test with padding and border" );
	$div.css( "margin", "10px" );
	assert.equal( $div.outerHeight(), 74, "Test with padding, border and margin without margin option" );
	$div.css( "position", "absolute" );
	assert.equal( $div.outerHeight( true ), 94, "Test with padding, border and margin with margin option" );
	$div.css( "display", "none" );
	assert.equal( $div.outerHeight( true ), 94, "Test hidden div with padding, border and margin with margin option" );

	// reset styles
	$div.css( { "position": "", "display": "", "border": "", "padding": "", "width": "", "height": "" } );

	div = jQuery( "<div>" );

	// Temporarily require 0 for backwards compat - should be auto
	assert.equal( div.outerWidth(), 0, "Make sure that disconnected nodes are handled." );

	div.remove();
} );

QUnit.test( "child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #9441 #9300", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
diff --git a/a.js b/b.js
@@ -290,33 +290,33 @@ QUnit.test( "child of a hidden elem (or unconnected node) has accurate inner/out
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	assert.equal( div.outerWidth(), 0, "Make sure that disconnected nodes are handled." );

	div.remove();
} );

QUnit.test( "child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #9441 #9300", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
		$divChild = $divNormal.clone(),
		$divUnconnected = $divNormal.clone(),
		$divHiddenParent = jQuery( "<div>" ).css( "display", "none" ).append( $divChild ).appendTo( "body" );
	$divNormal.appendTo( "body" );

	// tests that child div of a hidden div works the same as a normal div
	assert.equal( $divChild.width(), $divNormal.width(), "child of a hidden element width() is wrong see #9441" );
	assert.equal( $divChild.innerWidth(), $divNormal.innerWidth(), "child of a hidden element innerWidth() is wrong see #9441" );
	assert.equal( $divChild.outerWidth(), $divNormal.outerWidth(), "child of a hidden element outerWidth() is wrong see #9441" );
	assert.equal( $divChild.outerWidth( true ), $divNormal.outerWidth( true ), "child of a hidden element outerWidth( true ) is wrong see #9300" );

	assert.equal( $divChild.height(), $divNormal.height(), "child of a hidden element height() is wrong see #9441" );
	assert.equal( $divChild.innerHeight(), $divNormal.innerHeight(), "child of a hidden element innerHeight() is wrong see #9441" );
	assert.equal( $divChild.outerHeight(), $divNormal.outerHeight(), "child of a hidden element outerHeight() is wrong see #9441" );
	assert.equal( $divChild.outerHeight( true ), $divNormal.outerHeight( true ), "child of a hidden element outerHeight( true ) is wrong see #9300" );

	// tests that child div of an unconnected div works the same as a normal div
	assert.equal( $divUnconnected.width(), $divNormal.width(), "unconnected element width() is wrong see #9441" );
	assert.equal( $divUnconnected.innerWidth(), $divNormal.innerWidth(), "unconnected element innerWidth() is wrong see #9441" );
	assert.equal( $divUnconnected.outerWidth(), $divNormal.outerWidth(), "unconnected element outerWidth() is wrong see #9441" );
	assert.equal( $divUnconnected.outerWidth( true ), $divNormal.outerWidth( true ), "unconnected element outerWidth( true ) is wrong see #9300" );

	assert.equal( $divUnconnected.height(), $divNormal.height(), "unconnected element height() is wrong see #9441" );
	assert.equal( $divUnconnected.innerHeight(), $divNormal.innerHeight(), "unconnected element innerHeight() is wrong see #9441" );
	assert.equal( $divUnconnected.outerHeight(), $divNormal.outerHeight(), "unconnected element outerHeight() is wrong see #9441" );
	assert.equal( $divUnconnected.outerHeight( true ), $divNormal.outerHeight( true ), "unconnected element outerHeight( true ) is wrong see #9300" );

	// teardown html
	$divHiddenParent.remove();
	$divNormal.remove();
} );

QUnit.test( "getting dimensions shouldn't modify runtimeStyle see #9233", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		div = $div.get( 0 ),
diff --git a/a.js b/b.js
@@ -331,9 +331,9 @@ QUnit.test( "getting dimensions shouldn't modify runtimeStyle see #9233", functi
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	// teardown html
	$divHiddenParent.remove();
	$divNormal.remove();
} );

QUnit.test( "getting dimensions shouldn't modify runtimeStyle see #9233", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div>" ).appendTo( "#qunit-fixture" ),
		div = $div.get( 0 ),
		runtimeStyle = div.runtimeStyle;

	if ( runtimeStyle ) {
		div.runtimeStyle.marginLeft = "12em";
		div.runtimeStyle.left = "11em";
	}

	$div.outerWidth( true );

	if ( runtimeStyle ) {
		assert.equal( div.runtimeStyle.left, "11em", "getting dimensions modifies runtimeStyle, see #9233" );
	} else {
		assert.ok( true, "this browser doesn't support runtimeStyle, see #9233" );
	}

	$div.remove();
} );
diff --git a/a.js b/b.js
@@ -348,8 +348,8 @@ QUnit.test( "table dimensions", function( assert ) {
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	}

	$div.remove();
} );

QUnit.test( "table dimensions", function( assert ) {
	assert.expect( 2 );

	var table = jQuery( "<table><colgroup><col></col><col></col></colgroup><tbody><tr><td></td><td>a</td></tr><tr><td></td><td>a</td></tr></tbody></table>" ).appendTo( "#qunit-fixture" ),
		tdElem = table.find( "td" ).first(),
		colElem = table.find( "col" ).first().width( 300 );

	table.find( "td" ).css( { "margin": 0, "padding": 0 } );

	assert.equal( tdElem.width(), tdElem.width(), "width() doesn't alter dimension values of empty cells, see #11293" );
	assert.equal( colElem.width(), 300, "col elements have width(), see #12243" );
} );

QUnit.test( "SVG dimensions (basic content-box)", function( assert ) {
	assert.expect( 8 );
diff --git a/a.js b/b.js
@@ -412,7 +412,7 @@ QUnit.test( "SVG dimensions (border-box)", function( assert ) {
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	assert.equal( svg.outerHeight( true ), 112 );

	svg.remove();
} );

QUnit.test( "SVG dimensions (border-box)", function( assert ) {
	assert.expect( 8 );

	var svg = jQuery( "<svg style='width: 100px; height: 100px; box-sizing: border-box; border: 1px solid white; padding: 2px; margin: 3px'></svg>" ).appendTo( "#qunit-fixture" );

	assert.equal( svg.width(), 94, "width" );
	assert.equal( svg.height(), 94, "height" );

	assert.equal( svg.innerWidth(), 98, "innerWidth" );
	assert.equal( svg.innerHeight(), 98, "innerHeight" );

	assert.equal( svg.outerWidth(), 100, "outerWidth" );
	assert.equal( svg.outerHeight(), 100, "outerHeight" );

	assert.equal( svg.outerWidth( true ), 106, "outerWidth( true )" );
	assert.equal( svg.outerHeight( true ), 106, "outerHeight( true )" );

	svg.remove();
} );

QUnit.test( "box-sizing:border-box child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #10413", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "boxSizing": "border-box", "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
diff --git a/a.js b/b.js
@@ -423,38 +423,38 @@ QUnit.test( "box-sizing:border-box child of a hidden elem (or unconnected node)
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
	assert.equal( svg.outerHeight( true ), 106, "outerHeight( true )" );

	svg.remove();
} );

QUnit.test( "box-sizing:border-box child of a hidden elem (or unconnected node) has accurate inner/outer/Width()/Height()  see #10413", function( assert ) {
	assert.expect( 16 );

	// setup html
	var $divNormal = jQuery( "<div>" ).css( { "boxSizing": "border-box", "width": "100px", "height": "100px", "border": "10px solid white", "padding": "2px", "margin": "3px" } ),
		$divChild = $divNormal.clone(),
		$divUnconnected = $divNormal.clone(),
		$divHiddenParent = jQuery( "<div>" ).css( "display", "none" ).append( $divChild ).appendTo( "body" );
	$divNormal.appendTo( "body" );

	// tests that child div of a hidden div works the same as a normal div
	assert.equal( $divChild.width(), $divNormal.width(), "child of a hidden element width() is wrong see #10413" );
	assert.equal( $divChild.innerWidth(), $divNormal.innerWidth(), "child of a hidden element innerWidth() is wrong see #10413" );
	assert.equal( $divChild.outerWidth(), $divNormal.outerWidth(), "child of a hidden element outerWidth() is wrong see #10413" );
	assert.equal( $divChild.outerWidth( true ), $divNormal.outerWidth( true ), "child of a hidden element outerWidth( true ) is wrong see #10413" );

	assert.equal( $divChild.height(), $divNormal.height(), "child of a hidden element height() is wrong see #10413" );
	assert.equal( $divChild.innerHeight(), $divNormal.innerHeight(), "child of a hidden element innerHeight() is wrong see #10413" );
	assert.equal( $divChild.outerHeight(), $divNormal.outerHeight(), "child of a hidden element outerHeight() is wrong see #10413" );
	assert.equal( $divChild.outerHeight( true ), $divNormal.outerHeight( true ), "child of a hidden element outerHeight( true ) is wrong see #10413" );

	// tests that child div of an unconnected div works the same as a normal div
	assert.equal( $divUnconnected.width(), $divNormal.width(), "unconnected element width() is wrong see #10413" );
	assert.equal( $divUnconnected.innerWidth(), $divNormal.innerWidth(), "unconnected element innerWidth() is wrong see #10413" );
	assert.equal( $divUnconnected.outerWidth(), $divNormal.outerWidth(), "unconnected element outerWidth() is wrong see #10413" );
	assert.equal( $divUnconnected.outerWidth( true ), $divNormal.outerWidth( true ), "unconnected element outerWidth( true ) is wrong see #10413" );

	assert.equal( $divUnconnected.height(), $divNormal.height(), "unconnected element height() is wrong see #10413" );
	assert.equal( $divUnconnected.innerHeight(), $divNormal.innerHeight(), "unconnected element innerHeight() is wrong see #10413" );
	assert.equal( $divUnconnected.outerHeight(), $divNormal.outerHeight(), "unconnected element outerHeight() is wrong see #10413" );
	assert.equal( $divUnconnected.outerHeight( true ), $divNormal.outerHeight( true ), "unconnected element outerHeight( true ) is wrong see #10413" );

	// teardown html
	$divHiddenParent.remove();
	$divNormal.remove();
} );

QUnit.test( "passing undefined is a setter #5571", function( assert ) {
	assert.expect( 4 );
	assert.equal( jQuery( "#nothiddendiv" ).height( 30 ).height( undefined ).height(), 30, ".height(undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#nothiddendiv" ).height( 30 ).innerHeight( undefined ).height(), 30, ".innerHeight(undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#nothiddendiv" ).height( 30 ).outerHeight( undefined ).height(), 30, ".outerHeight(undefined) is chainable (#5571)" );
	assert.equal( jQuery( "#nothiddendiv" ).width( 30 ).width( undefined ).width(), 30, ".width(undefined) is chainable (#5571)" );
} );

QUnit.test( "setters with and without box-sizing:border-box", function( assert ) {
	assert.expect( 120 );
diff --git a/a.js b/b.js
@@ -627,13 +627,7 @@ function( assert ) {
A blob:280a54ebc8bfce7f34d849570ae3aedd9df51346
		assert.equal( $elem[ "outer" + method ]( true ), val + 12, "outer" + method + "(true) should include padding, border, and margin" );
	} );
} );

QUnit.test( "width/height on an inline element with percentage dimensions (gh-3611)",
	function( assert ) {
		assert.expect( 4 );

		jQuery( "<div id='gh3611' style='width: 100px;'>" +
			"<span style='width: 100%; padding: 0 5px'>text</span>" +
		"</div>" ).appendTo( "#qunit-fixture" );

		var $elem = jQuery( "#gh3611 span" ),
			actualWidth = $elem[ 0 ].getBoundingClientRect().width,
			marginWidth = $elem.outerWidth( true ),
			borderWidth = $elem.outerWidth(),
			paddingWidth = $elem.innerWidth(),
			contentWidth = $elem.width();

		assert.equal( Math.round( borderWidth ), Math.round( actualWidth ),
			".outerWidth(): " + borderWidth + " approximates " + actualWidth );
		assert.equal( marginWidth, borderWidth, ".outerWidth(true) matches .outerWidth()" );
		assert.equal( paddingWidth, borderWidth, ".innerWidth() matches .outerWidth()" );
		assert.equal( contentWidth, borderWidth - 10, ".width() excludes padding" );
	}
);

// Support: Firefox 70+
// Firefox 70 & newer fail this test but the issue there is more profound - Firefox doesn't
// subtract borders from table row computed widths.
// See https://github.com/jquery/jquery/issues/4529
// See https://bugzilla.mozilla.org/show_bug.cgi?id=1590837
// See https://github.com/w3c/csswg-drafts/issues/4444
QUnit[ /firefox/i.test( navigator.userAgent ) ? "skip" : "test" ](
	"width/height on a table row with phantom borders (gh-3698)", function( assert ) {
	assert.expect( 4 );

	jQuery( "<table id='gh3698' style='border-collapse: separate; border-spacing: 0;'><tbody>" +
diff --git a/a.js b/b.js
@@ -19,7 +19,7 @@ function getComputedSupport( support ) {
A blob:008453085868fce0a113c82c0695029867b6de1b
QUnit.module( "support", { afterEach: moduleTeardown } );

var computedSupport = getComputedSupport( jQuery.support );

function getComputedSupport( support ) {
	var prop,
		result = {};

	for ( prop in support ) {
		if ( typeof support[ prop ] === "function" ) {
			result[ prop ] = support[ prop ]();
		} else {
			result[ prop ] = support[ prop ];
		}
	}

	return result;
}

if ( jQuery.css ) {
	testIframe(
		"body background is not lost if set prior to loading jQuery (#9239)",
		"support/bodyBackground.html",
		function( assert, jQuery, window, document, color, support ) {
			assert.expect( 2 );
			var okValue = {
diff --git a/a.js b/b.js
@@ -58,11 +58,21 @@ function( assert, jQuery, window, document, support ) {
A blob:008453085868fce0a113c82c0695029867b6de1b
// This test checks CSP only for browsers with "Content-Security-Policy" header support
// i.e. no IE
testIframe(
	"Check CSP (https://developer.mozilla.org/en-US/docs/Security/CSP) restrictions",
	"mock.php?action=cspFrame",
	function( assert, jQuery, window, document, support ) {
		var done = assert.async();

		assert.expect( 2 );
		assert.deepEqual( jQuery.extend( {}, support ), computedSupport,
			"No violations of CSP polices" );

		supportjQuery.get( baseURL + "support/csp.log" ).done( function( data ) {
			assert.equal( data, "", "No log request should be sent" );
			supportjQuery.get( baseURL + "mock.php?action=cspClean" ).done( done );
		} );
	}
);

( function() {
	var expected,
		userAgent = window.navigator.userAgent,
		expectedMap = {
			ie_11: {},
			chrome: {},
			safari: {},
			firefox: {},
			ios: {}
		};

	if ( document.documentMode ) {
		expected = expectedMap.ie_11;
diff --git a/a.js b/b.js
@@ -2,7 +2,7 @@
A blob:715f59f1fe06627a1788bd0724830fb21fa8ec8b
import jQuery from "../core.js";

// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

diff --git a/a.js b/b.js
@@ -11,12 +11,17 @@ jQuery.parseXML = function( data ) {
A blob:715f59f1fe06627a1788bd0724830fb21fa8ec8b
import jQuery from "../core.js";

// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11+
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};

diff --git a/a.js b/b.js
@@ -92,7 +92,7 @@ QUnit.test( "jQuery()", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
	assert.ok( RegExp, "RegExp" );
	assert.ok( jQuery, "jQuery" );
	assert.ok( $, "$" );
} );

QUnit.test( "jQuery()", function( assert ) {

	var elem, i,
		obj = jQuery( "div" ),
		code = jQuery( "<code></code>" ),
		img = jQuery( "<img/>" ),
		div = jQuery( "<div></div><hr/><code></code><b/>" ),
		exec = false,
		expected = 23,
		attrObj = {
			"text": "test",
			"class": "test2",
			"id": "test3"
		};

	// The $(html, props) signature can stealth-call any $.fn method, check for a
	// few here but beware of modular builds where these methods may be excluded.
	if ( jQuery.fn.click ) {
		expected++;
		attrObj[ "click" ] = function() { assert.ok( exec, "Click executed." ); };
	}
	if ( jQuery.fn.width ) {
		expected++;
		attrObj[ "width" ] = 10;
	}
	if ( jQuery.fn.offset ) {
		expected++;
		attrObj[ "offset" ] = { "top": 1, "left": 1 };
	}
	if ( jQuery.fn.css ) {
		expected += 2;
		attrObj[ "css" ] = { "paddingLeft": 1, "paddingRight": 1 };
	}
	if ( jQuery.fn.attr ) {
		expected++;
		attrObj.attr = { "desired": "very" };
	}

	assert.expect( expected );

	// Basic constructor's behavior
	assert.equal( jQuery().length, 0, "jQuery() === jQuery([])" );
	assert.equal( jQuery( undefined ).length, 0, "jQuery(undefined) === jQuery([])" );
	assert.equal( jQuery( null ).length, 0, "jQuery(null) === jQuery([])" );
	assert.equal( jQuery( "" ).length, 0, "jQuery('') === jQuery([])" );
	assert.deepEqual( jQuery( obj ).get(), obj.get(), "jQuery(jQueryObj) == jQueryObj" );

	// Invalid #id will throw an error (gh-1682)
	try {
		jQuery( "#" );
	} catch ( e ) {
		assert.ok( true, "Threw an error on #id with no id" );
	}

	// can actually yield more than one, when iframes are included, the window is an array as well
	assert.equal( jQuery( window ).length, 1, "Correct number of elements generated for jQuery(window)" );

/*
	// disabled since this test was doing nothing. i tried to fix it but i'm not sure
	// what the expected behavior should even be. FF returns "\n" for the text node
	// make sure this is handled
	var crlfContainer = jQuery('<p>\r\n</p>');
	var x = crlfContainer.contents().get(0).nodeValue;
	assert.equal( x, what???, "Check for \\r and \\n in jQuery()" );
*/

	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		jQuery("<div>Testing</div>").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	assert.ok( pass, "jQuery('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	assert.equal( code.length, 1, "Correct number of elements generated for code" );
	assert.equal( code.parent().length, 0, "Make sure that the generated HTML has no parent." );

diff --git a/a.js b/b.js
@@ -146,7 +146,7 @@ QUnit.test( "jQuery()", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
	assert.ok( RegExp, "RegExp" );
	assert.ok( jQuery, "jQuery" );
	assert.ok( $, "$" );
} );

QUnit.test( "jQuery()", function( assert ) {

	var elem, i,
		obj = jQuery( "div" ),
		code = jQuery( "<code></code>" ),
		img = jQuery( "<img/>" ),
		div = jQuery( "<div></div><hr/><code></code><b/>" ),
		exec = false,
		expected = 23,
		attrObj = {
			"text": "test",
			"class": "test2",
			"id": "test3"
		};

	// The $(html, props) signature can stealth-call any $.fn method, check for a
	// few here but beware of modular builds where these methods may be excluded.
	if ( jQuery.fn.click ) {
		expected++;
		attrObj[ "click" ] = function() { assert.ok( exec, "Click executed." ); };
	}
	if ( jQuery.fn.width ) {
		expected++;
		attrObj[ "width" ] = 10;
	}
	if ( jQuery.fn.offset ) {
		expected++;
		attrObj[ "offset" ] = { "top": 1, "left": 1 };
	}
	if ( jQuery.fn.css ) {
		expected += 2;
		attrObj[ "css" ] = { "paddingLeft": 1, "paddingRight": 1 };
	}
	if ( jQuery.fn.attr ) {
		expected++;
		attrObj.attr = { "desired": "very" };
	}

	assert.expect( expected );

	// Basic constructor's behavior
	assert.equal( jQuery().length, 0, "jQuery() === jQuery([])" );
	assert.equal( jQuery( undefined ).length, 0, "jQuery(undefined) === jQuery([])" );
	assert.equal( jQuery( null ).length, 0, "jQuery(null) === jQuery([])" );
	assert.equal( jQuery( "" ).length, 0, "jQuery('') === jQuery([])" );
	assert.deepEqual( jQuery( obj ).get(), obj.get(), "jQuery(jQueryObj) == jQueryObj" );

	// Invalid #id will throw an error (gh-1682)
	try {
		jQuery( "#" );
	} catch ( e ) {
		assert.ok( true, "Threw an error on #id with no id" );
	}

	// can actually yield more than one, when iframes are included, the window is an array as well
	assert.equal( jQuery( window ).length, 1, "Correct number of elements generated for jQuery(window)" );

/*
	// disabled since this test was doing nothing. i tried to fix it but i'm not sure
	// what the expected behavior should even be. FF returns "\n" for the text node
	// make sure this is handled
	var crlfContainer = jQuery('<p>\r\n</p>');
	var x = crlfContainer.contents().get(0).nodeValue;
	assert.equal( x, what???, "Check for \\r and \\n in jQuery()" );
*/

	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		jQuery("<div>Testing</div>").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	assert.ok( pass, "jQuery('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	assert.equal( code.length, 1, "Correct number of elements generated for code" );
	assert.equal( code.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( img.length, 1, "Correct number of elements generated for img" );
	assert.equal( img.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( div.length, 4, "Correct number of elements generated for div hr code b" );
	assert.equal( div.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( jQuery( [ 1, 2, 3 ] ).get( 1 ), 2, "Test passing an array to the factory" );

	assert.equal( jQuery( document.body ).get( 0 ), jQuery( "body" ).get( 0 ), "Test passing an html node to the factory" );

	elem = jQuery( "  <em>hello</em>" )[ 0 ];
	assert.equal( elem.nodeName.toLowerCase(), "em", "leading space" );

	elem = jQuery( "\n\n<em>world</em>" )[ 0 ];
	assert.equal( elem.nodeName.toLowerCase(), "em", "leading newlines" );

	elem = jQuery( "<div></div>", attrObj );

	if ( jQuery.fn.width ) {
		assert.equal( elem[ 0 ].style.width, "10px", "jQuery() quick setter width" );
	}

	if ( jQuery.fn.offset ) {
		assert.equal( elem[ 0 ].style.top, "1px", "jQuery() quick setter offset" );
	}

	if ( jQuery.fn.css ) {
		assert.equal( elem[ 0 ].style.paddingLeft, "1px", "jQuery quick setter css" );
		assert.equal( elem[ 0 ].style.paddingRight, "1px", "jQuery quick setter css" );
	}

	if ( jQuery.fn.attr ) {
		assert.equal( elem[ 0 ].getAttribute( "desired" ), "very", "jQuery quick setter attr" );
	}

	assert.equal( elem[ 0 ].childNodes.length, 1, "jQuery quick setter text" );
	assert.equal( elem[ 0 ].firstChild.nodeValue, "test", "jQuery quick setter text" );
	assert.equal( elem[ 0 ].className, "test2", "jQuery() quick setter class" );
	assert.equal( elem[ 0 ].id, "test3", "jQuery() quick setter id" );

	exec = true;
	elem.trigger( "click" );

	// manually clean up detached elements
	elem.remove();

	for ( i = 0; i < 3; ++i ) {
		elem = jQuery( "<input type='text' value='TEST' />" );
	}
	assert.equal( elem[ 0 ].defaultValue, "TEST", "Ensure cached nodes are cloned properly (Bug #6655)" );

	elem = jQuery( "<input type='hidden'>", {} );
	assert.strictEqual( elem[ 0 ].ownerDocument, document,
		"Empty attributes object is not interpreted as a document (trac-8950)" );
diff --git a/a.js b/b.js
@@ -182,7 +182,7 @@ QUnit.test( "globalEval with 'use strict'", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706

	jQuery.globalEval( "this.globalEvalTest = 3;" );
	assert.equal( window.globalEvalTest, 3, "Test context (this) is the window object" );
} );

QUnit.test( "globalEval with 'use strict'", function( assert ) {
	assert.expect( 1 );
	Globals.register( "strictEvalTest" );

	jQuery.globalEval( "'use strict'; var strictEvalTest = 1;" );
	assert.equal( window.strictEvalTest, 1, "Test variable declarations are global (strict mode)" );
} );

QUnit.test( "globalEval execution after script injection (#7862)", function( assert ) {
	assert.expect( 1 );

	var now,
		script = document.createElement( "script" );
diff --git a/a.js b/b.js
@@ -475,7 +475,7 @@ QUnit.test( "jQuery('html')", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
	} catch ( err ) {
		jQuery[ "_check9521" ]( true );
	}
} );

QUnit.test( "jQuery('html')", function( assert ) {
	assert.expect( 18 );

	var s, div, j;

	jQuery[ "foo" ] = false;
	s = jQuery( "<script>jQuery.foo='test';</script>" )[ 0 ];
	assert.ok( s, "Creating a script" );
	assert.ok( !jQuery[ "foo" ], "Make sure the script wasn't executed prematurely" );
	jQuery( "body" ).append( "<script>jQuery.foo='test';</script>" );
	assert.ok( jQuery[ "foo" ], "Executing a script's contents in the right context" );

	// Test multi-line HTML
	div = jQuery( "<div>\r\nsome text\n<p>some p</p>\nmore text\r\n</div>" )[ 0 ];
	assert.equal( div.nodeName.toUpperCase(), "DIV", "Make sure we're getting a div." );
	assert.equal( div.firstChild.nodeType, 3, "Text node." );
	assert.equal( div.lastChild.nodeType, 3, "Text node." );
	assert.equal( div.childNodes[ 1 ].nodeType, 1, "Paragraph." );
	assert.equal( div.childNodes[ 1 ].firstChild.nodeType, 3, "Paragraph text." );

	assert.ok( jQuery( "<link rel='stylesheet'/>" )[ 0 ], "Creating a link" );

	assert.ok( !jQuery( "<script></script>" )[ 0 ].parentNode, "Create a script" );

	assert.ok( jQuery( "<input/>" ).attr( "type", "hidden" ), "Create an input and set the type." );

	j = jQuery( "<span>hi</span> there <!-- mon ami -->" );
	assert.ok( j.length >= 2, "Check node,textnode,comment creation (some browsers delete comments)" );

	assert.ok( !jQuery( "<option>test</option>" )[ 0 ].selected, "Make sure that options are auto-selected #2050" );

	assert.ok( jQuery( "<div></div>" )[ 0 ], "Create a div with closing tag." );
	assert.ok( jQuery( "<table></table>" )[ 0 ], "Create a table with closing tag." );

diff --git a/a.js b/b.js
@@ -516,7 +516,7 @@ QUnit.test( "jQuery(element with non-alphanumeric name)", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		assert.ok( "skip", "Complex :not not supported in selector-native" );
	}
	assert.equal( jQuery( "\\<div\\>" ).length, 0, "Ignore escaped html characters" );
} );

QUnit.test( "jQuery(element with non-alphanumeric name)", function( assert ) {
	assert.expect( 36 );

	jQuery.each( [ "-", ":" ], function( i, symbol ) {
		jQuery.each( [ "thead", "tbody", "tfoot", "colgroup", "caption", "tr", "th", "td" ],
			function( j, tag ) {
				var tagName = tag + symbol + "test";
				var el = jQuery( "<" + tagName + "></" + tagName + ">" );
				assert.ok( el[ 0 ], "Create a " + tagName + " element" );
				assert.ok( el[ 0 ].nodeName === tagName.toUpperCase(),
					tagName + " element has expected node name" );
			}
		);

		var tagName = [ "tr", "multiple", "symbol" ].join( symbol );
		var el = jQuery( "<" + tagName + "></" + tagName + ">" );
		assert.ok( el[ 0 ], "Create a " + tagName + " element" );
		assert.ok( el[ 0 ].nodeName === tagName.toUpperCase(),
			tagName + " element has expected node name" );
	} );
} );

QUnit.test( "jQuery('massive html #7990')", function( assert ) {
	assert.expect( 3 );

	var i,
		li = "<li>very very very very large html string</li>",
diff --git a/a.js b/b.js
@@ -538,7 +538,7 @@ QUnit.test( "jQuery('html', context)", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
	assert.equal( html.nodeName.toLowerCase(), "ul" );
	assert.equal( html.firstChild.nodeName.toLowerCase(), "li" );
	assert.equal( html.childNodes.length, 30000 );
} );

QUnit.test( "jQuery('html', context)", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div></div>" )[ 0 ],
		$span = jQuery( "<span></span>", $div );
	assert.equal( $span.length, 1, "verify a span created with a div context works, #1763" );
} );

QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -546,7 +546,7 @@ QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", functio
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
	var $div = jQuery( "<div></div>" )[ 0 ],
		$span = jQuery( "<span></span>", $div );
	assert.equal( $span.length, 1, "verify a span created with a div context works, #1763" );
} );

QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", function( assert ) {
	assert.expect( 2 );

	var xml = createDashboardXML(),

	// tests for #1419 where ie was a problem
		tab = jQuery( "tab", xml ).eq( 0 );
	assert.equal( tab.text(), "blabla", "verify initial text correct" );
	tab.text( "newtext" );
	assert.equal( tab.text(), "newtext", "verify new text correct" );
diff --git a/a.js b/b.js
@@ -803,7 +803,7 @@ 	callback = function( v, k ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (#2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
diff --git a/a.js b/b.js
@@ -817,7 +817,7 @@ 	callback = function( v, k ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (#2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
	assert.equal( result.length, 3, "Array flatten only one level down" );
	assert.ok( Array.isArray( result[ 0 ] ), "Array flatten only one level down" );

	// Support: IE 11+
	// IE doesn't have Array#flat so it'd fail the test.
	if ( !QUnit.isIE ) {
		result = jQuery.map( Array( 300000 ), function( v, k ) {
			return k;
		} );
		assert.equal( result.length, 300000, "Able to map 300000 records without any problems (#4320)" );
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );
diff --git a/a.js b/b.js
@@ -854,14 +854,14 @@ QUnit.test( "jQuery.merge()", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );

QUnit.test( "jQuery.merge()", function( assert ) {
	assert.expect( 10 );

	assert.deepEqual(
		jQuery.merge( [], [] ),
		[],
		"Empty arrays"
	);

	assert.deepEqual(
		jQuery.merge( [ 1 ], [ 2 ] ),
		[ 1, 2 ],
		"Basic (single-element)"
	);
	assert.deepEqual(
		jQuery.merge( [ 1, 2 ], [ 3, 4 ] ),
		[ 1, 2, 3, 4 ],
		"Basic (multiple-element)"
	);

	assert.deepEqual(
		jQuery.merge( [ 1, 2 ], [] ),
		[ 1, 2 ],
		"Second empty"
	);
	assert.deepEqual(
		jQuery.merge( [], [ 1, 2 ] ),
		[ 1, 2 ],
		"First empty"
	);

	// Fixed at [5998], #3641
	assert.deepEqual(
		jQuery.merge( [ -2, -1 ], [ 0, 1, 2 ] ),
		[ -2, -1, 0, 1, 2 ],
		"Second array including a zero (falsy)"
	);

	// After fixing #5527
	assert.deepEqual(
		jQuery.merge( [], [ null, undefined ] ),
		[ null, undefined ],
		"Second array including null and undefined values"
diff --git a/a.js b/b.js
@@ -1005,7 +1005,7 @@ QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		[],
		"Satisfying elements absent, Array-like object used, and grep explicitly uninverted"
	);
} );

QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
	assert.expect( 28 );

	var empty, optionsWithLength, optionsWithDate, myKlass,
		customObject, optionsWithCustomObject, MyNumber, ret,
		nullUndef, target, recursive, obj,
		defaults, defaultsCopy, options1, options1Copy, options2, options2Copy, merged2,
		settings = { "xnumber1": 5, "xnumber2": 7, "xstring1": "peter", "xstring2": "pan" },
		options = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		optionsCopy = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		merged = { "xnumber1": 5, "xnumber2": 1, "xstring1": "peter", "xstring2": "x", "xxx": "newstring" },
		deep1 = { "foo": { "bar": true } },
		deep2 = { "foo": { "baz": true }, "foo2": document },
		deep2copy = { "foo": { "baz": true }, "foo2": document },
		deepmerged = { "foo": { "bar": true, "baz": true }, "foo2": document },
		arr = [ 1, 2, 3 ],
		nestedarray = { "arr": arr };

	jQuery.extend( settings, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( settings, null, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( true, deep1, deep2 );
	assert.deepEqual( deep1[ "foo" ], deepmerged[ "foo" ], "Check if foo: settings must be extended" );
	assert.deepEqual( deep2[ "foo" ], deep2copy[ "foo" ], "Check if not deep2: options must not be modified" );
	assert.equal( deep1[ "foo2" ], document, "Make sure that a deep clone was not attempted on the document" );

	assert.ok( jQuery.extend( true, {}, nestedarray )[ "arr" ] !== arr, "Deep extend of object must clone child array" );

	// #5991
	assert.ok( Array.isArray( jQuery.extend( true, { "arr": {} }, nestedarray )[ "arr" ] ), "Cloned array have to be an Array" );
	assert.ok( jQuery.isPlainObject( jQuery.extend( true, { "arr": arr }, { "arr": {} } )[ "arr" ] ), "Cloned object have to be an plain object" );

	empty = {};
diff --git a/a.js b/b.js
@@ -1053,13 +1053,13 @@ QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		[],
		"Satisfying elements absent, Array-like object used, and grep explicitly uninverted"
	);
} );

QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
	assert.expect( 28 );

	var empty, optionsWithLength, optionsWithDate, myKlass,
		customObject, optionsWithCustomObject, MyNumber, ret,
		nullUndef, target, recursive, obj,
		defaults, defaultsCopy, options1, options1Copy, options2, options2Copy, merged2,
		settings = { "xnumber1": 5, "xnumber2": 7, "xstring1": "peter", "xstring2": "pan" },
		options = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		optionsCopy = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		merged = { "xnumber1": 5, "xnumber2": 1, "xstring1": "peter", "xstring2": "x", "xxx": "newstring" },
		deep1 = { "foo": { "bar": true } },
		deep2 = { "foo": { "baz": true }, "foo2": document },
		deep2copy = { "foo": { "baz": true }, "foo2": document },
		deepmerged = { "foo": { "bar": true, "baz": true }, "foo2": document },
		arr = [ 1, 2, 3 ],
		nestedarray = { "arr": arr };

	jQuery.extend( settings, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( settings, null, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( true, deep1, deep2 );
	assert.deepEqual( deep1[ "foo" ], deepmerged[ "foo" ], "Check if foo: settings must be extended" );
	assert.deepEqual( deep2[ "foo" ], deep2copy[ "foo" ], "Check if not deep2: options must not be modified" );
	assert.equal( deep1[ "foo2" ], document, "Make sure that a deep clone was not attempted on the document" );

	assert.ok( jQuery.extend( true, {}, nestedarray )[ "arr" ] !== arr, "Deep extend of object must clone child array" );

	// #5991
	assert.ok( Array.isArray( jQuery.extend( true, { "arr": {} }, nestedarray )[ "arr" ] ), "Cloned array have to be an Array" );
	assert.ok( jQuery.isPlainObject( jQuery.extend( true, { "arr": arr }, { "arr": {} } )[ "arr" ] ), "Cloned object have to be an plain object" );

	empty = {};
	optionsWithLength = { "foo": { "length": -1 } };
	jQuery.extend( true, empty, optionsWithLength );
	assert.deepEqual( empty[ "foo" ], optionsWithLength[ "foo" ], "The length property must copy correctly" );

	empty = {};
	optionsWithDate = { "foo": { "date": new Date() } };
	jQuery.extend( true, empty, optionsWithDate );
	assert.deepEqual( empty[ "foo" ], optionsWithDate[ "foo" ], "Dates copy correctly" );

	/** @constructor */
	myKlass = function() {};
	customObject = new myKlass();
	optionsWithCustomObject = { "foo": { "date": customObject } };
	empty = {};
	jQuery.extend( true, empty, optionsWithCustomObject );
	assert.ok( empty[ "foo" ] && empty[ "foo" ][ "date" ] === customObject, "Custom objects copy correctly (no methods)" );

	// Makes the class a little more realistic
	myKlass.prototype = { "someMethod": function() {} };
	empty = {};
	jQuery.extend( true, empty, optionsWithCustomObject );
	assert.ok( empty[ "foo" ] && empty[ "foo" ][ "date" ] === customObject, "Custom objects copy correctly" );

	MyNumber = Number;

	ret = jQuery.extend( true, { "foo": 4 }, { "foo": new MyNumber( 5 ) } );
	assert.ok( parseInt( ret.foo, 10 ) === 5, "Wrapped numbers copy correctly" );

	nullUndef = jQuery.extend( {}, options, { "xnumber2": null } );
	assert.ok( nullUndef[ "xnumber2" ] === null, "Check to make sure null values are copied" );

	nullUndef = jQuery.extend( {}, options, { "xnumber2": undefined } );
	assert.ok( nullUndef[ "xnumber2" ] === options[ "xnumber2" ], "Check to make sure undefined values are not copied" );

	nullUndef = jQuery.extend( {}, options, { "xnumber0": null } );
	assert.ok( nullUndef[ "xnumber0" ] === null, "Check to make sure null values are inserted" );

	target = {};
	recursive = { foo:target, bar:5 };
	jQuery.extend( true, target, recursive );
	assert.deepEqual( target, { bar:5 }, "Check to make sure a recursive obj doesn't go never-ending loop by not copying it over" );

	ret = jQuery.extend( true, { foo: [] }, { foo: [ 0 ] } ); // 1907
	assert.equal( ret.foo.length, 1, "Check to make sure a value with coercion 'false' copies over when necessary to fix #1907" );

	ret = jQuery.extend( true, { foo: "1,2,3" }, { foo: [ 1, 2, 3 ] } );
	assert.ok( typeof ret.foo !== "string", "Check to make sure values equal with coercion (but not actually equal) overwrite correctly" );

	ret = jQuery.extend( true, { foo:"bar" }, { foo:null } );
	assert.ok( typeof ret.foo !== "undefined", "Make sure a null value doesn't crash with deep extend, for #1908" );

	obj = { foo:null };
	jQuery.extend( true, obj, { foo:"notnull" } );
	assert.equal( obj.foo, "notnull", "Make sure a null value can be overwritten" );
diff --git a/a.js b/b.js
@@ -1365,7 +1365,7 @@ QUnit.test( "jQuery.parseHTML", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706

	// What about this ?
	// equal(true, jQuery.isEmptyObject(null), "isEmptyObject on null" );
} );

QUnit.test( "jQuery.parseHTML", function( assert ) {
	assert.expect( 23 );

	var html, nodes;

	assert.deepEqual( jQuery.parseHTML(), [], "Without arguments" );
	assert.deepEqual( jQuery.parseHTML( undefined ), [], "Undefined" );
	assert.deepEqual( jQuery.parseHTML( null ), [], "Null" );
	assert.deepEqual( jQuery.parseHTML( false ), [], "Boolean false" );
	assert.deepEqual( jQuery.parseHTML( 0 ), [], "Zero" );
	assert.deepEqual( jQuery.parseHTML( true ), [], "Boolean true" );
	assert.deepEqual( jQuery.parseHTML( 42 ), [], "Positive number" );
	assert.deepEqual( jQuery.parseHTML( "" ), [], "Empty string" );
	assert.throws( function() {
		jQuery.parseHTML( "<div></div>", document.getElementById( "form" ) );
	}, "Passing an element as the context raises an exception (context should be a document)" );

	nodes = jQuery.parseHTML( jQuery( "body" )[ 0 ].innerHTML );
	assert.ok( nodes.length > 4, "Parse a large html string" );
	assert.ok( Array.isArray( nodes ), "parseHTML returns an array rather than a nodelist" );

	html = "<script>undefined()</script>";
	assert.equal( jQuery.parseHTML( html ).length, 0, "Ignore scripts by default" );
	assert.equal( jQuery.parseHTML( html, true )[ 0 ].nodeName.toLowerCase(), "script", "Preserve scripts when requested" );

	html += "<div></div>";
	assert.equal( jQuery.parseHTML( html )[ 0 ].nodeName.toLowerCase(), "div", "Preserve non-script nodes" );
	assert.equal( jQuery.parseHTML( html, true )[ 0 ].nodeName.toLowerCase(), "script", "Preserve script position" );

	assert.equal( jQuery.parseHTML( "text" )[ 0 ].nodeType, 3, "Parsing text returns a text node" );
	assert.equal( jQuery.parseHTML( "\t<div></div>" )[ 0 ].nodeValue, "\t", "Preserve leading whitespace" );

	assert.equal( jQuery.parseHTML( " <div></div> " )[ 0 ].nodeType, 3, "Leading spaces are treated as text nodes (#11290)" );

	html = jQuery.parseHTML( "<div>test div</div>" );

	assert.equal( html[ 0 ].parentNode.nodeType, 11, "parentNode should be documentFragment" );
diff --git a/a.js b/b.js
@@ -1418,9 +1418,9 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid xml not detected" );
	} catch ( e ) {
		assert.strictEqual( e.message, "Invalid XML: <p>Not a <<b>well-formed</b> xml string</p>", "invalid xml detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
diff --git a/a.js b/b.js
@@ -1436,8 +1436,37 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid xml not detected" );
	} catch ( e ) {
		assert.strictEqual( e.message, "Invalid XML: <p>Not a <<b>well-formed</b> xml string</p>", "invalid xml detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
		xml = jQuery.parseXML();
		assert.strictEqual( xml, null, "undefined string => null document" );
		xml = jQuery.parseXML( null );
		assert.strictEqual( xml, null, "null string => null document" );
		xml = jQuery.parseXML( true );
		assert.strictEqual( xml, null, "non-string => null document" );
	} catch ( e ) {
		assert.ok( false, "empty input throws exception" );
	}
} );

testIframe(
	"document ready when jQuery loaded asynchronously (#13655)",
	"core/dynamic_ready.html",
	function( assert, jQuery, window, document, ready ) {
		assert.expect( 1 );
		assert.equal( true, ready, "document ready correctly fired when jQuery is loaded after DOMContentLoaded" );
diff --git a/a.js b/b.js
@@ -1446,7 +1475,7 @@ function( assert, jQuery, window, document, ready ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
} );

testIframe(
	"document ready when jQuery loaded asynchronously (#13655)",
	"core/dynamic_ready.html",
	function( assert, jQuery, window, document, ready ) {
		assert.expect( 1 );
		assert.equal( true, ready, "document ready correctly fired when jQuery is loaded after DOMContentLoaded" );
	}
);

testIframe(
	"Tolerating alias-masked DOM properties (#14074)",
	"core/aliased.html",
	function( assert, jQuery, window, document, errors ) {
		assert.expect( 1 );
		assert.deepEqual( errors, [], "jQuery loaded" );
diff --git a/a.js b/b.js
@@ -1455,7 +1484,7 @@ function( assert, jQuery, window, document, errors ) {
A blob:6bcea95af20ff0da0968d0a8a7288f0d95db9706
);

testIframe(
	"Tolerating alias-masked DOM properties (#14074)",
	"core/aliased.html",
	function( assert, jQuery, window, document, errors ) {
		assert.expect( 1 );
		assert.deepEqual( errors, [], "jQuery loaded" );
	}
);

testIframe(
	"Don't call window.onready (#14802)",
	"core/onready.html",
	function( assert, jQuery, window, document, error ) {
		assert.expect( 1 );
		assert.equal( error, false, "no call to user-defined onready" );
diff --git a/a.js b/b.js
@@ -10,9 +10,8 @@
A blob:e122305cef37ce3ea2b0c03521dddffe61a5bda5
import indexOf from "./var/indexOf.js";
import class2type from "./var/class2type.js";
import toString from "./var/toString.js";
import hasOwn from "./var/hasOwn.js";
import fnToString from "./var/fnToString.js";
import ObjectFunctionString from "./var/ObjectFunctionString.js";
import support from "./var/support.js";
import isWindow from "./var/isWindow.js";
import DOMEval from "./core/DOMEval.js";
import toType from "./core/toType.js";

var version = "@VERSION",

	rhtmlSuffix = /HTML$/i,
diff --git a/a.js b/b.js
@@ -307,8 +306,8 @@ inArray: function( elem, arr, i ) {
A blob:e122305cef37ce3ea2b0c03521dddffe61a5bda5
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem.namespaceURI,
			docElem = ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
diff --git a/a.js b/b.js
@@ -398,17 +397,4 @@ function( _i, name ) {
A blob:e122305cef37ce3ea2b0c03521dddffe61a5bda5
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	var length = !!obj && obj.length,
		type = toType( obj );

	if ( typeof obj === "function" || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}

export default jQuery;

diff --git a/a.js b/b.js
@@ -92,7 +92,7 @@ QUnit.test( "jQuery()", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
	assert.ok( RegExp, "RegExp" );
	assert.ok( jQuery, "jQuery" );
	assert.ok( $, "$" );
} );

QUnit.test( "jQuery()", function( assert ) {

	var elem, i,
		obj = jQuery( "div" ),
		code = jQuery( "<code></code>" ),
		img = jQuery( "<img/>" ),
		div = jQuery( "<div></div><hr/><code></code><b/>" ),
		exec = false,
		expected = 23,
		attrObj = {
			"text": "test",
			"class": "test2",
			"id": "test3"
		};

	// The $(html, props) signature can stealth-call any $.fn method, check for a
	// few here but beware of modular builds where these methods may be excluded.
	if ( jQuery.fn.click ) {
		expected++;
		attrObj[ "click" ] = function() { assert.ok( exec, "Click executed." ); };
	}
	if ( jQuery.fn.width ) {
		expected++;
		attrObj[ "width" ] = 10;
	}
	if ( jQuery.fn.offset ) {
		expected++;
		attrObj[ "offset" ] = { "top": 1, "left": 1 };
	}
	if ( jQuery.fn.css ) {
		expected += 2;
		attrObj[ "css" ] = { "paddingLeft": 1, "paddingRight": 1 };
	}
	if ( jQuery.fn.attr ) {
		expected++;
		attrObj.attr = { "desired": "very" };
	}

	assert.expect( expected );

	// Basic constructor's behavior
	assert.equal( jQuery().length, 0, "jQuery() === jQuery([])" );
	assert.equal( jQuery( undefined ).length, 0, "jQuery(undefined) === jQuery([])" );
	assert.equal( jQuery( null ).length, 0, "jQuery(null) === jQuery([])" );
	assert.equal( jQuery( "" ).length, 0, "jQuery('') === jQuery([])" );
	assert.deepEqual( jQuery( obj ).get(), obj.get(), "jQuery(jQueryObj) == jQueryObj" );

	// Invalid #id will throw an error (gh-1682)
	try {
		jQuery( "#" );
	} catch ( e ) {
		assert.ok( true, "Threw an error on #id with no id" );
	}

	// can actually yield more than one, when iframes are included, the window is an array as well
	assert.equal( jQuery( window ).length, 1, "Correct number of elements generated for jQuery(window)" );

/*
	// disabled since this test was doing nothing. i tried to fix it but i'm not sure
	// what the expected behavior should even be. FF returns "\n" for the text node
	// make sure this is handled
	var crlfContainer = jQuery('<p>\r\n</p>');
	var x = crlfContainer.contents().get(0).nodeValue;
	assert.equal( x, what???, "Check for \\r and \\n in jQuery()" );
*/

	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		jQuery("<div>Testing</div>").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	assert.ok( pass, "jQuery('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	assert.equal( code.length, 1, "Correct number of elements generated for code" );
	assert.equal( code.parent().length, 0, "Make sure that the generated HTML has no parent." );

diff --git a/a.js b/b.js
@@ -146,7 +146,7 @@ QUnit.test( "jQuery()", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
	assert.ok( RegExp, "RegExp" );
	assert.ok( jQuery, "jQuery" );
	assert.ok( $, "$" );
} );

QUnit.test( "jQuery()", function( assert ) {

	var elem, i,
		obj = jQuery( "div" ),
		code = jQuery( "<code></code>" ),
		img = jQuery( "<img/>" ),
		div = jQuery( "<div></div><hr/><code></code><b/>" ),
		exec = false,
		expected = 23,
		attrObj = {
			"text": "test",
			"class": "test2",
			"id": "test3"
		};

	// The $(html, props) signature can stealth-call any $.fn method, check for a
	// few here but beware of modular builds where these methods may be excluded.
	if ( jQuery.fn.click ) {
		expected++;
		attrObj[ "click" ] = function() { assert.ok( exec, "Click executed." ); };
	}
	if ( jQuery.fn.width ) {
		expected++;
		attrObj[ "width" ] = 10;
	}
	if ( jQuery.fn.offset ) {
		expected++;
		attrObj[ "offset" ] = { "top": 1, "left": 1 };
	}
	if ( jQuery.fn.css ) {
		expected += 2;
		attrObj[ "css" ] = { "paddingLeft": 1, "paddingRight": 1 };
	}
	if ( jQuery.fn.attr ) {
		expected++;
		attrObj.attr = { "desired": "very" };
	}

	assert.expect( expected );

	// Basic constructor's behavior
	assert.equal( jQuery().length, 0, "jQuery() === jQuery([])" );
	assert.equal( jQuery( undefined ).length, 0, "jQuery(undefined) === jQuery([])" );
	assert.equal( jQuery( null ).length, 0, "jQuery(null) === jQuery([])" );
	assert.equal( jQuery( "" ).length, 0, "jQuery('') === jQuery([])" );
	assert.deepEqual( jQuery( obj ).get(), obj.get(), "jQuery(jQueryObj) == jQueryObj" );

	// Invalid #id will throw an error (gh-1682)
	try {
		jQuery( "#" );
	} catch ( e ) {
		assert.ok( true, "Threw an error on #id with no id" );
	}

	// can actually yield more than one, when iframes are included, the window is an array as well
	assert.equal( jQuery( window ).length, 1, "Correct number of elements generated for jQuery(window)" );

/*
	// disabled since this test was doing nothing. i tried to fix it but i'm not sure
	// what the expected behavior should even be. FF returns "\n" for the text node
	// make sure this is handled
	var crlfContainer = jQuery('<p>\r\n</p>');
	var x = crlfContainer.contents().get(0).nodeValue;
	assert.equal( x, what???, "Check for \\r and \\n in jQuery()" );
*/

	/* // Disabled until we add this functionality in
	var pass = true;
	try {
		jQuery("<div>Testing</div>").appendTo(document.getElementById("iframe").contentDocument.body);
	} catch(e){
		pass = false;
	}
	assert.ok( pass, "jQuery('&lt;tag&gt;') needs optional document parameter to ease cross-frame DOM wrangling, see #968" );*/

	assert.equal( code.length, 1, "Correct number of elements generated for code" );
	assert.equal( code.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( img.length, 1, "Correct number of elements generated for img" );
	assert.equal( img.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( div.length, 4, "Correct number of elements generated for div hr code b" );
	assert.equal( div.parent().length, 0, "Make sure that the generated HTML has no parent." );

	assert.equal( jQuery( [ 1, 2, 3 ] ).get( 1 ), 2, "Test passing an array to the factory" );

	assert.equal( jQuery( document.body ).get( 0 ), jQuery( "body" ).get( 0 ), "Test passing an html node to the factory" );

	elem = jQuery( "  <em>hello</em>" )[ 0 ];
	assert.equal( elem.nodeName.toLowerCase(), "em", "leading space" );

	elem = jQuery( "\n\n<em>world</em>" )[ 0 ];
	assert.equal( elem.nodeName.toLowerCase(), "em", "leading newlines" );

	elem = jQuery( "<div></div>", attrObj );

	if ( jQuery.fn.width ) {
		assert.equal( elem[ 0 ].style.width, "10px", "jQuery() quick setter width" );
	}

	if ( jQuery.fn.offset ) {
		assert.equal( elem[ 0 ].style.top, "1px", "jQuery() quick setter offset" );
	}

	if ( jQuery.fn.css ) {
		assert.equal( elem[ 0 ].style.paddingLeft, "1px", "jQuery quick setter css" );
		assert.equal( elem[ 0 ].style.paddingRight, "1px", "jQuery quick setter css" );
	}

	if ( jQuery.fn.attr ) {
		assert.equal( elem[ 0 ].getAttribute( "desired" ), "very", "jQuery quick setter attr" );
	}

	assert.equal( elem[ 0 ].childNodes.length, 1, "jQuery quick setter text" );
	assert.equal( elem[ 0 ].firstChild.nodeValue, "test", "jQuery quick setter text" );
	assert.equal( elem[ 0 ].className, "test2", "jQuery() quick setter class" );
	assert.equal( elem[ 0 ].id, "test3", "jQuery() quick setter id" );

	exec = true;
	elem.trigger( "click" );

	// manually clean up detached elements
	elem.remove();

	for ( i = 0; i < 3; ++i ) {
		elem = jQuery( "<input type='text' value='TEST' />" );
	}
	assert.equal( elem[ 0 ].defaultValue, "TEST", "Ensure cached nodes are cloned properly (Bug #6655)" );

	elem = jQuery( "<input type='hidden'>", {} );
	assert.strictEqual( elem[ 0 ].ownerDocument, document,
		"Empty attributes object is not interpreted as a document (trac-8950)" );
diff --git a/a.js b/b.js
@@ -182,7 +182,7 @@ QUnit.test( "globalEval with 'use strict'", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8

	jQuery.globalEval( "this.globalEvalTest = 3;" );
	assert.equal( window.globalEvalTest, 3, "Test context (this) is the window object" );
} );

QUnit.test( "globalEval with 'use strict'", function( assert ) {
	assert.expect( 1 );
	Globals.register( "strictEvalTest" );

	jQuery.globalEval( "'use strict'; var strictEvalTest = 1;" );
	assert.equal( window.strictEvalTest, 1, "Test variable declarations are global (strict mode)" );
} );

QUnit.test( "globalEval execution after script injection (#7862)", function( assert ) {
	assert.expect( 1 );

	var now,
		script = document.createElement( "script" );
diff --git a/a.js b/b.js
@@ -417,6 +417,16 @@ QUnit.test( "isXMLDoc - XML", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8

	assert.strictEqual( jQuery.isXMLDoc( htmlTree.firstChild.firstChild ), true,
		"disconnected HTML-embedded SVG child element" );
} );

QUnit.test( "isXMLDoc - XML", function( assert ) {
	assert.expect( 8 );

	var xml = createDashboardXML();
	var svg = jQuery.parseXML(
		"<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" " +
		"\"http://www.w3.org/Gaphics/SVG/1.1/DTD/svg11.dtd\">" +
		"<svg version='1.1' xmlns='http://www.w3.org/2000/svg'><desc/></svg>"
	);
	assert.ok( jQuery.isXMLDoc( xml ), "XML document" );
	assert.ok( jQuery.isXMLDoc( xml.documentElement ), "XML documentElement" );
	assert.ok( jQuery.isXMLDoc( xml.documentElement.firstChild ), "XML child element" );
	assert.ok( jQuery.isXMLDoc( jQuery( "tab", xml )[ 0 ] ), "XML tab Element" );

	assert.ok( jQuery.isXMLDoc( svg ), "SVG document" );
	assert.ok( jQuery.isXMLDoc( svg.documentElement ), "SVG documentElement" );
	assert.ok( jQuery.isXMLDoc( svg.documentElement.firstChild ), "SVG child element" );
	assert.ok( jQuery.isXMLDoc( jQuery( "desc", svg )[ 0 ] ), "XML desc Element" );
} );

QUnit.test( "XSS via location.hash", function( assert ) {
	var done = assert.async();
	assert.expect( 1 );

diff --git a/a.js b/b.js
@@ -465,7 +475,7 @@ QUnit.test( "jQuery('html')", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
	} catch ( err ) {
		jQuery[ "_check9521" ]( true );
	}
} );

QUnit.test( "jQuery('html')", function( assert ) {
	assert.expect( 18 );

	var s, div, j;

	jQuery[ "foo" ] = false;
	s = jQuery( "<script>jQuery.foo='test';</script>" )[ 0 ];
	assert.ok( s, "Creating a script" );
	assert.ok( !jQuery[ "foo" ], "Make sure the script wasn't executed prematurely" );
	jQuery( "body" ).append( "<script>jQuery.foo='test';</script>" );
	assert.ok( jQuery[ "foo" ], "Executing a script's contents in the right context" );

	// Test multi-line HTML
	div = jQuery( "<div>\r\nsome text\n<p>some p</p>\nmore text\r\n</div>" )[ 0 ];
	assert.equal( div.nodeName.toUpperCase(), "DIV", "Make sure we're getting a div." );
	assert.equal( div.firstChild.nodeType, 3, "Text node." );
	assert.equal( div.lastChild.nodeType, 3, "Text node." );
	assert.equal( div.childNodes[ 1 ].nodeType, 1, "Paragraph." );
	assert.equal( div.childNodes[ 1 ].firstChild.nodeType, 3, "Paragraph text." );

	assert.ok( jQuery( "<link rel='stylesheet'/>" )[ 0 ], "Creating a link" );

	assert.ok( !jQuery( "<script></script>" )[ 0 ].parentNode, "Create a script" );

	assert.ok( jQuery( "<input/>" ).attr( "type", "hidden" ), "Create an input and set the type." );

	j = jQuery( "<span>hi</span> there <!-- mon ami -->" );
	assert.ok( j.length >= 2, "Check node,textnode,comment creation (some browsers delete comments)" );

	assert.ok( !jQuery( "<option>test</option>" )[ 0 ].selected, "Make sure that options are auto-selected #2050" );

	assert.ok( jQuery( "<div></div>" )[ 0 ], "Create a div with closing tag." );
	assert.ok( jQuery( "<table></table>" )[ 0 ], "Create a table with closing tag." );

diff --git a/a.js b/b.js
@@ -506,7 +516,7 @@ QUnit.test( "jQuery(element with non-alphanumeric name)", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		assert.ok( "skip", "Complex :not not supported in selector-native" );
	}
	assert.equal( jQuery( "\\<div\\>" ).length, 0, "Ignore escaped html characters" );
} );

QUnit.test( "jQuery(element with non-alphanumeric name)", function( assert ) {
	assert.expect( 36 );

	jQuery.each( [ "-", ":" ], function( i, symbol ) {
		jQuery.each( [ "thead", "tbody", "tfoot", "colgroup", "caption", "tr", "th", "td" ],
			function( j, tag ) {
				var tagName = tag + symbol + "test";
				var el = jQuery( "<" + tagName + "></" + tagName + ">" );
				assert.ok( el[ 0 ], "Create a " + tagName + " element" );
				assert.ok( el[ 0 ].nodeName === tagName.toUpperCase(),
					tagName + " element has expected node name" );
			}
		);

		var tagName = [ "tr", "multiple", "symbol" ].join( symbol );
		var el = jQuery( "<" + tagName + "></" + tagName + ">" );
		assert.ok( el[ 0 ], "Create a " + tagName + " element" );
		assert.ok( el[ 0 ].nodeName === tagName.toUpperCase(),
			tagName + " element has expected node name" );
	} );
} );

QUnit.test( "jQuery('massive html #7990')", function( assert ) {
	assert.expect( 3 );

	var i,
		li = "<li>very very very very large html string</li>",
diff --git a/a.js b/b.js
@@ -528,7 +538,7 @@ QUnit.test( "jQuery('html', context)", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
	assert.equal( html.nodeName.toLowerCase(), "ul" );
	assert.equal( html.firstChild.nodeName.toLowerCase(), "li" );
	assert.equal( html.childNodes.length, 30000 );
} );

QUnit.test( "jQuery('html', context)", function( assert ) {
	assert.expect( 1 );

	var $div = jQuery( "<div></div>" )[ 0 ],
		$span = jQuery( "<span></span>", $div );
	assert.equal( $span.length, 1, "verify a span created with a div context works, #1763" );
} );

QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", function( assert ) {
	assert.expect( 2 );
diff --git a/a.js b/b.js
@@ -536,7 +546,7 @@ QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", functio
A blob:e24966551caf382e5792e1f766993bc99ef077c8
	var $div = jQuery( "<div></div>" )[ 0 ],
		$span = jQuery( "<span></span>", $div );
	assert.equal( $span.length, 1, "verify a span created with a div context works, #1763" );
} );

QUnit.test( "jQuery(selector, xml).text(str) - loaded via xml document", function( assert ) {
	assert.expect( 2 );

	var xml = createDashboardXML(),

	// tests for #1419 where ie was a problem
		tab = jQuery( "tab", xml ).eq( 0 );
	assert.equal( tab.text(), "blabla", "verify initial text correct" );
	tab.text( "newtext" );
	assert.equal( tab.text(), "newtext", "verify new text correct" );
diff --git a/a.js b/b.js
@@ -793,7 +803,7 @@ 	callback = function( v, k ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (#2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
diff --git a/a.js b/b.js
@@ -807,7 +817,7 @@ 	callback = function( v, k ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		"sparse Array": Array( 4 ),
		"length: 1 plain object": { length: 1, "0": true },
		"length: 2 plain object": { length: 2, "0": true, "1": true },
		NodeList: document.getElementsByTagName( "html" )
	};
	callback = function( v, k ) {
		if ( result[ label ] ) {
			delete result[ label ];
			assert.equal( k, "0", label + " treated like array" );
		}
	};
	for ( i in result ) {
		label = i;
		jQuery.map( result[ i ], callback );
	}

	result = false;
	jQuery.map( { length: 0 }, function() {
		result = true;
	} );
	assert.ok( !result, "length: 0 plain object treated like array" );

	result = false;
	jQuery.map( document.getElementsByTagName( "asdf" ), function() {
		result = true;
	} );
	assert.ok( !result, "empty NodeList treated like array" );

	result = jQuery.map( Array( 4 ), function( v, k ) {
		return k % 2 ? k : [ k, k, k ];
	} );
	assert.equal( result.join( "" ), "00012223", "Array results flattened (#2616)" );

	result = jQuery.map( [ [ [ 1, 2 ], 3 ], 4 ], function( v, k ) {
		return v;
	} );
	assert.equal( result.length, 3, "Array flatten only one level down" );
	assert.ok( Array.isArray( result[ 0 ] ), "Array flatten only one level down" );

	// Support: IE 11+
	// IE doesn't have Array#flat so it'd fail the test.
	if ( !QUnit.isIE ) {
		result = jQuery.map( Array( 300000 ), function( v, k ) {
			return k;
		} );
		assert.equal( result.length, 300000, "Able to map 300000 records without any problems (#4320)" );
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );
diff --git a/a.js b/b.js
@@ -844,14 +854,14 @@ QUnit.test( "jQuery.merge()", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
	} else {
		assert.ok( "skip", "Array#flat isn't supported in IE" );
	}
} );

QUnit.test( "jQuery.merge()", function( assert ) {
	assert.expect( 10 );

	assert.deepEqual(
		jQuery.merge( [], [] ),
		[],
		"Empty arrays"
	);

	assert.deepEqual(
		jQuery.merge( [ 1 ], [ 2 ] ),
		[ 1, 2 ],
		"Basic (single-element)"
	);
	assert.deepEqual(
		jQuery.merge( [ 1, 2 ], [ 3, 4 ] ),
		[ 1, 2, 3, 4 ],
		"Basic (multiple-element)"
	);

	assert.deepEqual(
		jQuery.merge( [ 1, 2 ], [] ),
		[ 1, 2 ],
		"Second empty"
	);
	assert.deepEqual(
		jQuery.merge( [], [ 1, 2 ] ),
		[ 1, 2 ],
		"First empty"
	);

	// Fixed at [5998], #3641
	assert.deepEqual(
		jQuery.merge( [ -2, -1 ], [ 0, 1, 2 ] ),
		[ -2, -1, 0, 1, 2 ],
		"Second array including a zero (falsy)"
	);

	// After fixing #5527
	assert.deepEqual(
		jQuery.merge( [], [ null, undefined ] ),
		[ null, undefined ],
		"Second array including null and undefined values"
diff --git a/a.js b/b.js
@@ -995,7 +1005,7 @@ QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		[],
		"Satisfying elements absent, Array-like object used, and grep explicitly uninverted"
	);
} );

QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
	assert.expect( 28 );

	var empty, optionsWithLength, optionsWithDate, myKlass,
		customObject, optionsWithCustomObject, MyNumber, ret,
		nullUndef, target, recursive, obj,
		defaults, defaultsCopy, options1, options1Copy, options2, options2Copy, merged2,
		settings = { "xnumber1": 5, "xnumber2": 7, "xstring1": "peter", "xstring2": "pan" },
		options = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		optionsCopy = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		merged = { "xnumber1": 5, "xnumber2": 1, "xstring1": "peter", "xstring2": "x", "xxx": "newstring" },
		deep1 = { "foo": { "bar": true } },
		deep2 = { "foo": { "baz": true }, "foo2": document },
		deep2copy = { "foo": { "baz": true }, "foo2": document },
		deepmerged = { "foo": { "bar": true, "baz": true }, "foo2": document },
		arr = [ 1, 2, 3 ],
		nestedarray = { "arr": arr };

	jQuery.extend( settings, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( settings, null, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( true, deep1, deep2 );
	assert.deepEqual( deep1[ "foo" ], deepmerged[ "foo" ], "Check if foo: settings must be extended" );
	assert.deepEqual( deep2[ "foo" ], deep2copy[ "foo" ], "Check if not deep2: options must not be modified" );
	assert.equal( deep1[ "foo2" ], document, "Make sure that a deep clone was not attempted on the document" );

	assert.ok( jQuery.extend( true, {}, nestedarray )[ "arr" ] !== arr, "Deep extend of object must clone child array" );

	// #5991
	assert.ok( Array.isArray( jQuery.extend( true, { "arr": {} }, nestedarray )[ "arr" ] ), "Cloned array have to be an Array" );
	assert.ok( jQuery.isPlainObject( jQuery.extend( true, { "arr": arr }, { "arr": {} } )[ "arr" ] ), "Cloned object have to be an plain object" );

	empty = {};
diff --git a/a.js b/b.js
@@ -1043,13 +1053,13 @@ QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		[],
		"Satisfying elements absent, Array-like object used, and grep explicitly uninverted"
	);
} );

QUnit.test( "jQuery.extend(Object, Object)", function( assert ) {
	assert.expect( 28 );

	var empty, optionsWithLength, optionsWithDate, myKlass,
		customObject, optionsWithCustomObject, MyNumber, ret,
		nullUndef, target, recursive, obj,
		defaults, defaultsCopy, options1, options1Copy, options2, options2Copy, merged2,
		settings = { "xnumber1": 5, "xnumber2": 7, "xstring1": "peter", "xstring2": "pan" },
		options = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		optionsCopy = { "xnumber2": 1, "xstring2": "x", "xxx": "newstring" },
		merged = { "xnumber1": 5, "xnumber2": 1, "xstring1": "peter", "xstring2": "x", "xxx": "newstring" },
		deep1 = { "foo": { "bar": true } },
		deep2 = { "foo": { "baz": true }, "foo2": document },
		deep2copy = { "foo": { "baz": true }, "foo2": document },
		deepmerged = { "foo": { "bar": true, "baz": true }, "foo2": document },
		arr = [ 1, 2, 3 ],
		nestedarray = { "arr": arr };

	jQuery.extend( settings, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( settings, null, options );
	assert.deepEqual( settings, merged, "Check if extended: settings must be extended" );
	assert.deepEqual( options, optionsCopy, "Check if not modified: options must not be modified" );

	jQuery.extend( true, deep1, deep2 );
	assert.deepEqual( deep1[ "foo" ], deepmerged[ "foo" ], "Check if foo: settings must be extended" );
	assert.deepEqual( deep2[ "foo" ], deep2copy[ "foo" ], "Check if not deep2: options must not be modified" );
	assert.equal( deep1[ "foo2" ], document, "Make sure that a deep clone was not attempted on the document" );

	assert.ok( jQuery.extend( true, {}, nestedarray )[ "arr" ] !== arr, "Deep extend of object must clone child array" );

	// #5991
	assert.ok( Array.isArray( jQuery.extend( true, { "arr": {} }, nestedarray )[ "arr" ] ), "Cloned array have to be an Array" );
	assert.ok( jQuery.isPlainObject( jQuery.extend( true, { "arr": arr }, { "arr": {} } )[ "arr" ] ), "Cloned object have to be an plain object" );

	empty = {};
	optionsWithLength = { "foo": { "length": -1 } };
	jQuery.extend( true, empty, optionsWithLength );
	assert.deepEqual( empty[ "foo" ], optionsWithLength[ "foo" ], "The length property must copy correctly" );

	empty = {};
	optionsWithDate = { "foo": { "date": new Date() } };
	jQuery.extend( true, empty, optionsWithDate );
	assert.deepEqual( empty[ "foo" ], optionsWithDate[ "foo" ], "Dates copy correctly" );

	/** @constructor */
	myKlass = function() {};
	customObject = new myKlass();
	optionsWithCustomObject = { "foo": { "date": customObject } };
	empty = {};
	jQuery.extend( true, empty, optionsWithCustomObject );
	assert.ok( empty[ "foo" ] && empty[ "foo" ][ "date" ] === customObject, "Custom objects copy correctly (no methods)" );

	// Makes the class a little more realistic
	myKlass.prototype = { "someMethod": function() {} };
	empty = {};
	jQuery.extend( true, empty, optionsWithCustomObject );
	assert.ok( empty[ "foo" ] && empty[ "foo" ][ "date" ] === customObject, "Custom objects copy correctly" );

	MyNumber = Number;

	ret = jQuery.extend( true, { "foo": 4 }, { "foo": new MyNumber( 5 ) } );
	assert.ok( parseInt( ret.foo, 10 ) === 5, "Wrapped numbers copy correctly" );

	nullUndef = jQuery.extend( {}, options, { "xnumber2": null } );
	assert.ok( nullUndef[ "xnumber2" ] === null, "Check to make sure null values are copied" );

	nullUndef = jQuery.extend( {}, options, { "xnumber2": undefined } );
	assert.ok( nullUndef[ "xnumber2" ] === options[ "xnumber2" ], "Check to make sure undefined values are not copied" );

	nullUndef = jQuery.extend( {}, options, { "xnumber0": null } );
	assert.ok( nullUndef[ "xnumber0" ] === null, "Check to make sure null values are inserted" );

	target = {};
	recursive = { foo:target, bar:5 };
	jQuery.extend( true, target, recursive );
	assert.deepEqual( target, { bar:5 }, "Check to make sure a recursive obj doesn't go never-ending loop by not copying it over" );

	ret = jQuery.extend( true, { foo: [] }, { foo: [ 0 ] } ); // 1907
	assert.equal( ret.foo.length, 1, "Check to make sure a value with coercion 'false' copies over when necessary to fix #1907" );

	ret = jQuery.extend( true, { foo: "1,2,3" }, { foo: [ 1, 2, 3 ] } );
	assert.ok( typeof ret.foo !== "string", "Check to make sure values equal with coercion (but not actually equal) overwrite correctly" );

	ret = jQuery.extend( true, { foo:"bar" }, { foo:null } );
	assert.ok( typeof ret.foo !== "undefined", "Make sure a null value doesn't crash with deep extend, for #1908" );

	obj = { foo:null };
	jQuery.extend( true, obj, { foo:"notnull" } );
	assert.equal( obj.foo, "notnull", "Make sure a null value can be overwritten" );
diff --git a/a.js b/b.js
@@ -1355,7 +1365,7 @@ QUnit.test( "jQuery.parseHTML", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8

	// What about this ?
	// equal(true, jQuery.isEmptyObject(null), "isEmptyObject on null" );
} );

QUnit.test( "jQuery.parseHTML", function( assert ) {
	assert.expect( 23 );

	var html, nodes;

	assert.deepEqual( jQuery.parseHTML(), [], "Without arguments" );
	assert.deepEqual( jQuery.parseHTML( undefined ), [], "Undefined" );
	assert.deepEqual( jQuery.parseHTML( null ), [], "Null" );
	assert.deepEqual( jQuery.parseHTML( false ), [], "Boolean false" );
	assert.deepEqual( jQuery.parseHTML( 0 ), [], "Zero" );
	assert.deepEqual( jQuery.parseHTML( true ), [], "Boolean true" );
	assert.deepEqual( jQuery.parseHTML( 42 ), [], "Positive number" );
	assert.deepEqual( jQuery.parseHTML( "" ), [], "Empty string" );
	assert.throws( function() {
		jQuery.parseHTML( "<div></div>", document.getElementById( "form" ) );
	}, "Passing an element as the context raises an exception (context should be a document)" );

	nodes = jQuery.parseHTML( jQuery( "body" )[ 0 ].innerHTML );
	assert.ok( nodes.length > 4, "Parse a large html string" );
	assert.ok( Array.isArray( nodes ), "parseHTML returns an array rather than a nodelist" );

	html = "<script>undefined()</script>";
	assert.equal( jQuery.parseHTML( html ).length, 0, "Ignore scripts by default" );
	assert.equal( jQuery.parseHTML( html, true )[ 0 ].nodeName.toLowerCase(), "script", "Preserve scripts when requested" );

	html += "<div></div>";
	assert.equal( jQuery.parseHTML( html )[ 0 ].nodeName.toLowerCase(), "div", "Preserve non-script nodes" );
	assert.equal( jQuery.parseHTML( html, true )[ 0 ].nodeName.toLowerCase(), "script", "Preserve script position" );

	assert.equal( jQuery.parseHTML( "text" )[ 0 ].nodeType, 3, "Parsing text returns a text node" );
	assert.equal( jQuery.parseHTML( "\t<div></div>" )[ 0 ].nodeValue, "\t", "Preserve leading whitespace" );

	assert.equal( jQuery.parseHTML( " <div></div> " )[ 0 ].nodeType, 3, "Leading spaces are treated as text nodes (#11290)" );

	html = jQuery.parseHTML( "<div>test div</div>" );

	assert.equal( html[ 0 ].parentNode.nodeType, 11, "parentNode should be documentFragment" );
diff --git a/a.js b/b.js
@@ -1408,9 +1418,9 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid xml not detected" );
	} catch ( e ) {
		assert.strictEqual( e.message, "Invalid XML: <p>Not a <<b>well-formed</b> xml string</p>", "invalid xml detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
diff --git a/a.js b/b.js
@@ -1426,8 +1436,37 @@ QUnit.test( "jQuery.parseXML", function( assert ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
		assert.equal( window.parseHTMLError, false, "onerror eventhandler has not been called." );
		done();
	}, 2000 );
} );

QUnit.test( "jQuery.parseXML", function( assert ) {
	assert.expect( 8 );

	var xml, tmp;
	try {
		xml = jQuery.parseXML( "<p>A <b>well-formed</b> xml string</p>" );
		tmp = xml.getElementsByTagName( "p" )[ 0 ];
		assert.ok( !!tmp, "<p> present in document" );
		tmp = tmp.getElementsByTagName( "b" )[ 0 ];
		assert.ok( !!tmp, "<b> present in document" );
		assert.strictEqual( tmp.childNodes[ 0 ].nodeValue, "well-formed", "<b> text is as expected" );
	} catch ( e ) {
		assert.strictEqual( e, undefined, "unexpected error" );
	}
	try {
		xml = jQuery.parseXML( "<p>Not a <<b>well-formed</b> xml string</p>" );
		assert.ok( false, "invalid xml not detected" );
	} catch ( e ) {
		assert.strictEqual( e.message, "Invalid XML: <p>Not a <<b>well-formed</b> xml string</p>", "invalid xml detected" );
	}
	try {
		xml = jQuery.parseXML( "" );
		assert.strictEqual( xml, null, "empty string => null document" );
		xml = jQuery.parseXML();
		assert.strictEqual( xml, null, "undefined string => null document" );
		xml = jQuery.parseXML( null );
		assert.strictEqual( xml, null, "null string => null document" );
		xml = jQuery.parseXML( true );
		assert.strictEqual( xml, null, "non-string => null document" );
	} catch ( e ) {
		assert.ok( false, "empty input throws exception" );
	}
} );

testIframe(
	"document ready when jQuery loaded asynchronously (#13655)",
	"core/dynamic_ready.html",
	function( assert, jQuery, window, document, ready ) {
		assert.expect( 1 );
		assert.equal( true, ready, "document ready correctly fired when jQuery is loaded after DOMContentLoaded" );
diff --git a/a.js b/b.js
@@ -1436,7 +1475,7 @@ function( assert, jQuery, window, document, ready ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
} );

testIframe(
	"document ready when jQuery loaded asynchronously (#13655)",
	"core/dynamic_ready.html",
	function( assert, jQuery, window, document, ready ) {
		assert.expect( 1 );
		assert.equal( true, ready, "document ready correctly fired when jQuery is loaded after DOMContentLoaded" );
	}
);

testIframe(
	"Tolerating alias-masked DOM properties (#14074)",
	"core/aliased.html",
	function( assert, jQuery, window, document, errors ) {
		assert.expect( 1 );
		assert.deepEqual( errors, [], "jQuery loaded" );
diff --git a/a.js b/b.js
@@ -1445,7 +1484,7 @@ function( assert, jQuery, window, document, errors ) {
A blob:e24966551caf382e5792e1f766993bc99ef077c8
);

testIframe(
	"Tolerating alias-masked DOM properties (#14074)",
	"core/aliased.html",
	function( assert, jQuery, window, document, errors ) {
		assert.expect( 1 );
		assert.deepEqual( errors, [], "jQuery loaded" );
	}
);

testIframe(
	"Don't call window.onready (#14802)",
	"core/onready.html",
	function( assert, jQuery, window, document, error ) {
		assert.expect( 1 );
		assert.equal( error, false, "no call to user-defined onready" );
diff --git a/a.js b/b.js
@@ -369,15 +369,15 @@ handlers: function( event, handlers ) {
A blob:4418fbbbf809eeab906938eec3ec77f5fae4e085
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: Firefox <=42 - 66+
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11+
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
diff --git a/a.js b/b.js
@@ -746,6 +746,12 @@ stopImmediatePropagation: function() {
A blob:4418fbbbf809eeab906938eec3ec77f5fae4e085

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

diff --git a/a.js b/b.js
@@ -8,7 +8,7 @@ beforeEach: function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
QUnit.module( "event", {
	beforeEach: function() {
		document.body.focus();
	},
	afterEach: moduleTeardown
} );

QUnit.test( "null or undefined handler", function( assert ) {
	assert.expect( 4 );

	// Supports Fixes bug #7229
	try {
		jQuery( "#firstp" ).on( "click", null );
		assert.ok( true, "Passing a null handler will not throw an exception" );
	} catch ( e ) {}
diff --git a/a.js b/b.js
@@ -484,7 +484,7 @@ 		neverCallMe = function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
QUnit.test( "trigger() works with events that were previously stopped", function( assert ) {
	assert.expect( 0 );

	var $button = jQuery( "#button" ),
		$parent = $button.parent(),
		neverCallMe = function() {
			assert.ok( false, "propagation should have been stopped" );
		};

	$parent[ 0 ].addEventListener( "click", neverCallMe );
	$button.on( "click", neverCallMe );

	var clickEvent =  jQuery.Event( "click" );
	clickEvent.stopPropagation();
	$button.trigger( clickEvent );

	$parent[ 0 ].removeEventListener( "click", neverCallMe );
	$button.off( "click", neverCallMe );
} );


QUnit.test( "on(), iframes", function( assert ) {
	assert.expect( 1 );

	// events don't work with iframes, see #939 - this test fails in IE because of contentDocument
	var doc = jQuery( "#loadediframe" ).contents();

	jQuery( "div", doc ).on( "click", function() {
		assert.ok( true, "Binding to element inside iframe" );
diff --git a/a.js b/b.js
@@ -552,7 +552,7 @@ jQuery( "#nonnodes" ).contents().on( "tester", function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157

	// Try triggering the custom event (0)
	firstp.trigger( "custom" );

	// using contents will get comments regular, text, and comment nodes
	jQuery( "#nonnodes" ).contents().on( "tester", function() {
		assert.equal( this.nodeType, 1, "Check node,textnode,comment on just does real nodes" );
	} ).trigger( "tester" );

	// Make sure events stick with appendTo'd elements (which are cloned) #2027
	jQuery( "<a href='#fail' class='test'>test</a>" ).on( "click", function() { return false; } ).appendTo( "#qunit-fixture" );
	assert.ok( jQuery( "a.test" ).eq( 0 ).triggerHandler( "click" ) === false, "Handler is bound to appendTo'd elements" );
} );

diff --git a/a.js b/b.js
@@ -589,7 +589,7 @@ jQuery( "#firstp" ).on( "click.test.abc", function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157

	jQuery( "#firstp" ).on( "click.test", function() {
		check( "click.test", "Normal click triggered" );
	} );

	jQuery( "#firstp" ).on( "click.test.abc", function() {
		check( "click.test.abc", "Namespaced click triggered" );
	} );

	// Those would not trigger/off (#5303)
	jQuery( "#firstp" ).trigger( "click.a.test" );
	jQuery( "#firstp" ).off( "click.a.test" );

	// Trigger both bound fn (1)
diff --git a/a.js b/b.js
@@ -812,7 +812,7 @@ QUnit.test( "off(type)", function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	assert.equal( obj && obj[ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ][ "events" ], undefined, "Make sure events object is removed" );
} );

QUnit.test( "off(type)", function( assert ) {
	assert.expect( 1 );

	var message, func,
		$elem = jQuery( "#firstp" );

	function error() {
		assert.ok( false, message );
	}

	message = "unbind passing function";
	$elem.on( "error1", error ).off( "error1", error ).triggerHandler( "error1" );

	message = "unbind all from event";
	$elem.on( "error1", error ).off( "error1" ).triggerHandler( "error1" );

	message = "unbind all";
	$elem.on( "error1", error ).off().triggerHandler( "error1" );

	message = "unbind many with function";
	$elem.on( "error1 error2", error )
		.off( "error1 error2", error )
		.trigger( "error1" ).triggerHandler( "error2" );

	message = "unbind many"; // #3538
	$elem.on( "error1 error2", error )
		.off( "error1 error2" )
		.trigger( "error1" ).triggerHandler( "error2" );

diff --git a/a.js b/b.js
@@ -1041,7 +1041,7 @@ 	$elem[ 0 ].click = function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	// Triggers handlers and native
	// Trigger 5
	$elem.on( "click", handler ).trigger( "click", [ 1, "2", "abc" ] );

	// Simulate a "native" click
	$elem[ 0 ].click = function() {
		assert.ok( false, "Native call was triggered" );
	};

	// Trigger only the handlers (no native)
	// Triggers 5
	assert.equal( $elem.triggerHandler( "click", [ 1, "2", "abc" ] ), "test", "Verify handler response" );

	pass = true;
	try {
		elem2 = jQuery( "#form input" ).eq( 0 );
		elem2.get( 0 ).style.display = "none";
		elem2.trigger( "focus" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger focus on hidden element" );

	pass = true;
	try {
		jQuery( "#qunit-fixture table" ).eq( 0 ).on( "test:test", function() {} ).trigger( "test:test" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger on a table with a colon in the even type, see #3533" );

	form = jQuery( "<form action=''></form>" ).appendTo( "body" );

	// Make sure it can be prevented locally
diff --git a/a.js b/b.js
@@ -1069,7 +1069,7 @@ jQuery( document ).on( "submit", function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	// Trigger 1
	form.trigger( "submit" );

	form.off( "submit" );

	jQuery( document ).on( "submit", function() {
		assert.ok( true, "Make sure bubble works up to document." );
		return false;
	} );

	// Trigger 1
	form.trigger( "submit" );

	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
diff --git a/a.js b/b.js
@@ -1105,7 +1105,7 @@ QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
		$fixture = jQuery( "#qunit-fixture" ),
		$wrapperDiv = jQuery( "<div></div>" ).appendTo( $fixture );

	function noSubmit( e ) {
		e.preventDefault();
	}
	function delegatedSubmit() {
		assert.ok( true, "Make sure submit event bubbles up." );
		return false;
	}

	// Attach a delegated submit handler to the parent element
	$fixture.on( "submit", "form", delegatedSubmit );

	// Trigger form submission to introduce the _submit_attached property
	$testForm.on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Copy the form via .clone() and .html()
	$formByClone = $testForm.clone( true, true ).removeAttr( "id" );
	$formByHTML = jQuery( jQuery.parseHTML( $fixture.html() ) ).filter( "#testForm" ).removeAttr( "id" );
	$wrapperDiv.append( $formByClone, $formByHTML );

	// Check submit bubbling on the copied forms
	$wrapperDiv.find( "form" ).on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "submit", "form", delegatedSubmit );
	$testForm.off( "submit", noSubmit );
} );

QUnit.test( "change event bubbles on copied forms (#11796)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$form = jQuery( "#form" ),
diff --git a/a.js b/b.js
@@ -1227,7 +1227,7 @@ QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "change", "form", delegatedChange );
} );

QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
	assert.expect( 28 );

	var event,
		$parent = jQuery( "<div id='par'></div>" ).appendTo( "body" ),
		$child = jQuery( "<p id='child'>foo</p>" ).appendTo( $parent );

	$parent.get( 0 ).style.display = "none";

	event = jQuery.Event( "noNew" );
	assert.ok( event !== window, "Instantiate jQuery.Event without the 'new' keyword" );
	assert.equal( event.type, "noNew", "Verify its type" );

	assert.equal( event.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
	assert.equal( event.isPropagationStopped(), false, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

	event.preventDefault();
	assert.equal( event.isDefaultPrevented(), true, "Verify isDefaultPrevented" );
	event.stopPropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );

	event.isPropagationStopped = function() { return false; };
	event.stopImmediatePropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), true, "Verify isPropagationStopped" );

	$parent.on( "foo", function( e ) {

		// Tries bubbling
		assert.equal( e.type, "foo", "Verify event type when passed passing an event object" );
		assert.equal( e.target.id, "child", "Verify event.target when passed passing an event object" );
		assert.equal( e.currentTarget.id, "par", "Verify event.currentTarget when passed passing an event object" );
		assert.equal( e.secret, "boo!", "Verify event object's custom attribute when passed passing an event object" );
	} );

	// test with an event object
	event = new jQuery.Event( "foo" );
	event.secret = "boo!";
	$child.trigger( event );

	// test with a literal object
	$child.trigger( { "type": "foo", "secret": "boo!" } );

	$parent.off();

	function error() {
		assert.ok( false, "This assertion shouldn't be reached" );
	}

	$parent.on( "foo", error );

	$child.on( "foo", function( e, a, b, c ) {
		assert.equal( arguments.length, 4, "Check arguments length" );
		assert.equal( a, 1, "Check first custom argument" );
		assert.equal( b, 2, "Check second custom argument" );
		assert.equal( c, 3, "Check third custom argument" );

		assert.equal( e.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
		assert.equal( e.isPropagationStopped(), false, "Verify isPropagationStopped" );
		assert.equal( e.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

		// Skips both errors
		e.stopImmediatePropagation();

		return "result";
	} );

	// We should add this back in when we want to test the order
	// in which event handlers are iterated.
	//$child.on("foo", error );

	event = new jQuery.Event( "foo" );
	$child.trigger( event, [ 1, 2, 3 ] ).off();
	assert.equal( event.result, "result", "Check event.result attribute" );

	// Will error if it bubbles
	$child.triggerHandler( "foo" );

	$child.off();
	$parent.off().remove();

	// Ensure triggerHandler doesn't molest its event object (#xxx)
	event = jQuery.Event( "zowie" );
	jQuery( document ).triggerHandler( event );
	assert.equal( event.type, "zowie", "Verify its type" );
	assert.equal( event.isPropagationStopped(), false, "propagation not stopped" );
	assert.equal( event.isDefaultPrevented(), false, "default not prevented" );
} );

QUnit.test( ".trigger() bubbling on disconnected elements (#10489)", function( assert ) {
	assert.expect( 2 );

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
diff --git a/a.js b/b.js
@@ -1251,7 +1251,7 @@ jQuery( "<div><p>hi</p></div>" )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
	} );

	jQuery( "<div><p>hi</p></div>" )
		.on( "click", function() {
			assert.ok( true, "click fired on div" );
		} )
		.find( "p" )
			.on( "click", function() {
				assert.ok( true, "click fired on p" );
			} )
			.trigger( "click" )
			.off( "click" )
		.end()
		.off( "click" )
		.remove();

	jQuery( window ).off( "click" );
} );

QUnit.test( ".trigger() doesn't bubble load event (#10717)", function( assert ) {
	assert.expect( 1 );

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
diff --git a/a.js b/b.js
@@ -1269,7 +1269,7 @@ jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
	} );

	jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
		.appendTo( "body" )
		.on( "load", function() {
			assert.ok( true, "load fired on img" );
		} )
		.trigger( "load" )
		.remove();

	jQuery( window ).off( "load" );
} );

QUnit.test( "Delegated events in SVG (#10791; #13180)", function( assert ) {
	assert.expect( 2 );

	var useElem, e,
		svg = jQuery(
diff --git a/a.js b/b.js
@@ -1295,7 +1295,7 @@ jQuery( "#qunit-fixture" )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
			"<rect id='svg-by-id' x='10' y='20' width='100' height='60' r='10' rx='10' ry='10'></rect>" +
			"<use id='use' xlink:href='#ref'></use>" +
			"</svg>"
		);

	jQuery( "#qunit-fixture" )
		.append( svg )
		.on( "click", "#svg-by-id", function() {
			assert.ok( true, "delegated id selector" );
		} )
		.on( "click", "[class~='svg-by-class']", function() {
			assert.ok( true, "delegated class selector" );
		} )
		.find( "#svg-by-id, [class~='svg-by-class']" )
			.trigger( "click" )
		.end();

	// Fire a native click on an SVGElementInstance (the instance tree of an SVG <use>)
	// to confirm that it doesn't break our event delegation handling (#13180)
	useElem = svg.find( "#use" )[ 0 ];
	if ( document.createEvent && useElem && useElem.instanceRoot ) {
		e = document.createEvent( "MouseEvents" );
		e.initEvent( "click", true, true );
diff --git a/a.js b/b.js
@@ -1321,7 +1321,7 @@ QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( ass
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	}

	jQuery( "#qunit-fixture" ).off( "click" );
} );

QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( assert ) {
	assert.expect( 3 );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", ":not", function() {} );
	}, "malformed selector throws on attach" );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", "nonexistent:not", function() {} );
	}, "short-circuitable malformed selector throws on attach" );

	jQuery( "#foo > :first-child" ).trigger( "click" );
	assert.ok( true, "malformed selector does not throw on event" );
} );

QUnit.test( "Delegated events in forms (#10844; #11145; #8165; #11382, #11764)", function( assert ) {
	assert.expect( 5 );

	// Alias names like "id" cause havoc
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ jQuery( "body" )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form.append( "<input type='text' name='disabled' value='differently abled' />" );
	jQuery( "body" )
		.on( "submit", "#myform", function() {
			assert.ok( true, "delegated id selector with aliased disabled" );
		} )
		.find( "#myform" )
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form
		.append( "<button id='nestyDisabledBtn'><span>Zing</span></button>" )
		.on( "click", "#nestyDisabledBtn", function() {
			assert.ok( true, "click on enabled/disabled button with nesty elements" );
		} )
		.on( "mouseover", "#nestyDisabledBtn", function() {
			assert.ok( true, "mouse on enabled/disabled button with nesty elements" );
		} )
		.find( "span" )
			.trigger( "click" )		// yep
			.trigger( "mouseover" )	// yep
		.end()
		.find( "#nestyDisabledBtn" ).prop( "disabled", true ).end()
		.find( "span" )
			.trigger( "click" )		// nope
			.trigger( "mouseover" )	// yep
		.end()
		.off( "click" );

	form.remove();
} );

QUnit.test( "Submit event can be stopped (#11049)", function( assert ) {
	assert.expect( 1 );

	// Since we manually bubble in IE, make sure inner handlers get a chance to cancel
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1450,7 +1450,7 @@ 			handler = function( event ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
QUnit.test( "jQuery.Event( type, props )", function( assert ) {

	assert.expect( 6 );

	var event = jQuery.Event( "keydown", { keyCode: 64 } ),
			handler = function( event ) {
				assert.ok( "keyCode" in event, "Special property 'keyCode' exists" );
				assert.equal( event.keyCode, 64, "event.keyCode has explicit value '64'" );
			};

	// Supports jQuery.Event implementation
	assert.equal( event.type, "keydown", "Verify type" );

	// ensure "type" in props won't clobber the one set by constructor
	assert.equal( jQuery.inArray( "type", jQuery.event.props ), -1, "'type' property not in props (#10375)" );

	assert.ok( "keyCode" in event, "Special 'keyCode' property exists" );

	assert.strictEqual( jQuery.isPlainObject( event ), false, "Instances of $.Event should not be identified as a plain object." );
diff --git a/a.js b/b.js
@@ -1844,7 +1844,7 @@ function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
diff --git a/a.js b/b.js
@@ -1859,7 +1859,7 @@ function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
diff --git a/a.js b/b.js
@@ -1879,7 +1879,7 @@ function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
			.find( "#ul0" )
				.on( "click", "li:first>a", function() {
					assert.ok( this.id === "a0_0", "first li under #u10 was clicked" );
				} )
			.end()
			.find( "a" ).trigger( "click" ).end()
			.find( "#ul0" ).off();
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	markup.remove();
} );

QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

diff --git a/a.js b/b.js
@@ -1893,7 +1893,7 @@ jQuery( "#foo" ).on( "click", "toString", function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

	jQuery( "#foo" ).on( "click", "toString", function() {
		matched++;
	} );

	jQuery( "#anchor2" ).trigger( "click" );

	assert.equal( matched, 0, "Nothing matched 'toString'" );
} );

QUnit.test( "delegated event with intermediate DOM manipulation (#13208)", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" ).on( "click", "[id=sap]", function() {} );
	jQuery( "#sap" ).on( "click", "[id=anchor2]", function() {
diff --git a/a.js b/b.js
@@ -2187,7 +2187,7 @@ jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		order = 0;

	// focus the element so DOM focus won't fire
	input[ 0 ].focus();

	jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
		assert.equal( 1, order++, "focusin on the body second" );
	} );

	input.on( "focusin.focusinBubblesTest", function() {
		assert.equal( 0, order++, "focusin on the element first" );
	} );

// Removed since DOM focus is unreliable on test swarm
	// DOM focus method
//	input[0].focus();

	// To make the next focus test work, we need to take focus off the input.
	// This will fire another focusin event, so set order to reflect that.
//	order = 1;
//	jQuery("#text1")[0].focus();

	// jQuery trigger, which calls DOM focus
	order = 0;
	input.trigger( "focus" );

	input.remove();
	jQuery( "body" ).off( "focusin.focusinBubblesTest" );
} );

QUnit.test( "custom events with colons (#3533, #8272)", function( assert ) {
	assert.expect( 1 );

	var tab = jQuery( "<table><tr><td>trigger</td></tr></table>" ).appendTo( "body" );
	try {
diff --git a/a.js b/b.js
@@ -2370,7 +2370,7 @@ jQuery( "<p>Gut Feeling</p>" )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		.off( ".Devo" )
		.trigger( "gutfeeling" )
		.remove();

	// Ensure .one() events are removed after their maiden voyage
	jQuery( "<p>Gut Feeling</p>" )
		.one( "gutfeeling", jQuery.noop )
		.trigger( "gutfeeling" )	// This one should
		.trigger( "gutfeeling" )	// This one should not
		.remove();

	delete jQuery.event.special[ "gutfeeling" ];
} );

QUnit.test( ".on and .off, selective mixed removal (#10705)", function( assert ) {
	assert.expect( 7 );

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
diff --git a/a.js b/b.js
@@ -2392,7 +2392,7 @@ jQuery( "<p>Strange Pursuit</p>" )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
	};

	jQuery( "<p>Strange Pursuit</p>" )
		.on( "click", timingx )
		.on( "click.duty", timingx )
		.on( "click.now", timingx )
		.on( "devo", timingx )
		.on( "future", timingx )
		.trigger( "click" )		// 3
		.trigger( "devo" )		// 1
		.off( ".duty devo " )	// trailing space
		.trigger( "future" )	// 1
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
diff --git a/a.js b/b.js
@@ -2408,7 +2408,7 @@ QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
		data = "bar",
		map = {
			"foo": function( event ) {
				assert.equal( event.data, "bar", "event.data correctly relayed with null selector" );
				$p.remove();
			}
		};

	$p.on( map, null, data ).trigger( "foo" );
} );

QUnit.test( "clone() delegated events (#11076)", function( assert ) {
	assert.expect( 3 );

	var counter = { "center": 0, "fold": 0, "centerfold": 0 },
		clicked = function() {
diff --git a/a.js b/b.js
@@ -2745,7 +2745,7 @@ QUnit.test( "trigger click on checkbox, fires change event", function( assert )
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	$fixture.remove();

	jQuery.removeEvent = originRemoveEvent;
} );

QUnit.test( "trigger click on checkbox, fires change event", function( assert ) {
	assert.expect( 1 );

	var check = jQuery( "#check2" );
	var done = assert.async();

	check.on( "change", function() {

		// get it?
		check.off( "change" );
		assert.ok( true, "Change event fired as a result of triggered click" );
		done();
	} ).trigger( "click" );
} );

QUnit.test( "Namespace preserved when passed an Event (#12739)", function( assert ) {
	assert.expect( 4 );

	var markup = jQuery(
			"<div id='parent'><div id='child'></div></div>"
diff --git a/a.js b/b.js
@@ -2833,7 +2833,7 @@ QUnit.test( "make sure events cloned correctly", function( assert ) {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	markup.remove();

	assert.equal( triggered, 3, "foo.bar triggered" );
} );

QUnit.test( "make sure events cloned correctly", function( assert ) {
	assert.expect( 18 );

	var clone,
		fixture = jQuery( "#qunit-fixture" ),
		checkbox = jQuery( "#check1" ),
		p = jQuery( "#firstp" );

	fixture.on( "click change", function( event, result ) {
		assert.ok( result,  event.type + " on original element is fired" );

	} ).on( "click", "#firstp", function( event, result ) {
		assert.ok( result, "Click on original child element though delegation is fired" );

	} ).on( "change", "#check1", function( event, result ) {
		assert.ok( result, "Change on original child element though delegation is fired" );
	} );

	p.on( "click", function() {
		assert.ok( true, "Click on original child element is fired" );
	} );

	checkbox.on( "change", function() {
		assert.ok( true, "Change on original child element is fired" );
	} );

	fixture.clone().trigger( "click" ).trigger( "change" ); // 0 events should be fired

	clone = fixture.clone( true );

	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone = fixture.clone( true, true );
	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire

	fixture.off();
	p.off();
	checkbox.off();

	p.trigger( "click" ); // 0 should be fired
	checkbox.trigger( "change" ); // 0 should be fired

	clone.find( "p" ).eq( 0 ).trigger( "click", true );  // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};
diff --git a/a.js b/b.js
@@ -2848,7 +2848,7 @@ QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#1336
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};

	try {
		jQuery( "<p>" ).trigger( "foo.bar" );
	} catch ( e ) {
		errored = true;
	}
	assert.equal( errored, false, "trigger() did not throw exception" );
	delete String.prototype.namespace;
} );

QUnit.test( "Inline event result is returned (#13993)", function( assert ) {
	assert.expect( 1 );

	var result = jQuery( "<p onclick='return 42'>hello</p>" ).triggerHandler( "click" );

diff --git a/a.js b/b.js
@@ -3137,7 +3137,7 @@ setTimeout( function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
		input[ 0 ].focus();

		// then lose it
		inputExternal[ 0 ].focus();

		setTimeout( function() {

			// DOM focus is unreliable in TestSwarm
			if ( QUnit.isSwarm && !focus ) {
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
			}

			// cleanup
			parent.off();
			input.off();

			done();
		}, 50 );
	}, 50 );
} );

QUnit.test( "focus-blur order (#12868)", function( assert ) {
	assert.expect( 5 );

	var order,
		$text = jQuery( "#text1" ),
diff --git a/a.js b/b.js
@@ -3291,6 +3291,56 @@ setTimeout( function() {
A blob:90318f8fefb3c8ad7884374802aa2de7cda27157
	checkbox.trigger( "focus", data );
	setTimeout( function() {
		assert.strictEqual( document.activeElement, checkbox[ 0 ],
			"element focused after focus event (default action)" );
		checkbox.trigger( "blur", data );
		setTimeout( function() {
			assert.notEqual( document.activeElement, checkbox[ 0 ],
				"element not focused after blur event (default action)" );
			done();
		}, 50 );
	}, 50 );
} );

// TODO replace with an adaptation of
// https://github.com/jquery/jquery/pull/1367/files#diff-a215316abbaabdf71857809e8673ea28R2464
( function() {
	supportjQuery.each(
diff --git a/a.js b/b.js
@@ -369,15 +369,15 @@ handlers: function( event, handlers ) {
A blob:b8c5e96fe3da2ab1ef2fbec82b32c59829b66408
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: Firefox <=42 - 66+
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11+
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
diff --git a/a.js b/b.js
@@ -558,7 +558,13 @@ function leverageNative( el, type, expectSync ) {
A blob:b8c5e96fe3da2ab1ef2fbec82b32c59829b66408

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
diff --git a/a.js b/b.js
@@ -740,6 +746,12 @@ stopImmediatePropagation: function() {
A blob:b8c5e96fe3da2ab1ef2fbec82b32c59829b66408

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

diff --git a/a.js b/b.js
@@ -8,7 +8,7 @@ beforeEach: function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
QUnit.module( "event", {
	beforeEach: function() {
		document.body.focus();
	},
	afterEach: moduleTeardown
} );

QUnit.test( "null or undefined handler", function( assert ) {
	assert.expect( 4 );

	// Supports Fixes bug #7229
	try {
		jQuery( "#firstp" ).on( "click", null );
		assert.ok( true, "Passing a null handler will not throw an exception" );
	} catch ( e ) {}
diff --git a/a.js b/b.js
@@ -484,7 +484,7 @@ 		neverCallMe = function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
QUnit.test( "trigger() works with events that were previously stopped", function( assert ) {
	assert.expect( 0 );

	var $button = jQuery( "#button" ),
		$parent = $button.parent(),
		neverCallMe = function() {
			assert.ok( false, "propagation should have been stopped" );
		};

	$parent[ 0 ].addEventListener( "click", neverCallMe );
	$button.on( "click", neverCallMe );

	var clickEvent =  jQuery.Event( "click" );
	clickEvent.stopPropagation();
	$button.trigger( clickEvent );

	$parent[ 0 ].removeEventListener( "click", neverCallMe );
	$button.off( "click", neverCallMe );
} );


QUnit.test( "on(), iframes", function( assert ) {
	assert.expect( 1 );

	// events don't work with iframes, see #939 - this test fails in IE because of contentDocument
	var doc = jQuery( "#loadediframe" ).contents();

	jQuery( "div", doc ).on( "click", function() {
		assert.ok( true, "Binding to element inside iframe" );
diff --git a/a.js b/b.js
@@ -552,7 +552,7 @@ jQuery( "#nonnodes" ).contents().on( "tester", function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849

	// Try triggering the custom event (0)
	firstp.trigger( "custom" );

	// using contents will get comments regular, text, and comment nodes
	jQuery( "#nonnodes" ).contents().on( "tester", function() {
		assert.equal( this.nodeType, 1, "Check node,textnode,comment on just does real nodes" );
	} ).trigger( "tester" );

	// Make sure events stick with appendTo'd elements (which are cloned) #2027
	jQuery( "<a href='#fail' class='test'>test</a>" ).on( "click", function() { return false; } ).appendTo( "#qunit-fixture" );
	assert.ok( jQuery( "a.test" ).eq( 0 ).triggerHandler( "click" ) === false, "Handler is bound to appendTo'd elements" );
} );

diff --git a/a.js b/b.js
@@ -589,7 +589,7 @@ jQuery( "#firstp" ).on( "click.test.abc", function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849

	jQuery( "#firstp" ).on( "click.test", function() {
		check( "click.test", "Normal click triggered" );
	} );

	jQuery( "#firstp" ).on( "click.test.abc", function() {
		check( "click.test.abc", "Namespaced click triggered" );
	} );

	// Those would not trigger/off (#5303)
	jQuery( "#firstp" ).trigger( "click.a.test" );
	jQuery( "#firstp" ).off( "click.a.test" );

	// Trigger both bound fn (1)
diff --git a/a.js b/b.js
@@ -812,7 +812,7 @@ QUnit.test( "off(type)", function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
	assert.equal( obj && obj[ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ] &&
			obj[ jQuery.expando ][ jQuery.expando ][ "events" ], undefined, "Make sure events object is removed" );
} );

QUnit.test( "off(type)", function( assert ) {
	assert.expect( 1 );

	var message, func,
		$elem = jQuery( "#firstp" );

	function error() {
		assert.ok( false, message );
	}

	message = "unbind passing function";
	$elem.on( "error1", error ).off( "error1", error ).triggerHandler( "error1" );

	message = "unbind all from event";
	$elem.on( "error1", error ).off( "error1" ).triggerHandler( "error1" );

	message = "unbind all";
	$elem.on( "error1", error ).off().triggerHandler( "error1" );

	message = "unbind many with function";
	$elem.on( "error1 error2", error )
		.off( "error1 error2", error )
		.trigger( "error1" ).triggerHandler( "error2" );

	message = "unbind many"; // #3538
	$elem.on( "error1 error2", error )
		.off( "error1 error2" )
		.trigger( "error1" ).triggerHandler( "error2" );

diff --git a/a.js b/b.js
@@ -1041,7 +1041,7 @@ 	$elem[ 0 ].click = function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
	// Triggers handlers and native
	// Trigger 5
	$elem.on( "click", handler ).trigger( "click", [ 1, "2", "abc" ] );

	// Simulate a "native" click
	$elem[ 0 ].click = function() {
		assert.ok( false, "Native call was triggered" );
	};

	// Trigger only the handlers (no native)
	// Triggers 5
	assert.equal( $elem.triggerHandler( "click", [ 1, "2", "abc" ] ), "test", "Verify handler response" );

	pass = true;
	try {
		elem2 = jQuery( "#form input" ).eq( 0 );
		elem2.get( 0 ).style.display = "none";
		elem2.trigger( "focus" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger focus on hidden element" );

	pass = true;
	try {
		jQuery( "#qunit-fixture table" ).eq( 0 ).on( "test:test", function() {} ).trigger( "test:test" );
	} catch ( e ) {
		pass = false;
	}
	assert.ok( pass, "Trigger on a table with a colon in the even type, see #3533" );

	form = jQuery( "<form action=''></form>" ).appendTo( "body" );

	// Make sure it can be prevented locally
diff --git a/a.js b/b.js
@@ -1069,7 +1069,7 @@ jQuery( document ).on( "submit", function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
	// Trigger 1
	form.trigger( "submit" );

	form.off( "submit" );

	jQuery( document ).on( "submit", function() {
		assert.ok( true, "Make sure bubble works up to document." );
		return false;
	} );

	// Trigger 1
	form.trigger( "submit" );

	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
diff --git a/a.js b/b.js
@@ -1105,7 +1105,7 @@ QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert )
A blob:771283c2f63293c53c3866515ff5c842664bd849
	jQuery( document ).off( "submit" );

	form.remove();
} );

QUnit.test( "submit event bubbles on copied forms (#11649)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$testForm = jQuery( "#testForm" ),
		$fixture = jQuery( "#qunit-fixture" ),
		$wrapperDiv = jQuery( "<div></div>" ).appendTo( $fixture );

	function noSubmit( e ) {
		e.preventDefault();
	}
	function delegatedSubmit() {
		assert.ok( true, "Make sure submit event bubbles up." );
		return false;
	}

	// Attach a delegated submit handler to the parent element
	$fixture.on( "submit", "form", delegatedSubmit );

	// Trigger form submission to introduce the _submit_attached property
	$testForm.on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Copy the form via .clone() and .html()
	$formByClone = $testForm.clone( true, true ).removeAttr( "id" );
	$formByHTML = jQuery( jQuery.parseHTML( $fixture.html() ) ).filter( "#testForm" ).removeAttr( "id" );
	$wrapperDiv.append( $formByClone, $formByHTML );

	// Check submit bubbling on the copied forms
	$wrapperDiv.find( "form" ).on( "submit", noSubmit ).find( "input[name=sub1]" ).trigger( "click" );

	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "submit", "form", delegatedSubmit );
	$testForm.off( "submit", noSubmit );
} );

QUnit.test( "change event bubbles on copied forms (#11796)", function( assert ) {
	assert.expect( 3 );

	var $formByClone, $formByHTML,
		$form = jQuery( "#form" ),
diff --git a/a.js b/b.js
@@ -1227,7 +1227,7 @@ QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
	// Clean up
	$wrapperDiv.remove();
	$fixture.off( "change", "form", delegatedChange );
} );

QUnit.test( "trigger(eventObject, [data], [fn])", function( assert ) {
	assert.expect( 28 );

	var event,
		$parent = jQuery( "<div id='par'></div>" ).appendTo( "body" ),
		$child = jQuery( "<p id='child'>foo</p>" ).appendTo( $parent );

	$parent.get( 0 ).style.display = "none";

	event = jQuery.Event( "noNew" );
	assert.ok( event !== window, "Instantiate jQuery.Event without the 'new' keyword" );
	assert.equal( event.type, "noNew", "Verify its type" );

	assert.equal( event.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
	assert.equal( event.isPropagationStopped(), false, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

	event.preventDefault();
	assert.equal( event.isDefaultPrevented(), true, "Verify isDefaultPrevented" );
	event.stopPropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );

	event.isPropagationStopped = function() { return false; };
	event.stopImmediatePropagation();
	assert.equal( event.isPropagationStopped(), true, "Verify isPropagationStopped" );
	assert.equal( event.isImmediatePropagationStopped(), true, "Verify isPropagationStopped" );

	$parent.on( "foo", function( e ) {

		// Tries bubbling
		assert.equal( e.type, "foo", "Verify event type when passed passing an event object" );
		assert.equal( e.target.id, "child", "Verify event.target when passed passing an event object" );
		assert.equal( e.currentTarget.id, "par", "Verify event.currentTarget when passed passing an event object" );
		assert.equal( e.secret, "boo!", "Verify event object's custom attribute when passed passing an event object" );
	} );

	// test with an event object
	event = new jQuery.Event( "foo" );
	event.secret = "boo!";
	$child.trigger( event );

	// test with a literal object
	$child.trigger( { "type": "foo", "secret": "boo!" } );

	$parent.off();

	function error() {
		assert.ok( false, "This assertion shouldn't be reached" );
	}

	$parent.on( "foo", error );

	$child.on( "foo", function( e, a, b, c ) {
		assert.equal( arguments.length, 4, "Check arguments length" );
		assert.equal( a, 1, "Check first custom argument" );
		assert.equal( b, 2, "Check second custom argument" );
		assert.equal( c, 3, "Check third custom argument" );

		assert.equal( e.isDefaultPrevented(), false, "Verify isDefaultPrevented" );
		assert.equal( e.isPropagationStopped(), false, "Verify isPropagationStopped" );
		assert.equal( e.isImmediatePropagationStopped(), false, "Verify isImmediatePropagationStopped" );

		// Skips both errors
		e.stopImmediatePropagation();

		return "result";
	} );

	// We should add this back in when we want to test the order
	// in which event handlers are iterated.
	//$child.on("foo", error );

	event = new jQuery.Event( "foo" );
	$child.trigger( event, [ 1, 2, 3 ] ).off();
	assert.equal( event.result, "result", "Check event.result attribute" );

	// Will error if it bubbles
	$child.triggerHandler( "foo" );

	$child.off();
	$parent.off().remove();

	// Ensure triggerHandler doesn't molest its event object (#xxx)
	event = jQuery.Event( "zowie" );
	jQuery( document ).triggerHandler( event );
	assert.equal( event.type, "zowie", "Verify its type" );
	assert.equal( event.isPropagationStopped(), false, "propagation not stopped" );
	assert.equal( event.isDefaultPrevented(), false, "default not prevented" );
} );

QUnit.test( ".trigger() bubbling on disconnected elements (#10489)", function( assert ) {
	assert.expect( 2 );

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
diff --git a/a.js b/b.js
@@ -1251,7 +1251,7 @@ jQuery( "<div><p>hi</p></div>" )
A blob:771283c2f63293c53c3866515ff5c842664bd849

	jQuery( window ).on( "click", function() {
		assert.ok( false, "click fired on window" );
	} );

	jQuery( "<div><p>hi</p></div>" )
		.on( "click", function() {
			assert.ok( true, "click fired on div" );
		} )
		.find( "p" )
			.on( "click", function() {
				assert.ok( true, "click fired on p" );
			} )
			.trigger( "click" )
			.off( "click" )
		.end()
		.off( "click" )
		.remove();

	jQuery( window ).off( "click" );
} );

QUnit.test( ".trigger() doesn't bubble load event (#10717)", function( assert ) {
	assert.expect( 1 );

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
diff --git a/a.js b/b.js
@@ -1269,7 +1269,7 @@ jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
A blob:771283c2f63293c53c3866515ff5c842664bd849

	jQuery( window ).on( "load", function() {
		assert.ok( false, "load fired on window" );
	} );

	jQuery( "<img src='" + baseURL + "1x1.jpg' />" )
		.appendTo( "body" )
		.on( "load", function() {
			assert.ok( true, "load fired on img" );
		} )
		.trigger( "load" )
		.remove();

	jQuery( window ).off( "load" );
} );

QUnit.test( "Delegated events in SVG (#10791; #13180)", function( assert ) {
	assert.expect( 2 );

	var useElem, e,
		svg = jQuery(
diff --git a/a.js b/b.js
@@ -1295,7 +1295,7 @@ jQuery( "#qunit-fixture" )
A blob:771283c2f63293c53c3866515ff5c842664bd849
			"<rect id='svg-by-id' x='10' y='20' width='100' height='60' r='10' rx='10' ry='10'></rect>" +
			"<use id='use' xlink:href='#ref'></use>" +
			"</svg>"
		);

	jQuery( "#qunit-fixture" )
		.append( svg )
		.on( "click", "#svg-by-id", function() {
			assert.ok( true, "delegated id selector" );
		} )
		.on( "click", "[class~='svg-by-class']", function() {
			assert.ok( true, "delegated class selector" );
		} )
		.find( "#svg-by-id, [class~='svg-by-class']" )
			.trigger( "click" )
		.end();

	// Fire a native click on an SVGElementInstance (the instance tree of an SVG <use>)
	// to confirm that it doesn't break our event delegation handling (#13180)
	useElem = svg.find( "#use" )[ 0 ];
	if ( document.createEvent && useElem && useElem.instanceRoot ) {
		e = document.createEvent( "MouseEvents" );
		e.initEvent( "click", true, true );
diff --git a/a.js b/b.js
@@ -1321,7 +1321,7 @@ QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( ass
A blob:771283c2f63293c53c3866515ff5c842664bd849
	}

	jQuery( "#qunit-fixture" ).off( "click" );
} );

QUnit.test( "Delegated events with malformed selectors (gh-3071)", function( assert ) {
	assert.expect( 3 );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", ":not", function() {} );
	}, "malformed selector throws on attach" );

	assert.throws( function() {
		jQuery( "#foo" ).on( "click", "nonexistent:not", function() {} );
	}, "short-circuitable malformed selector throws on attach" );

	jQuery( "#foo > :first-child" ).trigger( "click" );
	assert.ok( true, "malformed selector does not throw on event" );
} );

QUnit.test( "Delegated events in forms (#10844; #11145; #8165; #11382, #11764)", function( assert ) {
	assert.expect( 5 );

	// Alias names like "id" cause havoc
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1376,7 +1376,7 @@ jQuery( "body" )
A blob:771283c2f63293c53c3866515ff5c842664bd849
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form.append( "<input type='text' name='disabled' value='differently abled' />" );
	jQuery( "body" )
		.on( "submit", "#myform", function() {
			assert.ok( true, "delegated id selector with aliased disabled" );
		} )
		.find( "#myform" )
			.trigger( "submit" )
		.end()
		.off( "submit" );

	form
		.append( "<button id='nestyDisabledBtn'><span>Zing</span></button>" )
		.on( "click", "#nestyDisabledBtn", function() {
			assert.ok( true, "click on enabled/disabled button with nesty elements" );
		} )
		.on( "mouseover", "#nestyDisabledBtn", function() {
			assert.ok( true, "mouse on enabled/disabled button with nesty elements" );
		} )
		.find( "span" )
			.trigger( "click" )		// yep
			.trigger( "mouseover" )	// yep
		.end()
		.find( "#nestyDisabledBtn" ).prop( "disabled", true ).end()
		.find( "span" )
			.trigger( "click" )		// nope
			.trigger( "mouseover" )	// yep
		.end()
		.off( "click" );

	form.remove();
} );

QUnit.test( "Submit event can be stopped (#11049)", function( assert ) {
	assert.expect( 1 );

	// Since we manually bubble in IE, make sure inner handlers get a chance to cancel
	var form = jQuery(
diff --git a/a.js b/b.js
@@ -1450,7 +1450,7 @@ 			handler = function( event ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
QUnit.test( "jQuery.Event( type, props )", function( assert ) {

	assert.expect( 6 );

	var event = jQuery.Event( "keydown", { keyCode: 64 } ),
			handler = function( event ) {
				assert.ok( "keyCode" in event, "Special property 'keyCode' exists" );
				assert.equal( event.keyCode, 64, "event.keyCode has explicit value '64'" );
			};

	// Supports jQuery.Event implementation
	assert.equal( event.type, "keydown", "Verify type" );

	// ensure "type" in props won't clobber the one set by constructor
	assert.equal( jQuery.inArray( "type", jQuery.event.props ), -1, "'type' property not in props (#10375)" );

	assert.ok( "keyCode" in event, "Special 'keyCode' property exists" );

	assert.strictEqual( jQuery.isPlainObject( event ), false, "Instances of $.Event should not be identified as a plain object." );
diff --git a/a.js b/b.js
@@ -1844,7 +1844,7 @@ function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
diff --git a/a.js b/b.js
@@ -1859,7 +1859,7 @@ function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
diff --git a/a.js b/b.js
@@ -1879,7 +1879,7 @@ function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
		assert.strictEqual( eventFired, true, "trigger fired without crashing" );
	}
} );

// selector-native does not support scope-fixing in delegation
QUnit[ QUnit.jQuerySelectors ? "test" : "skip" ]( "delegated event with delegateTarget-relative selector", function( assert ) {
	assert.expect( 3 );
	var markup = jQuery( "<div><ul><li><a id=\"a0\"></a><ul id=\"ul0\"><li class=test><a id=\"a0_0\"></a></li><li><a id=\"a0_1\"></a></li></ul></li></ul></div>" ).appendTo( "#qunit-fixture" );

	// Non-positional selector (#12383)
	markup.find( "#ul0" )
		.on( "click", "div li a", function() {
			assert.ok( false, "div is ABOVE the delegation point!" );
		} )
		.on( "click", "ul a", function() {
			assert.ok( false, "ul IS the delegation point!" );
		} )
		.on( "click", "li.test a", function() {
			assert.ok( true, "li.test is below the delegation point." );
		} )
		.find( "#a0_0" ).trigger( "click" ).end()
		.off( "click" );

	if ( QUnit.jQuerySelectorsPos ) {
		// Positional selector (#11315)
		markup.find( "ul" ).eq( 0 )
			.on( "click", ">li>a", function() {
				assert.ok( this.id === "a0", "child li was clicked" );
			} )
			.find( "#ul0" )
				.on( "click", "li:first>a", function() {
					assert.ok( this.id === "a0_0", "first li under #u10 was clicked" );
				} )
			.end()
			.find( "a" ).trigger( "click" ).end()
			.find( "#ul0" ).off();
	} else {
		assert.ok( "skip", "Positional selectors are not supported" );
		assert.ok( "skip", "Positional selectors are not supported" );
	}

	markup.remove();
} );

QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

diff --git a/a.js b/b.js
@@ -1893,7 +1893,7 @@ jQuery( "#foo" ).on( "click", "toString", function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
QUnit.test( "delegated event with selector matching Object.prototype property (#13203)", function( assert ) {
	assert.expect( 1 );

	var matched = 0;

	jQuery( "#foo" ).on( "click", "toString", function() {
		matched++;
	} );

	jQuery( "#anchor2" ).trigger( "click" );

	assert.equal( matched, 0, "Nothing matched 'toString'" );
} );

QUnit.test( "delegated event with intermediate DOM manipulation (#13208)", function( assert ) {
	assert.expect( 1 );

	jQuery( "#foo" ).on( "click", "[id=sap]", function() {} );
	jQuery( "#sap" ).on( "click", "[id=anchor2]", function() {
diff --git a/a.js b/b.js
@@ -2187,7 +2187,7 @@ jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
		order = 0;

	// focus the element so DOM focus won't fire
	input[ 0 ].focus();

	jQuery( "body" ).on( "focusin.focusinBubblesTest", function() {
		assert.equal( 1, order++, "focusin on the body second" );
	} );

	input.on( "focusin.focusinBubblesTest", function() {
		assert.equal( 0, order++, "focusin on the element first" );
	} );

// Removed since DOM focus is unreliable on test swarm
	// DOM focus method
//	input[0].focus();

	// To make the next focus test work, we need to take focus off the input.
	// This will fire another focusin event, so set order to reflect that.
//	order = 1;
//	jQuery("#text1")[0].focus();

	// jQuery trigger, which calls DOM focus
	order = 0;
	input.trigger( "focus" );

	input.remove();
	jQuery( "body" ).off( "focusin.focusinBubblesTest" );
} );

QUnit.test( "custom events with colons (#3533, #8272)", function( assert ) {
	assert.expect( 1 );

	var tab = jQuery( "<table><tr><td>trigger</td></tr></table>" ).appendTo( "body" );
	try {
diff --git a/a.js b/b.js
@@ -2370,7 +2370,7 @@ jQuery( "<p>Gut Feeling</p>" )
A blob:771283c2f63293c53c3866515ff5c842664bd849
		.off( ".Devo" )
		.trigger( "gutfeeling" )
		.remove();

	// Ensure .one() events are removed after their maiden voyage
	jQuery( "<p>Gut Feeling</p>" )
		.one( "gutfeeling", jQuery.noop )
		.trigger( "gutfeeling" )	// This one should
		.trigger( "gutfeeling" )	// This one should not
		.remove();

	delete jQuery.event.special[ "gutfeeling" ];
} );

QUnit.test( ".on and .off, selective mixed removal (#10705)", function( assert ) {
	assert.expect( 7 );

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
diff --git a/a.js b/b.js
@@ -2392,7 +2392,7 @@ jQuery( "<p>Strange Pursuit</p>" )
A blob:771283c2f63293c53c3866515ff5c842664bd849

	var timingx = function( e ) {
		assert.ok( true, "triggered " + e.type );
	};

	jQuery( "<p>Strange Pursuit</p>" )
		.on( "click", timingx )
		.on( "click.duty", timingx )
		.on( "click.now", timingx )
		.on( "devo", timingx )
		.on( "future", timingx )
		.trigger( "click" )		// 3
		.trigger( "devo" )		// 1
		.off( ".duty devo " )	// trailing space
		.trigger( "future" )	// 1
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
diff --git a/a.js b/b.js
@@ -2408,7 +2408,7 @@ QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
		.trigger( "click" )		// 2
		.off( "future click" )
		.trigger( "click" );	// 0
} );

QUnit.test( ".on( event-map, null-selector, data ) #11130", function( assert ) {

	assert.expect( 1 );

	var $p = jQuery( "<p>Strange Pursuit</p>" ),
		data = "bar",
		map = {
			"foo": function( event ) {
				assert.equal( event.data, "bar", "event.data correctly relayed with null selector" );
				$p.remove();
			}
		};

	$p.on( map, null, data ).trigger( "foo" );
} );

QUnit.test( "clone() delegated events (#11076)", function( assert ) {
	assert.expect( 3 );

	var counter = { "center": 0, "fold": 0, "centerfold": 0 },
		clicked = function() {
diff --git a/a.js b/b.js
@@ -2630,6 +2630,33 @@ QUnit.test( "focusin on document & window", function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
			done();
		}, 50 );
	}
);

QUnit.test( "focusin on document & window", function( assert ) {
	assert.expect( 1 );

	var counter = 0,
		input = jQuery( "<input />" );

	function increment() {
		counter++;
	}

	input.appendTo( "#qunit-fixture" );

	input[ 0 ].focus();

	jQuery( window ).on( "focusout", increment );
	jQuery( document ).on( "focusout", increment );

	input[ 0 ].blur();

	// DOM focus is unreliable in TestSwarm
	if ( QUnit.isSwarm && counter === 0 ) {
		assert.ok( true, "GAP: Could not observe focus change" );
	}

	assert.strictEqual( counter, 2,
		"focusout handlers on document/window fired once only" );

	jQuery( window ).off( "focusout", increment );
	jQuery( document ).off( "focusout", increment );
} );

testIframe(
	"jQuery.ready promise",
	"event/promiseReady.html",
	function( assert, jQuery, window, document, isOk ) {
diff --git a/a.js b/b.js
@@ -2718,7 +2745,7 @@ QUnit.test( "trigger click on checkbox, fires change event", function( assert )
A blob:771283c2f63293c53c3866515ff5c842664bd849
	$fixture.remove();

	jQuery.removeEvent = originRemoveEvent;
} );

QUnit.test( "trigger click on checkbox, fires change event", function( assert ) {
	assert.expect( 1 );

	var check = jQuery( "#check2" );
	var done = assert.async();

	check.on( "change", function() {

		// get it?
		check.off( "change" );
		assert.ok( true, "Change event fired as a result of triggered click" );
		done();
	} ).trigger( "click" );
} );

QUnit.test( "Namespace preserved when passed an Event (#12739)", function( assert ) {
	assert.expect( 4 );

	var markup = jQuery(
			"<div id='parent'><div id='child'></div></div>"
diff --git a/a.js b/b.js
@@ -2806,7 +2833,7 @@ QUnit.test( "make sure events cloned correctly", function( assert ) {
A blob:771283c2f63293c53c3866515ff5c842664bd849
	markup.remove();

	assert.equal( triggered, 3, "foo.bar triggered" );
} );

QUnit.test( "make sure events cloned correctly", function( assert ) {
	assert.expect( 18 );

	var clone,
		fixture = jQuery( "#qunit-fixture" ),
		checkbox = jQuery( "#check1" ),
		p = jQuery( "#firstp" );

	fixture.on( "click change", function( event, result ) {
		assert.ok( result,  event.type + " on original element is fired" );

	} ).on( "click", "#firstp", function( event, result ) {
		assert.ok( result, "Click on original child element though delegation is fired" );

	} ).on( "change", "#check1", function( event, result ) {
		assert.ok( result, "Change on original child element though delegation is fired" );
	} );

	p.on( "click", function() {
		assert.ok( true, "Click on original child element is fired" );
	} );

	checkbox.on( "change", function() {
		assert.ok( true, "Change on original child element is fired" );
	} );

	fixture.clone().trigger( "click" ).trigger( "change" ); // 0 events should be fired

	clone = fixture.clone( true );

	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone = fixture.clone( true, true );
	clone.find( "p" ).eq( 0 ).trigger( "click", true ); // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire

	fixture.off();
	p.off();
	checkbox.off();

	p.trigger( "click" ); // 0 should be fired
	checkbox.trigger( "change" ); // 0 should be fired

	clone.find( "p" ).eq( 0 ).trigger( "click", true );  // 3 events should fire
	clone.find( "#check1" ).trigger( "change", true ); // 3 events should fire
	clone.remove();

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};
diff --git a/a.js b/b.js
@@ -2821,7 +2848,7 @@ QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#1336
A blob:771283c2f63293c53c3866515ff5c842664bd849

	clone.find( "p" ).eq( 0 ).trigger( "click" );  // 0 should be fired
	clone.find( "#check1" ).trigger( "change" ); // 0 events should fire
} );

QUnit.test( "String.prototype.namespace does not cause trigger() to throw (#13360)", function( assert ) {
	assert.expect( 1 );
	var errored = false;

	String.prototype.namespace = function() {};

	try {
		jQuery( "<p>" ).trigger( "foo.bar" );
	} catch ( e ) {
		errored = true;
	}
	assert.equal( errored, false, "trigger() did not throw exception" );
	delete String.prototype.namespace;
} );

QUnit.test( "Inline event result is returned (#13993)", function( assert ) {
	assert.expect( 1 );

	var result = jQuery( "<p onclick='return 42'>hello</p>" ).triggerHandler( "click" );

diff --git a/a.js b/b.js
@@ -3110,7 +3137,7 @@ setTimeout( function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
		input[ 0 ].focus();

		// then lose it
		inputExternal[ 0 ].focus();

		setTimeout( function() {

			// DOM focus is unreliable in TestSwarm
			if ( QUnit.isSwarm && !focus ) {
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
				assert.ok( true, "GAP: Could not observe focus change" );
			}

			// cleanup
			parent.off();
			input.off();

			done();
		}, 50 );
	}, 50 );
} );

QUnit.test( "focus-blur order (#12868)", function( assert ) {
	assert.expect( 5 );

	var order,
		$text = jQuery( "#text1" ),
diff --git a/a.js b/b.js
@@ -3264,6 +3291,56 @@ setTimeout( function() {
A blob:771283c2f63293c53c3866515ff5c842664bd849
	checkbox.trigger( "focus", data );
	setTimeout( function() {
		assert.strictEqual( document.activeElement, checkbox[ 0 ],
			"element focused after focus event (default action)" );
		checkbox.trigger( "blur", data );
		setTimeout( function() {
			assert.notEqual( document.activeElement, checkbox[ 0 ],
				"element not focused after blur event (default action)" );
			done();
		}, 50 );
	}, 50 );
} );

// TODO replace with an adaptation of
// https://github.com/jquery/jquery/pull/1367/files#diff-a215316abbaabdf71857809e8673ea28R2464
( function() {
	supportjQuery.each(
diff --git a/a.js b/b.js
@@ -60,7 +60,7 @@ async function() {
A blob:06a5f404863bb8ef0077f7ed7396ce9c62ac43de

	grunt.registerMultiTask(
		"build",
		"Build jQuery ECMAScript modules, " +
			"(include/exclude modules with +/- flags), embed date/version",
	async function() {
		const done = this.async();

		try {
			const slimFlags = [ "-ajax", "-callbacks", "-deferred", "-effects" ];
			const flags = this.flags;
			const optIn = flags[ "*" ];
			let name = grunt.option( "filename" );
			const minimum = this.data.minimum;
