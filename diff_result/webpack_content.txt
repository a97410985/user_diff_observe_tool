diff --git a/a.js b/b.js
@@ -10,7 +10,6 @@
A blob:9777333cc5d14ff686a6008144ffc4ae999b8391
"use strict";

const HotModuleReplacementPlugin = require("../HotModuleReplacementPlugin");
const InnerGraph = require("../optimize/InnerGraph");
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes } = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
diff --git a/a.js b/b.js
@@ -144,45 +143,6 @@ apply(parser) {
A blob:9777333cc5d14ff686a6008144ffc4ae999b8391

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;

		function getNonOptionalPart(members, membersOptionals) {
			let i = 0;
			while (i < members.length && membersOptionals[i] === false) i++;
			return i !== members.length ? members.slice(0, i) : members;
		}

		function getNonOptionalMemberChain(node, count) {
			while (count--) node = node.object;
			return node;
		}

		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPartEvaluated = parser.evaluateExpression(expression.left);
				if (leftPartEvaluated.couldHaveSideEffects()) return;
				const leftPart = leftPartEvaluated.asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in"
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
diff --git a/a.js b/b.js
@@ -261,32 +261,14 @@ makeSerializable(
A blob:35354ca7bb976dcb838ee69d4de885aaf5e0170d
		this.usedByExports = read();
		super.deserialize(context);
	}
}

makeSerializable(
	HarmonyImportSpecifierDependency,
	"webpack/lib/dependencies/HarmonyImportSpecifierDependency"
);

HarmonyImportSpecifierDependency.Template = class HarmonyImportSpecifierDependencyTemplate extends (
	HarmonyImportDependency.Template
) {
	/**
	 * @param {Dependency} dependency the dependency for which the template should be applied
	 * @param {ReplaceSource} source the current replace source which can be modified
	 * @param {DependencyTemplateContext} templateContext the context object
	 * @returns {void}
	 */
	apply(dependency, source, templateContext) {
		const dep = /** @type {HarmonyImportSpecifierDependency} */ (dependency);
		const { moduleGraph, runtime } = templateContext;
		const connection = moduleGraph.getConnection(dep);
		// Skip rendering depending when dependency is conditional
		if (connection && !connection.isTargetActive(runtime)) return;

		const ids = dep.getIds(moduleGraph);
		const exportExpr = this._getCodeForIds(dep, source, templateContext, ids);
		const range = dep.range;
		if (dep.shorthand) {
			source.insert(range[1], `: ${exportExpr}`);
		} else {
			source.replace(range[0], range[1] - 1, exportExpr);
		}
	}

	/**
	 * @param {HarmonyImportSpecifierDependency} dep dependency
	 * @param {ReplaceSource} source source
	 * @param {DependencyTemplateContext} templateContext context
	 * @param {string[]} ids ids
	 * @returns {string} generated code
	 */
	_getCodeForIds(dep, source, templateContext, ids) {
		const { moduleGraph, module, runtime, concatenationScope } =
			templateContext;
		const connection = moduleGraph.getConnection(dep);
		let exportExpr;
		if (
			connection &&
			concatenationScope &&
diff --git a/a.js b/b.js
@@ -317,7 +299,7 @@ _getCodeForIds(dep, source, templateContext, ids) {
A blob:35354ca7bb976dcb838ee69d4de885aaf5e0170d
	 * @param {ReplaceSource} source source
	 * @param {DependencyTemplateContext} templateContext context
	 * @param {string[]} ids ids
	 * @returns {string} generated code
	 */
	_getCodeForIds(dep, source, templateContext, ids) {
		const { moduleGraph, module, runtime, concatenationScope } =
			templateContext;
		const connection = moduleGraph.getConnection(dep);
		let exportExpr;
		if (
			connection &&
			concatenationScope &&
			concatenationScope.isModuleInScope(connection.module)
		) {
			if (ids.length === 0) {
				exportExpr = concatenationScope.createModuleReference(
					connection.module,
					{
						asiSafe: dep.asiSafe
					}
				);
			} else if (dep.namespaceObjectAsContext && ids.length === 1) {
				exportExpr =
					concatenationScope.createModuleReference(connection.module, {
						asiSafe: dep.asiSafe
					}) + propertyAccess(ids);
			} else {
				exportExpr = concatenationScope.createModuleReference(
					connection.module,
					{
						ids,
						call: dep.call,
						directImport: dep.directImport,
						asiSafe: dep.asiSafe
					}
				);
			}
		} else {
			super.apply(dep, source, templateContext);

			const { runtimeTemplate, initFragments, runtimeRequirements } =
				templateContext;

diff --git a/a.js b/b.js
@@ -338,7 +320,11 @@ _getCodeForIds(dep, source, templateContext, ids) {
A blob:35354ca7bb976dcb838ee69d4de885aaf5e0170d
	 * @param {ReplaceSource} source source
	 * @param {DependencyTemplateContext} templateContext context
	 * @param {string[]} ids ids
	 * @returns {string} generated code
	 */
	_getCodeForIds(dep, source, templateContext, ids) {
		const { moduleGraph, module, runtime, concatenationScope } =
			templateContext;
		const connection = moduleGraph.getConnection(dep);
		let exportExpr;
		if (
			connection &&
			concatenationScope &&
			concatenationScope.isModuleInScope(connection.module)
		) {
			if (ids.length === 0) {
				exportExpr = concatenationScope.createModuleReference(
					connection.module,
					{
						asiSafe: dep.asiSafe
					}
				);
			} else if (dep.namespaceObjectAsContext && ids.length === 1) {
				exportExpr =
					concatenationScope.createModuleReference(connection.module, {
						asiSafe: dep.asiSafe
					}) + propertyAccess(ids);
			} else {
				exportExpr = concatenationScope.createModuleReference(
					connection.module,
					{
						ids,
						call: dep.call,
						directImport: dep.directImport,
						asiSafe: dep.asiSafe
					}
				);
			}
		} else {
			super.apply(dep, source, templateContext);

			const { runtimeTemplate, initFragments, runtimeRequirements } =
				templateContext;

			exportExpr = runtimeTemplate.exportFromImport({
				moduleGraph,
				module: moduleGraph.getModule(dep),
				request: dep.request,
				exportName: ids,
				originModule: module,
				asiSafe: dep.shorthand ? true : dep.asiSafe,
				isCall: dep.call,
				callContext: !dep.directImport,
				defaultInterop: true,
				importVar: dep.getImportVar(moduleGraph),
				initFragments,
				runtime,
				runtimeRequirements
			});
		}
		return exportExpr;
	}
};

module.exports = HarmonyImportSpecifierDependency;
diff --git a/a.js b/b.js
@@ -8,7 +8,6 @@
A blob:1e97a94dc1415bdf5f5b3e768aacaea17874409a
*/

"use strict";

const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyCompatibilityDependency = require("./HarmonyCompatibilityDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExportExpressionDependency = require("./HarmonyExportExpressionDependency");
const HarmonyExportHeaderDependency = require("./HarmonyExportHeaderDependency");
const HarmonyExportImportedSpecifierDependency = require("./HarmonyExportImportedSpecifierDependency");
const HarmonyExportSpecifierDependency = require("./HarmonyExportSpecifierDependency");
diff --git a/a.js b/b.js
@@ -60,15 +59,6 @@ apply(compiler) {
A blob:1e97a94dc1415bdf5f5b3e768aacaea17874409a
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"HarmonyModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyTemplates.set(
					HarmonyCompatibilityDependency,
					new HarmonyCompatibilityDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSideEffectDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSideEffectDependency,
					new HarmonyImportSideEffectDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSpecifierDependency,
					new HarmonyImportSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyEvaluatedImportSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyEvaluatedImportSpecifierDependency,
					new HarmonyEvaluatedImportSpecifierDependency.Template()
				);

				compilation.dependencyTemplates.set(
					HarmonyExportHeaderDependency,
					new HarmonyExportHeaderDependency.Template()
				);
diff --git a/a.js b/b.js
@@ -61,7 +61,7 @@ constructor() {
A blob:808e2ffa5329b94e21356df7fef5def6efe8d48c
const TypeWrapped = 11;
const TypeTemplateString = 12;
const TypeBigInt = 13;

class BasicEvaluatedExpression {
	constructor() {
		this.type = TypeUnknown;
		/** @type {[number, number]} */
		this.range = undefined;
		/** @type {boolean} */
		this.falsy = false;
		/** @type {boolean} */
		this.truthy = false;
		/** @type {boolean | undefined} */
		this.nullish = undefined;
		/** @type {boolean} */
		this.sideEffects = true;
		/** @type {boolean | undefined} */
		this.bool = undefined;
		/** @type {number | undefined} */
		this.number = undefined;
		/** @type {bigint | undefined} */
		this.bigint = undefined;
		/** @type {RegExp | undefined} */
		this.regExp = undefined;
		/** @type {string | undefined} */
		this.string = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.quasis = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.parts = undefined;
		/** @type {any[] | undefined} */
		this.array = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.items = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.options = undefined;
		/** @type {BasicEvaluatedExpression | undefined} */
		this.prefix = undefined;
		/** @type {BasicEvaluatedExpression | undefined} */
		this.postfix = undefined;
		this.wrappedInnerExpressions = undefined;
		/** @type {string | VariableInfoInterface | undefined} */
		this.identifier = undefined;
		/** @type {VariableInfoInterface} */
		this.rootInfo = undefined;
		/** @type {() => string[]} */
diff --git a/a.js b/b.js
@@ -292,8 +292,6 @@ constructor(sourceType = "auto") {
A blob:0273c5fc6e0dd2c8a22d096b13865a3457cc232c

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[], boolean[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members", "membersOptionals"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"callExpression",
						"members"
					])
			),
			/** Something like "a.b().c.d()"" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			callMemberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"innerCallExpression",
						"members"
					])
			),
			/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */
			optionalChaining: new SyncBailHook(["optionalChaining"]),
			/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */
			new: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[BinaryExpressionNode], boolean | void>} */
			binaryExpression: new SyncBailHook(["binaryExpression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], boolean[]], boolean | void>>} */
			expressionMemberChain: new HookMap(
diff --git a/a.js b/b.js
@@ -2463,9 +2461,7 @@ walkLeftRightExpression(expression) {
A blob:0273c5fc6e0dd2c8a22d096b13865a3457cc232c
			}
		}
		this.walkExpression(expression.argument);
	}

	walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}

	walkBinaryExpression(expression) {
		if (this.hooks.binaryExpression.call(expression) === undefined) {
			this.walkLeftRightExpression(expression);
		}
	}

	walkLogicalExpression(expression) {
		const result = this.hooks.expressionLogicalOperator.call(expression);
diff --git a/a.js b/b.js
@@ -2500,9 +2496,7 @@ walkAssignmentExpression(expression) {
A blob:0273c5fc6e0dd2c8a22d096b13865a3457cc232c
				this.walkExpression(expression.right);
			}
		}
	}

	walkAssignmentExpression(expression) {
		if (expression.left.type === "Identifier") {
			const renameIdentifier = this.getRenameIdentifier(expression.right);
			if (renameIdentifier) {
				if (
					this.callHooksForInfo(
						this.hooks.canRename,
						renameIdentifier,
						expression.right
					)
				) {
					// renaming "a = b;"
					if (
						!this.callHooksForInfo(
							this.hooks.rename,
							renameIdentifier,
							expression.right
						)
					) {
						this.setVariable(
							expression.left.name,
							typeof renameIdentifier === "string"
								? this.getVariableInfo(renameIdentifier)
								: renameIdentifier
						);
					}
					return;
				}
diff --git a/a.js b/b.js
@@ -2637,9 +2631,7 @@ _walkIIFE(functionExpression, options, currentThis) {
A blob:0273c5fc6e0dd2c8a22d096b13865a3457cc232c
				this.walkMemberExpression(expression.expression);
			}
		}
	}

	_walkIIFE(functionExpression, options, currentThis) {
		const getVarInfo = argOrThis => {
			const renameIdentifier = this.getRenameIdentifier(argOrThis);
			if (renameIdentifier) {
				if (
					this.callHooksForInfo(
						this.hooks.canRename,
						renameIdentifier,
						argOrThis
					)
				) {
					if (
						!this.callHooksForInfo(
							this.hooks.rename,
							renameIdentifier,
							argOrThis
						)
					) {
						return typeof renameIdentifier === "string"
							? this.getVariableInfo(renameIdentifier)
							: renameIdentifier;
					}
				}
			}
			this.walkExpression(argOrThis);
diff --git a/a.js b/b.js
@@ -103,8 +103,6 @@
A blob:4fe124cdb3a4833d971e84d41e644e9a6fbf08fc
		require("../dependencies/HarmonyExportImportedSpecifierDependency"),
	"dependencies/HarmonyExportSpecifierDependency": () =>
		require("../dependencies/HarmonyExportSpecifierDependency"),
	"dependencies/HarmonyImportSideEffectDependency": () =>
		require("../dependencies/HarmonyImportSideEffectDependency"),
	"dependencies/HarmonyImportSpecifierDependency": () =>
		require("../dependencies/HarmonyImportSpecifierDependency"),
	"dependencies/HarmonyEvaluatedImportSpecifierDependency": () =>
		require("../dependencies/HarmonyEvaluatedImportSpecifierDependency"),
	"dependencies/ImportContextDependency": () =>
		require("../dependencies/ImportContextDependency"),
	"dependencies/ImportDependency": () =>
		require("../dependencies/ImportDependency"),
diff --git a/a.js b/b.js
@@ -5,12 +5,6 @@
A blob:830b02d03787a62ea9b420951a4a85642d41d9b2
"use strict";

import { x, y } from "./a";
import { d2, usedD1, usedD2 } from "./d.js";
import { b1, usedB1, usedB2, usedB3, usedB4 } from "./b.js";
import { usedE1, usedE2 } from "./e.js";
import { h } from "./h.js";
import * as m from "./m";
import * as o from "./o";
import * as p from "./p";
import * as q from "./q";
import * as so from "./side-effect-free/o";
import * as sm from "./side-effect-free/m";

it("namespace export as from commonjs should override named export", function () {
	expect(x).toBe(1);
	expect(y).toBe(3);
diff --git a/a.js b/b.js
@@ -41,24 +35,3 @@ it("complex case should work correctly", () => {
A blob:830b02d03787a62ea9b420951a4a85642d41d9b2
		expect(usedB3).toBe(false);
		expect(usedB4).toBe(false);
	}
});

it("complex case should work correctly", () => {
	expect(h.f1.e.e1).toBe(10);
	expect(h.g1.e1).toBe(10);
	expect(usedE1).toBe(true);
	if (process.env.NODE_ENV === "production") {
		expect(usedE2).toBe(false);
	}
});

it("should handle 'm in n' case", () => {
	const obj = { aaa: "aaa" in m };
	expect(obj.aaa).toBe(true);
	expect("aaa" in o).toBe(true);
	expect("aaa" in p).toBe(false);
	expect("ccc" in m).toBe(false);
	expect("aaa" in q).toBe(true);
	expect("aaa" in so).toBe(true);
	expect("ccc" in sm).toBe(false);
	expect("ccc" in (false ? {} : m.ddd)).toBe(true);
	expect("ccc" in (false ? {} : sm.ddd)).toBe(true);
	expect("ddd" in m.ddd).toBe(false);
	expect("ddd" in sm.ddd).toBe(false);
	if (process.env.NODE_ENV === "production") {
		expect(m.ddd.usedA).toBe(false);
		expect(m.usedB).toBe(false);
		expect(m.usedA).toBe(true);
		expect(m.canMangleA).toBe(true);
	}
});

diff --git a/a.js b/b.js
@@ -11,6 +11,7 @@
A blob:6d33a8ab94b3210a7fdae4db418f60a085b1bad7

const RuntimeGlobals = require("./RuntimeGlobals");
const { getChunkFilenameTemplate } = require("./css/CssModulesPlugin");
const RuntimeRequirementsDependency = require("./dependencies/RuntimeRequirementsDependency");
const JavascriptModulesPlugin = require("./javascript/JavascriptModulesPlugin");
const AsyncModuleRuntimeModule = require("./runtime/AsyncModuleRuntimeModule");
const AutoPublicPathRuntimeModule = require("./runtime/AutoPublicPathRuntimeModule");
const CompatGetDefaultExportRuntimeModule = require("./runtime/CompatGetDefaultExportRuntimeModule");
const CompatRuntimeModule = require("./runtime/CompatRuntimeModule");
const CreateFakeNamespaceObjectRuntimeModule = require("./runtime/CreateFakeNamespaceObjectRuntimeModule");
const CreateScriptRuntimeModule = require("./runtime/CreateScriptRuntimeModule");
diff --git a/a.js b/b.js
@@ -96,6 +97,15 @@
A blob:6d33a8ab94b3210a7fdae4db418f60a085b1bad7
class RuntimePlugin {
	/**
	 * @param {Compiler} compiler the Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap("RuntimePlugin", compilation => {
			compilation.dependencyTemplates.set(
				RuntimeRequirementsDependency,
				new RuntimeRequirementsDependency.Template()
			);
diff --git a/a.js b/b.js
@@ -413,6 +423,14 @@ apply(compiler) {
A blob:6d33a8ab94b3210a7fdae4db418f60a085b1bad7
class RuntimePlugin {
	/**
	 * @param {Compiler} compiler the Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap("RuntimePlugin", compilation => {
			compilation.dependencyTemplates.set(
				RuntimeRequirementsDependency,
				new RuntimeRequirementsDependency.Template()
			);
			for (const req of GLOBALS_ON_REQUIRE) {
				compilation.hooks.runtimeRequirementInModule
					.for(req)
					.tap("RuntimePlugin", (module, set) => {
						set.add(RuntimeGlobals.requireScope);
					});
				compilation.hooks.runtimeRequirementInTree
					.for(req)
					.tap("RuntimePlugin", (module, set) => {
						set.add(RuntimeGlobals.requireScope);
					});
			}
			for (const req of Object.keys(TREE_DEPENDENCIES)) {
				const deps = TREE_DEPENDENCIES[req];
				compilation.hooks.runtimeRequirementInTree
					.for(req)
					.tap("RuntimePlugin", (chunk, set) => {
						for (const dep of deps) set.add(dep);
					});
			}
			for (const req of Object.keys(MODULE_DEPENDENCIES)) {
				const deps = MODULE_DEPENDENCIES[req];
				compilation.hooks.runtimeRequirementInModule
					.for(req)
					.tap("RuntimePlugin", (chunk, set) => {
						for (const dep of deps) set.add(dep);
					});
			}
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.definePropertyGetters)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new DefinePropertyGettersRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.makeNamespaceObject)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new MakeNamespaceObjectRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.createFakeNamespaceObject)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new CreateFakeNamespaceObjectRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.hasOwnProperty)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new HasOwnPropertyRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.compatGetDefaultExport)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new CompatGetDefaultExportRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.runtimeId)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(chunk, new RuntimeIdRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.publicPath)
				.tap("RuntimePlugin", (chunk, set) => {
					const { outputOptions } = compilation;
					const { publicPath: globalPublicPath, scriptType } = outputOptions;
					const entryOptions = chunk.getEntryOptions();
					const publicPath =
						entryOptions && entryOptions.publicPath !== undefined
							? entryOptions.publicPath
							: globalPublicPath;

					if (publicPath === "auto") {
						const module = new AutoPublicPathRuntimeModule();
						if (scriptType !== "module") set.add(RuntimeGlobals.global);
						compilation.addRuntimeModule(chunk, module);
					} else {
						const module = new PublicPathRuntimeModule(publicPath);

						if (
							typeof publicPath !== "string" ||
							/\[(full)?hash\]/.test(publicPath)
						) {
							module.fullHash = true;
						}

						compilation.addRuntimeModule(chunk, module);
					}
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.global)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(chunk, new GlobalRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.asyncModule)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(chunk, new AsyncModuleRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.systemContext)
				.tap("RuntimePlugin", chunk => {
					const { outputOptions } = compilation;
					const { library: globalLibrary } = outputOptions;
					const entryOptions = chunk.getEntryOptions();
					const libraryType =
						entryOptions && entryOptions.library !== undefined
							? entryOptions.library.type
							: globalLibrary.type;

					if (libraryType === "system") {
						compilation.addRuntimeModule(
							chunk,
							new SystemContextRuntimeModule()
						);
					}
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getChunkScriptFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						typeof compilation.outputOptions.chunkFilename === "string" &&
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.chunkFilename
						)
					) {
						set.add(RuntimeGlobals.getFullHash);
					}
					compilation.addRuntimeModule(
						chunk,
						new GetChunkFilenameRuntimeModule(
							"javascript",
							"javascript",
							RuntimeGlobals.getChunkScriptFilename,
							chunk =>
								chunk.filenameTemplate ||
								(chunk.canBeInitial()
									? compilation.outputOptions.filename
									: compilation.outputOptions.chunkFilename),
							false
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getChunkCssFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						typeof compilation.outputOptions.cssChunkFilename === "string" &&
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.cssChunkFilename
						)
					) {
						set.add(RuntimeGlobals.getFullHash);
					}
					compilation.addRuntimeModule(
						chunk,
						new GetChunkFilenameRuntimeModule(
							"css",
							"css",
							RuntimeGlobals.getChunkCssFilename,
							chunk =>
								getChunkFilenameTemplate(chunk, compilation.outputOptions),
							set.has(RuntimeGlobals.hmrDownloadUpdateHandlers)
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getChunkUpdateScriptFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.hotUpdateChunkFilename
						)
					)
						set.add(RuntimeGlobals.getFullHash);
					compilation.addRuntimeModule(
						chunk,
						new GetChunkFilenameRuntimeModule(
							"javascript",
							"javascript update",
							RuntimeGlobals.getChunkUpdateScriptFilename,
							c => compilation.outputOptions.hotUpdateChunkFilename,
							true
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getUpdateManifestFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.hotUpdateMainFilename
						)
					) {
						set.add(RuntimeGlobals.getFullHash);
					}
					compilation.addRuntimeModule(
						chunk,
						new GetMainFilenameRuntimeModule(
							"update manifest",
							RuntimeGlobals.getUpdateManifestFilename,
							compilation.outputOptions.hotUpdateMainFilename
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.ensureChunk)
				.tap("RuntimePlugin", (chunk, set) => {
					const hasAsyncChunks = chunk.hasAsyncChunks();
					if (hasAsyncChunks) {
						set.add(RuntimeGlobals.ensureChunkHandlers);
					}
					compilation.addRuntimeModule(
						chunk,
						new EnsureChunkRuntimeModule(set)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.ensureChunkIncludeEntries)
				.tap("RuntimePlugin", (chunk, set) => {
					set.add(RuntimeGlobals.ensureChunkHandlers);
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.shareScopeMap)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(chunk, new ShareRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.loadScript)
				.tap("RuntimePlugin", (chunk, set) => {
					const withCreateScriptUrl = !!compilation.outputOptions.trustedTypes;
					if (withCreateScriptUrl) {
						set.add(RuntimeGlobals.createScriptUrl);
					}
					compilation.addRuntimeModule(
						chunk,
						new LoadScriptRuntimeModule(withCreateScriptUrl)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.createScript)
				.tap("RuntimePlugin", (chunk, set) => {
					if (compilation.outputOptions.trustedTypes) {
						set.add(RuntimeGlobals.getTrustedTypesPolicy);
					}
					compilation.addRuntimeModule(chunk, new CreateScriptRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.createScriptUrl)
				.tap("RuntimePlugin", (chunk, set) => {
					if (compilation.outputOptions.trustedTypes) {
						set.add(RuntimeGlobals.getTrustedTypesPolicy);
					}
					compilation.addRuntimeModule(
						chunk,
						new CreateScriptUrlRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getTrustedTypesPolicy)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(
						chunk,
						new GetTrustedTypesPolicyRuntimeModule(set)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.relativeUrl)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(chunk, new RelativeUrlRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.onChunksLoaded)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(
						chunk,
						new OnChunksLoadedRuntimeModule()
					);
					return true;
				});
			// TODO webpack 6: remove CompatRuntimeModule
			compilation.hooks.additionalTreeRuntimeRequirements.tap(
				"RuntimePlugin",
				(chunk, set) => {
diff --git a/a.js b/b.js
@@ -83,6 +83,18 @@ constructor(options) {
A blob:c0c1f6896ceb561e4869140370698cc5d062752a

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.exportsPresence)
				: options.strictExportPresence
				? ExportPresenceModes.ERROR
				: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
diff --git a/a.js b/b.js
@@ -154,51 +166,83 @@ apply(parser) {
A blob:c0c1f6896ceb561e4869140370698cc5d062752a

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const { arguments: args, callee } = expr;
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					callee.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.directImport = members.length === 0;
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(callee.range[0]);
				// only in case when we strictly follow the spec we need a special case here
				dep.namespaceObjectAsContext =
					members.length > 0 && this.strictThisContextOnImports;
				dep.loc = callee.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		const { hotAcceptCallback, hotAcceptWithoutCallback } =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
diff --git a/a.js b/b.js
@@ -67,6 +67,8 @@ constructor() {
A blob:0e5a21183c9300ef5ba8a0736701b1d1a3c5aeb3
const TypeWrapped = 11;
const TypeTemplateString = 12;
const TypeBigInt = 13;

class BasicEvaluatedExpression {
	constructor() {
		this.type = TypeUnknown;
		/** @type {[number, number]} */
		this.range = undefined;
		/** @type {boolean} */
		this.falsy = false;
		/** @type {boolean} */
		this.truthy = false;
		/** @type {boolean | undefined} */
		this.nullish = undefined;
		/** @type {boolean} */
		this.sideEffects = true;
		/** @type {boolean | undefined} */
		this.bool = undefined;
		/** @type {number | undefined} */
		this.number = undefined;
		/** @type {bigint | undefined} */
		this.bigint = undefined;
		/** @type {RegExp | undefined} */
		this.regExp = undefined;
		/** @type {string | undefined} */
		this.string = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.quasis = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.parts = undefined;
		/** @type {any[] | undefined} */
		this.array = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.items = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.options = undefined;
		/** @type {BasicEvaluatedExpression | undefined} */
		this.prefix = undefined;
		/** @type {BasicEvaluatedExpression | undefined} */
		this.postfix = undefined;
		this.wrappedInnerExpressions = undefined;
		/** @type {string | undefined} */
		this.identifier = undefined;
		/** @type {VariableInfoInterface} */
		this.rootInfo = undefined;
		/** @type {() => string[]} */
		this.getMembers = undefined;
		/** @type {EsTreeNode} */
		this.expression = undefined;
	}

diff --git a/a.js b/b.js
@@ -342,11 +344,12 @@ setRegExp(regExp) {
A blob:0e5a21183c9300ef5ba8a0736701b1d1a3c5aeb3
		this.bool = bool;
		this.sideEffects = false;
		return this;
	}

	setRegExp(regExp) {
		this.type = TypeRegExp;
		this.regExp = regExp;
		this.sideEffects = false;
		return this;
	}

	setIdentifier(identifier, rootInfo, getMembers) {
		this.type = TypeIdentifier;
		this.identifier = identifier;
		this.rootInfo = rootInfo;
		this.getMembers = getMembers;
		this.sideEffects = true;
		return this;
	}

diff --git a/a.js b/b.js
@@ -57,7 +57,7 @@
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
/** @typedef {import("estree").ThisExpression} ThisExpressionNode */
/** @typedef {import("estree").UnaryExpression} UnaryExpressionNode */
/** @typedef {import("estree").VariableDeclarator} VariableDeclaratorNode */
/** @template T @typedef {import("tapable").AsArray<T>} AsArray<T> */
/** @typedef {import("../Parser").ParserState} ParserState */
/** @typedef {import("../Parser").PreparsedAst} PreparsedAst */
/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */
/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[] }} GetInfoResult */

const EMPTY_ARRAY = [];
const ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;
const ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;
diff --git a/a.js b/b.js
@@ -262,9 +262,9 @@ constructor(sourceType = "auto") {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
diff --git a/a.js b/b.js
@@ -294,9 +294,9 @@ constructor(sourceType = "auto") {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"callExpression",
						"members"
					])
			),
			/** Something like "a.b().c.d()"" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			callMemberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"innerCallExpression",
						"members"
					])
			),
			/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */
			optionalChaining: new SyncBailHook(["optionalChaining"]),
			/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */
			new: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
			expressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
			unhandledExpressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
diff --git a/a.js b/b.js
@@ -971,7 +971,12 @@ _initializeEvaluating() {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
diff --git a/a.js b/b.js
@@ -988,7 +993,12 @@ _initializeEvaluating() {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
diff --git a/a.js b/b.js
@@ -997,7 +1007,12 @@ _initializeEvaluating() {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					const right = this.evaluateExpression(expr.right);
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);
diff --git a/a.js b/b.js
@@ -2716,7 +2731,10 @@ walkCallExpression(expression) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
		if (result === true) return;

		this.walkExpression(expression.source);
	}

	walkCallExpression(expression) {
		const isSimpleFunction = fn => {
			return fn.params.every(p => p.type === "Identifier");
		};
		if (
			expression.callee.type === "MemberExpression" &&
			expression.callee.object.type.endsWith("FunctionExpression") &&
			!expression.callee.computed &&
			(expression.callee.property.name === "call" ||
				expression.callee.property.name === "bind") &&
			expression.arguments.length > 0 &&
			isSimpleFunction(expression.callee.object)
		) {
			// (function() { }.call/bind(?, ))
			this._walkIIFE(
				expression.callee.object,
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		} else if (
			expression.callee.type.endsWith("FunctionExpression") &&
			isSimpleFunction(expression.callee)
		) {
			// (function() { }())
			this._walkIIFE(expression.callee, expression.arguments, null);
		} else {
			if (expression.callee.type === "MemberExpression") {
				const exprInfo = this.getMemberExpressionInfo(
					expression.callee,
					ALLOWED_MEMBER_TYPES_CALL_EXPRESSION
				);
				if (exprInfo && exprInfo.type === "call") {
					const result = this.callHooksForInfo(
						this.hooks.callMemberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers()
					);
					if (result === true) return;
				}
			}
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const result1 = this.callHooksForInfo(
					this.hooks.callMemberChain,
					callee.rootInfo,
					expression,
					callee.getMembers()
				);
				if (result1 === true) return;
				const result2 = this.callHooksForInfo(
					this.hooks.call,
diff --git a/a.js b/b.js
@@ -2756,11 +2774,13 @@ walkMemberExpression(expression) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
			}
			if (expression.arguments) this.walkExpressions(expression.arguments);
		}
	}

	walkMemberExpression(expression) {
		const exprInfo = this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_ALL
		);
		if (exprInfo) {
			switch (exprInfo.type) {
				case "expression": {
					const result1 = this.callHooksForInfo(
						this.hooks.expression,
						exprInfo.name,
						expression
					);
					if (result1 === true) return;
					const members = exprInfo.getMembers();
					const result2 = this.callHooksForInfo(
						this.hooks.expressionMemberChain,
						exprInfo.rootInfo,
						expression,
						members
					);
					if (result2 === true) return;
					this.walkMemberExpressionWithExpressionName(
						expression,
diff --git a/a.js b/b.js
@@ -3600,12 +3620,13 @@ parseCommentOptions(range) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
		} else {
			this.scope.definitions.set(name, variableInfo);
		}
	}

	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		}
		let options = {};
		let errors = [];
		for (const comment of comments) {
			const { value } = comment;
			if (value && webpackCommentRegExp.test(value)) {
				// try compile only if webpack options comment is present
				try {
					const val = vm.runInNewContext(`(function(){return {${value}};})()`);
					Object.assign(options, val);
				} catch (e) {
					e.comment = comment;
					errors.push(e);
				}
			}
		}
		return { options, errors };
	}

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {AnyNode} */
		let expr = expression;
		const members = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value}`);
diff --git a/a.js b/b.js
@@ -3614,10 +3635,13 @@ extractMemberExpressionChain(expression) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {AnyNode} */
		let expr = expression;
		const members = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value}`);
			} else {
				if (expr.property.type !== "Identifier") break;
				members.push(expr.property.name);
			}
			expr = expr.object;
		}
		return {
			members,
			object: expr
		};
	}

diff --git a/a.js b/b.js
@@ -3640,8 +3664,8 @@ getFreeInfoFromVariable(varName) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return undefined;
		} else if (typeof info !== "string") {
			return undefined;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: "call", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
diff --git a/a.js b/b.js
@@ -3649,7 +3673,8 @@ getFreeInfoFromVariable(varName) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return undefined;
		} else if (typeof info !== "string") {
			return undefined;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: "call", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
diff --git a/a.js b/b.js
@@ -3673,7 +3698,8 @@ getMemberExpressionInfo(expression, allowedTypes) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return undefined;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() => members.reverse())
				};
			}
			case "Identifier":
			case "MetaProperty":
diff --git a/a.js b/b.js
@@ -3691,7 +3717,8 @@ getMemberExpressionInfo(expression, allowedTypes) {
A blob:55e26202d137dce0475bc1845b2f1a5236c52e7d
	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return undefined;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() => members.reverse())
				};
			}
			case "Identifier":
			case "MetaProperty":
			case "ThisExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)
					return undefined;
				const rootName = getRootName(object);
				if (!rootName) return undefined;

				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				return {
					type: "expression",
					name: objectAndMembersToName(resolvedRoot, members),
					rootInfo,
					getMembers: memoize(() => members.reverse())
				};
			}
		}
	}
diff --git a/a.js b/b.js
@@ -1,3 +1,15 @@
A blob:cff0a3dbb5b7791c85cf20ead3a4c9cc350bcdc9
it("should evaluate optional members", () => {
	if (!module.hot) {
		expect(
			module.hot?.accept((() => {throw new Error("fail")})())
diff --git a/a.js b/b.js
@@ -60,7 +60,7 @@ exports.replaceResults = (template, baseDir, stdout, prefix) => {
A blob:c68c5ac1d0f02e24be9f94d51ea06be2d69a56f9
exports.needResults = (template, prefix) => {
	const regExp = prefix ? new RegExp(`_\\{\\{${prefix}:`) : /_\{\{/;
	return regExp.test(template);
};

exports.replaceResults = (template, baseDir, stdout, prefix) => {
	const regexp = new RegExp("_\\{\\{" + (prefix ? prefix + ":" : "") + "([^:\\}]+)\\}\\}_", "g");

	return template.replace(regexp, function(match) {
		match = match.substr(3 + (prefix ? prefix.length + 1 : 0), match.length - 6 - (prefix ? prefix.length + 1 : 0));
		if(match === "stdout")
			return stdout;
		try {
			return fs.readFileSync(path.join(baseDir, match), "utf-8").replace(/[\r\n]*$/, "");
diff --git a/a.js b/b.js
@@ -4,7 +4,7 @@
A blob:dab215a426a63d2ef95f9ad26ada21e3e00ff4ce
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/*globals __resourceQuery */
if (module.hot) {
	var hotPollInterval = +__resourceQuery.substr(1) || 10 * 60 * 1000;
	var log = require("./log");

	var checkForUpdate = function checkForUpdate(fromUpdate) {
		if (module.hot.status() === "idle") {
diff --git a/a.js b/b.js
@@ -45,7 +45,7 @@ 	var checkForUpdate = function checkForUpdate(fromUpdate) {
A blob:ef949521f155966346a0f87f5b82fa69d8986f2e
	Author Tobias Koppers @sokra
*/
/*globals __resourceQuery */
if (module.hot) {
	var log = require("./log");
	var checkForUpdate = function checkForUpdate(fromUpdate) {
		module.hot
			.check()
			.then(function (updatedModules) {
				if (!updatedModules) {
					if (fromUpdate) log("info", "[HMR] Update applied.");
					else log("warning", "[HMR] Cannot find update.");
					return;
				}

				return module.hot
					.apply({
						ignoreUnaccepted: true,
						onUnaccepted: function (data) {
							log(
								"warning",
								"Ignored an update to unaccepted module " +
									data.chain.join(" -> ")
							);
						}
					})
					.then(function (renewedModules) {
						require("./log-apply-result")(updatedModules, renewedModules);

						checkForUpdate(true);
						return null;
					});
			})
			.catch(function (err) {
				var status = module.hot.status();
				if (["abort", "fail"].indexOf(status) >= 0) {
					log("warning", "[HMR] Cannot apply update.");
					log("warning", "[HMR] " + log.formatError(err));
					log("warning", "[HMR] You need to restart the application!");
				} else {
					log("warning", "[HMR] Update failed: " + (err.stack || err.message));
				}
			});
	};

	process.on(__resourceQuery.substr(1) || "SIGUSR2", function () {
		if (module.hot.status() !== "idle") {
			log(
				"warning",
				"[HMR] Got signal but currently in " + module.hot.status() + " state."
diff --git a/a.js b/b.js
@@ -690,7 +690,7 @@ getChildIdsByOrders(chunkGraph, filterFn) {
A blob:db598c70b425863286507b0080ab5b191eef8051
	/**
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @param {ChunkFilterPredicate=} filterFn function used to filter chunks
	 * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)
	 */
	getChildIdsByOrders(chunkGraph, filterFn) {
		/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */
		const lists = new Map();
		for (const group of this.groupsIterable) {
			if (group.chunks[group.chunks.length - 1] === this) {
				for (const childGroup of group.childrenIterable) {
					for (const key of Object.keys(childGroup.options)) {
						if (key.endsWith("Order")) {
							const name = key.substr(0, key.length - "Order".length);
							let list = lists.get(name);
							if (list === undefined) {
								list = [];
								lists.set(name, list);
diff --git a/a.js b/b.js
@@ -486,7 +486,7 @@ getChildrenByOrders(moduleGraph, chunkGraph) {
A blob:69b2128a316201a49d05ab3b62ce7495566810d1
	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups
	 */
	getChildrenByOrders(moduleGraph, chunkGraph) {
		/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */
		const lists = new Map();
		for (const childGroup of this._children) {
			for (const key of Object.keys(childGroup.options)) {
				if (key.endsWith("Order")) {
					const name = key.substr(0, key.length - "Order".length);
					let list = lists.get(name);
					if (list === undefined) {
						lists.set(name, (list = []));
					}
diff --git a/a.js b/b.js
@@ -3896,7 +3896,7 @@ createModuleHashes() {
A blob:35e4018f16983ac8038d8d333ca2b299a4ec3133
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		const errors = [];
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
diff --git a/a.js b/b.js
@@ -3960,7 +3960,7 @@ _createModuleHash(
A blob:35e4018f16983ac8038d8d333ca2b299a4ec3133
				) / 100
			} variants per module in average)`
		);
	}

	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength,
		errors
	) {
		let moduleHashDigest;
		try {
			const moduleHash = createHash(hashFunction);
			module.updateHash(moduleHash, {
				chunkGraph,
				runtime,
				runtimeTemplate
			});
			moduleHashDigest = /** @type {string} */ (moduleHash.digest(hashDigest));
		} catch (err) {
			errors.push(new ModuleHashingError(module, err));
			moduleHashDigest = "XXXXXX";
		}
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

diff --git a/a.js b/b.js
@@ -4164,7 +4164,7 @@ createHash() {
A blob:35e4018f16983ac8038d8d333ca2b299a4ec3133
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
diff --git a/a.js b/b.js
@@ -4191,7 +4191,7 @@ createHash() {
A blob:35e4018f16983ac8038d8d333ca2b299a4ec3133
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
diff --git a/a.js b/b.js
@@ -4211,7 +4211,7 @@ createHash() {
A blob:35e4018f16983ac8038d8d333ca2b299a4ec3133
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
diff --git a/a.js b/b.js
@@ -4222,7 +4222,7 @@ createHash() {
A blob:35e4018f16983ac8038d8d333ca2b299a4ec3133
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest = /** @type {string} */ (
				chunkHash.digest(hashDigest)
			);
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd("hashing: process full hash modules");
		return codeGenerationJobs;
diff --git a/a.js b/b.js
@@ -596,7 +596,7 @@ emitAssets(compilation, callback) {
A blob:9bf57f028ee2167fb294cfea7ab388b9007e4f14
	/**
	 * @param {Compilation} compilation the compilation
	 * @param {Callback<void>} callback signals when the assets are emitted
	 * @returns {void}
	 */
	emitAssets(compilation, callback) {
		let outputPath;

		const emitFiles = err => {
			if (err) return callback(err);

			const assets = compilation.getAssets();
			compilation.assets = { ...compilation.assets };
			/** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */
			const caseInsensitiveMap = new Map();
			/** @type {Set<string>} */
			const allTargetPaths = new Set();
			asyncLib.forEachLimit(
				assets,
				15,
				({ name: file, source, info }, callback) => {
					let targetFile = file;
					let immutable = info.immutable;
					const queryStringIdx = targetFile.indexOf("?");
					if (queryStringIdx >= 0) {
						targetFile = targetFile.substr(0, queryStringIdx);
						// We may remove the hash, which is in the query string
						// So we recheck if the file is immutable
						// This doesn't cover all cases, but immutable is only a performance optimization anyway
						immutable =
diff --git a/a.js b/b.js
@@ -128,7 +128,7 @@ create(data, callback) {
A blob:dac23100a8c3e48f096905dac5019d18d2c23a73
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
diff --git a/a.js b/b.js
@@ -138,7 +138,7 @@ create(data, callback) {
A blob:dac23100a8c3e48f096905dac5019d18d2c23a73
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
diff --git a/a.js b/b.js
@@ -146,7 +146,7 @@ create(data, callback) {
A blob:dac23100a8c3e48f096905dac5019d18d2c23a73
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}
diff --git a/a.js b/b.js
@@ -348,7 +348,7 @@ resolveDependencies(fs, options, callback) {
A blob:dac23100a8c3e48f096905dac5019d18d2c23a73
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix
		} = options;
		if (!regExp || !resource) return callback(null, []);

		let severalContexts = false;
		const addDirectoryChecked = (ctx, directory, visited, callback) => {
			fs.realpath(directory, (err, realPath) => {
				if (err) return callback(err);
				if (visited.has(realPath)) return callback(null, []);
				let recursionStack;
				addDirectory(
					ctx,
					directory,
					(_, dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(ctx, dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		const addDirectory = (ctx, directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file => file.normalize("NFC"))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(ctx, subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: ctx,
										request:
											"." + subResource.substr(ctx.length).replace(/\\/g, "/")
									};

									this.hooks.alternativeRequests.callAsync(
										[obj],
diff --git a/a.js b/b.js
@@ -29,7 +29,7 @@ apply(normalModuleFactory) {
A blob:1614c74ae271ff765df58c6b8baba9077bc66d65
		this.options = options;
		options.type = options.type || "require";
		options.extensions = options.extensions || ["", ".js", ".json", ".wasm"];
	}

	apply(normalModuleFactory) {
		const scope = this.options.scope;
		if (scope) {
			normalModuleFactory.hooks.factorize.tapAsync(
				"DelegatedModuleFactoryPlugin",
				(data, callback) => {
					const [dependency] = data.dependencies;
					const { request } = dependency;
					if (request && request.startsWith(`${scope}/`)) {
						const innerRequest = "." + request.substr(scope.length);
						let resolved;
						if (innerRequest in this.options.content) {
							resolved = this.options.content[innerRequest];
							return callback(
diff --git a/a.js b/b.js
@@ -43,8 +43,8 @@ exports.cutOffMessage = (stack, message) => {
A blob:7851bdc8eb00a409b6a268aef621a13713b037ff
	});

	return result.join("\n");
};

exports.cutOffMessage = (stack, message) => {
	const nextLine = stack.indexOf("\n");
	if (nextLine === -1) {
		return stack === message ? "" : stack;
	} else {
		const firstLine = stack.substr(0, nextLine);
		return firstLine === message ? stack.substr(nextLine + 1) : stack;
	}
};

exports.cleanUp = (stack, message) => {
diff --git a/a.js b/b.js
@@ -89,8 +89,8 @@ apply(normalModuleFactory) {
A blob:92d564700259c9a98501633c61c76fc1fdd2937a

	/**
	 * @param {NormalModuleFactory} normalModuleFactory the normal module factory
	 * @returns {void}
	 */
	apply(normalModuleFactory) {
		const globalType = this.type;
		normalModuleFactory.hooks.factorize.tapAsync(
			"ExternalModuleFactoryPlugin",
			(data, callback) => {
				const context = data.context;
				const contextInfo = data.contextInfo;
				const dependency = data.dependencies[0];
				const dependencyType = data.dependencyType;

				/**
				 * @param {string|string[]|boolean|Record<string, string|string[]>} value the external config
				 * @param {string|undefined} type type of external
				 * @param {function(Error=, ExternalModule=): void} callback callback
				 * @returns {void}
				 */
				const handleExternal = (value, type, callback) => {
					if (value === false) {
						// Not externals, fallback to original factory
						return callback();
					}
					/** @type {string | string[] | Record<string, string|string[]>} */
					let externalConfig;
					if (value === true) {
						externalConfig = dependency.request;
					} else {
						externalConfig = value;
					}
					// When no explicit type is specified, extract it from the externalConfig
					if (type === undefined) {
						if (
							typeof externalConfig === "string" &&
							UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig)
						) {
							const idx = externalConfig.indexOf(" ");
							type = externalConfig.substr(0, idx);
							externalConfig = externalConfig.substr(idx + 1);
						} else if (
							Array.isArray(externalConfig) &&
							externalConfig.length > 0 &&
							UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig[0])
diff --git a/a.js b/b.js
@@ -98,9 +98,9 @@ apply(normalModuleFactory) {
A blob:92d564700259c9a98501633c61c76fc1fdd2937a

	/**
	 * @param {NormalModuleFactory} normalModuleFactory the normal module factory
	 * @returns {void}
	 */
	apply(normalModuleFactory) {
		const globalType = this.type;
		normalModuleFactory.hooks.factorize.tapAsync(
			"ExternalModuleFactoryPlugin",
			(data, callback) => {
				const context = data.context;
				const contextInfo = data.contextInfo;
				const dependency = data.dependencies[0];
				const dependencyType = data.dependencyType;

				/**
				 * @param {string|string[]|boolean|Record<string, string|string[]>} value the external config
				 * @param {string|undefined} type type of external
				 * @param {function(Error=, ExternalModule=): void} callback callback
				 * @returns {void}
				 */
				const handleExternal = (value, type, callback) => {
					if (value === false) {
						// Not externals, fallback to original factory
						return callback();
					}
					/** @type {string | string[] | Record<string, string|string[]>} */
					let externalConfig;
					if (value === true) {
						externalConfig = dependency.request;
					} else {
						externalConfig = value;
					}
					// When no explicit type is specified, extract it from the externalConfig
					if (type === undefined) {
						if (
							typeof externalConfig === "string" &&
							UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig)
						) {
							const idx = externalConfig.indexOf(" ");
							type = externalConfig.substr(0, idx);
							externalConfig = externalConfig.substr(idx + 1);
						} else if (
							Array.isArray(externalConfig) &&
							externalConfig.length > 0 &&
							UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig[0])
						) {
							const firstItem = externalConfig[0];
							const idx = firstItem.indexOf(" ");
							type = firstItem.substr(0, idx);
							externalConfig = [
								firstItem.substr(idx + 1),
								...externalConfig.slice(1)
							];
						}
					}
diff --git a/a.js b/b.js
@@ -52,7 +52,7 @@ apply(compiler) {
A blob:a96c5bb7d58e018f1f06cf4cf64bedee0277b668
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("LoaderOptionsPlugin", compilation => {
			NormalModule.getCompilationHooks(compilation).loader.tap(
				"LoaderOptionsPlugin",
				(context, module) => {
					const resource = module.resource;
					if (!resource) return;
					const i = resource.indexOf("?");
					if (
						ModuleFilenameHelpers.matchObject(
							options,
							i < 0 ? resource : resource.substr(0, i)
						)
					) {
						for (const key of Object.keys(options)) {
							if (key === "include" || key === "exclude" || key === "test") {
diff --git a/a.js b/b.js
@@ -47,7 +47,7 @@ const getAfter = (strFn, token) => {
A blob:610615d82d304af2dd2d171cf540a46ca4ae82c2
ModuleFilenameHelpers.HASH = "[hash]";
ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi;
ModuleFilenameHelpers.NAMESPACE = "[namespace]";
ModuleFilenameHelpers.REGEXP_NAMESPACE = /\[namespace\]/gi;

const getAfter = (strFn, token) => {
	return () => {
		const str = strFn();
		const idx = str.indexOf(token);
		return idx < 0 ? "" : str.substr(idx);
	};
};

const getBefore = (strFn, token) => {
diff --git a/a.js b/b.js
@@ -55,7 +55,7 @@ const getBefore = (strFn, token) => {
A blob:610615d82d304af2dd2d171cf540a46ca4ae82c2
		const idx = str.indexOf(token);
		return idx < 0 ? "" : str.substr(idx);
	};
};

const getBefore = (strFn, token) => {
	return () => {
		const str = strFn();
		const idx = str.lastIndexOf(token);
		return idx < 0 ? "" : str.substr(0, idx);
	};
};

const getHash = (strFn, hashFunction) => {
diff --git a/a.js b/b.js
@@ -64,7 +64,7 @@ const getHash = (strFn, hashFunction) => {
A blob:610615d82d304af2dd2d171cf540a46ca4ae82c2
		const idx = str.lastIndexOf(token);
		return idx < 0 ? "" : str.substr(0, idx);
	};
};

const getHash = (strFn, hashFunction) => {
	return () => {
		const hash = createHash(hashFunction);
		hash.update(strFn());
		const digest = /** @type {string} */ (hash.digest("hex"));
		return digest.substr(0, 4);
	};
};

const asRegExp = test => {
diff --git a/a.js b/b.js
@@ -375,7 +375,7 @@ libIdent(options) {
A blob:5484e195703eb78499be2f099118673a323cb1bf

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let ident = contextify(
			options.context,
			this.userRequest,
			options.associatedObjectForCache
		);
		if (this.layer) ident = `(${this.layer})/${ident}`;
		return ident;
	}

	/**
	 * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)
	 */
	nameForCondition() {
		const resource = this.matchResource || this.resource;
		const idx = resource.indexOf("?");
		if (idx >= 0) return resource.substr(0, idx);
		return resource;
	}

	/**
diff --git a/a.js b/b.js
@@ -558,7 +558,7 @@ _createLoaderContext(resolver, options, compilation, fs, hooks) {
A blob:5484e195703eb78499be2f099118673a323cb1bf
	 * @param {Compilation} compilation the compilation
	 * @param {InputFileSystem} fs file system from reading
	 * @param {NormalModuleCompilationHooks} hooks the hooks
	 * @returns {NormalModuleLoaderContext} loader context
	 */
	_createLoaderContext(resolver, options, compilation, fs, hooks) {
		const { requestShortener } = compilation.runtimeTemplate;
		const getCurrentLoaderName = () => {
			const currentLoader = this.getCurrentLoader(loaderContext);
			if (!currentLoader) return "(not in loader scope)";
			return requestShortener.shorten(currentLoader.loader);
		};
		const getResolveContext = () => {
			return {
				fileDependencies: {
					add: d => loaderContext.addDependency(d)
				},
				contextDependencies: {
					add: d => loaderContext.addContextDependency(d)
				},
				missingDependencies: {
					add: d => loaderContext.addMissingDependency(d)
				}
			};
		};
		const getAbsolutify = memoize(() =>
			absolutify.bindCache(compilation.compiler.root)
		);
		const getAbsolutifyInContext = memoize(() =>
			absolutify.bindContextCache(this.context, compilation.compiler.root)
		);
		const getContextify = memoize(() =>
			contextify.bindCache(compilation.compiler.root)
		);
		const getContextifyInContext = memoize(() =>
			contextify.bindContextCache(this.context, compilation.compiler.root)
		);
		const utils = {
			absolutify: (context, request) => {
				return context === this.context
					? getAbsolutifyInContext()(request)
					: getAbsolutify()(context, request);
			},
			contextify: (context, request) => {
				return context === this.context
					? getContextifyInContext()(request)
					: getContextify()(context, request);
			},
			createHash: type => {
				return createHash(type || compilation.outputOptions.hashFunction);
			}
		};
		const loaderContext = {
			version: 2,
			getOptions: schema => {
				const loader = this.getCurrentLoader(loaderContext);

				let { options } = loader;

				if (typeof options === "string") {
					if (options.substr(0, 1) === "{" && options.substr(-1) === "}") {
						try {
							options = parseJson(options);
						} catch (e) {
							throw new Error(`Cannot parse string options: ${e.message}`);
diff --git a/a.js b/b.js
@@ -379,7 +379,7 @@ constructor({
A blob:a6895d7e5577c73bb7fd5c5bf83dcdf6711a94a2
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], Module | false | void>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], Module>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], false | void>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], false | void>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], Module | void>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], Module>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);
		const cachedParseResourceWithoutFragment =
			parseResourceWithoutFragment.bindCache(associatedObjectForCache);
		this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment;

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(
										/** @type {NormalModuleCreateData} */ (createData)
									);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {ParsedLoaderRequest[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

diff --git a/a.js b/b.js
@@ -437,7 +437,7 @@ constructor({
A blob:a6895d7e5577c73bb7fd5c5bf83dcdf6711a94a2
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], Module | false | void>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], Module>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], false | void>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], false | void>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], Module | void>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], Module>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);
		const cachedParseResourceWithoutFragment =
			parseResourceWithoutFragment.bindCache(associatedObjectForCache);
		this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment;

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(
										/** @type {NormalModuleCreateData} */ (createData)
									);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {ParsedLoaderRequest[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

					scheme = getScheme(requestWithoutMatchResource);

					if (!scheme && !contextScheme) {
						const firstChar = requestWithoutMatchResource.charCodeAt(0);
						const secondChar = requestWithoutMatchResource.charCodeAt(1);
						noPreAutoLoaders = firstChar === 45 && secondChar === 33; // startsWith "-!"
						noAutoLoaders = noPreAutoLoaders || firstChar === 33; // startsWith "!"
						noPrePostAutoLoaders = firstChar === 33 && secondChar === 33; // startsWith "!!";
						const rawElements = requestWithoutMatchResource
							.slice(
								noPreAutoLoaders || noPrePostAutoLoaders
									? 2
									: noAutoLoaders
									? 1
									: 0
							)
							.split(/!+/);
						unresolvedResource = rawElements.pop();
						elements = rawElements.map(el => {
							const { path, query } = cachedParseResourceWithoutFragment(el);
							return {
								loader: path,
								options: query ? query.slice(1) : undefined
							};
						});
						scheme = getScheme(unresolvedResource);
					} else {
						unresolvedResource = requestWithoutMatchResource;
						elements = EMPTY_ELEMENTS;
					}
				} else {
					unresolvedResource = request;
					elements = EMPTY_ELEMENTS;
				}

				const resolveContext = {
					fileDependencies,
					missingDependencies,
					contextDependencies
				};

				/** @type {ResourceDataWithData} */
				let resourceData;

				let loaders;

				const continueCallback = needCalls(2, err => {
					if (err) return callback(err);

					// translate option idents
					try {
						for (const item of loaders) {
							if (typeof item.options === "string" && item.options[0] === "?") {
								const ident = item.options.substr(1);
								if (ident === "[[missing ident]]") {
									throw new Error(
										"No ident is provided by referenced loader. " +
											"When using a function for Rule.use in config you need to " +
diff --git a/a.js b/b.js
@@ -28,8 +28,8 @@ const splitContextFromPrefix = prefix => {
A blob:488ed9a1db3fe94e242443beb30fdce72c7f8e55
 */
const quoteMeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

const splitContextFromPrefix = prefix => {
	const idx = prefix.lastIndexOf("/");
	let context = ".";
	if (idx >= 0) {
		context = prefix.substr(0, idx);
		prefix = `.${prefix.substr(idx)}`;
	}
	return {
		context,
		prefix
diff --git a/a.js b/b.js
@@ -64,8 +64,8 @@ apply(compiler) {
A blob:585e12cff99cd20ce7bf1ee6f6c79d175ffcd734
			hashDigestLength: 4,
			...options
		};
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("HashedModuleIdsPlugin", compilation => {
			compilation.hooks.moduleIds.tap("HashedModuleIdsPlugin", () => {
				const chunkGraph = compilation.chunkGraph;
				const context = this.options.context
					? this.options.context
					: compiler.context;

				const [usedIds, modules] = getUsedModuleIdsAndModules(compilation);
				const modulesInNaturalOrder = modules.sort(
					compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph)
				);
				for (const module of modulesInNaturalOrder) {
					const ident = getFullModuleName(module, context, compiler.root);
					const hash = createHash(options.hashFunction);
					hash.update(ident || "");
					const hashId = /** @type {string} */ (
						hash.digest(options.hashDigest)
					);
					let len = options.hashDigestLength;
					while (usedIds.has(hashId.substr(0, len))) len++;
					const moduleId = hashId.substr(0, len);
					chunkGraph.setModuleId(module, moduleId);
					usedIds.add(moduleId);
				}
			});
diff --git a/a.js b/b.js
@@ -25,7 +25,7 @@ const getHash = (str, len, hashFunction) => {
A blob:9e011cf8b43a808675bb56a28929812c479b4b8d
 * @param {string} str string to hash
 * @param {number} len max length of the hash
 * @param {string | Hash} hashFunction hash function to use
 * @returns {string} hash
 */
const getHash = (str, len, hashFunction) => {
	const hash = createHash(hashFunction);
	hash.update(str);
	const digest = /** @type {string} */ (hash.digest("hex"));
	return digest.substr(0, len);
};

/**
 * @param {string} str the string
diff --git a/a.js b/b.js
@@ -2155,7 +2155,7 @@ const MODULES_GROUPERS = type =>
A blob:b99ce1708eb599cfe37efbf0f8d85f88469d5130
		});
	}
};

/** @type {function("module" | "chunk" | "root-of-chunk" | "nested"): Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */
const MODULES_GROUPERS = type => ({
	_: (groupConfigs, context, options) => {
		const groupByFlag = (name, type, exclude) => {
			groupConfigs.push({
				getKeys: module => {
					return module[name] ? ["1"] : undefined;
				},
				getOptions: () => {
					return {
						groupChildren: !exclude,
						force: exclude
					};
				},
				createGroup: (key, children, modules) => {
					return {
						type,
						[name]: !!key,
						...(exclude ? { filteredChildren: modules.length } : { children }),
						...moduleGroup(children, modules)
					};
				}
			});
		};
		const {
			groupModulesByCacheStatus,
			groupModulesByLayer,
			groupModulesByAttributes,
			groupModulesByType,
			groupModulesByPath,
			groupModulesByExtension
		} = options;
		if (groupModulesByAttributes) {
			groupByFlag("errors", "modules with errors");
			groupByFlag("warnings", "modules with warnings");
			groupByFlag("assets", "modules with assets");
			groupByFlag("optional", "optional modules");
		}
		if (groupModulesByCacheStatus) {
			groupByFlag("cacheable", "cacheable modules");
			groupByFlag("built", "built modules");
			groupByFlag("codeGenerated", "code generated modules");
		}
		if (groupModulesByCacheStatus || !options.cachedModules) {
			groupByFlag("cached", "cached modules", !options.cachedModules);
		}
		if (groupModulesByAttributes || !options.orphanModules) {
			groupByFlag("orphan", "orphan modules", !options.orphanModules);
		}
		if (groupModulesByAttributes || !options.dependentModules) {
			groupByFlag("dependent", "dependent modules", !options.dependentModules);
		}
		if (groupModulesByType || !options.runtimeModules) {
			groupConfigs.push({
				getKeys: module => {
					if (!module.moduleType) return;
					if (groupModulesByType) {
						return [module.moduleType.split("/", 1)[0]];
					} else if (module.moduleType === "runtime") {
						return ["runtime"];
					}
				},
				getOptions: key => {
					const exclude = key === "runtime" && !options.runtimeModules;
					return {
						groupChildren: !exclude,
						force: exclude
					};
				},
				createGroup: (key, children, modules) => {
					const exclude = key === "runtime" && !options.runtimeModules;
					return {
						type: `${key} modules`,
						moduleType: key,
						...(exclude ? { filteredChildren: modules.length } : { children }),
						...moduleGroup(children, modules)
					};
				}
			});
		}
		if (groupModulesByLayer) {
			groupConfigs.push({
				getKeys: module => {
					return [module.layer];
				},
				createGroup: (key, children, modules) => {
					return {
						type: "modules by layer",
						layer: key,
						children,
						...moduleGroup(children, modules)
					};
				}
			});
		}
		if (groupModulesByPath || groupModulesByExtension) {
			groupConfigs.push({
				getKeys: module => {
					if (!module.name) return;
					const resource = parseResource(module.name.split("!").pop()).path;
					const dataUrl = /^data:[^,;]+/.exec(resource);
					if (dataUrl) return [dataUrl[0]];
					const extensionMatch =
						groupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);
					const extension = extensionMatch ? extensionMatch[1] : "";
					const pathMatch =
						groupModulesByPath && GROUP_PATH_REGEXP.exec(resource);
					const path = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
					const keys = [];
					if (groupModulesByPath) {
						if (extension)
							keys.push(
								path.length
									? `${path.join("/")}/*${extension}`
									: `*${extension}`
							);
						while (path.length > 0) {
							keys.push(path.join("/") + "/");
							path.pop();
						}
					} else {
						if (extension) keys.push(`*${extension}`);
					}
					return keys;
				},
				createGroup: (key, children, modules) => {
					const isDataUrl = key.startsWith("data:");
					return {
						type: isDataUrl
							? "modules by mime type"
							: groupModulesByPath
							? "modules by path"
							: "modules by extension",
						name: isDataUrl ? key.slice(/* 'data:'.length */ 5) : key,
						children,
						...moduleGroup(children, modules)
					};
				}
			});
		}
	},
	excludeModules: (groupConfigs, context, { excludeModules }) => {
		groupConfigs.push({
			getKeys: module => {
				const name = module.name;
				if (name) {
					const excluded = excludeModules.some(fn => fn(name, module, type));
					if (excluded) return ["1"];
				}
			},
			getOptions: () => ({
				groupChildren: false,
				force: true
			}),
			createGroup: (key, children, modules) => ({
				type: "hidden modules",
				filteredChildren: children.length,
				...moduleGroup(children, modules)
			})
		});
	}
});

/** @type {Record<string, Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */
const RESULT_GROUPERS = {
	"compilation.assets": ASSETS_GROUPERS,
	"asset.related": ASSETS_GROUPERS,
	"compilation.modules": MODULES_GROUPERS("module"),
	"chunk.modules": MODULES_GROUPERS("chunk"),
	"chunk.rootModules": MODULES_GROUPERS("root-of-chunk"),
	"module.modules": MODULES_GROUPERS("nested"),
	"module.reasons": {
		groupReasonsByOrigin: groupConfigs => {
			groupConfigs.push({
				getKeys: reason => {
					return [reason.module];
				},
				createGroup: (key, children, reasons) => {
					return {
						type: "from origin",
						module: key,
						children,
						...reasonGroup(children, reasons)
					};
				}
			});
		}
	}
};

// remove a prefixed "!" that can be specified to reverse sort order
const normalizeFieldKey = field => {
	if (field[0] === "!") {
		return field.substr(1);
	}
	return field;
};

diff --git a/a.js b/b.js
@@ -22,8 +22,8 @@ describe("Examples", () => {
A blob:39a39608a169ab0599257582488fe40733307187
require("./helpers/warmup-webpack");

const path = require("path");
const fs = require("graceful-fs");

describe("Examples", () => {
	const basePath = path.join(__dirname, "..", "examples");
	const examples = require("../examples/examples.js");

	examples.forEach(examplePath => {
		const filterPath = path.join(examplePath, "test.filter.js");
		const relativePath = path.relative(basePath, examplePath);
		if (fs.existsSync(filterPath) && !require(filterPath)()) {
			describe.skip(relativePath, () => it("filtered"));
			return;
		}
		it(
			"should compile " + relativePath,
			function (done) {
				let options = {};
				let webpackConfigPath = path.join(examplePath, "webpack.config.js");
				webpackConfigPath =
					webpackConfigPath.substr(0, 1).toUpperCase() +
					webpackConfigPath.substr(1);
				if (fs.existsSync(webpackConfigPath))
					options = require(webpackConfigPath);
				if (typeof options === "function") options = options();
				if (Array.isArray(options)) options.forEach(processOptions);
diff --git a/a.js b/b.js
@@ -249,7 +249,7 @@ describe(config.name, () => {
A blob:8c086f5fd2e9974c45de2ab7f7c669fbcd72afb5
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		categories.forEach(category => {
			describe(category.name, () => {
				category.tests.forEach(testName => {
					const testDirectory = path.join(casesPath, category.name, testName);
					const filterPath = path.join(testDirectory, "test.filter.js");
					if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
						describe.skip(testName, () => {
							it("filtered", () => {});
						});
						return;
					}
					describe(testName, () => {
						let compiler;
						afterAll(callback => {
							compiler.close(callback);
							compiler = undefined;
						});

						it(
							testName + " should compile",
							done => {
								const webpack = require("..");
								const outputDirectory = path.join(
									__dirname,
									"js",
									`hot-cases-${config.name}`,
									category.name,
									testName
								);
								rimraf.sync(outputDirectory);
								const recordsPath = path.join(outputDirectory, "records.json");
								const fakeUpdateLoaderOptions = {
									updateIndex: 0
								};
								const configPath = path.join(
									testDirectory,
									"webpack.config.js"
								);
								let options = {};
								if (fs.existsSync(configPath)) options = require(configPath);
								if (typeof options === "function") {
									options = options({ config });
								}
								if (!options.mode) options.mode = "development";
								if (!options.devtool) options.devtool = false;
								if (!options.context) options.context = testDirectory;
								if (!options.entry) options.entry = "./index.js";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (!options.output.filename)
									options.output.filename = "bundle.js";
								if (!options.output.chunkFilename)
									options.output.chunkFilename = "[name].chunk.[fullhash].js";
								if (options.output.pathinfo === undefined)
									options.output.pathinfo = true;
								if (options.output.publicPath === undefined)
									options.output.publicPath = "https://test.cases/path/";
								if (options.output.library === undefined)
									options.output.library = { type: "commonjs2" };
								if (!options.optimization) options.optimization = {};
								if (!options.optimization.moduleIds)
									options.optimization.moduleIds = "named";
								if (!options.module) options.module = {};
								if (!options.module.rules) options.module.rules = [];
								options.module.rules.push({
									loader: path.join(
										__dirname,
										"hotCases",
										"fake-update-loader.js"
									),
									enforce: "pre"
								});
								if (!options.target) options.target = config.target;
								if (!options.plugins) options.plugins = [];
								options.plugins.push(
									new webpack.HotModuleReplacementPlugin(),
									new webpack.LoaderOptionsPlugin(fakeUpdateLoaderOptions)
								);
								if (!options.recordsPath) options.recordsPath = recordsPath;
								compiler = webpack(options);
								compiler.run((err, stats) => {
									if (err) return done(err);
									const jsonStats = stats.toJson({
										errorDetails: true
									});
									if (
										checkArrayExpectation(
											testDirectory,
											jsonStats,
											"error",
											"Error",
											done
										)
									) {
										return;
									}
									if (
										checkArrayExpectation(
											testDirectory,
											jsonStats,
											"warning",
											"Warning",
											done
										)
									) {
										return;
									}

									const urlToPath = url => {
										if (url.startsWith("https://test.cases/path/"))
											url = url.slice(24);
										return path.resolve(outputDirectory, `./${url}`);
									};
									const urlToRelativePath = url => {
										if (url.startsWith("https://test.cases/path/"))
											url = url.slice(24);
										return `./${url}`;
									};
									const window = {
										fetch: async url => {
											try {
												const buffer = await new Promise((resolve, reject) =>
													fs.readFile(urlToPath(url), (err, b) =>
														err ? reject(err) : resolve(b)
													)
												);
												return {
													status: 200,
													ok: true,
													json: async () => JSON.parse(buffer.toString("utf-8"))
												};
											} catch (err) {
												if (err.code === "ENOENT") {
													return {
														status: 404,
														ok: false
													};
												}
												throw err;
											}
										},
										importScripts: url => {
											expect(url).toMatch(/^https:\/\/test\.cases\/path\//);
											_require(urlToRelativePath(url));
										},
										document: {
											createElement(type) {
												return {
													_type: type,
													_attrs: {},
													setAttribute(name, value) {
														this._attrs[name] = value;
													},
													parentNode: {
														removeChild(node) {
															// ok
														}
													}
												};
											},
											head: {
												appendChild(element) {
													if (element._type === "script") {
														// run it
														Promise.resolve().then(() => {
															_require(urlToRelativePath(element.src));
														});
													}
												}
											},
											getElementsByTagName(name) {
												if (name === "head") return [this.head];
												if (name === "script") return [];
												throw new Error("Not supported");
											}
										},
										Worker: require("./helpers/createFakeWorker")({
											outputDirectory
										}),
										EventSource: require("./helpers/EventSourceForNode"),
										location: {
											href: "https://test.cases/path/index.html",
											origin: "https://test.cases",
											toString() {
												return "https://test.cases/path/index.html";
											}
										}
									};

									function _next(callback) {
										fakeUpdateLoaderOptions.updateIndex++;
										compiler.run((err, stats) => {
											if (err) return callback(err);
											const jsonStats = stats.toJson({
												errorDetails: true
											});
											if (
												checkArrayExpectation(
													testDirectory,
													jsonStats,
													"error",
													"errors" + fakeUpdateLoaderOptions.updateIndex,
													"Error",
													callback
												)
											) {
												return;
											}
											if (
												checkArrayExpectation(
													testDirectory,
													jsonStats,
													"warning",
													"warnings" + fakeUpdateLoaderOptions.updateIndex,
													"Warning",
													callback
												)
											) {
												return;
											}
											callback(null, jsonStats);
										});
									}

									function _require(module) {
										if (module.substr(0, 2) === "./") {
											const p = path.join(outputDirectory, module);
											if (module.endsWith(".json")) {
												return JSON.parse(fs.readFileSync(p, "utf-8"));
											} else {
diff --git a/a.js b/b.js
@@ -256,7 +256,7 @@ describe("JavascriptParser", () => {
A blob:813f07fc69dee839710e13fd1ebc30d11f2f1b80

// cspell:ignore fghsub notry fghsub notry notry this's ijksub this's ijksub fghsub fghsub notry ijksub ijksub strrring strrring strr strrring strrring strr Sstrrringy strone stronetwo stronetwothree stronetwo stronetwothree stronetwothreefour onetwo onetwo twothree twothree twothree threefour onetwo onetwo threefour threefour fourfive startstrmid igmy igmyi igmya
const BasicEvaluatedExpression = require("../lib/javascript/BasicEvaluatedExpression");
const JavascriptParser = require("../lib/javascript/JavascriptParser");

describe("JavascriptParser", () => {
	/* eslint-disable no-undef */
	/* eslint-disable no-unused-vars */
	/* eslint-disable no-inner-declarations */
	const testCases = {
		"call ident": [
			function () {
				abc("test");
			},
			{
				abc: ["test"]
			}
		],
		"call member": [
			function () {
				cde.abc("membertest");
			},
			{
				cdeabc: ["membertest"]
			}
		],
		"call member using bracket notation": [
			function () {
				cde["abc"]("membertest");
			},
			{
				cdeabc: ["membertest"]
			}
		],
		"call inner member": [
			function () {
				cde.ddd.abc("inner");
			},
			{
				cdedddabc: ["inner"]
			}
		],
		"call inner member using bracket notation": [
			function () {
				cde.ddd["abc"]("inner");
			},
			{
				cdedddabc: ["inner"]
			}
		],
		expression: [
			function () {
				fgh;
			},
			{
				fgh: [""]
			}
		],
		"expression sub": [
			function () {
				fgh.sub;
			},
			{
				fghsub: ["notry"]
			}
		],
		"member expression": [
			function () {
				test[memberExpr];
				test[+memberExpr];
			},
			{
				expressions: ["memberExpr", "memberExpr"]
			}
		],
		"in function definition": [
			function () {
				(function (abc, cde, fgh) {
					abc("test");
					cde.abc("test");
					cde.ddd.abc("test");
					fgh;
					fgh.sub;
				})();
			},
			{}
		],
		"const definition": [
			function () {
				let abc, cde, fgh;
				abc("test");
				cde.abc("test");
				cde.ddd.abc("test");
				fgh;
				fgh.sub;
			},
			{}
		],
		"var definition": [
			function () {
				var abc, cde, fgh;
				abc("test");
				cde.abc("test");
				cde.ddd.abc("test");
				fgh;
				fgh.sub;
			},
			{}
		],
		"function definition": [
			function () {
				function abc() {}

				function cde() {}

				function fgh() {}
				abc("test");
				cde.abc("test");
				cde.ddd.abc("test");
				fgh;
				fgh.sub;
			},
			{}
		],
		"class definition": [
			function () {
				class memberExpr {
					cde() {
						abc("cde");
					}
					static fgh() {
						abc("fgh");
						fgh();
					}
				}
			},
			{
				abc: ["cde", "fgh"],
				fgh: ["memberExpr"]
			}
		],
		"in try": [
			function () {
				try {
					fgh.sub;
					fgh;

					function test(ttt) {
						fgh.sub;
						fgh;
					}
				} catch (e) {
					fgh.sub;
					fgh;
				}
			},
			{
				fghsub: ["try", "notry", "notry"],
				fgh: ["test", "test ttt", "test e"]
			}
		],
		"renaming with const": [
			function () {
				const xyz = abc;
				xyz("test");
			},
			{
				abc: ["test"]
			}
		],
		"renaming with var": [
			function () {
				var xyz = abc;
				xyz("test");
			},
			{
				abc: ["test"]
			}
		],
		"renaming with assignment": [
			function () {
				const xyz = abc;
				xyz("test");
			},
			{
				abc: ["test"]
			}
		],
		"renaming with IIFE": [
			function () {
				!(function (xyz) {
					xyz("test");
				})(abc);
			},
			{
				abc: ["test"]
			}
		],
		"renaming arguments with IIFE (called)": [
			function () {
				!function (xyz) {
					xyz("test");
				}.call(fgh, abc);
			},
			{
				abc: ["test"],
				fgh: [""]
			}
		],
		"renaming this's properties with IIFE (called)": [
			function () {
				!function () {
					this.sub;
				}.call(ijk);
			},
			{
				ijksub: ["test"]
			}
		],
		"renaming this's properties with nested IIFE (called)": [
			function () {
				!function () {
					!function () {
						this.sub;
					}.call(this);
				}.call(ijk);
			},
			{
				ijksub: ["test"]
			}
		],
		"new Foo(...)": [
			function () {
				new xyz("membertest");
			},
			{
				xyz: ["membertest"]
			}
		],
		"spread calls/literals": [
			function () {
				var xyz = [...abc("xyz"), cde];
				Math.max(...fgh);
			},
			{
				abc: ["xyz"],
				fgh: ["xyz"]
			}
		]
	};
	/* eslint-enable no-undef */
	/* eslint-enable no-unused-vars */
	/* eslint-enable no-inner-declarations */

	Object.keys(testCases).forEach(name => {
		it("should parse " + name, () => {
			let source = testCases[name][0].toString();
			source = source.substr(13, source.length - 14).trim();
			const state = testCases[name][1];

			const testParser = new JavascriptParser({});
			testParser.hooks.canRename
diff --git a/a.js b/b.js
@@ -541,12 +541,12 @@ describe("expression evaluation", () => {
A blob:813f07fc69dee839710e13fd1ebc30d11f2f1b80
			expect(element.type).toBe(state[index].type);
			expect(element.value).toBe(state[index].value);
		});
	});

	describe("expression evaluation", () => {
		function evaluateInParser(source) {
			const parser = new JavascriptParser();
			parser.hooks.call.for("test").tap("JavascriptParserTest", expr => {
				parser.state.result = parser.evaluateExpression(expr.arguments[0]);
			});
			parser.hooks.evaluateIdentifier
				.for("aString")
				.tap("JavascriptParserTest", expr =>
					new BasicEvaluatedExpression()
						.setString("aString")
						.setRange(expr.range)
				);
			parser.hooks.evaluateIdentifier
				.for("b.Number")
				.tap("JavascriptParserTest", expr =>
					new BasicEvaluatedExpression().setNumber(123).setRange(expr.range)
				);
			return parser.parse("test(" + source + ");", {}).result;
		}

		const testCases = {
			true: "bool=true",
			false: "bool=false",
			"!true": "bool=false",
			"!false": "bool=true",
			'"strrring"': "string=strrring",
			'"strr" + "ring"': "string=strrring",
			'"s" + ("trr" + "rin") + "g"': "string=strrring",
			"'S' + (\"strr\" + \"ring\") + 'y'": "string=Sstrrringy",
			"/abc/": "regExp=/abc/",
			1: "number=1",
			"1 + 3": "number=4",
			"3 - 1": "number=2",
			"2 * 3": "number=6",
			"8 / 2": "number=4",
			"2 ** 3": "number=8",
			"12 & 5": "number=4",
			"12 | 5": "number=13",
			"12 ^ 5": "number=9",
			"9 >>> 2": "number=2",
			"9 >> 2": "number=2",
			"9 << 2": "number=36",
			"~3": "number=-4",
			"1 == 1": "bool=true",
			"1 === 1": "bool=true",
			"3 != 1": "bool=true",
			"3 !== 1": "bool=true",
			"3 == 1": "bool=false",
			"3 === 1": "bool=false",
			"1 != 1": "bool=false",
			"1 !== 1": "bool=false",
			100.25: "number=100.25",
			"!100.25": "bool=false",
			"!+100.25": "bool=false",
			"!-100.25": "bool=false",
			0: "number=0",
			"!0": "bool=true",
			"!-0": "bool=true",
			"!+0": "bool=true",
			"20n": "bigint=20",
			"10n + 10n": "bigint=20",
			"10n - 5n": "bigint=5",
			"10n * 5n": "bigint=50",
			"10n / 5n": "bigint=2",
			"5n ** 2n": "bigint=25",
			"5n == 5n": "bool=true",
			"5n === 5n": "bool=true",
			"5n != 5n": "bool=false",
			"5n !== 5n": "bool=false",
			"5n != 1n": "bool=true",
			"5n !== 1n": "bool=true",
			"5n & 3n": "bigint=1",
			"5n | 2n": "bigint=7",
			"5n ^ 2n": "bigint=7",
			"5n >> 2n": "bigint=1",
			"5n << 2n": "bigint=20",
			"null == null": "bool=true",
			"null === null": "bool=true",
			"null != null": "bool=false",
			"null !== null": "bool=false",
			"true === false": "bool=false",
			"false !== false": "bool=false",
			"true == true": "bool=true",
			"false != true": "bool=true",
			"!'a'": "bool=false",
			"!''": "bool=true",
			"!null": "bool=true",
			"'pre' + a": "wrapped=['pre' string=pre]+[null]",
			"a + 'post'": "wrapped=[null]+['post' string=post]",
			"'pre' + a + 'post'": "wrapped=['pre' string=pre]+['post' string=post]",
			"1 + a + 2": "",
			"1 + a + 'post'": "wrapped=[null]+['post' string=post]",
			"'' + 1 + a + 2": "wrapped=['' + 1 string=1]+[2 string=2]",
			"'' + 1 + a + 2 + 3": "wrapped=['' + 1 string=1]+[2 + 3 string=23]",
			"'' + 1 + a + (2 + 3)": "wrapped=['' + 1 string=1]+[2 + 3 string=5]",
			"'pre' + (1 + a) + (2 + 3)":
				"wrapped=['pre' string=pre]+[2 + 3 string=5]",
			"a ? 'o1' : 'o2'": "options=['o1' string=o1],['o2' string=o2]",
			"a ? 'o1' : b ? 'o2' : 'o3'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3]",
			"a ? (b ? 'o1' : 'o2') : 'o3'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3]",
			"a ? (b ? 'o1' : 'o2') : c ? 'o3' : 'o4'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3],['o4' string=o4]",
			"a ? 'o1' : b ? 'o2' : c ? 'o3' : 'o4'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3],['o4' string=o4]",
			"a ? 'o1' : b ? b : c ? 'o3' : c":
				"options=['o1' string=o1],[b],['o3' string=o3],[c]",
			"['i1', 'i2', 3, a, b ? 4 : 5]":
				"items=['i1' string=i1],['i2' string=i2],[3 number=3],[a],[b ? 4 : 5 options=[4 number=4],[5 number=5]]",
			"typeof 'str'": "string=string",
			"typeof aString": "string=string",
			"typeof b.Number": "string=number",
			"typeof b['Number']": "string=number",
			"typeof b[Number]": "",
			"typeof true": "string=boolean",
			"typeof null": "string=object",
			"typeof 1": "string=number",
			"typeof 1n": "string=bigint",
			"b.Number": "number=123",
			"b['Number']": "number=123",
			"b[Number]": "",
			"'str'.concat()": "string=str",
			"'str'.concat('one')": "string=strone",
			"'str'.concat('one').concat('two')": "string=stronetwo",
			"'str'.concat('one').concat('two', 'three')": "string=stronetwothree",
			"'str'.concat('one', 'two')": "string=stronetwo",
			"'str'.concat('one', 'two').concat('three')": "string=stronetwothree",
			"'str'.concat('one', 'two').concat('three', 'four')":
				"string=stronetwothreefour",
			"'str'.concat('one', obj)": "wrapped=['str' string=str]+[null]",
			"'str'.concat('one', obj).concat()": "wrapped=['str' string=str]+[null]",
			"'str'.concat('one', obj, 'two')":
				"wrapped=['str' string=str]+['two' string=two]",
			"'str'.concat('one', obj, 'two').concat()":
				"wrapped=['str' string=str]+['two' string=two]",
			"'str'.concat('one', obj, 'two').concat('three')":
				"wrapped=['str' string=str]+['three' string=three]",
			"'str'.concat(obj)": "wrapped=['str' string=str]+[null]",
			"'str'.concat(obj).concat()": "wrapped=['str' string=str]+[null]",
			"'str'.concat(obj).concat('one', 'two')":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj).concat(obj, 'one')":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj).concat(obj, 'one', 'two')":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj).concat('one', obj, 'one')":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj).concat('one', obj, 'two', 'three')":
				"wrapped=['str' string=str]+['two', 'three' string=twothree]",
			"'str'.concat(obj, 'one')":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj, 'one').concat()":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj, 'one').concat('two', 'three')":
				"wrapped=['str' string=str]+['two', 'three' string=twothree]",
			"'str'.concat(obj, 'one').concat(obj, 'two', 'three')":
				"wrapped=['str' string=str]+['two', 'three' string=twothree]",
			"'str'.concat(obj, 'one').concat('two', obj, 'three')":
				"wrapped=['str' string=str]+['three' string=three]",
			"'str'.concat(obj, 'one').concat('two', obj, 'three', 'four')":
				"wrapped=['str' string=str]+['three', 'four' string=threefour]",
			"'str'.concat(obj, 'one', 'two')":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj, 'one', 'two').concat()":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj, 'one', 'two').concat('three', 'four')":
				"wrapped=['str' string=str]+['three', 'four' string=threefour]",
			"'str'.concat(obj, 'one', 'two').concat(obj, 'three', 'four')":
				"wrapped=['str' string=str]+['three', 'four' string=threefour]",
			"'str'.concat(obj, 'one', 'two').concat('three', obj, 'four')":
				"wrapped=['str' string=str]+['four' string=four]",
			"'str'.concat(obj, 'one', 'two').concat('three', obj, 'four', 'five')":
				"wrapped=['str' string=str]+['four', 'five' string=fourfive]",
			// eslint-disable-next-line no-template-curly-in-string
			"`start${obj}mid${obj2}end`":
				"template=[start string=start],[mid string=mid],[end string=end]",
			// eslint-disable-next-line no-template-curly-in-string
			"`start${'str'}mid${obj2}end`":
				// eslint-disable-next-line no-template-curly-in-string
				"template=[start${'str'}mid string=startstrmid],[end string=end]",
			"'abc'.substr(1)": "string=bc",
			"'abcdef'.substr(2, 3)": "string=cde",
			"'abcdef'.substring(2, 3)": "string=c",
			"'abcdef'.substring(2, 3, 4)": "",
			"'abc'[\"substr\"](1)": "string=bc",
			"'abc'[substr](1)": "",
			"'1,2+3'.split(/[,+]/)": "array=[1],[2],[3]",
			"'1,2+3'.split(expr)": "",
			"'a' + (expr + 'c')": "wrapped=['a' string=a]+['c' string=c]",
			"1 + 'a'": "string=1a",
diff --git a/a.js b/b.js
@@ -596,7 +596,7 @@ describe("expression evaluation", () => {
A blob:813f07fc69dee839710e13fd1ebc30d11f2f1b80
			expect(element.type).toBe(state[index].type);
			expect(element.value).toBe(state[index].value);
		});
	});

	describe("expression evaluation", () => {
		function evaluateInParser(source) {
			const parser = new JavascriptParser();
			parser.hooks.call.for("test").tap("JavascriptParserTest", expr => {
				parser.state.result = parser.evaluateExpression(expr.arguments[0]);
			});
			parser.hooks.evaluateIdentifier
				.for("aString")
				.tap("JavascriptParserTest", expr =>
					new BasicEvaluatedExpression()
						.setString("aString")
						.setRange(expr.range)
				);
			parser.hooks.evaluateIdentifier
				.for("b.Number")
				.tap("JavascriptParserTest", expr =>
					new BasicEvaluatedExpression().setNumber(123).setRange(expr.range)
				);
			return parser.parse("test(" + source + ");", {}).result;
		}

		const testCases = {
			true: "bool=true",
			false: "bool=false",
			"!true": "bool=false",
			"!false": "bool=true",
			'"strrring"': "string=strrring",
			'"strr" + "ring"': "string=strrring",
			'"s" + ("trr" + "rin") + "g"': "string=strrring",
			"'S' + (\"strr\" + \"ring\") + 'y'": "string=Sstrrringy",
			"/abc/": "regExp=/abc/",
			1: "number=1",
			"1 + 3": "number=4",
			"3 - 1": "number=2",
			"2 * 3": "number=6",
			"8 / 2": "number=4",
			"2 ** 3": "number=8",
			"12 & 5": "number=4",
			"12 | 5": "number=13",
			"12 ^ 5": "number=9",
			"9 >>> 2": "number=2",
			"9 >> 2": "number=2",
			"9 << 2": "number=36",
			"~3": "number=-4",
			"1 == 1": "bool=true",
			"1 === 1": "bool=true",
			"3 != 1": "bool=true",
			"3 !== 1": "bool=true",
			"3 == 1": "bool=false",
			"3 === 1": "bool=false",
			"1 != 1": "bool=false",
			"1 !== 1": "bool=false",
			100.25: "number=100.25",
			"!100.25": "bool=false",
			"!+100.25": "bool=false",
			"!-100.25": "bool=false",
			0: "number=0",
			"!0": "bool=true",
			"!-0": "bool=true",
			"!+0": "bool=true",
			"20n": "bigint=20",
			"10n + 10n": "bigint=20",
			"10n - 5n": "bigint=5",
			"10n * 5n": "bigint=50",
			"10n / 5n": "bigint=2",
			"5n ** 2n": "bigint=25",
			"5n == 5n": "bool=true",
			"5n === 5n": "bool=true",
			"5n != 5n": "bool=false",
			"5n !== 5n": "bool=false",
			"5n != 1n": "bool=true",
			"5n !== 1n": "bool=true",
			"5n & 3n": "bigint=1",
			"5n | 2n": "bigint=7",
			"5n ^ 2n": "bigint=7",
			"5n >> 2n": "bigint=1",
			"5n << 2n": "bigint=20",
			"null == null": "bool=true",
			"null === null": "bool=true",
			"null != null": "bool=false",
			"null !== null": "bool=false",
			"true === false": "bool=false",
			"false !== false": "bool=false",
			"true == true": "bool=true",
			"false != true": "bool=true",
			"!'a'": "bool=false",
			"!''": "bool=true",
			"!null": "bool=true",
			"'pre' + a": "wrapped=['pre' string=pre]+[null]",
			"a + 'post'": "wrapped=[null]+['post' string=post]",
			"'pre' + a + 'post'": "wrapped=['pre' string=pre]+['post' string=post]",
			"1 + a + 2": "",
			"1 + a + 'post'": "wrapped=[null]+['post' string=post]",
			"'' + 1 + a + 2": "wrapped=['' + 1 string=1]+[2 string=2]",
			"'' + 1 + a + 2 + 3": "wrapped=['' + 1 string=1]+[2 + 3 string=23]",
			"'' + 1 + a + (2 + 3)": "wrapped=['' + 1 string=1]+[2 + 3 string=5]",
			"'pre' + (1 + a) + (2 + 3)":
				"wrapped=['pre' string=pre]+[2 + 3 string=5]",
			"a ? 'o1' : 'o2'": "options=['o1' string=o1],['o2' string=o2]",
			"a ? 'o1' : b ? 'o2' : 'o3'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3]",
			"a ? (b ? 'o1' : 'o2') : 'o3'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3]",
			"a ? (b ? 'o1' : 'o2') : c ? 'o3' : 'o4'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3],['o4' string=o4]",
			"a ? 'o1' : b ? 'o2' : c ? 'o3' : 'o4'":
				"options=['o1' string=o1],['o2' string=o2],['o3' string=o3],['o4' string=o4]",
			"a ? 'o1' : b ? b : c ? 'o3' : c":
				"options=['o1' string=o1],[b],['o3' string=o3],[c]",
			"['i1', 'i2', 3, a, b ? 4 : 5]":
				"items=['i1' string=i1],['i2' string=i2],[3 number=3],[a],[b ? 4 : 5 options=[4 number=4],[5 number=5]]",
			"typeof 'str'": "string=string",
			"typeof aString": "string=string",
			"typeof b.Number": "string=number",
			"typeof b['Number']": "string=number",
			"typeof b[Number]": "",
			"typeof true": "string=boolean",
			"typeof null": "string=object",
			"typeof 1": "string=number",
			"typeof 1n": "string=bigint",
			"b.Number": "number=123",
			"b['Number']": "number=123",
			"b[Number]": "",
			"'str'.concat()": "string=str",
			"'str'.concat('one')": "string=strone",
			"'str'.concat('one').concat('two')": "string=stronetwo",
			"'str'.concat('one').concat('two', 'three')": "string=stronetwothree",
			"'str'.concat('one', 'two')": "string=stronetwo",
			"'str'.concat('one', 'two').concat('three')": "string=stronetwothree",
			"'str'.concat('one', 'two').concat('three', 'four')":
				"string=stronetwothreefour",
			"'str'.concat('one', obj)": "wrapped=['str' string=str]+[null]",
			"'str'.concat('one', obj).concat()": "wrapped=['str' string=str]+[null]",
			"'str'.concat('one', obj, 'two')":
				"wrapped=['str' string=str]+['two' string=two]",
			"'str'.concat('one', obj, 'two').concat()":
				"wrapped=['str' string=str]+['two' string=two]",
			"'str'.concat('one', obj, 'two').concat('three')":
				"wrapped=['str' string=str]+['three' string=three]",
			"'str'.concat(obj)": "wrapped=['str' string=str]+[null]",
			"'str'.concat(obj).concat()": "wrapped=['str' string=str]+[null]",
			"'str'.concat(obj).concat('one', 'two')":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj).concat(obj, 'one')":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj).concat(obj, 'one', 'two')":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj).concat('one', obj, 'one')":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj).concat('one', obj, 'two', 'three')":
				"wrapped=['str' string=str]+['two', 'three' string=twothree]",
			"'str'.concat(obj, 'one')":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj, 'one').concat()":
				"wrapped=['str' string=str]+['one' string=one]",
			"'str'.concat(obj, 'one').concat('two', 'three')":
				"wrapped=['str' string=str]+['two', 'three' string=twothree]",
			"'str'.concat(obj, 'one').concat(obj, 'two', 'three')":
				"wrapped=['str' string=str]+['two', 'three' string=twothree]",
			"'str'.concat(obj, 'one').concat('two', obj, 'three')":
				"wrapped=['str' string=str]+['three' string=three]",
			"'str'.concat(obj, 'one').concat('two', obj, 'three', 'four')":
				"wrapped=['str' string=str]+['three', 'four' string=threefour]",
			"'str'.concat(obj, 'one', 'two')":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj, 'one', 'two').concat()":
				"wrapped=['str' string=str]+['one', 'two' string=onetwo]",
			"'str'.concat(obj, 'one', 'two').concat('three', 'four')":
				"wrapped=['str' string=str]+['three', 'four' string=threefour]",
			"'str'.concat(obj, 'one', 'two').concat(obj, 'three', 'four')":
				"wrapped=['str' string=str]+['three', 'four' string=threefour]",
			"'str'.concat(obj, 'one', 'two').concat('three', obj, 'four')":
				"wrapped=['str' string=str]+['four' string=four]",
			"'str'.concat(obj, 'one', 'two').concat('three', obj, 'four', 'five')":
				"wrapped=['str' string=str]+['four', 'five' string=fourfive]",
			// eslint-disable-next-line no-template-curly-in-string
			"`start${obj}mid${obj2}end`":
				"template=[start string=start],[mid string=mid],[end string=end]",
			// eslint-disable-next-line no-template-curly-in-string
			"`start${'str'}mid${obj2}end`":
				// eslint-disable-next-line no-template-curly-in-string
				"template=[start${'str'}mid string=startstrmid],[end string=end]",
			"'abc'.substr(1)": "string=bc",
			"'abcdef'.substr(2, 3)": "string=cde",
			"'abcdef'.substring(2, 3)": "string=c",
			"'abcdef'.substring(2, 3, 4)": "",
			"'abc'[\"substr\"](1)": "string=bc",
			"'abc'[substr](1)": "",
			"'1,2+3'.split(/[,+]/)": "array=[1],[2],[3]",
			"'1,2+3'.split(expr)": "",
			"'a' + (expr + 'c')": "wrapped=['a' string=a]+['c' string=c]",
			"1 + 'a'": "string=1a",
			"'a' + 1": "string=a1",
			"'a' + expr + 1": "wrapped=['a' string=a]+[1 string=1]"
		};

		Object.keys(testCases).forEach(key => {
			function evalExprToString(evalExpr) {
				if (!evalExpr) {
					return "null";
				} else {
					const result = [];
					if (evalExpr.isString()) result.push("string=" + evalExpr.string);
					if (evalExpr.isNumber()) result.push("number=" + evalExpr.number);
					if (evalExpr.isBigInt()) result.push("bigint=" + evalExpr.bigint);
					if (evalExpr.isBoolean()) result.push("bool=" + evalExpr.bool);
					if (evalExpr.isRegExp()) result.push("regExp=" + evalExpr.regExp);
					if (evalExpr.isConditional())
						result.push(
							"options=[" +
								evalExpr.options.map(evalExprToString).join("],[") +
								"]"
						);
					if (evalExpr.isArray())
						result.push(
							"items=[" + evalExpr.items.map(evalExprToString).join("],[") + "]"
						);
					if (evalExpr.isConstArray())
						result.push("array=[" + evalExpr.array.join("],[") + "]");
					if (evalExpr.isTemplateString())
						result.push(
							"template=[" +
								evalExpr.quasis.map(evalExprToString).join("],[") +
								"]"
						);
					if (evalExpr.isWrapped())
						result.push(
							"wrapped=[" +
								evalExprToString(evalExpr.prefix) +
								"]+[" +
								evalExprToString(evalExpr.postfix) +
								"]"
						);
					if (evalExpr.range) {
						const start = evalExpr.range[0] - 5;
						const end = evalExpr.range[1] - 5;
						return (
							key.substr(start, end - start) +
							(result.length > 0 ? " " + result.join(" ") : "")
						);
					}
					return result.join(" ");
diff --git a/a.js b/b.js
@@ -427,7 +427,7 @@ describe(config.name, () => {
A blob:909b3989f0c0dbdb3c034bb5b3f913c2d275d9d0
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						let infraStructureLog = [];

						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								},
								infrastructureLogging: config.cache && {
									debug: true,
									console: createLogger(infraStructureLog)
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											const infrastructureLogErrors =
												filterInfraStructureErrors(infraStructureLog, {
													run: 1,
													options
												});
											if (
												infrastructureLogErrors.length &&
												checkArrayExpectation(
													testDirectory,
													{ infrastructureLogs: infrastructureLogErrors },
													"infrastructureLog",
													"infrastructure-log",
													"InfrastructureLog",
													done
												)
											) {
												return;
											}
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											const infrastructureLogErrors =
												filterInfraStructureErrors(infraStructureLog, {
													run: 2,
													options
												});
											if (
												infrastructureLogErrors.length &&
												checkArrayExpectation(
													testDirectory,
													{ infrastructureLogs: infrastructureLogErrors },
													"infrastructureLog",
													"infrastructure-log",
													"InfrastructureLog",
													done
												)
											) {
												return;
											}
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
								);
							}
							it(
								testName + " should compile",
								done => {
									infraStructureLog.length = 0;
									const webpack = require("..");
									const compiler = webpack(options);
									const run = () => {
										const deprecationTracker = deprecationTracking.start();
										compiler.run((err, stats) => {
											const deprecations = deprecationTracker();
											if (err) return done(err);
											const infrastructureLogErrors =
												filterInfraStructureErrors(infraStructureLog, {
													run: 3,
													options
												});
											if (
												infrastructureLogErrors.length &&
												checkArrayExpectation(
													testDirectory,
													{ infrastructureLogs: infrastructureLogErrors },
													"infrastructureLog",
													"infrastructure-log",
													"InfrastructureLog",
													done
												)
											) {
												return;
											}
											compiler.close(err => {
												if (err) return done(err);
												const statOptions = {
													preset: "verbose",
													colors: false,
													modules: true,
													reasonsSpace: 1000
												};
												fs.mkdirSync(outputDirectory, { recursive: true });
												fs.writeFileSync(
													path.join(outputDirectory, "stats.txt"),
													stats.toString(statOptions),
													"utf-8"
												);
												const jsonStats = stats.toJson({
													errorDetails: true,
													modules: false,
													assets: false,
													chunks: false
												});
												if (
													checkArrayExpectation(
														testDirectory,
														jsonStats,
														"error",
														"Error",
														done
													)
												) {
													return;
												}
												if (
													checkArrayExpectation(
														testDirectory,
														jsonStats,
														"warning",
														"Warning",
														done
													)
												) {
													return;
												}
												const infrastructureLogging = stderr.toString();
												if (infrastructureLogging) {
													done(
														new Error(
															"Errors/Warnings during build:\n" +
																infrastructureLogging
														)
													);
												}

												expect(deprecations).toEqual(config.deprecations || []);

												Promise.resolve().then(done);
											});
										});
									};
									if (config.cache) {
										// pre-compile to fill memory cache
										const deprecationTracker = deprecationTracking.start();
										compiler.run(err => {
											deprecationTracker();
											if (err) return done(err);
											run();
										});
									} else {
										run();
									}
								},
								testConfig.cachedTimeout ||
									testConfig.timeout ||
									(config.cache ? 20000 : 60000)
							);

							it(
								testName + " should load the compiled tests",
								done => {
									const esmContext = vm.createContext({
										it: _it,
										expect,
										process,
										global,
										URL,
										Buffer,
										setTimeout,
										setImmediate,
										nsObj: function (m) {
											Object.defineProperty(m, Symbol.toStringTag, {
												value: "Module"
											});
											return m;
										}
									});
									cleanups.push(() => (esmContext.it = undefined));
									function _require(module, esmMode) {
										if (module.substr(0, 2) === "./") {
											const p = path.join(outputDirectory, module);
											const content = fs.readFileSync(p, "utf-8");
											if (p.endsWith(".mjs")) {
												let esm;
diff --git a/a.js b/b.js
@@ -3,4 +3,4 @@
A blob:670c28f0d85704a1486781332638a19c51394122
import("./c?0" + __resourceQuery);
import("./c?1" + __resourceQuery);
import("./c?2" + __resourceQuery);
import("./c?3" + __resourceQuery);
import("./c?4" + __resourceQuery);
import("./a" + __resourceQuery.substr(0, 2));

diff --git a/a.js b/b.js
@@ -8,4 +8,4 @@
A blob:269a2572379dc1b803d733e6700c549d1a877e28
require("./c?3" + __resourceQuery);
require("./c?4" + __resourceQuery);
require("./c?5" + __resourceQuery);
require("./c?6" + __resourceQuery);
require("./c?7" + __resourceQuery);
require("./c?8" + __resourceQuery);
require("./c?9" + __resourceQuery);
require("./a" + __resourceQuery.substr(0, 2));

diff --git a/a.js b/b.js
@@ -1,7 +1,7 @@
A blob:be76a21875569b586f80f947a84adcdeeacf9db0
module.exports = function() {
	let str = "";
	let sum = ["1"];
	const query = +this.query.substr(1);
	for(let i = 0; i < query; i++) {
		str += `import b${i} from "./b?${Math.floor(i/2)}!";\n`;
		sum.push(`b${i}`);
	}
diff --git a/a.js b/b.js
@@ -1,5 +1,5 @@
A blob:30bf15c0cfc6c8f5082946ae1bcb237c945a2fb2
if(__resourceQuery === "?0") {
	module.exports = "module";
} else {
	module.exports = require("./module?" + (+__resourceQuery.substr(1) - 1));
}

diff --git a/a.js b/b.js
@@ -1,6 +1,6 @@
A blob:8c63082d41736d481e5969a356ce2b969b42d172
/** @type {import("../../../../").LoaderDefinition<string>} */
module.exports = function (source) {
	//@ts-expect-error errors must be Errors, string is not recommended and should lead to type error
	this.emitError(this.query.substr(1));
	return source;
};

diff --git a/a.js b/b.js
@@ -1,6 +1,6 @@
A blob:adc1a120a8493f8bd0d5cd63561a030efb43960d
/** @type {import("../../../../").LoaderDefinition<string>} */
module.exports = function (source) {
	//@ts-expect-error warnings must be Errors, string is not recommended and should lead to type error
	this.emitWarning(this.query.substr(1));
	return source;
};

diff --git a/a.js b/b.js
@@ -1,3 +1,3 @@
A blob:fc699a5aad81f7c23eb8d774b2628bebec95092e
module.exports = require((
	__resourceFragment.substr(1) + "/resourceFragment/returnRF#XXXFragment"
).replace(/XXX/g, "resource"));

diff --git a/a.js b/b.js
@@ -17,7 +17,7 @@ it("should parse fancy function calls with arrow functions", function() {
A blob:a79383e0026b11b5353f815835eb58357366b666
it("should parse fancy function calls with arrow functions", function() {
	("function"==typeof define && define.amd ?
		define :
		(e,t) => {return t()}
	)(["./constructor"], (c) => {
		return new c(1324);
	});
	expect(module.exports).toHaveProperty("value", 1324);
	(("function"==typeof define && define.amd ?
		define :
		(e,t) => {return t()}
	)(["./constructor"], (c) => {
		return new c(4231);
	}));
	expect(module.exports).toHaveProperty("value", 4231);
});

it("should parse fancy AMD calls with arrow functions", function() {
	require("./constructor ./a".split(" "));
	require("-> module module exports *constructor *a".replace("module", "require").substr(3).replace(/\*/g, "./").split(" "), (require, module, exports, constructor, a) => {
		expect((typeof require)).toBe("function");
		expect((typeof module)).toBe("object");
		expect((typeof exports)).toBe("object");
		expect((typeof require("./constructor"))).toBe("function");
diff --git a/a.js b/b.js
@@ -25,7 +25,7 @@ require("-> module module exports *constructor *a".replace("module", "require").
A blob:a79383e0026b11b5353f815835eb58357366b666
	expect(module.exports).toHaveProperty("value", 4231);
});

it("should parse fancy AMD calls with arrow functions", function() {
	require("./constructor ./a".split(" "));
	require("-> module module exports *constructor *a".replace("module", "require").substr(3).replace(/\*/g, "./").split(" "), (require, module, exports, constructor, a) => {
		expect((typeof require)).toBe("function");
		expect((typeof module)).toBe("object");
		expect((typeof exports)).toBe("object");
		expect((typeof require("./constructor"))).toBe("function");
		expect((typeof constructor)).toBe("function");
		expect(a).toBe("a");
	});
	define("-> module module exports *constructor *a".replace("module", "require").substr(3).replace(/\*/g, "./").split(" "), (require, module, exports, constructor, a) => {
		expect((typeof require)).toBe("function");
		expect((typeof module)).toBe("object");
		expect((typeof exports)).toBe("object");
		expect((typeof require("./constructor"))).toBe("function");
diff --git a/a.js b/b.js
@@ -17,7 +17,7 @@ it("should parse fancy function calls", function() {
A blob:13cc0d3f047905ea1227999f7b35b67e8972af59
it("should parse fancy function calls", function() {
	("function"==typeof define && define.amd ?
		define :
		function(e,t){return t()}
	)(["./constructor"], function(c) {
		return new c(1324);
	});
	expect(module.exports).toHaveProperty("value", 1324);
	(("function"==typeof define && define.amd ?
		define :
		function(e,t){return t()}
	)(["./constructor"], function(c) {
		return new c(4231);
	}));
	expect(module.exports).toHaveProperty("value", 4231);
});

it("should parse fancy AMD calls", function() {
	require("./constructor ./a".split(" "));
	require("-> module module exports *constructor *a".replace("module", "require").substr(3).replace(/\*/g, "./").split(" "), function(require, module, exports, constructor, a) {
		expect((typeof require)).toBe("function");
		expect((typeof module)).toBe("object");
		expect((typeof exports)).toBe("object");
		expect((typeof require("./constructor"))).toBe("function");
diff --git a/a.js b/b.js
@@ -25,7 +25,7 @@ require("-> module module exports *constructor *a".replace("module", "require").
A blob:13cc0d3f047905ea1227999f7b35b67e8972af59
	expect(module.exports).toHaveProperty("value", 4231);
});

it("should parse fancy AMD calls", function() {
	require("./constructor ./a".split(" "));
	require("-> module module exports *constructor *a".replace("module", "require").substr(3).replace(/\*/g, "./").split(" "), function(require, module, exports, constructor, a) {
		expect((typeof require)).toBe("function");
		expect((typeof module)).toBe("object");
		expect((typeof exports)).toBe("object");
		expect((typeof require("./constructor"))).toBe("function");
		expect((typeof constructor)).toBe("function");
		expect(a).toBe("a");
	});
	define("-> module module exports *constructor *a".replace("module", "require").substr(3).replace(/\*/g, "./").split(" "), function(require, module, exports, constructor, a) {
		expect((typeof require)).toBe("function");
		expect((typeof module)).toBe("object");
		expect((typeof exports)).toBe("object");
		expect((typeof require("./constructor"))).toBe("function");
diff --git a/a.js b/b.js
@@ -104,9 +104,9 @@ _toRealUrl(value) {
A blob:aa837df29dfc9a5ffd25d486390ffc12ba5821ac

	getAttribute(name) {
		return this._attributes[name];
	}

	_toRealUrl(value) {
		if (/^\//.test(value)) {
			return `https://test.cases${value}`;
		} else if (/^\.\.\//.test(value)) {
			return `https://test.cases${value.substr(2)}`;
		} else if (/^\.\//.test(value)) {
			return `https://test.cases/path${value.substr(1)}`;
		} else if (/^\w+:\/\//.test(value)) {
			return value;
		} else if (/^\/\//.test(value)) {
			return `https:${value}`;
diff --git a/a.js b/b.js
@@ -324,7 +324,7 @@ 								//       const g = function g() {}
A blob:844da0c6fa362baae794933b4fac8b0e2710a86e
								// Given the following code:
								//
								//     if (true) f() else g()
								//     if (false) {
								//       function f() {}
								//       const g = function g() {}
								//       if (someTest) {
								//         let a = 1
								//         var x, {y, z} = obj
								//       }
								//     } else {
								//       
								//     }
								//
								// the generated code is:
								//
								//     if (true) f() else {}
								//     if (false) {
								//       var f, x, y, z;   (in loose mode)
								//       var x, y, z;      (in strict mode)
								//     } else {
								//       
								//     }
								//
								// NOTE: When code runs in strict mode, `var` declarations
								// are hoisted but `function` declarations don't.
								//
								let declarations;
								if (parser.scope.isStrict) {
									// If the code runs in strict mode, variable declarations
									// using `var` must be hoisted.
									declarations = getHoistedDeclarations(branchToRemove, false);
								} else {
									// Otherwise, collect all hoisted declaration.
									declarations = getHoistedDeclarations(branchToRemove, true);
								}
								let replacement;
								if (declarations.length > 0) {
									replacement = `{ var ${declarations.join(", ")}; }`;
								} else {
									replacement = "{}";
								}
								const dep = new ConstDependency(
									replacement,
									branchToRemove.range
								);
								dep.loc = branchToRemove.loc;
								parser.state.module.addPresentationalDependency(dep);
							}
							return bool;
						}
					});
					parser.hooks.expressionConditionalOperator.tap(
						"ConstPlugin",
						expression => {
							if (parser.scope.isAsmJs) return;
							const param = parser.evaluateExpression(expression.test);
							const bool = param.asBool();
							if (typeof bool === "boolean") {
								if (!param.couldHaveSideEffects()) {
									const dep = new ConstDependency(` ${bool}`, param.range);
									dep.loc = expression.loc;
									parser.state.module.addPresentationalDependency(dep);
								} else {
									parser.walkExpression(expression.test);
								}
								// Expressions do not hoist.
								// It is safe to remove the dead branch.
								//
								// Given the following code:
								//
								//   false ? someExpression() : otherExpression();
								//
								// the generated code is:
								//
								//   false ? 0 : otherExpression();
								//
								const branchToRemove = bool
									? expression.alternate
									: expression.consequent;
								const dep = new ConstDependency("0", branchToRemove.range);
								dep.loc = branchToRemove.loc;
								parser.state.module.addPresentationalDependency(dep);
								return bool;
							}
						}
					);
					parser.hooks.expressionLogicalOperator.tap(
						"ConstPlugin",
						expression => {
							if (parser.scope.isAsmJs) return;
							if (
								expression.operator === "&&" ||
								expression.operator === "||"
							) {
								const param = parser.evaluateExpression(expression.left);
								const bool = param.asBool();
								if (typeof bool === "boolean") {
									// Expressions do not hoist.
									// It is safe to remove the dead branch.
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   falsyExpression() && false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   true && someExpression();
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   truthyExpression() || false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   false && someExpression();
									//
									const keepRight =
										(expression.operator === "&&" && bool) ||
										(expression.operator === "||" && !bool);

									if (
										!param.couldHaveSideEffects() &&
										(param.isBoolean() || keepRight)
									) {
										// for case like
										//
										//   return'development'===process.env.NODE_ENV&&'foo'
										//
										// we need a space before the bool to prevent result like
										//
										//   returnfalse&&'foo'
										//
										const dep = new ConstDependency(` ${bool}`, param.range);
										dep.loc = expression.loc;
										parser.state.module.addPresentationalDependency(dep);
									} else {
										parser.walkExpression(expression.left);
									}
									if (!keepRight) {
										const dep = new ConstDependency(
											"0",
											expression.right.range
										);
										dep.loc = expression.loc;
										parser.state.module.addPresentationalDependency(dep);
									}
									return keepRight;
								}
							} else if (expression.operator === "??") {
								const param = parser.evaluateExpression(expression.left);
								const keepRight = param && param.asNullish();
								if (typeof keepRight === "boolean") {
									// ------------------------------------------
									//
									// Given the following code:
diff --git a/a.js b/b.js
@@ -407,7 +407,7 @@ 								//       const g = function g() {}
A blob:844da0c6fa362baae794933b4fac8b0e2710a86e
								// Given the following code:
								//
								//     if (true) f() else g()
								//     if (false) {
								//       function f() {}
								//       const g = function g() {}
								//       if (someTest) {
								//         let a = 1
								//         var x, {y, z} = obj
								//       }
								//     } else {
								//       
								//     }
								//
								// the generated code is:
								//
								//     if (true) f() else {}
								//     if (false) {
								//       var f, x, y, z;   (in loose mode)
								//       var x, y, z;      (in strict mode)
								//     } else {
								//       
								//     }
								//
								// NOTE: When code runs in strict mode, `var` declarations
								// are hoisted but `function` declarations don't.
								//
								let declarations;
								if (parser.scope.isStrict) {
									// If the code runs in strict mode, variable declarations
									// using `var` must be hoisted.
									declarations = getHoistedDeclarations(branchToRemove, false);
								} else {
									// Otherwise, collect all hoisted declaration.
									declarations = getHoistedDeclarations(branchToRemove, true);
								}
								let replacement;
								if (declarations.length > 0) {
									replacement = `{ var ${declarations.join(", ")}; }`;
								} else {
									replacement = "{}";
								}
								const dep = new ConstDependency(
									replacement,
									branchToRemove.range
								);
								dep.loc = branchToRemove.loc;
								parser.state.module.addPresentationalDependency(dep);
							}
							return bool;
						}
					});
					parser.hooks.expressionConditionalOperator.tap(
						"ConstPlugin",
						expression => {
							if (parser.scope.isAsmJs) return;
							const param = parser.evaluateExpression(expression.test);
							const bool = param.asBool();
							if (typeof bool === "boolean") {
								if (!param.couldHaveSideEffects()) {
									const dep = new ConstDependency(` ${bool}`, param.range);
									dep.loc = expression.loc;
									parser.state.module.addPresentationalDependency(dep);
								} else {
									parser.walkExpression(expression.test);
								}
								// Expressions do not hoist.
								// It is safe to remove the dead branch.
								//
								// Given the following code:
								//
								//   false ? someExpression() : otherExpression();
								//
								// the generated code is:
								//
								//   false ? 0 : otherExpression();
								//
								const branchToRemove = bool
									? expression.alternate
									: expression.consequent;
								const dep = new ConstDependency("0", branchToRemove.range);
								dep.loc = branchToRemove.loc;
								parser.state.module.addPresentationalDependency(dep);
								return bool;
							}
						}
					);
					parser.hooks.expressionLogicalOperator.tap(
						"ConstPlugin",
						expression => {
							if (parser.scope.isAsmJs) return;
							if (
								expression.operator === "&&" ||
								expression.operator === "||"
							) {
								const param = parser.evaluateExpression(expression.left);
								const bool = param.asBool();
								if (typeof bool === "boolean") {
									// Expressions do not hoist.
									// It is safe to remove the dead branch.
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   falsyExpression() && false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   true && someExpression();
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   truthyExpression() || false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   false && someExpression();
									//
									const keepRight =
										(expression.operator === "&&" && bool) ||
										(expression.operator === "||" && !bool);

									if (
										!param.couldHaveSideEffects() &&
										(param.isBoolean() || keepRight)
									) {
										// for case like
										//
										//   return'development'===process.env.NODE_ENV&&'foo'
										//
										// we need a space before the bool to prevent result like
										//
										//   returnfalse&&'foo'
										//
										const dep = new ConstDependency(` ${bool}`, param.range);
										dep.loc = expression.loc;
										parser.state.module.addPresentationalDependency(dep);
									} else {
										parser.walkExpression(expression.left);
									}
									if (!keepRight) {
										const dep = new ConstDependency(
											"0",
											expression.right.range
										);
										dep.loc = expression.loc;
										parser.state.module.addPresentationalDependency(dep);
									}
									return keepRight;
								}
							} else if (expression.operator === "??") {
								const param = parser.evaluateExpression(expression.left);
								const keepRight = param && param.asNullish();
								if (typeof keepRight === "boolean") {
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   nonNullish ?? someExpression();
									//
									// the generated code is:
									//
									//   nonNullish ?? 0;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   nullish ?? someExpression();
									//
									// the generated code is:
									//
									//   null ?? someExpression();
									//
									if (!param.couldHaveSideEffects() && keepRight) {
										// cspell:word returnnull
										// for case like
										//
										//   return('development'===process.env.NODE_ENV&&null)??'foo'
										//
										// we need a space before the bool to prevent result like
										//
										//   returnnull??'foo'
										//
										const dep = new ConstDependency(" null", param.range);
										dep.loc = expression.loc;
										parser.state.module.addPresentationalDependency(dep);
									} else {
										const dep = new ConstDependency(
											"0",
											expression.right.range
										);
										dep.loc = expression.loc;
										parser.state.module.addPresentationalDependency(dep);
										parser.walkExpression(expression.left);
									}

									return keepRight;
								}
							}
						}
					);
					parser.hooks.optionalChaining.tap("ConstPlugin", expr => {
						/** @type {ExpressionNode[]} */
						const optionalExpressionsStack = [];
						/** @type {ExpressionNode|SuperNode} */
						let next = expr.expression;

						while (
							next.type === "MemberExpression" ||
							next.type === "CallExpression"
						) {
							if (next.type === "MemberExpression") {
								if (next.optional) {
									// SuperNode can not be optional
									optionalExpressionsStack.push(
										/** @type {ExpressionNode} */ (next.object)
									);
								}
								next = next.object;
							} else {
								if (next.optional) {
									// SuperNode can not be optional
									optionalExpressionsStack.push(
										/** @type {ExpressionNode} */ (next.callee)
									);
								}
								next = next.callee;
							}
						}

						while (optionalExpressionsStack.length) {
							const expression = optionalExpressionsStack.pop();
							const evaluated = parser.evaluateExpression(expression);

							if (evaluated && evaluated.asNullish()) {
								// ------------------------------------------
								//
								// Given the following code:
								//
diff --git a/a.js b/b.js
@@ -201,7 +201,7 @@ apply(parser) {
A blob:a0be15e26dd1e5d3f8d28253b76155722b2b6f33
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 */
	apply(parser) {
		const enableStructuredExports = () => {
			DynamicExports.enable(parser.state);
		};
		const checkNamespace = (topLevel, members, valueExpr) => {
			if (!DynamicExports.isEnabled(parser.state)) return;
			if (members.length > 0 && members[0] === "__esModule") {
				if (valueExpr && isTruthyLiteral(valueExpr) && topLevel) {
					DynamicExports.setFlagged(parser.state);
				} else {
					DynamicExports.setDynamic(parser.state);
				}
			}
		};
		const bailout = reason => {
			DynamicExports.bailout(parser.state);
			if (reason) bailoutHint(reason);
		};
		const bailoutHint = reason => {
			this.moduleGraph
				.getOptimizationBailout(parser.state.module)
				.push(`CommonJS bailout: ${reason}`);
		};

		// metadata //
		parser.hooks.evaluateTypeof
			.for("module")
			.tap("CommonJsExportsParserPlugin", evaluateToString("object"));
		parser.hooks.evaluateTypeof
			.for("exports")
			.tap("CommonJsPlugin", evaluateToString("object"));

		// exporting //
		const handleAssignExport = (expr, base, members) => {
			if (HarmonyExports.isEnabled(parser.state)) return;
			// Handle reexporting
			const requireCall = parseRequireCall(parser, expr.right);
			if (
				requireCall &&
				requireCall.argument.isString() &&
				(members.length === 0 || members[0] !== "__esModule")
			) {
				enableStructuredExports();
				// It's possible to reexport __esModule, so we must convert to a dynamic module
				if (members.length === 0) DynamicExports.setDynamic(parser.state);
				const dep = new CommonJsExportRequireDependency(
					expr.range,
					null,
					base,
					members,
					requireCall.argument.string,
					requireCall.ids,
					!parser.isStatementLevelExpression(expr)
				);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.module.addDependency(dep);
				return true;
			}
			if (members.length === 0) return;
			enableStructuredExports();
			const remainingMembers = members;
			checkNamespace(
				parser.statementPath.length === 1 &&
					parser.isStatementLevelExpression(expr),
				remainingMembers,
				expr.right
			);
			const dep = new CommonJsExportsDependency(
				expr.left.range,
				null,
				base,
				remainingMembers
			);
			dep.loc = expr.loc;
			parser.state.module.addDependency(dep);
			parser.walkExpression(expr.right);
			return true;
		};
		parser.hooks.assignMemberChain
			.for("exports")
			.tap("CommonJsExportsParserPlugin", (expr, members) => {
				return handleAssignExport(expr, "exports", members);
			});
		parser.hooks.assignMemberChain
			.for("this")
			.tap("CommonJsExportsParserPlugin", (expr, members) => {
				if (!parser.scope.topLevelScope) return;
				return handleAssignExport(expr, "this", members);
			});
		parser.hooks.assignMemberChain
			.for("module")
			.tap("CommonJsExportsParserPlugin", (expr, members) => {
				if (members[0] !== "exports") return;
				return handleAssignExport(expr, "module.exports", members.slice(1));
			});
		parser.hooks.call
			.for("Object.defineProperty")
			.tap("CommonJsExportsParserPlugin", expression => {
				const expr = /** @type {import("estree").CallExpression} */ (
					expression
				);
				if (!parser.isStatementLevelExpression(expr)) return;
				if (expr.arguments.length !== 3) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				if (expr.arguments[2].type === "SpreadElement") return;
				const exportsArg = parser.evaluateExpression(expr.arguments[0]);
				if (!exportsArg || !exportsArg.isIdentifier()) return;
				if (
					exportsArg.identifier !== "exports" &&
					exportsArg.identifier !== "module.exports" &&
					(exportsArg.identifier !== "this" || !parser.scope.topLevelScope)
diff --git a/a.js b/b.js
@@ -210,7 +210,6 @@ apply(parser) {
A blob:a0be15e26dd1e5d3f8d28253b76155722b2b6f33
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 */
	apply(parser) {
		const enableStructuredExports = () => {
			DynamicExports.enable(parser.state);
		};
		const checkNamespace = (topLevel, members, valueExpr) => {
			if (!DynamicExports.isEnabled(parser.state)) return;
			if (members.length > 0 && members[0] === "__esModule") {
				if (valueExpr && isTruthyLiteral(valueExpr) && topLevel) {
					DynamicExports.setFlagged(parser.state);
				} else {
					DynamicExports.setDynamic(parser.state);
				}
			}
		};
		const bailout = reason => {
			DynamicExports.bailout(parser.state);
			if (reason) bailoutHint(reason);
		};
		const bailoutHint = reason => {
			this.moduleGraph
				.getOptimizationBailout(parser.state.module)
				.push(`CommonJS bailout: ${reason}`);
		};

		// metadata //
		parser.hooks.evaluateTypeof
			.for("module")
			.tap("CommonJsExportsParserPlugin", evaluateToString("object"));
		parser.hooks.evaluateTypeof
			.for("exports")
			.tap("CommonJsPlugin", evaluateToString("object"));

		// exporting //
		const handleAssignExport = (expr, base, members) => {
			if (HarmonyExports.isEnabled(parser.state)) return;
			// Handle reexporting
			const requireCall = parseRequireCall(parser, expr.right);
			if (
				requireCall &&
				requireCall.argument.isString() &&
				(members.length === 0 || members[0] !== "__esModule")
			) {
				enableStructuredExports();
				// It's possible to reexport __esModule, so we must convert to a dynamic module
				if (members.length === 0) DynamicExports.setDynamic(parser.state);
				const dep = new CommonJsExportRequireDependency(
					expr.range,
					null,
					base,
					members,
					requireCall.argument.string,
					requireCall.ids,
					!parser.isStatementLevelExpression(expr)
				);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.module.addDependency(dep);
				return true;
			}
			if (members.length === 0) return;
			enableStructuredExports();
			const remainingMembers = members;
			checkNamespace(
				parser.statementPath.length === 1 &&
					parser.isStatementLevelExpression(expr),
				remainingMembers,
				expr.right
			);
			const dep = new CommonJsExportsDependency(
				expr.left.range,
				null,
				base,
				remainingMembers
			);
			dep.loc = expr.loc;
			parser.state.module.addDependency(dep);
			parser.walkExpression(expr.right);
			return true;
		};
		parser.hooks.assignMemberChain
			.for("exports")
			.tap("CommonJsExportsParserPlugin", (expr, members) => {
				return handleAssignExport(expr, "exports", members);
			});
		parser.hooks.assignMemberChain
			.for("this")
			.tap("CommonJsExportsParserPlugin", (expr, members) => {
				if (!parser.scope.topLevelScope) return;
				return handleAssignExport(expr, "this", members);
			});
		parser.hooks.assignMemberChain
			.for("module")
			.tap("CommonJsExportsParserPlugin", (expr, members) => {
				if (members[0] !== "exports") return;
				return handleAssignExport(expr, "module.exports", members.slice(1));
			});
		parser.hooks.call
			.for("Object.defineProperty")
			.tap("CommonJsExportsParserPlugin", expression => {
				const expr = /** @type {import("estree").CallExpression} */ (
					expression
				);
				if (!parser.isStatementLevelExpression(expr)) return;
				if (expr.arguments.length !== 3) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				if (expr.arguments[2].type === "SpreadElement") return;
				const exportsArg = parser.evaluateExpression(expr.arguments[0]);
				if (!exportsArg || !exportsArg.isIdentifier()) return;
				if (
					exportsArg.identifier !== "exports" &&
					exportsArg.identifier !== "module.exports" &&
					(exportsArg.identifier !== "this" || !parser.scope.topLevelScope)
				) {
					return;
				}
				const propertyArg = parser.evaluateExpression(expr.arguments[1]);
				if (!propertyArg) return;
				const property = propertyArg.asString();
				if (typeof property !== "string") return;
				enableStructuredExports();
				const descArg = expr.arguments[2];
diff --git a/a.js b/b.js
@@ -57,7 +57,7 @@
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
/** @typedef {import("estree").ThisExpression} ThisExpressionNode */
/** @typedef {import("estree").UnaryExpression} UnaryExpressionNode */
/** @typedef {import("estree").VariableDeclarator} VariableDeclaratorNode */
/** @template T @typedef {import("tapable").AsArray<T>} AsArray<T> */
/** @typedef {import("../Parser").ParserState} ParserState */
/** @typedef {import("../Parser").PreparsedAst} PreparsedAst */
/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */
/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[] }} GetInfoResult */

const EMPTY_ARRAY = [];
const ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;
const ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;
diff --git a/a.js b/b.js
@@ -262,9 +262,9 @@ constructor(sourceType = "auto") {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
diff --git a/a.js b/b.js
@@ -294,9 +294,9 @@ constructor(sourceType = "auto") {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"callExpression",
						"members"
					])
			),
			/** Something like "a.b().c.d()"" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			callMemberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"innerCallExpression",
						"members"
					])
			),
			/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */
			optionalChaining: new SyncBailHook(["optionalChaining"]),
			/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */
			new: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
			expressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
			unhandledExpressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
diff --git a/a.js b/b.js
@@ -416,7 +416,6 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
diff --git a/a.js b/b.js
@@ -437,7 +436,6 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}
diff --git a/a.js b/b.js
@@ -486,10 +484,10 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
diff --git a/a.js b/b.js
@@ -545,9 +543,7 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
diff --git a/a.js b/b.js
@@ -600,9 +596,7 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
diff --git a/a.js b/b.js
@@ -635,9 +629,7 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
diff --git a/a.js b/b.js
@@ -816,7 +808,7 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
diff --git a/a.js b/b.js
@@ -915,7 +907,6 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
diff --git a/a.js b/b.js
@@ -980,7 +971,12 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
diff --git a/a.js b/b.js
@@ -997,7 +993,12 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
diff --git a/a.js b/b.js
@@ -1006,7 +1007,12 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);
diff --git a/a.js b/b.js
@@ -1039,7 +1045,6 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
diff --git a/a.js b/b.js
@@ -1306,7 +1311,6 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
diff --git a/a.js b/b.js
@@ -1380,7 +1384,7 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
						res.setOptions([consequent]);
					}
					if (alternate.isConditional()) {
						res.addOptions(alternate.options);
					} else {
						res.addOptions([alternate]);
					}
				} else {
					res = this.evaluateExpression(
						conditionValue ? expr.consequent : expr.alternate
					);
					if (condition.couldHaveSideEffects()) res.setSideEffects();
				}
				res.setRange(expr.range);
				return res;
			});
		this.hooks.evaluate
			.for("ArrayExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ArrayExpressionNode} */ (_expr);

				const items = expr.elements.map(element => {
					return (
						element !== null &&
						element.type !== "SpreadElement" &&
						this.evaluateExpression(element)
					);
				});
				if (!items.every(Boolean)) return;
				return new BasicEvaluatedExpression()
					.setItems(items)
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ChainExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ChainExpressionNode} */ (_expr);
				/** @type {ExpressionNode[]} */
				const optionalExpressionsStack = [];
				/** @type {ExpressionNode|SuperNode} */
				let next = expr.expression;

				while (
					next.type === "MemberExpression" ||
					next.type === "CallExpression"
				) {
					if (next.type === "MemberExpression") {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.object)
							);
						}
						next = next.object;
					} else {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.callee)
							);
						}
						next = next.callee;
					}
				}

				while (optionalExpressionsStack.length > 0) {
					const expression = optionalExpressionsStack.pop();
					const evaluated = this.evaluateExpression(expression);

					if (evaluated && evaluated.asNullish()) {
						return evaluated.setRange(_expr.range);
					}
				}
				return this.evaluateExpression(expr.expression);
diff --git a/a.js b/b.js
@@ -1390,7 +1394,7 @@ _initializeEvaluating() {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
						res.setOptions([consequent]);
					}
					if (alternate.isConditional()) {
						res.addOptions(alternate.options);
					} else {
						res.addOptions([alternate]);
					}
				} else {
					res = this.evaluateExpression(
						conditionValue ? expr.consequent : expr.alternate
					);
					if (condition.couldHaveSideEffects()) res.setSideEffects();
				}
				res.setRange(expr.range);
				return res;
			});
		this.hooks.evaluate
			.for("ArrayExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ArrayExpressionNode} */ (_expr);

				const items = expr.elements.map(element => {
					return (
						element !== null &&
						element.type !== "SpreadElement" &&
						this.evaluateExpression(element)
					);
				});
				if (!items.every(Boolean)) return;
				return new BasicEvaluatedExpression()
					.setItems(items)
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ChainExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ChainExpressionNode} */ (_expr);
				/** @type {ExpressionNode[]} */
				const optionalExpressionsStack = [];
				/** @type {ExpressionNode|SuperNode} */
				let next = expr.expression;

				while (
					next.type === "MemberExpression" ||
					next.type === "CallExpression"
				) {
					if (next.type === "MemberExpression") {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.object)
							);
						}
						next = next.object;
					} else {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.callee)
							);
						}
						next = next.callee;
					}
				}

				while (optionalExpressionsStack.length > 0) {
					const expression = optionalExpressionsStack.pop();
					const evaluated = this.evaluateExpression(expression);

					if (evaluated && evaluated.asNullish()) {
						return evaluated.setRange(_expr.range);
					}
				}
				return this.evaluateExpression(expr.expression);
			});
	}

	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result && result.isIdentifier()) {
			return result.identifier;
		}
	}

diff --git a/a.js b/b.js
@@ -2727,7 +2731,10 @@ walkCallExpression(expression) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		if (result === true) return;

		this.walkExpression(expression.source);
	}

	walkCallExpression(expression) {
		const isSimpleFunction = fn => {
			return fn.params.every(p => p.type === "Identifier");
		};
		if (
			expression.callee.type === "MemberExpression" &&
			expression.callee.object.type.endsWith("FunctionExpression") &&
			!expression.callee.computed &&
			(expression.callee.property.name === "call" ||
				expression.callee.property.name === "bind") &&
			expression.arguments.length > 0 &&
			isSimpleFunction(expression.callee.object)
		) {
			// (function() { }.call/bind(?, ))
			this._walkIIFE(
				expression.callee.object,
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		} else if (
			expression.callee.type.endsWith("FunctionExpression") &&
			isSimpleFunction(expression.callee)
		) {
			// (function() { }())
			this._walkIIFE(expression.callee, expression.arguments, null);
		} else {
			if (expression.callee.type === "MemberExpression") {
				const exprInfo = this.getMemberExpressionInfo(
					expression.callee,
					ALLOWED_MEMBER_TYPES_CALL_EXPRESSION
				);
				if (exprInfo && exprInfo.type === "call") {
					const result = this.callHooksForInfo(
						this.hooks.callMemberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers()
					);
					if (result === true) return;
				}
			}
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const result1 = this.callHooksForInfo(
					this.hooks.callMemberChain,
					callee.rootInfo,
					expression,
					callee.getMembers()
				);
				if (result1 === true) return;
				const result2 = this.callHooksForInfo(
					this.hooks.call,
diff --git a/a.js b/b.js
@@ -2767,11 +2774,13 @@ walkMemberExpression(expression) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
			}
			if (expression.arguments) this.walkExpressions(expression.arguments);
		}
	}

	walkMemberExpression(expression) {
		const exprInfo = this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_ALL
		);
		if (exprInfo) {
			switch (exprInfo.type) {
				case "expression": {
					const result1 = this.callHooksForInfo(
						this.hooks.expression,
						exprInfo.name,
						expression
					);
					if (result1 === true) return;
					const members = exprInfo.getMembers();
					const result2 = this.callHooksForInfo(
						this.hooks.expressionMemberChain,
						exprInfo.rootInfo,
						expression,
						members
					);
					if (result2 === true) return;
					this.walkMemberExpressionWithExpressionName(
						expression,
diff --git a/a.js b/b.js
@@ -3167,17 +3176,15 @@ enterAssignmentPattern(pattern, onIdent) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347

	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	}

	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	}

	/**
	 * @param {ExpressionNode} expression expression node
	 * @returns {BasicEvaluatedExpression | undefined} evaluation result
	 */
	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result !== undefined) {
					if (result) {
						result.setExpression(expression);
					}
					return result;
				}
			}
		} catch (e) {
diff --git a/a.js b/b.js
@@ -3348,6 +3355,10 @@ parse(source, state) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
	/**
	 * @param {string | Buffer | PreparsedAst} source the source to parse
	 * @param {ParserState} state the parser state
	 * @returns {ParserState} the parser state
	 */
	parse(source, state) {
		let ast;
		let comments;
		const semicolons = new Set();
		if (source === null) {
			throw new Error("source must not be null");
		}
		if (Buffer.isBuffer(source)) {
			source = source.toString("utf-8");
		}
		if (typeof source === "object") {
			ast = /** @type {ProgramNode} */ (source);
			comments = source.comments;
		} else {
			comments = [];
			ast = JavascriptParser._parse(source, {
				sourceType: this.sourceType,
				onComment: comments,
				onInsertedSemicolon: pos => semicolons.add(pos)
			});
		}

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		const oldSemicolons = this.semicolons;
		const oldStatementPath = this.statementPath;
		const oldPrevStatement = this.prevStatement;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			isStrict: false,
			isAsmJs: false,
			definitions: new StackedMap()
		};
		/** @type {ParserState} */
		this.state = state;
		this.comments = comments;
		this.semicolons = semicolons;
		this.statementPath = [];
		this.prevStatement = undefined;
		if (this.hooks.program.call(ast, comments) === undefined) {
			this.detectMode(ast.body);
			this.preWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.blockPreWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.walkStatements(ast.body);
		}
		this.hooks.finish.call(ast, comments);
		this.scope = oldScope;
		/** @type {ParserState} */
		this.state = oldState;
		this.comments = oldComments;
		this.semicolons = oldSemicolons;
		this.statementPath = oldStatementPath;
		this.prevStatement = oldPrevStatement;
		return state;
	}

	evaluate(source) {
		const ast = JavascriptParser._parse("(" + source + ")", {
			sourceType: this.sourceType,
			locations: false
diff --git a/a.js b/b.js
@@ -3609,12 +3620,13 @@ parseCommentOptions(range) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
		} else {
			this.scope.definitions.set(name, variableInfo);
		}
	}

	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		}
		let options = {};
		let errors = [];
		for (const comment of comments) {
			const { value } = comment;
			if (value && webpackCommentRegExp.test(value)) {
				// try compile only if webpack options comment is present
				try {
					const val = vm.runInNewContext(`(function(){return {${value}};})()`);
					Object.assign(options, val);
				} catch (e) {
					e.comment = comment;
					errors.push(e);
				}
			}
		}
		return { options, errors };
	}

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {AnyNode} */
		let expr = expression;
		const members = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value}`);
diff --git a/a.js b/b.js
@@ -3623,10 +3635,13 @@ extractMemberExpressionChain(expression) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {AnyNode} */
		let expr = expression;
		const members = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value}`);
			} else {
				if (expr.property.type !== "Identifier") break;
				members.push(expr.property.name);
			}
			expr = expr.object;
		}
		return {
			members,
			object: expr
		};
	}

diff --git a/a.js b/b.js
@@ -3649,8 +3664,8 @@ getFreeInfoFromVariable(varName) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return undefined;
		} else if (typeof info !== "string") {
			return undefined;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: "call", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
diff --git a/a.js b/b.js
@@ -3658,7 +3673,8 @@ getFreeInfoFromVariable(varName) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return undefined;
		} else if (typeof info !== "string") {
			return undefined;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: "call", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
diff --git a/a.js b/b.js
@@ -3682,7 +3698,8 @@ getMemberExpressionInfo(expression, allowedTypes) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return undefined;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() => members.reverse())
				};
			}
			case "Identifier":
			case "MetaProperty":
diff --git a/a.js b/b.js
@@ -3700,7 +3717,8 @@ getMemberExpressionInfo(expression, allowedTypes) {
A blob:93050a6352bdc659e7ccc7b4bcce86711450b347
	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return undefined;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() => members.reverse())
				};
			}
			case "Identifier":
			case "MetaProperty":
			case "ThisExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)
					return undefined;
				const rootName = getRootName(object);
				if (!rootName) return undefined;

				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				return {
					type: "expression",
					name: objectAndMembersToName(resolvedRoot, members),
					rootInfo,
					getMembers: memoize(() => members.reverse())
				};
			}
		}
	}
diff --git a/a.js b/b.js
@@ -715,7 +715,15 @@ A(module, "defaultRules", () => {
A blob:bfc8b297596bf765ef69ea65e682b6a26a166010
	F(module.parser, "javascript", () => ({}));
	applyJavascriptParserOptionsDefaults(module.parser.javascript, {
		futureDefaults
	});

	A(module, "defaultRules", () => {
		const esm = {
			type: "javascript/esm",
			resolve: {
				byDependency: {
					esm: {
						fullySpecified: true
					}
				}
			}
		};
		const commonjs = {
			type: "javascript/dynamic"
		};
		/** @type {RuleSetRules} */
		const rules = [
			{
				mimetype: "application/node",
				type: "javascript/auto"
			},
			{
				test: /\.json$/i,
				type: "json"
			},
			{
				mimetype: "application/json",
				type: "json"
			},
			{
				test: /\.mjs$/i,
				...esm
			},
			{
				test: /\.js$/i,
				descriptionData: {
					type: "module"
				},
				...esm
			},
			{
				test: /\.cjs$/i,
				...commonjs
			},
			{
				test: /\.js$/i,
				descriptionData: {
					type: "commonjs"
				},
				...commonjs
			},
			{
				mimetype: {
					or: ["text/javascript", "application/javascript"]
				},
				...esm
			}
		];
		if (asyncWebAssembly) {
			const wasm = {
				type: "webassembly/async",
				rules: [
					{
						descriptionData: {
							type: "module"
						},
						resolve: {
							fullySpecified: true
						}
					}
				]
			};
			rules.push({
				test: /\.wasm$/i,
				...wasm
			});
			rules.push({
				mimetype: "application/wasm",
				...wasm
			});
		} else if (syncWebAssembly) {
			const wasm = {
				type: "webassembly/sync",
				rules: [
					{
						descriptionData: {
							type: "module"
						},
						resolve: {
							fullySpecified: true
						}
					}
				]
			};
			rules.push({
				test: /\.wasm$/i,
				...wasm
			});
			rules.push({
				mimetype: "application/wasm",
				...wasm
			});
		}
		if (css) {
			const cssRule = {
				type: "css",
				resolve: {
					fullySpecified: true,
					preferRelative: true
				}
			};
			const cssModulesRule = {
				type: "css/module",
				resolve: {
					fullySpecified: true
				}
			};
			rules.push({
				test: /\.css$/i,
				oneOf: [
					{
						test: /\.module\.css$/i,
						...cssModulesRule
					},
					{
						...cssRule
					}
				]
			});
			rules.push({
				mimetype: "text/css+module",
				...cssModulesRule
			});
			rules.push({
				mimetype: "text/css",
				...cssRule
			});
		}
		rules.push(
			{
				dependency: "url",
				oneOf: [
					{
						scheme: /^data$/,
						type: "asset/inline"
					},
					{
						type: "asset/resource"
					}
				]
			},
			{
				assert: { type: "json" },
				type: "json"
			}
		);
		return rules;
	});
};

/**
 * @param {Output} output options
 * @param {Object} options options
 * @param {string} options.context context
 * @param {TargetProperties | false} options.targetProperties target properties
 * @param {boolean} options.isAffectedByBrowserslist is affected by browserslist
 * @param {boolean} options.outputModule is outputModule experiment enabled
 * @param {boolean} options.development is development mode
 * @param {Entry} options.entry entry option
 * @param {ModuleOptions} options.module module option
 * @param {boolean} options.futureDefaults is future defaults enabled
 * @returns {void}
 */
const applyOutputDefaults = (
	output,
	{
		context,
		targetProperties: tp,
		isAffectedByBrowserslist,
		outputModule,
		development,
		entry,
		module,
		futureDefaults
	}
) => {
	/**
	 * @param {Library=} library the library option
	 * @returns {string} a readable library name
	 */
	const getLibraryName = library => {
		const libraryName =
			typeof library === "object" &&
			library &&
			!Array.isArray(library) &&
			"type" in library
				? library.name
				: /** @type {LibraryName=} */ (library);
		if (Array.isArray(libraryName)) {
			return libraryName.join(".");
		} else if (typeof libraryName === "object") {
			return getLibraryName(libraryName.root);
		} else if (typeof libraryName === "string") {
			return libraryName;
		}
		return "";
	};

	F(output, "uniqueName", () => {
		const libraryName = getLibraryName(output.library);
		if (libraryName) return libraryName;
		const pkgPath = path.resolve(context, "package.json");
		try {
			const packageInfo = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
diff --git a/a.js b/b.js
@@ -1060,6 +1060,197 @@ test("library", { output: { library: ["myLib", "awesome"] } }, e =>
A blob:13c87da9f138b0d446e373666af7fecaf956c17e
		@@ ... @@
		-     "filename": "[name].js",
		+     "filename": [Function filename],
	`)
	);
	test("library", { output: { library: ["myLib", "awesome"] } }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received

		@@ ... @@
		-     "chunkLoadingGlobal": "webpackChunkwebpack",
		+     "chunkLoadingGlobal": "webpackChunkmyLib_awesome",
		@@ ... @@
		-     "devtoolNamespace": "webpack",
		+     "devtoolNamespace": "myLib.awesome",
		@@ ... @@
		-     "enabledLibraryTypes": Array [],
		+     "enabledLibraryTypes": Array [
		+       "var",
		+     ],
		@@ ... @@
		-     "hotUpdateGlobal": "webpackHotUpdatewebpack",
		+     "hotUpdateGlobal": "webpackHotUpdatemyLib_awesome",
		@@ ... @@
		-     "library": undefined,
		+     "library": Object {
		+       "auxiliaryComment": undefined,
		+       "export": undefined,
		+       "name": Array [
		+         "myLib",
		+         "awesome",
		+       ],
		+       "type": "var",
		+       "umdNamedDefine": undefined,
		+     },
		@@ ... @@
		-     "uniqueName": "webpack",
		+     "uniqueName": "myLib.awesome",
	`)
	);
	test("target node", { target: "node" }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received
diff --git a/a.js b/b.js
@@ -77,6 +77,7 @@ apply(compiler) {
A blob:81b765831b12901f784c19abbae299cc3d0e8212
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const options = this.options;
		const banner = this.banner;
		const matchObject = ModuleFilenameHelpers.matchObject.bind(
			undefined,
			options
		);

		compiler.hooks.compilation.tap("BannerPlugin", compilation => {
			compilation.hooks.processAssets.tap(
				{
diff --git a/a.js b/b.js
@@ -102,10 +103,15 @@ apply(compiler) {
A blob:81b765831b12901f784c19abbae299cc3d0e8212
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const options = this.options;
		const banner = this.banner;
		const matchObject = ModuleFilenameHelpers.matchObject.bind(
			undefined,
			options
		);

		compiler.hooks.compilation.tap("BannerPlugin", compilation => {
			compilation.hooks.processAssets.tap(
				{
					name: "BannerPlugin",
					stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
				},
				() => {
					for (const chunk of compilation.chunks) {
						if (options.entryOnly && !chunk.canBeInitial()) {
							continue;
						}

						for (const file of chunk.files) {
							if (!matchObject(file)) {
								continue;
							}

							const data = {
								chunk,
								filename: file
							};

							const comment = compilation.getPath(banner, data);

							compilation.updateAsset(
								file,
								old => new ConcatSource(comment, "\n", old)
							);
						}
					}
				}
			);
diff --git a/a.js b/b.js
@@ -3328,7 +3328,8 @@ _codeGenerationModule(
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
	 * @param {WebpackError[]} errors errors
	 * @param {CodeGenerationResults} results results
	 * @param {function(WebpackError=, boolean=): void} callback callback
	 */
	_codeGenerationModule(
		module,
		runtime,
		runtimes,
		hash,
		dependencyTemplates,
		chunkGraph,
		moduleGraph,
		runtimeTemplate,
		errors,
		results,
		callback
	) {
		let codeGenerated = false;
		const cache = new MultiItemCache(
			runtimes.map(runtime =>
				this._codeGenerationCache.getItemCache(
					`${module.identifier()}|${getRuntimeKey(runtime)}`,
					`${hash}|${dependencyTemplates.getHash()}`
				)
			)
		);
		cache.get((err, cachedResult) => {
			if (err) return callback(err);
			let result;
			if (!cachedResult) {
				try {
					codeGenerated = true;
					this.codeGeneratedModules.add(module);
					result = module.codeGeneration({
						chunkGraph,
						moduleGraph,
						dependencyTemplates,
						runtimeTemplate,
						runtime,
						codeGenerationResults: results
					});
				} catch (err) {
					errors.push(new CodeGenerationError(module, err));
					result = cachedResult = {
diff --git a/a.js b/b.js
@@ -3895,7 +3896,7 @@ createModuleHashes() {
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		const errors = [];
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
diff --git a/a.js b/b.js
@@ -3959,7 +3960,7 @@ _createModuleHash(
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
				) / 100
			} variants per module in average)`
		);
	}

	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength,
		errors
	) {
		let moduleHashDigest;
		try {
			const moduleHash = createHash(hashFunction);
			module.updateHash(moduleHash, {
				chunkGraph,
				runtime,
				runtimeTemplate
			});
			moduleHashDigest = /** @type {string} */ (moduleHash.digest(hashDigest));
		} catch (err) {
			errors.push(new ModuleHashingError(module, err));
			moduleHashDigest = "XXXXXX";
		}
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

diff --git a/a.js b/b.js
@@ -4163,7 +4164,7 @@ createHash() {
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
diff --git a/a.js b/b.js
@@ -4190,7 +4191,7 @@ createHash() {
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
diff --git a/a.js b/b.js
@@ -4210,7 +4211,7 @@ createHash() {
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
diff --git a/a.js b/b.js
@@ -4221,7 +4222,7 @@ createHash() {
A blob:3048f0d2989e72dee02bc73068bfc77ecf80cc49
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();
		const errors = [];

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			try {
				this.logger.time("hashing: hash chunks");
				const chunkHash = createHash(hashFunction);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length > 0) {
			errors.sort(compareSelect(err => err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest = /** @type {string} */ (
				chunkHash.digest(hashDigest)
			);
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd("hashing: process full hash modules");
		return codeGenerationJobs;
diff --git a/a.js b/b.js
@@ -19,7 +19,11 @@
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder,
	compareModulesById
} = require("./util/comparators");
const { contextify, parseResource } = require("./util/identifier");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptions */
diff --git a/a.js b/b.js
@@ -61,7 +65,7 @@
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
 * @property {string=} typePrefix
 * @property {string=} category
 * @property {string[][]=} referencedExports exports referenced from modules (won't be mangled)
 */

/**
 * @typedef {Object} ContextModuleOptionsExtras
 * @property {string} resource
 * @property {string=} resourceQuery
 * @property {string=} resourceFragment
 * @property {TODO} resolveOptions
 */
diff --git a/a.js b/b.js
@@ -92,23 +96,36 @@
A blob:e7170d44b538a94584e227826e8f224fcc56c52c

class ContextModule extends Module {
	/**
	 * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context
	 * @param {ContextModuleOptions} options options object
	 */
	constructor(resolveDependencies, options) {
		const parsed = parseResource(options ? options.resource : "");
		const resource = parsed.path;
		const resourceQuery = (options && options.resourceQuery) || parsed.query;
		const resourceFragment =
			(options && options.resourceFragment) || parsed.fragment;

		super("javascript/dynamic", resource);

		// Info from Factory
		this.resolveDependencies = resolveDependencies;
		/** @type {ContextModuleOptions} */
		this.options = {
			...options,
			resource,
			resourceQuery,
			resourceFragment
		};
		if (options && options.resolveOptions !== undefined) {
			this.resolveOptions = options.resolveOptions;
		}

diff --git a/a.js b/b.js
@@ -155,7 +172,12 @@ _prettyRegExp(regexString, stripSlash = true) {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
	cleanupForCache() {
		super.cleanupForCache();
		this.resolveDependencies = undefined;
	}

	_prettyRegExp(regexString, stripSlash = true) {
		const str = (regexString + "").replace(/!/g, "%21").replace(/\|/g, "%7C");
		return stripSlash ? str.substring(1, str.length - 1) : str;
	}

	_createIdentifier() {
		let identifier = this.context;
		if (this.options.resourceQuery) {
			identifier += `|${this.options.resourceQuery}`;
		}
		if (this.options.resourceFragment) {
diff --git a/a.js b/b.js
@@ -220,7 +242,19 @@ identifier() {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
	}

	/**
	 * @returns {string} a unique identifier of the module
	 */
	identifier() {
		return this._identifier;
	}

	/**
	 * @param {RequestShortener} requestShortener the request shortener
	 * @returns {string} a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		let identifier = requestShortener.shorten(this.context) + "/";
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
diff --git a/a.js b/b.js
@@ -270,11 +304,30 @@ readableIdentifier(requestShortener) {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c

	/**
	 * @param {RequestShortener} requestShortener the request shortener
	 * @returns {string} a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		let identifier = requestShortener.shorten(this.context) + "/";
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += " nonrecursive";
		}
		if (this.options.addon) {
			identifier += ` ${requestShortener.shorten(this.options.addon)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this._prettyRegExp(this.options.regExp)}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this._prettyRegExp(this.options.include)}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)}`;
		}
		if (this.options.referencedExports) {
			identifier += ` referencedExports: ${this.options.referencedExports
				.map(e => e.join("."))
				.join(", ")}`;
		}
		if (this.options.chunkName) {
			identifier += ` chunkName: ${this.options.chunkName}`;
		}
		if (this.options.groupOptions) {
			const groupOptions = this.options.groupOptions;
			for (const key of Object.keys(groupOptions)) {
				identifier += ` ${key}: ${groupOptions[key]}`;
			}
		}
		if (this.options.namespaceObject === "strict") {
			identifier += " strict namespace object";
		} else if (this.options.namespaceObject) {
			identifier += " namespace object";
		}

		return identifier;
	}

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let identifier = contextify(
			options.context,
			this.context,
			options.associatedObjectForCache
		);
		if (this.layer) identifier = `(${this.layer})/${identifier}`;
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
diff --git a/a.js b/b.js
@@ -323,8 +376,9 @@ needBuild({ fileSystemInfo }, callback) {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
	/**
	 * @param {NeedBuildContext} context context info
	 * @param {function((WebpackError | null)=, boolean=): void} callback callback function, returns true, if the module needs a rebuild
	 * @returns {void}
	 */
	needBuild({ fileSystemInfo }, callback) {
		// build if enforced
		if (this._forceBuild) return callback(null, true);

		// always build when we have no snapshot
		if (!this.buildInfo.snapshot) return callback(null, true);

		fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {
			callback(err, !valid);
		});
diff --git a/a.js b/b.js
@@ -439,10 +493,16 @@ build(options, compilation, resolver, fs, callback) {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {function(WebpackError=): void} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		/** @type {BuildMeta} */
		this.buildMeta = {
			exportsType: "default",
			defaultObject: "redirect-warn"
		};
		this.buildInfo = {
			snapshot: undefined
		};
		this.dependencies.length = 0;
		this.blocks.length = 0;
		const startTime = Date.now();
		this.resolveDependencies(fs, this.options, (err, dependencies) => {
			if (err) {
				return callback(
					makeWebpackError(err, "ContextModule.resolveDependencies")
				);
			}

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			}

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}
			dependencies.sort(
				concatComparators(
					compareSelect(a => a.loc, compareLocations),
					keepOriginalOrder(this.dependencies)
				)
			);

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy-once") {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock({
						...this.options.groupOptions,
						name: this.options.chunkName
					});
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy") {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						}
						chunkName = chunkName.replace(/\[index\]/g, `${index++}`);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						{
							...this.options.groupOptions,
							name: chunkName
						},
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new WebpackError(`Unsupported mode "${this.options.mode}" in context`)
				);
				return;
			}
			compilation.fileSystemInfo.createSnapshot(
				startTime,
				null,
				[this.context],
				null,
				SNAPSHOT_OPTIONS,
				(err, snapshot) => {
					if (err) return callback(err);
diff --git a/a.js b/b.js
@@ -466,7 +526,15 @@ addCacheDependencies(
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
	 * @param {LazySet<string>} fileDependencies set where file dependencies are added to
	 * @param {LazySet<string>} contextDependencies set where context dependencies are added to
	 * @param {LazySet<string>} missingDependencies set where missing dependencies are added to
	 * @param {LazySet<string>} buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {
		contextDependencies.add(this.context);
	}

	/**
	 * @param {ContextElementDependency[]} dependencies all dependencies
diff --git a/a.js b/b.js
@@ -1002,9 +1070,21 @@ getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
	/**
	 * @param {string} asyncMode module mode
	 * @param {CodeGenerationContext} context context info
	 * @returns {string} the source code
	 */
	getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
		const id = chunkGraph.getModuleId(this);
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(block, block.dependencies, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getWeakSyncSource(this.dependencies, id, chunkGraph);
			}
		}
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

diff --git a/a.js b/b.js
@@ -1014,11 +1094,14 @@ getSource(sourceString) {
A blob:e7170d44b538a94584e227826e8f224fcc56c52c
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration(context) {
		const { chunkGraph } = context;
		const sources = new Map();
		sources.set(
			"javascript",
			this.getSource(this.getSourceString(this.options.mode, context))
		);
		const set = new Set();
		const allDeps = /** @type {ContextElementDependency[]} */ (
			this.dependencies.concat(this.blocks.map(b => b.dependencies[0]))
diff --git a/a.js b/b.js
@@ -128,7 +128,7 @@ create(data, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
diff --git a/a.js b/b.js
@@ -138,7 +138,7 @@ create(data, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
diff --git a/a.js b/b.js
@@ -146,7 +146,7 @@ create(data, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}
diff --git a/a.js b/b.js
@@ -167,6 +167,9 @@ create(data, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					"context",
					dependencies.length > 0
						? cachedSetProperty(
								resolveOptions || EMPTY_RESOLVE_OPTIONS,
								"dependencyType",
								dependencies[0].category
						  )
						: resolveOptions
				);
				const loaderResolver = this.resolverFactory.get("loader");

				asyncLib.parallel(
					[
						callback => {
							contextResolver.resolve(
								{},
								context,
								resource,
diff --git a/a.js b/b.js
@@ -174,11 +177,12 @@ create(data, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					"context",
					dependencies.length > 0
						? cachedSetProperty(
								resolveOptions || EMPTY_RESOLVE_OPTIONS,
								"dependencyType",
								dependencies[0].category
						  )
						: resolveOptions
				);
				const loaderResolver = this.resolverFactory.get("loader");

				asyncLib.parallel(
					[
						callback => {
							contextResolver.resolve(
								{},
								context,
								resource,
								{
									fileDependencies,
									missingDependencies,
									contextDependencies
								},
								(err, result) => {
									if (err) return callback(err);
									callback(null, result);
								}
							);
						},
						callback => {
diff --git a/a.js b/b.js
@@ -213,15 +217,25 @@ create(data, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					"context",
					dependencies.length > 0
						? cachedSetProperty(
								resolveOptions || EMPTY_RESOLVE_OPTIONS,
								"dependencyType",
								dependencies[0].category
						  )
						: resolveOptions
				);
				const loaderResolver = this.resolverFactory.get("loader");

				asyncLib.parallel(
					[
						callback => {
							contextResolver.resolve(
								{},
								context,
								resource,
								{
									fileDependencies,
									missingDependencies,
									contextDependencies
								},
								(err, result) => {
									if (err) return callback(err);
									callback(null, result);
								}
							);
						},
						callback => {
							asyncLib.map(
								loaders,
								(loader, callback) => {
									loaderResolver.resolve(
										{},
										context,
										loader,
										{
											fileDependencies,
											missingDependencies,
											contextDependencies
										},
										(err, result) => {
											if (err) return callback(err);
											callback(null, result);
										}
									);
								},
								callback
							);
						}
					],
					(err, result) => {
						if (err) {
							return callback(err, {
								fileDependencies,
								missingDependencies,
								contextDependencies
							});
						}

						this.hooks.afterResolve.callAsync(
							{
								addon:
									loadersPrefix +
									result[1].join("!") +
									(result[1].length > 0 ? "!" : ""),
								resource: result[0],
								resolveDependencies: this.resolveDependencies.bind(this),
								...beforeResolveResult
							},
							(err, result) => {
								if (err) {
diff --git a/a.js b/b.js
@@ -278,26 +292,28 @@ resolveDependencies(fs, options, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix
		} = options;
		if (!regExp || !resource) return callback(null, []);

		const addDirectoryChecked = (directory, visited, callback) => {
			fs.realpath(directory, (err, realPath) => {
				if (err) return callback(err);
				if (visited.has(realPath)) return callback(null, []);
				let recursionStack;
				addDirectory(
					directory,
					(dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		const addDirectory = (directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file => file.normalize("NFC"))
diff --git a/a.js b/b.js
@@ -324,16 +340,15 @@ resolveDependencies(fs, options, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix
		} = options;
		if (!regExp || !resource) return callback(null, []);

		const addDirectoryChecked = (directory, visited, callback) => {
			fs.realpath(directory, (err, realPath) => {
				if (err) return callback(err);
				if (visited.has(realPath)) return callback(null, []);
				let recursionStack;
				addDirectory(
					directory,
					(dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		const addDirectory = (directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file => file.normalize("NFC"))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: resource,
										request:
											"." +
											subResource.substr(resource.length).replace(/\\/g, "/")
									};

									this.hooks.alternativeRequests.callAsync(
										[obj],
diff --git a/a.js b/b.js
@@ -344,8 +359,11 @@ resolveDependencies(fs, options, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix
		} = options;
		if (!regExp || !resource) return callback(null, []);

		const addDirectoryChecked = (directory, visited, callback) => {
			fs.realpath(directory, (err, realPath) => {
				if (err) return callback(err);
				if (visited.has(realPath)) return callback(null, []);
				let recursionStack;
				addDirectory(
					directory,
					(dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		const addDirectory = (directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file => file.normalize("NFC"))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: resource,
										request:
											"." +
											subResource.substr(resource.length).replace(/\\/g, "/")
									};

									this.hooks.alternativeRequests.callAsync(
										[obj],
										options,
										(err, alternatives) => {
											if (err) return callback(err);
											alternatives = alternatives
												.filter(obj => regExp.test(obj.request))
												.map(obj => {
													const dep = new ContextElementDependency(
														obj.request + resourceQuery + resourceFragment,
														obj.request,
														typePrefix,
														category,
														referencedExports
diff --git a/a.js b/b.js
@@ -382,12 +400,38 @@ resolveDependencies(fs, options, callback) {
A blob:f667e11f87f32acfc1734b9b26a941f94a577c5b
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix
		} = options;
		if (!regExp || !resource) return callback(null, []);

		const addDirectoryChecked = (directory, visited, callback) => {
			fs.realpath(directory, (err, realPath) => {
				if (err) return callback(err);
				if (visited.has(realPath)) return callback(null, []);
				let recursionStack;
				addDirectory(
					directory,
					(dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		const addDirectory = (directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file => file.normalize("NFC"))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: resource,
										request:
											"." +
											subResource.substr(resource.length).replace(/\\/g, "/")
									};

									this.hooks.alternativeRequests.callAsync(
										[obj],
										options,
										(err, alternatives) => {
											if (err) return callback(err);
											alternatives = alternatives
												.filter(obj => regExp.test(obj.request))
												.map(obj => {
													const dep = new ContextElementDependency(
														obj.request + resourceQuery + resourceFragment,
														obj.request,
														typePrefix,
														category,
														referencedExports
													);
													dep.optional = true;
													return dep;
												});
											callback(null, alternatives);
										}
									);
								} else {
									callback();
								}
							});
						} else {
							callback();
						}
					},
					(err, result) => {
						if (err) return callback(err);

						if (!result) return callback(null, []);

						const flattenedResult = [];

						for (const item of result) {
							if (item) flattenedResult.push(...item);
						}

						callback(null, flattenedResult);
					}
				);
			});
		};

		if (typeof fs.realpath === "function") {
			addDirectoryChecked(resource, new Set(), callback);
		} else {
			const addSubDirectory = (dir, callback) =>
				addDirectory(dir, addSubDirectory, callback);
			addDirectory(resource, addSubDirectory, callback);
		}
	}
};

diff --git a/a.js b/b.js
@@ -49,6 +49,7 @@
A blob:fadab9d0679667e32e9f0a4c63a4cf0127448f87
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {RuntimeSpec} runtime the runtimes code should be generated for
 * @property {string=} type the type of source that should be generated
 */

/**
 * @typedef {Object} CodeGenerationContext
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
diff --git a/a.js b/b.js
@@ -58,6 +59,7 @@
A blob:fadab9d0679667e32e9f0a4c63a4cf0127448f87
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {RuntimeSpec} runtime the runtimes code should be generated for
 * @property {ConcatenationScope=} concatenationScope when in concatenated module, information about other concatenated modules
 * @property {CodeGenerationResults} codeGenerationResults code generation results of other modules (need to have a codeGenerationDependency to use that)
 */

/**
 * @typedef {Object} ConcatenationBailoutReasonContext
diff --git a/a.js b/b.js
@@ -35,6 +35,7 @@
A blob:fc50a47251948b41bce7e497330f732b634420b2
const DataUriPlugin = require("./schemes/DataUriPlugin");
const FileUriPlugin = require("./schemes/FileUriPlugin");

const ResolverCachePlugin = require("./cache/ResolverCachePlugin");

const CommonJsPlugin = require("./dependencies/CommonJsPlugin");
const HarmonyModulesPlugin = require("./dependencies/HarmonyModulesPlugin");
const ImportMetaPlugin = require("./dependencies/ImportMetaPlugin");
const ImportPlugin = require("./dependencies/ImportPlugin");
const LoaderPlugin = require("./dependencies/LoaderPlugin");
const RequireContextPlugin = require("./dependencies/RequireContextPlugin");
diff --git a/a.js b/b.js
@@ -361,6 +362,7 @@ process(options, compiler) {
A blob:fc50a47251948b41bce7e497330f732b634420b2
	/**
	 * @param {WebpackOptions} options options object
	 * @param {Compiler} compiler compiler object
	 * @returns {WebpackOptions} options object
	 */
	process(options, compiler) {
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || null;
		compiler.recordsOutputPath = options.recordsOutputPath || null;
		compiler.name = options.name;

		if (options.externals) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ExternalsPlugin = require("./ExternalsPlugin");
			new ExternalsPlugin(options.externalsType, options.externals).apply(
				compiler
			);
		}

		if (options.externalsPresets.node) {
			const NodeTargetPlugin = require("./node/NodeTargetPlugin");
			new NodeTargetPlugin().apply(compiler);
		}
		if (options.externalsPresets.electronMain) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ElectronTargetPlugin = require("./electron/ElectronTargetPlugin");
			new ElectronTargetPlugin("main").apply(compiler);
		}
		if (options.externalsPresets.electronPreload) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ElectronTargetPlugin = require("./electron/ElectronTargetPlugin");
			new ElectronTargetPlugin("preload").apply(compiler);
		}
		if (options.externalsPresets.electronRenderer) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ElectronTargetPlugin = require("./electron/ElectronTargetPlugin");
			new ElectronTargetPlugin("renderer").apply(compiler);
		}
		if (
			options.externalsPresets.electron &&
			!options.externalsPresets.electronMain &&
			!options.externalsPresets.electronPreload &&
			!options.externalsPresets.electronRenderer
		) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ElectronTargetPlugin = require("./electron/ElectronTargetPlugin");
			new ElectronTargetPlugin().apply(compiler);
		}
		if (options.externalsPresets.nwjs) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ExternalsPlugin = require("./ExternalsPlugin");
			new ExternalsPlugin("node-commonjs", "nw.gui").apply(compiler);
		}
		if (options.externalsPresets.webAsync) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ExternalsPlugin = require("./ExternalsPlugin");
			new ExternalsPlugin(
				"import",
				options.experiments.css
					? ({ request, dependencyType }, callback) => {
							if (dependencyType === "url") {
								if (/^(\/\/|https?:\/\/)/.test(request))
									return callback(null, `asset ${request}`);
							} else if (dependencyType === "css-import") {
								if (/^(\/\/|https?:\/\/)/.test(request))
									return callback(null, `css-import ${request}`);
							} else if (/^(\/\/|https?:\/\/|std:)/.test(request)) {
								if (/^\.css(\?|$)/.test(request))
									return callback(null, `css-import ${request}`);
								return callback(null, `import ${request}`);
							}
							callback();
					  }
					: /^(\/\/|https?:\/\/|std:)/
			).apply(compiler);
		} else if (options.externalsPresets.web) {
			//@ts-expect-error https://github.com/microsoft/TypeScript/issues/41697
			const ExternalsPlugin = require("./ExternalsPlugin");
			new ExternalsPlugin(
				"module",
				options.experiments.css
					? ({ request, dependencyType }, callback) => {
							if (dependencyType === "url") {
								if (/^(\/\/|https?:\/\/)/.test(request))
									return callback(null, `asset ${request}`);
							} else if (dependencyType === "css-import") {
								if (/^(\/\/|https?:\/\/)/.test(request))
									return callback(null, `css-import ${request}`);
							} else if (/^(\/\/|https?:\/\/|std:)/.test(request)) {
								if (/^\.css(\?|$)/.test(request))
									return callback(null, `css-import ${request}`);
								return callback(null, `module ${request}`);
							}
							callback();
					  }
					: /^(\/\/|https?:\/\/|std:)/
			).apply(compiler);
		}

		new ChunkPrefetchPreloadPlugin().apply(compiler);

		if (typeof options.output.chunkFormat === "string") {
			switch (options.output.chunkFormat) {
				case "array-push": {
					const ArrayPushCallbackChunkFormatPlugin = require("./javascript/ArrayPushCallbackChunkFormatPlugin");
					new ArrayPushCallbackChunkFormatPlugin().apply(compiler);
					break;
				}
				case "commonjs": {
					const CommonJsChunkFormatPlugin = require("./javascript/CommonJsChunkFormatPlugin");
					new CommonJsChunkFormatPlugin().apply(compiler);
					break;
				}
				case "module": {
					const ModuleChunkFormatPlugin = require("./esm/ModuleChunkFormatPlugin");
					new ModuleChunkFormatPlugin().apply(compiler);
					break;
				}
				default:
					throw new Error(
						"Unsupported chunk format '" + options.output.chunkFormat + "'."
					);
			}
		}

		if (options.output.enabledChunkLoadingTypes.length > 0) {
			for (const type of options.output.enabledChunkLoadingTypes) {
				const EnableChunkLoadingPlugin = require("./javascript/EnableChunkLoadingPlugin");
				new EnableChunkLoadingPlugin(type).apply(compiler);
			}
		}

		if (options.output.enabledWasmLoadingTypes.length > 0) {
			for (const type of options.output.enabledWasmLoadingTypes) {
				const EnableWasmLoadingPlugin = require("./wasm/EnableWasmLoadingPlugin");
				new EnableWasmLoadingPlugin(type).apply(compiler);
			}
		}

		if (options.output.enabledLibraryTypes.length > 0) {
			for (const type of options.output.enabledLibraryTypes) {
				const EnableLibraryPlugin = require("./library/EnableLibraryPlugin");
				new EnableLibraryPlugin(type).apply(compiler);
			}
		}

		if (options.output.pathinfo) {
			const ModuleInfoHeaderPlugin = require("./ModuleInfoHeaderPlugin");
			new ModuleInfoHeaderPlugin(options.output.pathinfo !== true).apply(
				compiler
			);
		}

		if (options.output.clean) {
			const CleanPlugin = require("./CleanPlugin");
			new CleanPlugin(
				options.output.clean === true ? {} : options.output.clean
			).apply(compiler);
		}

		if (options.devtool) {
			if (options.devtool.includes("source-map")) {
				const hidden = options.devtool.includes("hidden");
				const inline = options.devtool.includes("inline");
				const evalWrapped = options.devtool.includes("eval");
				const cheap = options.devtool.includes("cheap");
				const moduleMaps = options.devtool.includes("module");
				const noSources = options.devtool.includes("nosources");
				const Plugin = evalWrapped
					? require("./EvalSourceMapDevToolPlugin")
					: require("./SourceMapDevToolPlugin");
				new Plugin({
					filename: inline ? null : options.output.sourceMapFilename,
					moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
					fallbackModuleFilenameTemplate:
						options.output.devtoolFallbackModuleFilenameTemplate,
					append: hidden ? false : undefined,
					module: moduleMaps ? true : cheap ? false : true,
					columns: cheap ? false : true,
					noSources: noSources,
					namespace: options.output.devtoolNamespace
				}).apply(compiler);
			} else if (options.devtool.includes("eval")) {
				const EvalDevToolModulePlugin = require("./EvalDevToolModulePlugin");
				new EvalDevToolModulePlugin({
					moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
					namespace: options.output.devtoolNamespace
				}).apply(compiler);
			}
		}

		new JavascriptModulesPlugin().apply(compiler);
		new JsonModulesPlugin().apply(compiler);
		new AssetModulesPlugin().apply(compiler);

		if (!options.experiments.outputModule) {
			if (options.output.module) {
				throw new Error(
					"'output.module: true' is only allowed when 'experiments.outputModule' is enabled"
				);
			}
			if (options.output.enabledLibraryTypes.includes("module")) {
				throw new Error(
					"library type \"module\" is only allowed when 'experiments.outputModule' is enabled"
				);
			}
			if (options.externalsType === "module") {
				throw new Error(
					"'externalsType: \"module\"' is only allowed when 'experiments.outputModule' is enabled"
				);
			}
		}

		if (options.experiments.syncWebAssembly) {
			const WebAssemblyModulesPlugin = require("./wasm-sync/WebAssemblyModulesPlugin");
			new WebAssemblyModulesPlugin({
				mangleImports: options.optimization.mangleWasmImports
			}).apply(compiler);
		}

		if (options.experiments.asyncWebAssembly) {
			const AsyncWebAssemblyModulesPlugin = require("./wasm-async/AsyncWebAssemblyModulesPlugin");
			new AsyncWebAssemblyModulesPlugin({
				mangleImports: options.optimization.mangleWasmImports
			}).apply(compiler);
		}

		if (options.experiments.css) {
			const CssModulesPlugin = require("./css/CssModulesPlugin");
			new CssModulesPlugin(options.experiments.css).apply(compiler);
		}

		if (options.experiments.lazyCompilation) {
			const LazyCompilationPlugin = require("./hmr/LazyCompilationPlugin");
			const lazyOptions =
				typeof options.experiments.lazyCompilation === "object"
					? options.experiments.lazyCompilation
					: null;
			new LazyCompilationPlugin({
				backend:
					typeof lazyOptions.backend === "function"
						? lazyOptions.backend
						: require("./hmr/lazyCompilationBackend")({
								...lazyOptions.backend,
								client:
									(lazyOptions.backend && lazyOptions.backend.client) ||
									require.resolve(
										`../hot/lazy-compilation-${
											options.externalsPresets.node ? "node" : "web"
										}.js`
									)
						  }),
				entries: !lazyOptions || lazyOptions.entries !== false,
				imports: !lazyOptions || lazyOptions.imports !== false,
				test: (lazyOptions && lazyOptions.test) || undefined
			}).apply(compiler);
		}

		if (options.experiments.buildHttp) {
			const HttpUriPlugin = require("./schemes/HttpUriPlugin");
			const httpOptions = options.experiments.buildHttp;
			new HttpUriPlugin(httpOptions).apply(compiler);
		}

		new EntryOptionPlugin().apply(compiler);
		compiler.hooks.entryOption.call(options.context, options.entry);

		new RuntimePlugin().apply(compiler);

		new InferAsyncModulesPlugin().apply(compiler);

		new DataUriPlugin().apply(compiler);
		new FileUriPlugin().apply(compiler);

		new CompatibilityPlugin().apply(compiler);
		new HarmonyModulesPlugin({
			topLevelAwait: options.experiments.topLevelAwait
		}).apply(compiler);
		if (options.amd !== false) {
			const AMDPlugin = require("./dependencies/AMDPlugin");
			const RequireJsStuffPlugin = require("./RequireJsStuffPlugin");
			new AMDPlugin(options.amd || {}).apply(compiler);
			new RequireJsStuffPlugin().apply(compiler);
		}
		new CommonJsPlugin().apply(compiler);
		new LoaderPlugin({}).apply(compiler);
		if (options.node !== false) {
			const NodeStuffPlugin = require("./NodeStuffPlugin");
			new NodeStuffPlugin(options.node).apply(compiler);
		}
		new APIPlugin().apply(compiler);
		new ExportsInfoApiPlugin().apply(compiler);
		new WebpackIsIncludedPlugin().apply(compiler);
		new ConstPlugin().apply(compiler);
		new UseStrictPlugin().apply(compiler);
		new RequireIncludePlugin().apply(compiler);
		new RequireEnsurePlugin().apply(compiler);
		new RequireContextPlugin().apply(compiler);
		new ImportPlugin().apply(compiler);
		new SystemPlugin().apply(compiler);
		new ImportMetaPlugin().apply(compiler);
		new URLPlugin().apply(compiler);
		new WorkerPlugin(
diff --git a/a.js b/b.js
@@ -128,6 +128,13 @@ apply(compiler) {
A blob:a0c0bbccbdb2fae7d7810e80178ef24bc1770c77
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
diff --git a/a.js b/b.js
@@ -155,15 +162,22 @@ apply(compiler) {
A blob:a0c0bbccbdb2fae7d7810e80178ef24bc1770c77
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						fileDependencies,
						contextDependencies,
						missingDependencies,
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							if (!snapshot) {
								if (result) return callback(null, result);
								return callback();
							}
							itemCache.store(new CacheEntry(result, snapshot), storeErr => {
								if (storeErr) return callback(storeErr);
								if (result) return callback(null, result);
								callback();
							});
						}
					);
				}
			);
diff --git a/a.js b/b.js
@@ -173,6 +187,8 @@ apply(compiler) {
A blob:a0c0bbccbdb2fae7d7810e80178ef24bc1770c77
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						fileDependencies,
						contextDependencies,
						missingDependencies,
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							if (!snapshot) {
								if (result) return callback(null, result);
								return callback();
							}
							itemCache.store(new CacheEntry(result, snapshot), storeErr => {
								if (storeErr) return callback(storeErr);
								if (result) return callback(null, result);
								callback();
							});
						}
					);
				}
			);
		};
		compiler.resolverFactory.hooks.resolver.intercept({
			factory(type, hook) {
				/** @type {Map<string, (function(Error=, Object=): void)[]>} */
				const activeRequests = new Map();
				hook.tap(
					"ResolverCachePlugin",
					/**
					 * @param {Resolver} resolver the resolver
diff --git a/a.js b/b.js
@@ -197,29 +213,67 @@ apply(compiler) {
A blob:a0c0bbccbdb2fae7d7810e80178ef24bc1770c77
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						fileDependencies,
						contextDependencies,
						missingDependencies,
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							if (!snapshot) {
								if (result) return callback(null, result);
								return callback();
							}
							itemCache.store(new CacheEntry(result, snapshot), storeErr => {
								if (storeErr) return callback(storeErr);
								if (result) return callback(null, result);
								callback();
							});
						}
					);
				}
			);
		};
		compiler.resolverFactory.hooks.resolver.intercept({
			factory(type, hook) {
				/** @type {Map<string, (function(Error=, Object=): void)[]>} */
				const activeRequests = new Map();
				hook.tap(
					"ResolverCachePlugin",
					/**
					 * @param {Resolver} resolver the resolver
					 * @param {Object} options resolve options
					 * @param {Object} userOptions resolve options passed by the user
					 * @returns {void}
					 */
					(resolver, options, userOptions) => {
						if (options.cache !== true) return;
						const optionsIdent = objectToString(userOptions, false);
						const cacheWithContext =
							options.cacheWithContext !== undefined
								? options.cacheWithContext
								: false;
						resolver.hooks.resolve.tapAsync(
							{
								name: "ResolverCachePlugin",
								stage: -100
							},
							(request, resolveContext, callback) => {
								if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {
									return callback();
								}
								const identifier = `${type}${optionsIdent}${objectToString(
									request,
									!cacheWithContext
								)}`;
								const activeRequest = activeRequests.get(identifier);
								if (activeRequest) {
									activeRequest.push(callback);
									return;
								}
								const itemCache = cache.getItemCache(identifier, null);
								let callbacks;
								const done = (err, result) => {
									if (callbacks === undefined) {
										callback(err, result);
										callbacks = false;
									} else {
										for (const callback of callbacks) {
											callback(err, result);
										}
										activeRequests.delete(identifier);
										callbacks = false;
									}
								};
								/**
								 * @param {Error=} err error if any
								 * @param {CacheEntry=} cacheEntry cache entry
								 * @returns {void}
diff --git a/a.js b/b.js
@@ -276,7 +330,14 @@ apply(compiler) {
A blob:a0c0bbccbdb2fae7d7810e80178ef24bc1770c77
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						fileDependencies,
						contextDependencies,
						missingDependencies,
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							if (!snapshot) {
								if (result) return callback(null, result);
								return callback();
							}
							itemCache.store(new CacheEntry(result, snapshot), storeErr => {
								if (storeErr) return callback(storeErr);
								if (result) return callback(null, result);
								callback();
							});
						}
					);
				}
			);
		};
		compiler.resolverFactory.hooks.resolver.intercept({
			factory(type, hook) {
				/** @type {Map<string, (function(Error=, Object=): void)[]>} */
				const activeRequests = new Map();
				hook.tap(
					"ResolverCachePlugin",
					/**
					 * @param {Resolver} resolver the resolver
					 * @param {Object} options resolve options
					 * @param {Object} userOptions resolve options passed by the user
					 * @returns {void}
					 */
					(resolver, options, userOptions) => {
						if (options.cache !== true) return;
						const optionsIdent = objectToString(userOptions, false);
						const cacheWithContext =
							options.cacheWithContext !== undefined
								? options.cacheWithContext
								: false;
						resolver.hooks.resolve.tapAsync(
							{
								name: "ResolverCachePlugin",
								stage: -100
							},
							(request, resolveContext, callback) => {
								if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {
									return callback();
								}
								const identifier = `${type}${optionsIdent}${objectToString(
									request,
									!cacheWithContext
								)}`;
								const activeRequest = activeRequests.get(identifier);
								if (activeRequest) {
									activeRequest.push(callback);
									return;
								}
								const itemCache = cache.getItemCache(identifier, null);
								let callbacks;
								const done = (err, result) => {
									if (callbacks === undefined) {
										callback(err, result);
										callbacks = false;
									} else {
										for (const callback of callbacks) {
											callback(err, result);
										}
										activeRequests.delete(identifier);
										callbacks = false;
									}
								};
								/**
								 * @param {Error=} err error if any
								 * @param {CacheEntry=} cacheEntry cache entry
								 * @returns {void}
								 */
								const processCacheResult = (err, cacheEntry) => {
									if (err) return done(err);

									if (cacheEntry) {
										const { snapshot, result } = cacheEntry;
										fileSystemInfo.checkSnapshotValid(
											snapshot,
											(err, valid) => {
												if (err || !valid) {
													cacheInvalidResolves++;
													return doRealResolve(
														itemCache,
														resolver,
														resolveContext,
														request,
														done
													);
												}
												cachedResolves++;
												if (resolveContext.missingDependencies) {
													addAllToSet(
														resolveContext.missingDependencies,
														snapshot.getMissingIterable()
													);
												}
												if (resolveContext.fileDependencies) {
													addAllToSet(
														resolveContext.fileDependencies,
														snapshot.getFileIterable()
													);
												}
												if (resolveContext.contextDependencies) {
													addAllToSet(
														resolveContext.contextDependencies,
														snapshot.getContextIterable()
													);
												}
												done(null, result);
											}
										);
									} else {
										doRealResolve(
											itemCache,
											resolver,
											resolveContext,
											request,
											done
										);
									}
								};
								itemCache.get(processCacheResult);
								if (callbacks === undefined) {
									callbacks = [callback];
									activeRequests.set(identifier, callbacks);
								}
							}
diff --git a/a.js b/b.js
@@ -28,8 +28,8 @@ const splitContextFromPrefix = prefix => {
A blob:f8a0cb5bc867f6223c20d8e80166b2a1af82cc50
 */
const quoteMeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

const splitContextFromPrefix = prefix => {
	const idx = prefix.lastIndexOf("/");
	let context = ".";
	if (idx >= 0) {
		context = prefix.substr(0, idx);
		prefix = `.${prefix.substr(idx)}`;
	}
	return {
		context,
		prefix
diff --git a/a.js b/b.js
@@ -37,7 +37,7 @@ const splitContextFromPrefix = prefix => {
A blob:f8a0cb5bc867f6223c20d8e80166b2a1af82cc50
 */
const quoteMeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

const splitContextFromPrefix = prefix => {
	const idx = prefix.lastIndexOf("/");
	let context = ".";
	if (idx >= 0) {
		context = prefix.substr(0, idx);
		prefix = `.${prefix.substr(idx)}`;
	}
	return {
		context,
		prefix
	};
};

/** @typedef {Partial<Omit<ContextDependencyOptions, "resource"|"recursive"|"regExp">>} PartialContextDependencyOptions */

/** @typedef {{ new(options: ContextDependencyOptions, range: [number, number], valueRange: [number, number]): ContextDependency }} ContextDependencyConstructor */

/**
diff --git a/a.js b/b.js
@@ -10,7 +10,6 @@
A blob:16c9f33c6f9539bbeab5d3042f84cf3e33dfdc17
"use strict";

const HotModuleReplacementPlugin = require("../HotModuleReplacementPlugin");
const InnerGraph = require("../optimize/InnerGraph");
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes } = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
diff --git a/a.js b/b.js
@@ -84,6 +83,18 @@ constructor(options) {
A blob:16c9f33c6f9539bbeab5d3042f84cf3e33dfdc17

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.exportsPresence)
				: options.strictExportPresence
				? ExportPresenceModes.ERROR
				: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
diff --git a/a.js b/b.js
@@ -132,45 +143,6 @@ apply(parser) {
A blob:16c9f33c6f9539bbeab5d3042f84cf3e33dfdc17

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPartEvaluated = parser.evaluateExpression(expression.left);
				if (leftPartEvaluated.couldHaveSideEffects()) return;
				const leftPart = leftPartEvaluated.asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in"
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
diff --git a/a.js b/b.js
@@ -194,51 +166,83 @@ apply(parser) {
A blob:16c9f33c6f9539bbeab5d3042f84cf3e33dfdc17

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPartEvaluated = parser.evaluateExpression(expression.left);
				if (leftPartEvaluated.couldHaveSideEffects()) return;
				const leftPart = leftPartEvaluated.asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in"
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const { arguments: args, callee } = expr;
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					callee.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.directImport = members.length === 0;
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(callee.range[0]);
				// only in case when we strictly follow the spec we need a special case here
				dep.namespaceObjectAsContext =
					members.length > 0 && this.strictThisContextOnImports;
				dep.loc = callee.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		const { hotAcceptCallback, hotAcceptWithoutCallback } =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
diff --git a/a.js b/b.js
@@ -28,7 +28,6 @@ get category() {
A blob:f7f5f89d2bae576fe00f15b426ffbe8a7eb053cb

	get type() {
		return `import() context ${this.options.mode}`;
	}

	get category() {
		return "esm";
	}

	serialize(context) {
		const { write } = context;

		write(this.range);
		write(this.valueRange);

		super.serialize(context);
	}
diff --git a/a.js b/b.js
@@ -37,7 +36,6 @@ serialize(context) {
A blob:f7f5f89d2bae576fe00f15b426ffbe8a7eb053cb
		write(this.valueRange);

		super.serialize(context);
	}

	deserialize(context) {
		const { read } = context;

		this.range = read();
		this.valueRange = read();

		super.deserialize(context);
	}
diff --git a/a.js b/b.js
@@ -19,22 +19,6 @@ constructor(options, range) {
A blob:f0e90f53640b0ca7e626fc07a32054b7987835a3
const makeSerializable = require("../util/makeSerializable");
const ContextDependency = require("./ContextDependency");
const ModuleDependencyTemplateAsRequireId = require("./ModuleDependencyTemplateAsRequireId");

class RequireContextDependency extends ContextDependency {
	constructor(options, range) {
		super(options);

		this.range = range;
	}

	get type() {
		return "require.context";
	}

	serialize(context) {
		const { write } = context;

		write(this.range);

		super.serialize(context);
	}

	deserialize(context) {
		const { read } = context;

		this.range = read();

		super.deserialize(context);
	}
}

makeSerializable(
	RequireContextDependency,
diff --git a/a.js b/b.js
@@ -25,7 +25,9 @@ apply(compiler) {
A blob:c72180a430a89d4e319969a8be3bebe31ca73d81
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"ModuleChunkLoadingPlugin",
			compilation => {
				const globalChunkLoading = compilation.outputOptions.chunkLoading;
				const isEnabledForChunk = chunk => {
					const options = chunk.getEntryOptions();
					const chunkLoading =
						(options && options.chunkLoading) || globalChunkLoading;
					return chunkLoading === "import";
				};
				const onceForChunkSet = new WeakSet();
				const handler = (chunk, set) => {
diff --git a/a.js b/b.js
@@ -61,12 +61,14 @@ constructor() {
A blob:ca10383d21eee3f7f506d1126cf2b2f4a57c0b76
const TypeWrapped = 11;
const TypeTemplateString = 12;
const TypeBigInt = 13;

class BasicEvaluatedExpression {
	constructor() {
		this.type = TypeUnknown;
		/** @type {[number, number]} */
		this.range = undefined;
		/** @type {boolean} */
		this.falsy = false;
		/** @type {boolean} */
		this.truthy = false;
		/** @type {boolean | undefined} */
		this.nullish = undefined;
		/** @type {boolean} */
		this.sideEffects = true;
		/** @type {boolean | undefined} */
		this.bool = undefined;
		/** @type {number | undefined} */
		this.number = undefined;
		/** @type {bigint | undefined} */
		this.bigint = undefined;
		/** @type {RegExp | undefined} */
		this.regExp = undefined;
		/** @type {string | undefined} */
		this.string = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.quasis = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.parts = undefined;
		/** @type {any[] | undefined} */
		this.array = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.items = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined} */
		this.options = undefined;
		/** @type {BasicEvaluatedExpression | undefined} */
		this.prefix = undefined;
		/** @type {BasicEvaluatedExpression | undefined} */
		this.postfix = undefined;
		this.wrappedInnerExpressions = undefined;
		/** @type {string | VariableInfoInterface | undefined} */
		this.identifier = undefined;
		/** @type {VariableInfoInterface} */
		this.rootInfo = undefined;
		/** @type {() => string[]} */
		this.getMembers = undefined;
		/** @type {EsTreeNode} */
		this.expression = undefined;
	}

diff --git a/a.js b/b.js
@@ -342,11 +344,12 @@ setRegExp(regExp) {
A blob:ca10383d21eee3f7f506d1126cf2b2f4a57c0b76
		this.bool = bool;
		this.sideEffects = false;
		return this;
	}

	setRegExp(regExp) {
		this.type = TypeRegExp;
		this.regExp = regExp;
		this.sideEffects = false;
		return this;
	}

	setIdentifier(identifier, rootInfo, getMembers) {
		this.type = TypeIdentifier;
		this.identifier = identifier;
		this.rootInfo = rootInfo;
		this.getMembers = getMembers;
		this.sideEffects = true;
		return this;
	}

diff --git a/a.js b/b.js
@@ -57,7 +57,7 @@
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
/** @typedef {import("estree").ThisExpression} ThisExpressionNode */
/** @typedef {import("estree").UnaryExpression} UnaryExpressionNode */
/** @typedef {import("estree").VariableDeclarator} VariableDeclaratorNode */
/** @template T @typedef {import("tapable").AsArray<T>} AsArray<T> */
/** @typedef {import("../Parser").ParserState} ParserState */
/** @typedef {import("../Parser").PreparsedAst} PreparsedAst */
/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */
/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[] }} GetInfoResult */

const EMPTY_ARRAY = [];
const ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;
const ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;
diff --git a/a.js b/b.js
@@ -262,9 +262,9 @@ constructor(sourceType = "auto") {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
diff --git a/a.js b/b.js
@@ -292,13 +292,11 @@ constructor(sourceType = "auto") {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"} sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression], boolean | void>>} */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[import("estree").AssignmentExpression, string[]], boolean | void>>} */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[]], boolean | void>>} */
			callMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			memberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"callExpression",
						"members"
					])
			),
			/** Something like "a.b().c.d()"" */
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */
			callMemberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"innerCallExpression",
						"members"
					])
			),
			/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */
			optionalChaining: new SyncBailHook(["optionalChaining"]),
			/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */
			new: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[BinaryExpressionNode], boolean | void>} */
			binaryExpression: new SyncBailHook(["binaryExpression"]),
			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
			expressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
			unhandledExpressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
diff --git a/a.js b/b.js
@@ -418,7 +416,6 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
diff --git a/a.js b/b.js
@@ -439,7 +436,6 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}
diff --git a/a.js b/b.js
@@ -488,10 +484,10 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
diff --git a/a.js b/b.js
@@ -547,9 +543,7 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
diff --git a/a.js b/b.js
@@ -602,9 +596,7 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
diff --git a/a.js b/b.js
@@ -637,9 +629,7 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
diff --git a/a.js b/b.js
@@ -818,7 +808,7 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
diff --git a/a.js b/b.js
@@ -917,7 +907,6 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
diff --git a/a.js b/b.js
@@ -982,7 +971,12 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
diff --git a/a.js b/b.js
@@ -999,7 +993,12 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
diff --git a/a.js b/b.js
@@ -1008,7 +1007,12 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);
diff --git a/a.js b/b.js
@@ -1041,7 +1045,6 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
diff --git a/a.js b/b.js
@@ -1308,7 +1311,6 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
diff --git a/a.js b/b.js
@@ -1382,7 +1384,7 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
						res.setOptions([consequent]);
					}
					if (alternate.isConditional()) {
						res.addOptions(alternate.options);
					} else {
						res.addOptions([alternate]);
					}
				} else {
					res = this.evaluateExpression(
						conditionValue ? expr.consequent : expr.alternate
					);
					if (condition.couldHaveSideEffects()) res.setSideEffects();
				}
				res.setRange(expr.range);
				return res;
			});
		this.hooks.evaluate
			.for("ArrayExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ArrayExpressionNode} */ (_expr);

				const items = expr.elements.map(element => {
					return (
						element !== null &&
						element.type !== "SpreadElement" &&
						this.evaluateExpression(element)
					);
				});
				if (!items.every(Boolean)) return;
				return new BasicEvaluatedExpression()
					.setItems(items)
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ChainExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ChainExpressionNode} */ (_expr);
				/** @type {ExpressionNode[]} */
				const optionalExpressionsStack = [];
				/** @type {ExpressionNode|SuperNode} */
				let next = expr.expression;

				while (
					next.type === "MemberExpression" ||
					next.type === "CallExpression"
				) {
					if (next.type === "MemberExpression") {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.object)
							);
						}
						next = next.object;
					} else {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.callee)
							);
						}
						next = next.callee;
					}
				}

				while (optionalExpressionsStack.length > 0) {
					const expression = optionalExpressionsStack.pop();
					const evaluated = this.evaluateExpression(expression);

					if (evaluated && evaluated.asNullish()) {
						return evaluated.setRange(_expr.range);
					}
				}
				return this.evaluateExpression(expr.expression);
diff --git a/a.js b/b.js
@@ -1392,7 +1394,7 @@ _initializeEvaluating() {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(info.name, info.rootInfo, info.getMembers)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return { name: info, rootInfo: info, getMembers: () => [] };
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
						res.setOptions([consequent]);
					}
					if (alternate.isConditional()) {
						res.addOptions(alternate.options);
					} else {
						res.addOptions([alternate]);
					}
				} else {
					res = this.evaluateExpression(
						conditionValue ? expr.consequent : expr.alternate
					);
					if (condition.couldHaveSideEffects()) res.setSideEffects();
				}
				res.setRange(expr.range);
				return res;
			});
		this.hooks.evaluate
			.for("ArrayExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ArrayExpressionNode} */ (_expr);

				const items = expr.elements.map(element => {
					return (
						element !== null &&
						element.type !== "SpreadElement" &&
						this.evaluateExpression(element)
					);
				});
				if (!items.every(Boolean)) return;
				return new BasicEvaluatedExpression()
					.setItems(items)
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ChainExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ChainExpressionNode} */ (_expr);
				/** @type {ExpressionNode[]} */
				const optionalExpressionsStack = [];
				/** @type {ExpressionNode|SuperNode} */
				let next = expr.expression;

				while (
					next.type === "MemberExpression" ||
					next.type === "CallExpression"
				) {
					if (next.type === "MemberExpression") {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.object)
							);
						}
						next = next.object;
					} else {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.callee)
							);
						}
						next = next.callee;
					}
				}

				while (optionalExpressionsStack.length > 0) {
					const expression = optionalExpressionsStack.pop();
					const evaluated = this.evaluateExpression(expression);

					if (evaluated && evaluated.asNullish()) {
						return evaluated.setRange(_expr.range);
					}
				}
				return this.evaluateExpression(expr.expression);
			});
	}

	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result && result.isIdentifier()) {
			return result.identifier;
		}
	}

diff --git a/a.js b/b.js
@@ -2459,9 +2461,7 @@ walkLeftRightExpression(expression) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
			}
		}
		this.walkExpression(expression.argument);
	}

	walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}

	walkBinaryExpression(expression) {
		if (this.hooks.binaryExpression.call(expression) === undefined) {
			this.walkLeftRightExpression(expression);
		}
	}

	walkLogicalExpression(expression) {
		const result = this.hooks.expressionLogicalOperator.call(expression);
diff --git a/a.js b/b.js
@@ -2496,9 +2496,7 @@ walkAssignmentExpression(expression) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
				this.walkExpression(expression.right);
			}
		}
	}

	walkAssignmentExpression(expression) {
		if (expression.left.type === "Identifier") {
			const renameIdentifier = this.getRenameIdentifier(expression.right);
			if (renameIdentifier) {
				if (
					this.callHooksForInfo(
						this.hooks.canRename,
						renameIdentifier,
						expression.right
					)
				) {
					// renaming "a = b;"
					if (
						!this.callHooksForInfo(
							this.hooks.rename,
							renameIdentifier,
							expression.right
						)
					) {
						this.setVariable(
							expression.left.name,
							typeof renameIdentifier === "string"
								? this.getVariableInfo(renameIdentifier)
								: renameIdentifier
						);
					}
					return;
				}
diff --git a/a.js b/b.js
@@ -2633,9 +2631,7 @@ _walkIIFE(functionExpression, options, currentThis) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
				this.walkMemberExpression(expression.expression);
			}
		}
	}

	_walkIIFE(functionExpression, options, currentThis) {
		const getVarInfo = argOrThis => {
			const renameIdentifier = this.getRenameIdentifier(argOrThis);
			if (renameIdentifier) {
				if (
					this.callHooksForInfo(
						this.hooks.canRename,
						renameIdentifier,
						argOrThis
					)
				) {
					if (
						!this.callHooksForInfo(
							this.hooks.rename,
							renameIdentifier,
							argOrThis
						)
					) {
						return typeof renameIdentifier === "string"
							? this.getVariableInfo(renameIdentifier)
							: renameIdentifier;
					}
				}
			}
			this.walkExpression(argOrThis);
diff --git a/a.js b/b.js
@@ -2735,7 +2731,10 @@ walkCallExpression(expression) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		if (result === true) return;

		this.walkExpression(expression.source);
	}

	walkCallExpression(expression) {
		const isSimpleFunction = fn => {
			return fn.params.every(p => p.type === "Identifier");
		};
		if (
			expression.callee.type === "MemberExpression" &&
			expression.callee.object.type.endsWith("FunctionExpression") &&
			!expression.callee.computed &&
			(expression.callee.property.name === "call" ||
				expression.callee.property.name === "bind") &&
			expression.arguments.length > 0 &&
			isSimpleFunction(expression.callee.object)
		) {
			// (function() { }.call/bind(?, ))
			this._walkIIFE(
				expression.callee.object,
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		} else if (
			expression.callee.type.endsWith("FunctionExpression") &&
			isSimpleFunction(expression.callee)
		) {
			// (function() { }())
			this._walkIIFE(expression.callee, expression.arguments, null);
		} else {
			if (expression.callee.type === "MemberExpression") {
				const exprInfo = this.getMemberExpressionInfo(
					expression.callee,
					ALLOWED_MEMBER_TYPES_CALL_EXPRESSION
				);
				if (exprInfo && exprInfo.type === "call") {
					const result = this.callHooksForInfo(
						this.hooks.callMemberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers()
					);
					if (result === true) return;
				}
			}
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const result1 = this.callHooksForInfo(
					this.hooks.callMemberChain,
					callee.rootInfo,
					expression,
					callee.getMembers()
				);
				if (result1 === true) return;
				const result2 = this.callHooksForInfo(
					this.hooks.call,
diff --git a/a.js b/b.js
@@ -2775,11 +2774,13 @@ walkMemberExpression(expression) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
			}
			if (expression.arguments) this.walkExpressions(expression.arguments);
		}
	}

	walkMemberExpression(expression) {
		const exprInfo = this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_ALL
		);
		if (exprInfo) {
			switch (exprInfo.type) {
				case "expression": {
					const result1 = this.callHooksForInfo(
						this.hooks.expression,
						exprInfo.name,
						expression
					);
					if (result1 === true) return;
					const members = exprInfo.getMembers();
					const result2 = this.callHooksForInfo(
						this.hooks.expressionMemberChain,
						exprInfo.rootInfo,
						expression,
						members
					);
					if (result2 === true) return;
					this.walkMemberExpressionWithExpressionName(
						expression,
diff --git a/a.js b/b.js
@@ -3175,17 +3176,15 @@ enterAssignmentPattern(pattern, onIdent) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9

	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	}

	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	}

	/**
	 * @param {ExpressionNode} expression expression node
	 * @returns {BasicEvaluatedExpression | undefined} evaluation result
	 */
	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result !== undefined) {
					if (result) {
						result.setExpression(expression);
					}
					return result;
				}
			}
		} catch (e) {
diff --git a/a.js b/b.js
@@ -3356,6 +3355,10 @@ parse(source, state) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
	/**
	 * @param {string | Buffer | PreparsedAst} source the source to parse
	 * @param {ParserState} state the parser state
	 * @returns {ParserState} the parser state
	 */
	parse(source, state) {
		let ast;
		let comments;
		const semicolons = new Set();
		if (source === null) {
			throw new Error("source must not be null");
		}
		if (Buffer.isBuffer(source)) {
			source = source.toString("utf-8");
		}
		if (typeof source === "object") {
			ast = /** @type {ProgramNode} */ (source);
			comments = source.comments;
		} else {
			comments = [];
			ast = JavascriptParser._parse(source, {
				sourceType: this.sourceType,
				onComment: comments,
				onInsertedSemicolon: pos => semicolons.add(pos)
			});
		}

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		const oldSemicolons = this.semicolons;
		const oldStatementPath = this.statementPath;
		const oldPrevStatement = this.prevStatement;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			isStrict: false,
			isAsmJs: false,
			definitions: new StackedMap()
		};
		/** @type {ParserState} */
		this.state = state;
		this.comments = comments;
		this.semicolons = semicolons;
		this.statementPath = [];
		this.prevStatement = undefined;
		if (this.hooks.program.call(ast, comments) === undefined) {
			this.detectMode(ast.body);
			this.preWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.blockPreWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.walkStatements(ast.body);
		}
		this.hooks.finish.call(ast, comments);
		this.scope = oldScope;
		/** @type {ParserState} */
		this.state = oldState;
		this.comments = oldComments;
		this.semicolons = oldSemicolons;
		this.statementPath = oldStatementPath;
		this.prevStatement = oldPrevStatement;
		return state;
	}

	evaluate(source) {
		const ast = JavascriptParser._parse("(" + source + ")", {
			sourceType: this.sourceType,
			locations: false
diff --git a/a.js b/b.js
@@ -3617,12 +3620,13 @@ parseCommentOptions(range) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
		} else {
			this.scope.definitions.set(name, variableInfo);
		}
	}

	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		}
		let options = {};
		let errors = [];
		for (const comment of comments) {
			const { value } = comment;
			if (value && webpackCommentRegExp.test(value)) {
				// try compile only if webpack options comment is present
				try {
					const val = vm.runInNewContext(`(function(){return {${value}};})()`);
					Object.assign(options, val);
				} catch (e) {
					e.comment = comment;
					errors.push(e);
				}
			}
		}
		return { options, errors };
	}

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {AnyNode} */
		let expr = expression;
		const members = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value}`);
diff --git a/a.js b/b.js
@@ -3631,10 +3635,13 @@ extractMemberExpressionChain(expression) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @returns {{ members: string[], object: ExpressionNode | SuperNode }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {AnyNode} */
		let expr = expression;
		const members = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value}`);
			} else {
				if (expr.property.type !== "Identifier") break;
				members.push(expr.property.name);
			}
			expr = expr.object;
		}
		return {
			members,
			object: expr
		};
	}

diff --git a/a.js b/b.js
@@ -3657,8 +3664,8 @@ getFreeInfoFromVariable(varName) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return undefined;
		} else if (typeof info !== "string") {
			return undefined;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: "call", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
diff --git a/a.js b/b.js
@@ -3666,7 +3673,8 @@ getFreeInfoFromVariable(varName) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return undefined;
		} else if (typeof info !== "string") {
			return undefined;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: "call", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[]}} CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[]}} ExpressionExpressionInfo */

	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
diff --git a/a.js b/b.js
@@ -3690,7 +3698,8 @@ getMemberExpressionInfo(expression, allowedTypes) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return undefined;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() => members.reverse())
				};
			}
			case "Identifier":
			case "MetaProperty":
diff --git a/a.js b/b.js
@@ -3708,7 +3717,8 @@ getMemberExpressionInfo(expression, allowedTypes) {
A blob:c6765d68c75085f3cb600f34a0b9fb188a13a7f9
	/**
	 * @param {MemberExpressionNode} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members } = this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)
					return undefined;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return undefined;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() => members.reverse())
				};
			}
			case "Identifier":
			case "MetaProperty":
			case "ThisExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)
					return undefined;
				const rootName = getRootName(object);
				if (!rootName) return undefined;

				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return undefined;
				const { info: rootInfo, name: resolvedRoot } = result;
				return {
					type: "expression",
					name: objectAndMembersToName(resolvedRoot, members),
					rootInfo,
					getMembers: memoize(() => members.reverse())
				};
			}
		}
	}
diff --git a/a.js b/b.js
@@ -103,8 +103,6 @@
A blob:03d4ed6ce6af978c915bef8180ae4e3f2067d20e
		require("../dependencies/HarmonyExportImportedSpecifierDependency"),
	"dependencies/HarmonyExportSpecifierDependency": () =>
		require("../dependencies/HarmonyExportSpecifierDependency"),
	"dependencies/HarmonyImportSideEffectDependency": () =>
		require("../dependencies/HarmonyImportSideEffectDependency"),
	"dependencies/HarmonyImportSpecifierDependency": () =>
		require("../dependencies/HarmonyImportSpecifierDependency"),
	"dependencies/HarmonyEvaluatedImportSpecifierDependency": () =>
		require("../dependencies/HarmonyEvaluatedImportSpecifierDependency"),
	"dependencies/ImportContextDependency": () =>
		require("../dependencies/ImportContextDependency"),
	"dependencies/ImportDependency": () =>
		require("../dependencies/ImportDependency"),
diff --git a/a.js b/b.js
@@ -128,6 +126,8 @@
A blob:03d4ed6ce6af978c915bef8180ae4e3f2067d20e
		require("../dependencies/ModuleHotAcceptDependency"),
	"dependencies/ModuleHotDeclineDependency": () =>
		require("../dependencies/ModuleHotDeclineDependency"),
	"dependencies/ImportMetaHotAcceptDependency": () =>
		require("../dependencies/ImportMetaHotAcceptDependency"),
	"dependencies/ImportMetaHotDeclineDependency": () =>
		require("../dependencies/ImportMetaHotDeclineDependency"),
	"dependencies/ProvidedDependency": () =>
		require("../dependencies/ProvidedDependency"),
	"dependencies/PureExpressionDependency": () =>
		require("../dependencies/PureExpressionDependency"),
diff --git a/a.js b/b.js
@@ -3,4 +3,4 @@
A blob:1132bbeff639468e1e003bc7865779452527e57d
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
const e=/^(?:[A-Za-z]:[\\/]|\\\\|\/)/;module.exports=we,module.exports.default=we;const t={amd:{$ref:"#/definitions/Amd"},bail:{$ref:"#/definitions/Bail"},cache:{$ref:"#/definitions/CacheOptions"},context:{$ref:"#/definitions/Context"},dependencies:{$ref:"#/definitions/Dependencies"},devServer:{$ref:"#/definitions/DevServer"},devtool:{$ref:"#/definitions/DevTool"},entry:{$ref:"#/definitions/Entry"},experiments:{$ref:"#/definitions/Experiments"},externals:{$ref:"#/definitions/Externals"},externalsPresets:{$ref:"#/definitions/ExternalsPresets"},externalsType:{$ref:"#/definitions/ExternalsType"},ignoreWarnings:{$ref:"#/definitions/IgnoreWarnings"},infrastructureLogging:{$ref:"#/definitions/InfrastructureLogging"},loader:{$ref:"#/definitions/Loader"},mode:{$ref:"#/definitions/Mode"},module:{$ref:"#/definitions/ModuleOptions"},name:{$ref:"#/definitions/Name"},node:{$ref:"#/definitions/Node"},optimization:{$ref:"#/definitions/Optimization"},output:{$ref:"#/definitions/Output"},parallelism:{$ref:"#/definitions/Parallelism"},performance:{$ref:"#/definitions/Performance"},plugins:{$ref:"#/definitions/Plugins"},profile:{$ref:"#/definitions/Profile"},recordsInputPath:{$ref:"#/definitions/RecordsInputPath"},recordsOutputPath:{$ref:"#/definitions/RecordsOutputPath"},recordsPath:{$ref:"#/definitions/RecordsPath"},resolve:{$ref:"#/definitions/Resolve"},resolveLoader:{$ref:"#/definitions/ResolveLoader"},snapshot:{$ref:"#/definitions/SnapshotOptions"},stats:{$ref:"#/definitions/StatsValue"},target:{$ref:"#/definitions/Target"},watch:{$ref:"#/definitions/Watch"},watchOptions:{$ref:"#/definitions/WatchOptions"}},n=Object.prototype.hasOwnProperty,r={allowCollectingMemory:{type:"boolean"},buildDependencies:{type:"object",additionalProperties:{type:"array",items:{type:"string",minLength:1}}},cacheDirectory:{type:"string",absolutePath:!0},cacheLocation:{type:"string",absolutePath:!0},compression:{enum:[!1,"gzip","brotli"]},hashAlgorithm:{type:"string"},idleTimeout:{type:"number",minimum:0},idleTimeoutAfterLargeChanges:{type:"number",minimum:0},idleTimeoutForInitialStore:{type:"number",minimum:0},immutablePaths:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},managedPaths:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},maxAge:{type:"number",minimum:0},maxMemoryGenerations:{type:"number",minimum:0},memoryCacheUnaffected:{type:"boolean"},name:{type:"string"},profile:{type:"boolean"},store:{enum:["pack"]},type:{enum:["filesystem"]},version:{type:"string"}};function s(t,{instancePath:o="",parentData:a,parentDataProperty:i,rootData:l=t}={}){let p=null,u=0;const f=u;let c=!1;const m=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var y=m===u;if(c=c||y,!c){const s=u;if(u==u)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.type&&(e="type")){const t={params:{missingProperty:e}};null===p?p=[t]:p.push(t),u++}else{const e=u;for(const e in t)if("cacheUnaffected"!==e&&"maxGenerations"!==e&&"type"!==e){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(e===u){if(void 0!==t.cacheUnaffected){const e=u;if("boolean"!=typeof t.cacheUnaffected){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}var h=e===u}else h=!0;if(h){if(void 0!==t.maxGenerations){let e=t.maxGenerations;const n=u;if(u===n)if("number"==typeof e){if(e<1||isNaN(e)){const e={params:{comparison:">=",limit:1}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}h=n===u}else h=!0;if(h)if(void 0!==t.type){const e=u;if("memory"!==t.type){const e={params:{}};null===p?p=[e]:p.push(e),u++}h=e===u}else h=!0}}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}if(y=s===u,c=c||y,!c){const s=u;if(u==u)if(t&&"object"==typeof t&&!Array.isArray(t)){let s;if(void 0===t.type&&(s="type")){const e={params:{missingProperty:s}};null===p?p=[e]:p.push(e),u++}else{const s=u;for(const e in t)if(!n.call(r,e)){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(s===u){if(void 0!==t.allowCollectingMemory){const e=u;if("boolean"!=typeof t.allowCollectingMemory){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}var d=e===u}else d=!0;if(d){if(void 0!==t.buildDependencies){let e=t.buildDependencies;const n=u;if(u===n)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=u;if(u===r)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.cacheDirectory){let n=t.cacheDirectory;const r=u;if(u===r)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.cacheLocation){let n=t.cacheLocation;const r=u;if(u===r)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.compression){let e=t.compression;const n=u;if(!1!==e&&"gzip"!==e&&"brotli"!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.hashAlgorithm){const e=u;if("string"!=typeof t.hashAlgorithm){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.idleTimeout){let e=t.idleTimeout;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.idleTimeoutAfterLargeChanges){let e=t.idleTimeoutAfterLargeChanges;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.idleTimeoutForInitialStore){let e=t.idleTimeoutForInitialStore;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.immutablePaths){let n=t.immutablePaths;const r=u;if(u===r)if(Array.isArray(n)){const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var g=i===u;if(a=a||g,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=n===u,a=a||g}if(a)u=o,null!==p&&(o?p.length=o:p=null);else{const e={params:{}};null===p?p=[e]:p.push(e),u++}if(s!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.managedPaths){let n=t.managedPaths;const r=u;if(u===r)if(Array.isArray(n)){const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var b=i===u;if(a=a||b,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}b=n===u,a=a||b}if(a)u=o,null!==p&&(o?p.length=o:p=null);else{const e={params:{}};null===p?p=[e]:p.push(e),u++}if(s!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.maxAge){let e=t.maxAge;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.maxMemoryGenerations){let e=t.maxMemoryGenerations;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.memoryCacheUnaffected){const e=u;if("boolean"!=typeof t.memoryCacheUnaffected){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.name){const e=u;if("string"!=typeof t.name){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.profile){const e=u;if("boolean"!=typeof t.profile){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.store){const e=u;if("pack"!==t.store){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.type){const e=u;if("filesystem"!==t.type){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d)if(void 0!==t.version){const e=u;if("string"!=typeof t.version){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0}}}}}}}}}}}}}}}}}}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}y=s===u,c=c||y}}if(!c){const e={params:{}};return null===p?p=[e]:p.push(e),u++,s.errors=p,!1}return u=f,null!==p&&(f?p.length=f:p=null),s.errors=p,0===u}function o(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:a=e}={}){let i=null,l=0;const p=l;let u=!1;const f=l;if(!0!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=f===l;if(u=u||c,!u){const o=l;s(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:a})||(i=null===i?s.errors:i.concat(s.errors),l=i.length),c=o===l,u=u||c}if(!u){const e={params:{}};return null===i?i=[e]:i.push(e),l++,o.errors=i,!1}return l=p,null!==i&&(p?i.length=p:i=null),o.errors=i,0===l}const a={asyncChunks:{type:"boolean"},baseUri:{type:"string"},chunkLoading:{$ref:"#/definitions/ChunkLoading"},dependOn:{anyOf:[{type:"array",items:{type:"string",minLength:1},minItems:1,uniqueItems:!0},{type:"string",minLength:1}]},filename:{$ref:"#/definitions/EntryFilename"},import:{$ref:"#/definitions/EntryItem"},layer:{$ref:"#/definitions/Layer"},library:{$ref:"#/definitions/LibraryOptions"},publicPath:{$ref:"#/definitions/PublicPath"},runtime:{$ref:"#/definitions/EntryRuntime"},wasmLoading:{$ref:"#/definitions/WasmLoading"}};function i(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const l=a;let p=!1;const u=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=u===a;if(p=p||f,!p){const t=a,n=a;let r=!1;const s=a;if("jsonp"!==e&&"import-scripts"!==e&&"require"!==e&&"async-node"!==e&&"import"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var c=s===a;if(r=r||c,!r){const t=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a,r=r||c}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,p=p||f}if(!p){const e={params:{}};return null===o?o=[e]:o.push(e),a++,i.errors=o,!1}return a=l,null!==o&&(l?o.length=l:o=null),i.errors=o,0===a}function l(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const p=i;let u=!1,f=null;const c=i,m=i;let y=!1;const h=i;if(i===h)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var d=h===i;if(y=y||d,!y){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}d=e===i,y=y||d}if(y)i=m,null!==a&&(m?a.length=m:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(c===i&&(u=!0,f=0),!u){const e={params:{passingSchemas:f}};return null===a?a=[e]:a.push(e),i++,l.errors=a,!1}return i=p,null!==a&&(p?a.length=p:a=null),l.errors=a,0===i}function p(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const u=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=u===a;if(l=l||f,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("amd"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"root"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.amd){const t=a;if("string"!=typeof e.amd){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var c=t===a}else c=!0;if(c){if(void 0!==e.commonjs){const t=a;if("string"!=typeof e.commonjs){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0;if(c){if(void 0!==e.commonjs2){const t=a;if("string"!=typeof e.commonjs2){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0;if(c)if(void 0!==e.root){const t=a;if("string"!=typeof e.root){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,p.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),p.errors=o,0===a}function u(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a;if(a===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var f=p===a;if(l=l||f,!l){const t=a;if(a===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=t===a,l=l||f,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("amd"!==t&&"commonjs"!==t&&"root"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.amd){let t=e.amd;const n=a;if(a===n)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var c=n===a}else c=!0;if(c){if(void 0!==e.commonjs){let t=e.commonjs;const n=a;if(a===n)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=n===a}else c=!0;if(c)if(void 0!==e.root){let t=e.root;const n=a,r=a;let s=!1;const i=a;if(a===i)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var m=i===a;if(s=s||m,!s){const e=a;if(a===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}m=e===a,s=s||m}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}c=n===a}else c=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,u.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),u.errors=o,0===a}function f(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return f.errors=[{params:{type:"object"}}],!1;{let n;if(void 0===e.type&&(n="type"))return f.errors=[{params:{missingProperty:n}}],!1;{const n=a;for(const t in e)if("auxiliaryComment"!==t&&"export"!==t&&"name"!==t&&"type"!==t&&"umdNamedDefine"!==t)return f.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.auxiliaryComment){const n=a;p(e.auxiliaryComment,{instancePath:t+"/auxiliaryComment",parentData:e,parentDataProperty:"auxiliaryComment",rootData:s})||(o=null===o?p.errors:o.concat(p.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e.export){let t=e.export;const n=a,r=a;let s=!1;const p=a;if(a===p)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var l=p===a;if(s=s||l,!s){const e=a;if(a===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}l=e===a,s=s||l}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,f.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i){if(void 0!==e.name){const n=a;u(e.name,{instancePath:t+"/name",parentData:e,parentDataProperty:"name",rootData:s})||(o=null===o?u.errors:o.concat(u.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e.type){let t=e.type;const n=a,r=a;let s=!1;const l=a;if("var"!==t&&"module"!==t&&"assign"!==t&&"assign-properties"!==t&&"this"!==t&&"window"!==t&&"self"!==t&&"global"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"commonjs-module"!==t&&"commonjs-static"!==t&&"amd"!==t&&"amd-require"!==t&&"umd"!==t&&"umd2"!==t&&"jsonp"!==t&&"system"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var c=l===a;if(s=s||c,!s){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=e===a,s=s||c}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,f.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.umdNamedDefine){const t=a;if("boolean"!=typeof e.umdNamedDefine)return f.errors=[{params:{type:"boolean"}}],!1;i=t===a}else i=!0}}}}}}}return f.errors=o,0===a}function c(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if("auto"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a,n=a;let r=!1;const s=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=s===a;if(r=r||f,!r){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,r=r||f}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,c.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),c.errors=o,0===a}function m(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a,n=a;let r=!1;const s=a;if("fetch-streaming"!==e&&"fetch"!==e&&"async-node"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=s===a;if(r=r||f,!r){const t=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}f=t===a,r=r||f}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,m.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),m.errors=o,0===a}function y(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let p=null,u=0;if(0===u){if(!e||"object"!=typeof e||Array.isArray(e))return y.errors=[{params:{type:"object"}}],!1;{let r;if(void 0===e.import&&(r="import"))return y.errors=[{params:{missingProperty:r}}],!1;{const r=u;for(const t in e)if(!n.call(a,t))return y.errors=[{params:{additionalProperty:t}}],!1;if(r===u){if(void 0!==e.asyncChunks){const t=u;if("boolean"!=typeof e.asyncChunks)return y.errors=[{params:{type:"boolean"}}],!1;var h=t===u}else h=!0;if(h){if(void 0!==e.baseUri){const t=u;if("string"!=typeof e.baseUri)return y.errors=[{params:{type:"string"}}],!1;h=t===u}else h=!0;if(h){if(void 0!==e.chunkLoading){const n=u;i(e.chunkLoading,{instancePath:t+"/chunkLoading",parentData:e,parentDataProperty:"chunkLoading",rootData:o})||(p=null===p?i.errors:p.concat(i.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.dependOn){let t=e.dependOn;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t))if(t.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{var d=!0;const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(!(d=r===u))break}if(d){let e,n=t.length;if(n>1){const r={};for(;n--;){let s=t[n];if("string"==typeof s){if("number"==typeof r[s]){e=r[s];const t={params:{i:n,j:e}};null===p?p=[t]:p.push(t),u++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var g=o===u;if(s=s||g,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=e===u,s=s||g}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.filename){const n=u;l(e.filename,{instancePath:t+"/filename",parentData:e,parentDataProperty:"filename",rootData:o})||(p=null===p?l.errors:p.concat(l.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.import){let t=e.import;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t))if(t.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{var b=!0;const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(!(b=r===u))break}if(b){let e,n=t.length;if(n>1){const r={};for(;n--;){let s=t[n];if("string"==typeof s){if("number"==typeof r[s]){e=r[s];const t={params:{i:n,j:e}};null===p?p=[t]:p.push(t),u++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var v=o===u;if(s=s||v,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}v=e===u,s=s||v}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.layer){let t=e.layer;const n=u,r=u;let s=!1;const o=u;if(null!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var D=o===u;if(s=s||D,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}D=e===u,s=s||D}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.library){const n=u;f(e.library,{instancePath:t+"/library",parentData:e,parentDataProperty:"library",rootData:o})||(p=null===p?f.errors:p.concat(f.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.publicPath){const n=u;c(e.publicPath,{instancePath:t+"/publicPath",parentData:e,parentDataProperty:"publicPath",rootData:o})||(p=null===p?c.errors:p.concat(c.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.runtime){let t=e.runtime;const n=u,r=u;let s=!1;const o=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var P=o===u;if(s=s||P,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}P=e===u,s=s||P}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h)if(void 0!==e.wasmLoading){const n=u;m(e.wasmLoading,{instancePath:t+"/wasmLoading",parentData:e,parentDataProperty:"wasmLoading",rootData:o})||(p=null===p?m.errors:p.concat(m.errors),u=p.length),h=n===u}else h=!0}}}}}}}}}}}}}return y.errors=p,0===u}function h(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return h.errors=[{params:{type:"object"}}],!1;for(const n in e){let r=e[n];const u=a,f=a;let c=!1;const m=a,d=a;let g=!1;const b=a;if(a===b)if(Array.isArray(r))if(r.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{var i=!0;const e=r.length;for(let t=0;t<e;t++){let e=r[t];const n=a;if(a===n)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(!(i=n===a))break}if(i){let e,t=r.length;if(t>1){const n={};for(;t--;){let s=r[t];if("string"==typeof s){if("number"==typeof n[s]){e=n[s];const r={params:{i:t,j:e}};null===o?o=[r]:o.push(r),a++;break}n[s]=t}}}}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var l=b===a;if(g=g||l,!g){const e=a;if(a===e)if("string"==typeof r){if(r.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}l=e===a,g=g||l}if(g)a=d,null!==o&&(d?o.length=d:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}var p=m===a;if(c=c||p,!c){const i=a;y(r,{instancePath:t+"/"+n.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:n,rootData:s})||(o=null===o?y.errors:o.concat(y.errors),a=o.length),p=i===a,c=c||p}if(!c){const e={params:{}};return null===o?o=[e]:o.push(e),a++,h.errors=o,!1}if(a=f,null!==o&&(f?o.length=f:o=null),u!==a)break}}return h.errors=o,0===a}function d(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a,f=a;let c=!1;const m=a;if(a===m)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{var y=!0;const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a;if(a===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(!(y=r===a))break}if(y){let t,n=e.length;if(n>1){const r={};for(;n--;){let s=e[n];if("string"==typeof s){if("number"==typeof r[s]){t=r[s];const e={params:{i:n,j:t}};null===o?o=[e]:o.push(e),a++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var h=m===a;if(c=c||h,!c){const t=a;if(a===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}h=t===a,c=c||h}if(c)a=f,null!==o&&(f?o.length=f:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,d.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),d.errors=o,0===a}function g(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;h(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?h.errors:o.concat(h.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;d(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?d.errors:o.concat(d.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,g.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),g.errors=o,0===a}function b(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;g(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?g.errors:o.concat(g.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,b.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),b.errors=o,0===a}const v={asyncWebAssembly:{type:"boolean"},backCompat:{type:"boolean"},buildHttp:{anyOf:[{$ref:"#/definitions/HttpUriAllowedUris"},{$ref:"#/definitions/HttpUriOptions"}]},cacheUnaffected:{type:"boolean"},css:{anyOf:[{type:"boolean"},{$ref:"#/definitions/CssExperimentOptions"}]},futureDefaults:{type:"boolean"},layers:{type:"boolean"},lazyCompilation:{anyOf:[{type:"boolean"},{$ref:"#/definitions/LazyCompilationOptions"}]},outputModule:{type:"boolean"},syncWebAssembly:{type:"boolean"},topLevelAwait:{type:"boolean"}},D=new RegExp("^https?://","u");function P(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(a==a)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let i=!1;const l=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=l===a;if(i=i||f,!i){const e=a;if(a===e)if("string"==typeof t){if(!D.test(t)){const e={params:{pattern:"^https?://"}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=e===a,i=i||f}}if(i)a=s,null!==o&&(s?o.length=s:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}if(u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,P.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),P.errors=o,0===a}function A(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return A.errors=[{params:{type:"object"}}],!1;{let n;if(void 0===t.allowedUris&&(n="allowedUris"))return A.errors=[{params:{missingProperty:n}}],!1;{const n=i;for(const e in t)if("allowedUris"!==e&&"cacheLocation"!==e&&"frozen"!==e&&"lockfileLocation"!==e&&"proxy"!==e&&"upgrade"!==e)return A.errors=[{params:{additionalProperty:e}}],!1;if(n===i){if(void 0!==t.allowedUris){let e=t.allowedUris;const n=i;if(i==i){if(!Array.isArray(e))return A.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=i,s=i;let o=!1;const p=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var l=p===i;if(o=o||l,!o){const e=i;if(i===e)if("string"==typeof t){if(!D.test(t)){const e={params:{pattern:"^https?://"}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(l=e===i,o=o||l,!o){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}l=e===i,o=o||l}}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,A.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),r!==i)break}}}var p=n===i}else p=!0;if(p){if(void 0!==t.cacheLocation){let n=t.cacheLocation;const r=i,s=i;let o=!1;const l=i;if(!1!==n){const e={params:{}};null===a?a=[e]:a.push(e),i++}var u=l===i;if(o=o||u,!o){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}u=t===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,A.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),p=r===i}else p=!0;if(p){if(void 0!==t.frozen){const e=i;if("boolean"!=typeof t.frozen)return A.errors=[{params:{type:"boolean"}}],!1;p=e===i}else p=!0;if(p){if(void 0!==t.lockfileLocation){let n=t.lockfileLocation;const r=i;if(i===r){if("string"!=typeof n)return A.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return A.errors=[{params:{}}],!1}p=r===i}else p=!0;if(p){if(void 0!==t.proxy){const e=i;if("string"!=typeof t.proxy)return A.errors=[{params:{type:"string"}}],!1;p=e===i}else p=!0;if(p)if(void 0!==t.upgrade){const e=i;if("boolean"!=typeof t.upgrade)return A.errors=[{params:{type:"boolean"}}],!1;p=e===i}else p=!0}}}}}}}}return A.errors=a,0===i}function x(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return x.errors=[{params:{type:"object"}}],!1;{const t=a;for(const t in e)if("backend"!==t&&"entries"!==t&&"imports"!==t&&"test"!==t)return x.errors=[{params:{additionalProperty:t}}],!1;if(t===a){if(void 0!==e.backend){let t=e.backend;const n=a,r=a;let s=!1;const m=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=m===a;if(s=s||i,!s){const e=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=a;for(const e in t)if("client"!==e&&"listen"!==e&&"protocol"!==e&&"server"!==e){const t={params:{additionalProperty:e}};null===o?o=[t]:o.push(t),a++;break}if(e===a){if(void 0!==t.client){const e=a;if("string"!=typeof t.client){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var l=e===a}else l=!0;if(l){if(void 0!==t.listen){let e=t.listen;const n=a,r=a;let s=!1;const i=a;if("number"!=typeof e){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}var p=i===a;if(s=s||p,!s){const t=a;if(a===t)if(e&&"object"==typeof e&&!Array.isArray(e)){if(void 0!==e.host){const t=a;if("string"!=typeof e.host){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var u=t===a}else u=!0;if(u)if(void 0!==e.port){const t=a;if("number"!=typeof e.port){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}u=t===a}else u=!0}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}if(p=t===a,s=s||p,!s){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}p=t===a,s=s||p}}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0;if(l){if(void 0!==t.protocol){let e=t.protocol;const n=a;if("http"!==e&&"https"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0;if(l)if(void 0!==t.server){let e=t.server;const n=a,r=a;let s=!1;const i=a;if(a===i)if(e&&"object"==typeof e&&!Array.isArray(e));else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var f=i===a;if(s=s||f,!s){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,s=s||f}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}i=e===a,s=s||i}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,x.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var c=n===a}else c=!0;if(c){if(void 0!==e.entries){const t=a;if("boolean"!=typeof e.entries)return x.errors=[{params:{type:"boolean"}}],!1;c=t===a}else c=!0;if(c){if(void 0!==e.imports){const t=a;if("boolean"!=typeof e.imports)return x.errors=[{params:{type:"boolean"}}],!1;c=t===a}else c=!0;if(c)if(void 0!==e.test){let t=e.test;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var m=i===a;if(s=s||m,!s){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(m=e===a,s=s||m,!s){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}m=e===a,s=s||m}}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,x.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),c=n===a}else c=!0}}}}}return x.errors=o,0===a}function k(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return k.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(v,t))return k.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.asyncWebAssembly){const t=i;if("boolean"!=typeof e.asyncWebAssembly)return k.errors=[{params:{type:"boolean"}}],!1;var l=t===i}else l=!0;if(l){if(void 0!==e.backCompat){const t=i;if("boolean"!=typeof e.backCompat)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.buildHttp){let n=e.buildHttp;const r=i,s=i;let u=!1;const f=i;P(n,{instancePath:t+"/buildHttp",parentData:e,parentDataProperty:"buildHttp",rootData:o})||(a=null===a?P.errors:a.concat(P.errors),i=a.length);var p=f===i;if(u=u||p,!u){const r=i;A(n,{instancePath:t+"/buildHttp",parentData:e,parentDataProperty:"buildHttp",rootData:o})||(a=null===a?A.errors:a.concat(A.errors),i=a.length),p=r===i,u=u||p}if(!u){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.cacheUnaffected){const t=i;if("boolean"!=typeof e.cacheUnaffected)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.css){let t=e.css;const n=i,r=i;let s=!1;const o=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var u=o===i;if(s=s||u,!s){const e=i;if(i==i)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=i;for(const e in t)if("exportsOnly"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(e===i&&void 0!==t.exportsOnly&&"boolean"!=typeof t.exportsOnly){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}u=e===i,s=s||u}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.futureDefaults){const t=i;if("boolean"!=typeof e.futureDefaults)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.layers){const t=i;if("boolean"!=typeof e.layers)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.lazyCompilation){let n=e.lazyCompilation;const r=i,s=i;let p=!1;const u=i;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const r=i;x(n,{instancePath:t+"/lazyCompilation",parentData:e,parentDataProperty:"lazyCompilation",rootData:o})||(a=null===a?x.errors:a.concat(x.errors),i=a.length),f=r===i,p=p||f}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.outputModule){const t=i;if("boolean"!=typeof e.outputModule)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.syncWebAssembly){const t=i;if("boolean"!=typeof e.syncWebAssembly)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l)if(void 0!==e.topLevelAwait){const t=i;if("boolean"!=typeof e.topLevelAwait)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0}}}}}}}}}}}}return k.errors=a,0===i}const j={validate:S};function S(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const n=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(u=n===a,l=l||u,!l){const n=a;if(a===n)if(e&&"object"==typeof e&&!Array.isArray(e)){const n=a;for(const t in e)if("byLayer"!==t){let n=e[t];const r=a,s=a;let i=!1;const l=a;if(a===l)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var f=l===a;if(i=i||f,!i){const e=a;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if("string"!=typeof n){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if(!n||"object"!=typeof n||Array.isArray(n)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=e===a,i=i||f}}}if(i)a=s,null!==o&&(s?o.length=s:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}if(n===a&&void 0!==e.byLayer){let n=e.byLayer;const r=a;let i=!1;const l=a;if(a===l)if(n&&"object"==typeof n&&!Array.isArray(n))for(const e in n){const r=a;if(j.validate(n[e],{instancePath:t+"/byLayer/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:s})||(o=null===o?j.validate.errors:o.concat(j.validate.errors),a=o.length),r!==a)break}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var c=l===a;if(i=i||c,!i){const e=a;if(!(n instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}c=e===a,i=i||c}if(i)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}if(u=n===a,l=l||u,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,S.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),S.errors=o,0===a}function C(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e)){const n=e.length;for(let r=0;r<n;r++){const n=a;if(S(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?S.errors:o.concat(S.errors),a=o.length),n!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;S(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?S.errors:o.concat(S.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,C.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),C.errors=o,0===a}function O(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,O.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),O.errors=a,0===i}function F(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return F.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("appendOnly"!==t&&"colors"!==t&&"console"!==t&&"debug"!==t&&"level"!==t&&"stream"!==t)return F.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.appendOnly){const t=a;if("boolean"!=typeof e.appendOnly)return F.errors=[{params:{type:"boolean"}}],!1;var i=t===a}else i=!0;if(i){if(void 0!==e.colors){const t=a;if("boolean"!=typeof e.colors)return F.errors=[{params:{type:"boolean"}}],!1;i=t===a}else i=!0;if(i){if(void 0!==e.debug){let n=e.debug;const r=a,p=a;let u=!1;const f=a;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}var l=f===a;if(u=u||l,!u){const r=a;O(n,{instancePath:t+"/debug",parentData:e,parentDataProperty:"debug",rootData:s})||(o=null===o?O.errors:o.concat(O.errors),a=o.length),l=r===a,u=u||l}if(!u){const e={params:{}};return null===o?o=[e]:o.push(e),a++,F.errors=o,!1}a=p,null!==o&&(p?o.length=p:o=null),i=r===a}else i=!0;if(i)if(void 0!==e.level){let t=e.level;const n=a;if("none"!==t&&"error"!==t&&"warn"!==t&&"info"!==t&&"log"!==t&&"verbose"!==t)return F.errors=[{params:{}}],!1;i=n===a}else i=!0}}}}}return F.errors=o,0===a}const R={defaultRules:{oneOf:[{$ref:"#/definitions/RuleSetRules"}]},exprContextCritical:{type:"boolean"},exprContextRecursive:{type:"boolean"},exprContextRegExp:{anyOf:[{instanceof:"RegExp"},{type:"boolean"}]},exprContextRequest:{type:"string"},generator:{$ref:"#/definitions/GeneratorOptionsByModuleType"},noParse:{$ref:"#/definitions/NoParse"},parser:{$ref:"#/definitions/ParserOptionsByModuleType"},rules:{oneOf:[{$ref:"#/definitions/RuleSetRules"}]},strictExportPresence:{type:"boolean"},strictThisContextOnImports:{type:"boolean"},unknownContextCritical:{type:"boolean"},unknownContextRecursive:{type:"boolean"},unknownContextRegExp:{anyOf:[{instanceof:"RegExp"},{type:"boolean"}]},unknownContextRequest:{type:"string"},unsafeCache:{anyOf:[{type:"boolean"},{instanceof:"Function"}]},wrappedContextCritical:{type:"boolean"},wrappedContextRecursive:{type:"boolean"},wrappedContextRegExp:{instanceof:"RegExp"}},E={assert:{type:"object",additionalProperties:{$ref:"#/definitions/RuleSetConditionOrConditions"}},compiler:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},dependency:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},descriptionData:{type:"object",additionalProperties:{$ref:"#/definitions/RuleSetConditionOrConditions"}},enforce:{enum:["pre","post"]},exclude:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},generator:{type:"object"},include:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},issuer:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},issuerLayer:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},layer:{type:"string"},loader:{oneOf:[{$ref:"#/definitions/RuleSetLoader"}]},mimetype:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},oneOf:{type:"array",items:{oneOf:[{$ref:"#/definitions/RuleSetRule"}]}},options:{oneOf:[{$ref:"#/definitions/RuleSetLoaderOptions"}]},parser:{type:"object",additionalProperties:!0},realResource:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},resolve:{type:"object",oneOf:[{$ref:"#/definitions/ResolveOptions"}]},resource:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},resourceFragment:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},resourceQuery:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},rules:{type:"array",items:{oneOf:[{$ref:"#/definitions/RuleSetRule"}]}},scheme:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},sideEffects:{type:"boolean"},test:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},type:{type:"string"},use:{oneOf:[{$ref:"#/definitions/RuleSetUse"}]}},$={validate:w};function z(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return z.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if($.validate(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?$.validate.errors:o.concat($.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,z.errors=o,!1}if(a=i,null!==o&&(i?o.length=i:o=null),n!==a)break}}}return z.errors=o,0===a}function L(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return L.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("and"!==t&&"not"!==t&&"or"!==t)return L.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.and){const n=a,r=a;let l=!1,p=null;const u=a;if(z(e.and,{instancePath:t+"/and",parentData:e,parentDataProperty:"and",rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var i=n===a}else i=!0;if(i){if(void 0!==e.not){const n=a,r=a;let l=!1,p=null;const u=a;if($.validate(e.not,{instancePath:t+"/not",parentData:e,parentDataProperty:"not",rootData:s})||(o=null===o?$.validate.errors:o.concat($.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.or){const n=a,r=a;let l=!1,p=null;const u=a;if(z(e.or,{instancePath:t+"/or",parentData:e,parentDataProperty:"or",rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0}}}}return L.errors=o,0===a}function w(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;if(L(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?L.errors:o.concat(L.errors),a=o.length),u=i===a,l=l||u,!l){const i=a;z(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u=i===a,l=l||u}}}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,w.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),w.errors=o,0===a}function M(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;w(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?w.errors:o.concat(w.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;z(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,M.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),M.errors=o,0===a}const N={validate:B};function T(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return T.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if(N.validate(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?N.validate.errors:o.concat(N.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,T.errors=o,!1}if(a=i,null!==o&&(i?o.length=i:o=null),n!==a)break}}}return T.errors=o,0===a}function I(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return I.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("and"!==t&&"not"!==t&&"or"!==t)return I.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.and){const n=a,r=a;let l=!1,p=null;const u=a;if(T(e.and,{instancePath:t+"/and",parentData:e,parentDataProperty:"and",rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var i=n===a}else i=!0;if(i){if(void 0!==e.not){const n=a,r=a;let l=!1,p=null;const u=a;if(N.validate(e.not,{instancePath:t+"/not",parentData:e,parentDataProperty:"not",rootData:s})||(o=null===o?N.validate.errors:o.concat(N.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.or){const n=a,r=a;let l=!1,p=null;const u=a;if(T(e.or,{instancePath:t+"/or",parentData:e,parentDataProperty:"or",rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0}}}}return I.errors=o,0===a}function B(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const l=i;if(i===l)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=l===i,p=p||f,!p){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f=e===i,p=p||f,!p){const e=i;if(I(t,{instancePath:n,parentData:r,parentDataProperty:s,rootData:o})||(a=null===a?I.errors:a.concat(I.errors),i=a.length),f=e===i,p=p||f,!p){const e=i;T(t,{instancePath:n,parentData:r,parentDataProperty:s,rootData:o})||(a=null===a?T.errors:a.concat(T.errors),i=a.length),f=e===i,p=p||f}}}}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,B.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),B.errors=a,0===i}function U(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;B(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?B.errors:o.concat(B.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;T(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,U.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),U.errors=o,0===a}const q={alias:{$ref:"#/definitions/ResolveAlias"},aliasFields:{type:"array",items:{anyOf:[{type:"array",items:{type:"string",minLength:1}},{type:"string",minLength:1}]}},byDependency:{type:"object",additionalProperties:{oneOf:[{$ref:"#/definitions/ResolveOptions"}]}},cache:{type:"boolean"},cachePredicate:{instanceof:"Function"},cacheWithContext:{type:"boolean"},conditionNames:{type:"array",items:{type:"string"}},descriptionFiles:{type:"array",items:{type:"string",minLength:1}},enforceExtension:{type:"boolean"},exportsFields:{type:"array",items:{type:"string"}},extensions:{type:"array",items:{type:"string"}},fallback:{oneOf:[{$ref:"#/definitions/ResolveAlias"}]},fileSystem:{},fullySpecified:{type:"boolean"},importsFields:{type:"array",items:{type:"string"}},mainFields:{type:"array",items:{anyOf:[{type:"array",items:{type:"string",minLength:1}},{type:"string",minLength:1}]}},mainFiles:{type:"array",items:{type:"string",minLength:1}},modules:{type:"array",items:{type:"string",minLength:1}},plugins:{type:"array",items:{anyOf:[{enum:["..."]},{$ref:"#/definitions/ResolvePluginInstance"}]}},preferAbsolute:{type:"boolean"},preferRelative:{type:"boolean"},resolver:{},restrictions:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},roots:{type:"array",items:{type:"string"}},symlinks:{type:"boolean"},unsafeCache:{anyOf:[{type:"boolean"},{type:"object",additionalProperties:!0}]},useSyncFileSystemCalls:{type:"boolean"}},G={validate:W};function W(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return W.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(q,e))return W.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.alias&&(e="alias")||void 0===t.name&&(e="name")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else{const e=l;for(const e in t)if("alias"!==e&&"name"!==e&&"onlyModule"!==e){const t={params:{additionalProperty:e}};null===i?i=[t]:i.push(t),l++;break}if(e===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var p=o===l;if(s=s||p,!s){const t=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(p=t===l,s=s||p,!s){const t=l;if(l===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}p=t===l,s=s||p}}if(s)l=r,null!==i&&(r?i.length=r:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=n===l}else u=!0;if(u){if(void 0!==t.name){const e=l;if("string"!=typeof t.name){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}u=e===l}else u=!0;if(u)if(void 0!==t.onlyModule){const e=l;if("boolean"!=typeof t.onlyModule){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}u=e===l}else u=!0}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var f=o===l;if(s=s||f,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const e=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(c=e===l,o=o||c,!o){const e=l;if(l===e)if("string"==typeof n){if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}}if(o)l=s,null!==i&&(s?i.length=s:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}f=t===l,s=s||f}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null);var m=n===l}else m=!0;if(m){if(void 0!==t.aliasFields){let e=t.aliasFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var y=a===l;if(o=o||y,!o){const e=l;if(l===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}y=e===l,o=o||y}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.byDependency){let e=t.byDependency;const n=l;if(l===n){if(!e||"object"!=typeof e||Array.isArray(e))return W.errors=[{params:{type:"object"}}],!1;for(const t in e){const n=l,s=l;let o=!1,p=null;const u=l;if(G.validate(e[t],{instancePath:r+"/byDependency/"+t.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:t,rootData:a})||(i=null===i?G.validate.errors:i.concat(G.validate.errors),l=i.length),u===l&&(o=!0,p=0),!o){const e={params:{passingSchemas:p}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),n!==l)break}}m=n===l}else m=!0;if(m){if(void 0!==t.cache){const e=l;if("boolean"!=typeof t.cache)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.cachePredicate){const e=l;if(!(t.cachePredicate instanceof Function))return W.errors=[{params:{}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.cacheWithContext){const e=l;if("boolean"!=typeof t.cacheWithContext)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.conditionNames){let e=t.conditionNames;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.descriptionFiles){let e=t.descriptionFiles;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.enforceExtension){const e=l;if("boolean"!=typeof t.enforceExtension)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.exportsFields){let e=t.exportsFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.extensions){let e=t.extensions;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.fallback){let e=t.fallback;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.alias&&(e="alias")||void 0===t.name&&(e="name")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else{const e=l;for(const e in t)if("alias"!==e&&"name"!==e&&"onlyModule"!==e){const t={params:{additionalProperty:e}};null===i?i=[t]:i.push(t),l++;break}if(e===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var h=o===l;if(s=s||h,!s){const t=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(h=t===l,s=s||h,!s){const t=l;if(l===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}h=t===l,s=s||h}}if(s)l=r,null!==i&&(r?i.length=r:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}var d=n===l}else d=!0;if(d){if(void 0!==t.name){const e=l;if("string"!=typeof t.name){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}d=e===l}else d=!0;if(d)if(void 0!==t.onlyModule){const e=l;if("boolean"!=typeof t.onlyModule){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}d=e===l}else d=!0}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var g=f===l;if(u=u||g,!u){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var b=a===l;if(o=o||b,!o){const e=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(b=e===l,o=o||b,!o){const e=l;if(l===e)if("string"==typeof n){if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}b=e===l,o=o||b}}if(o)l=s,null!==i&&(s?i.length=s:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=t===l,u=u||g}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),m=n===l}else m=!0;if(m){if(void 0!==t.fullySpecified){const e=l;if("boolean"!=typeof t.fullySpecified)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.importsFields){let e=t.importsFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.mainFields){let e=t.mainFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var v=a===l;if(o=o||v,!o){const e=l;if(l===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}v=e===l,o=o||v}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.mainFiles){let e=t.mainFiles;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.modules){let e=t.modules;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.plugins){let e=t.plugins;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if("..."!==t){const e={params:{}};null===i?i=[e]:i.push(e),l++}var D=a===l;if(o=o||D,!o){const e=l;if(l==l)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.apply&&(e="apply")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else if(void 0!==t.apply&&!(t.apply instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}D=e===l,o=o||D}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.preferAbsolute){const e=l;if("boolean"!=typeof t.preferAbsolute)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.preferRelative){const e=l;if("boolean"!=typeof t.preferRelative)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.restrictions){let n=t.restrictions;const r=l;if(l===r){if(!Array.isArray(n))return W.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=l,o=l;let a=!1;const p=l;if(!(t instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var P=p===l;if(a=a||P,!a){const n=l;if(l===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}P=n===l,a=a||P}if(!a){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=o,null!==i&&(o?i.length=o:i=null),s!==l)break}}}m=r===l}else m=!0;if(m){if(void 0!==t.roots){let e=t.roots;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.symlinks){const e=l;if("boolean"!=typeof t.symlinks)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.unsafeCache){let e=t.unsafeCache;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var A=o===l;if(s=s||A,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e));else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}A=t===l,s=s||A}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),m=n===l}else m=!0;if(m)if(void 0!==t.useSyncFileSystemCalls){const e=l;if("boolean"!=typeof t.useSyncFileSystemCalls)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0}}}}}}}}}}}}}}}}}}}}}}}}}}return W.errors=i,0===l}function H(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("ident"!==t&&"loader"!==t&&"options"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.ident){const t=a;if("string"!=typeof e.ident){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var u=t===a}else u=!0;if(u){if(void 0!==e.loader){let t=e.loader;const n=a,r=a;let s=!1,i=null;const l=a;if(a==a)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(l===a&&(s=!0,i=0),s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{passingSchemas:i}};null===o?o=[e]:o.push(e),a++}u=n===a}else u=!0;if(u)if(void 0!==e.options){let t=e.options;const n=a,r=a;let s=!1,i=null;const l=a,p=a;let c=!1;const m=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=m===a;if(c=c||f,!c){const e=a;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=e===a,c=c||f}if(c)a=p,null!==o&&(p?o.length=p:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(l===a&&(s=!0,i=0),s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{passingSchemas:i}};null===o?o=[e]:o.push(e),a++}u=n===a}else u=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var c=p===a;if(l=l||c,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(c=t===a,l=l||c,!l){const t=a;if(a==a)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a,l=l||c}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,H.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),H.errors=o,0===a}function _(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e)){const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if(H(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?H.errors:o.concat(H.errors),a=o.length),u===a&&(l=!0,p=0),l)a=i,null!==o&&(i?o.length=i:o=null);else{const e={params:{passingSchemas:p}};null===o?o=[e]:o.push(e),a++}if(n!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;H(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?H.errors:o.concat(H.errors),a=o.length),u=i===a,l=l||u}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,_.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),_.errors=o,0===a}const Q={validate:J};function J(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return J.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(E,t))return J.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.assert){let n=e.assert;const r=i;if(i===r){if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;for(const e in n){const r=i;if(M(n[e],{instancePath:t+"/assert/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),r!==i)break}}var l=r===i}else l=!0;if(l){if(void 0!==e.compiler){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.compiler,{instancePath:t+"/compiler",parentData:e,parentDataProperty:"compiler",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.dependency){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.dependency,{instancePath:t+"/dependency",parentData:e,parentDataProperty:"dependency",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.descriptionData){let n=e.descriptionData;const r=i;if(i===r){if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;for(const e in n){const r=i;if(M(n[e],{instancePath:t+"/descriptionData/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),r!==i)break}}l=r===i}else l=!0;if(l){if(void 0!==e.enforce){let t=e.enforce;const n=i;if("pre"!==t&&"post"!==t)return J.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.exclude){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.exclude,{instancePath:t+"/exclude",parentData:e,parentDataProperty:"exclude",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.generator){let t=e.generator;const n=i;if(!t||"object"!=typeof t||Array.isArray(t))return J.errors=[{params:{type:"object"}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.include){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.include,{instancePath:t+"/include",parentData:e,parentDataProperty:"include",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.issuer){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.issuer,{instancePath:t+"/issuer",parentData:e,parentDataProperty:"issuer",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.issuerLayer){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.issuerLayer,{instancePath:t+"/issuerLayer",parentData:e,parentDataProperty:"issuerLayer",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.layer){const t=i;if("string"!=typeof e.layer)return J.errors=[{params:{type:"string"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.loader){let t=e.loader;const n=i,r=i;let s=!1,o=null;const p=i;if(i==i)if("string"==typeof t){if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(p===i&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.mimetype){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.mimetype,{instancePath:t+"/mimetype",parentData:e,parentDataProperty:"mimetype",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.oneOf){let n=e.oneOf;const r=i;if(i===r){if(!Array.isArray(n))return J.errors=[{params:{type:"array"}}],!1;{const e=n.length;for(let r=0;r<e;r++){const e=i,s=i;let l=!1,p=null;const u=i;if(Q.validate(n[r],{instancePath:t+"/oneOf/"+r,parentData:n,parentDataProperty:r,rootData:o})||(a=null===a?Q.validate.errors:a.concat(Q.validate.errors),i=a.length),u===i&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),e!==i)break}}}l=r===i}else l=!0;if(l){if(void 0!==e.options){let t=e.options;const n=i,r=i;let s=!1,o=null;const u=i,f=i;let c=!1;const m=i;if("string"!=typeof t){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=m===i;if(c=c||p,!c){const e=i;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}p=e===i,c=c||p}if(c)i=f,null!==a&&(f?a.length=f:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.parser){let t=e.parser;const n=i;if(i===n&&(!t||"object"!=typeof t||Array.isArray(t)))return J.errors=[{params:{type:"object"}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.realResource){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.realResource,{instancePath:t+"/realResource",parentData:e,parentDataProperty:"realResource",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resolve){let n=e.resolve;const r=i;if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;const s=i;let p=!1,u=null;const f=i;if(W(n,{instancePath:t+"/resolve",parentData:e,parentDataProperty:"resolve",rootData:o})||(a=null===a?W.errors:a.concat(W.errors),i=a.length),f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.resource){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.resource,{instancePath:t+"/resource",parentData:e,parentDataProperty:"resource",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resourceFragment){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.resourceFragment,{instancePath:t+"/resourceFragment",parentData:e,parentDataProperty:"resourceFragment",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resourceQuery){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.resourceQuery,{instancePath:t+"/resourceQuery",parentData:e,parentDataProperty:"resourceQuery",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.rules){let n=e.rules;const r=i;if(i===r){if(!Array.isArray(n))return J.errors=[{params:{type:"array"}}],!1;{const e=n.length;for(let r=0;r<e;r++){const e=i,s=i;let l=!1,p=null;const u=i;if(Q.validate(n[r],{instancePath:t+"/rules/"+r,parentData:n,parentDataProperty:r,rootData:o})||(a=null===a?Q.validate.errors:a.concat(Q.validate.errors),i=a.length),u===i&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),e!==i)break}}}l=r===i}else l=!0;if(l){if(void 0!==e.scheme){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.scheme,{instancePath:t+"/scheme",parentData:e,parentDataProperty:"scheme",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.sideEffects){const t=i;if("boolean"!=typeof e.sideEffects)return J.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.test){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.test,{instancePath:t+"/test",parentData:e,parentDataProperty:"test",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.type){const t=i;if("string"!=typeof e.type)return J.errors=[{params:{type:"string"}}],!1;l=t===i}else l=!0;if(l)if(void 0!==e.use){const n=i,r=i;let s=!1,p=null;const u=i;if(_(e.use,{instancePath:t+"/use",parentData:e,parentDataProperty:"use",rootData:o})||(a=null===a?_.errors:a.concat(_.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}return J.errors=a,0===i}function V(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return V.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){let n=e[r];const l=a,p=a;let u=!1;const f=a;if("..."!==n){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=f===a;if(u=u||i,!u){const l=a;J(n,{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?J.errors:o.concat(J.errors),a=o.length),i=l===a,u=u||i}if(!u){const e={params:{}};return null===o?o=[e]:o.push(e),a++,V.errors=o,!1}if(a=p,null!==o&&(p?o.length=p:o=null),l!==a)break}}}return V.errors=o,0===a}function Z(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("encoding"!==t&&"mimetype"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.encoding){let t=e.encoding;const n=a;if(!1!==t&&"base64"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=n===a}else u=!0;if(u)if(void 0!==e.mimetype){const t=a;if("string"!=typeof e.mimetype){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}u=t===a}else u=!0}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var f=p===a;if(l=l||f,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,Z.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Z.errors=o,0===a}function K(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return K.errors=[{params:{type:"object"}}],!1;{const r=i;for(const e in t)if("dataUrl"!==e&&"emit"!==e&&"filename"!==e&&"outputPath"!==e&&"publicPath"!==e)return K.errors=[{params:{additionalProperty:e}}],!1;if(r===i){if(void 0!==t.dataUrl){const e=i;Z(t.dataUrl,{instancePath:n+"/dataUrl",parentData:t,parentDataProperty:"dataUrl",rootData:o})||(a=null===a?Z.errors:a.concat(Z.errors),i=a.length);var l=e===i}else l=!0;if(l){if(void 0!==t.emit){const e=i;if("boolean"!=typeof t.emit)return K.errors=[{params:{type:"boolean"}}],!1;l=e===i}else l=!0;if(l){if(void 0!==t.filename){let n=t.filename;const r=i,s=i;let o=!1;const u=i;if(i===u)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(n.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=u===i;if(o=o||p,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}p=e===i,o=o||p}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==t.outputPath){let n=t.outputPath;const r=i,s=i;let o=!1;const p=i;if(i===p)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var u=p===i;if(o=o||u,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=e===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==t.publicPath){let e=t.publicPath;const n=i,r=i;let s=!1;const o=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=t===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}return K.errors=a,0===i}function X(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return X.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("dataUrl"!==t)return X.errors=[{params:{additionalProperty:t}}],!1;n===a&&void 0!==e.dataUrl&&(Z(e.dataUrl,{instancePath:t+"/dataUrl",parentData:e,parentDataProperty:"dataUrl",rootData:s})||(o=null===o?Z.errors:o.concat(Z.errors),a=o.length))}}return X.errors=o,0===a}function Y(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return Y.errors=[{params:{type:"object"}}],!1;{const n=i;for(const e in t)if("emit"!==e&&"filename"!==e&&"outputPath"!==e&&"publicPath"!==e)return Y.errors=[{params:{additionalProperty:e}}],!1;if(n===i){if(void 0!==t.emit){const e=i;if("boolean"!=typeof t.emit)return Y.errors=[{params:{type:"boolean"}}],!1;var l=e===i}else l=!0;if(l){if(void 0!==t.filename){let n=t.filename;const r=i,s=i;let o=!1;const u=i;if(i===u)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(n.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=u===i;if(o=o||p,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}p=e===i,o=o||p}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==t.outputPath){let n=t.outputPath;const r=i,s=i;let o=!1;const p=i;if(i===p)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var u=p===i;if(o=o||u,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=e===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==t.publicPath){let e=t.publicPath;const n=i,r=i;let s=!1;const o=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=t===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}return Y.errors=a,0===i}function ee(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return ee.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("asset"!==t&&"asset/inline"!==t&&"asset/resource"!==t&&"javascript"!==t&&"javascript/auto"!==t&&"javascript/dynamic"!==t&&"javascript/esm"!==t){let n=e[t];const r=a;if(a===r&&(!n||"object"!=typeof n||Array.isArray(n)))return ee.errors=[{params:{type:"object"}}],!1;if(r!==a)break}if(n===a){if(void 0!==e.asset){const n=a;K(e.asset,{instancePath:t+"/asset",parentData:e,parentDataProperty:"asset",rootData:s})||(o=null===o?K.errors:o.concat(K.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e["asset/inline"]){const n=a;X(e["asset/inline"],{instancePath:t+"/asset~1inline",parentData:e,parentDataProperty:"asset/inline",rootData:s})||(o=null===o?X.errors:o.concat(X.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["asset/resource"]){const n=a;Y(e["asset/resource"],{instancePath:t+"/asset~1resource",parentData:e,parentDataProperty:"asset/resource",rootData:s})||(o=null===o?Y.errors:o.concat(Y.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e.javascript){let t=e.javascript;const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["javascript/auto"]){let t=e["javascript/auto"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["javascript/dynamic"]){let t=e["javascript/dynamic"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i)if(void 0!==e["javascript/esm"]){let t=e["javascript/esm"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0}}}}}}}}return ee.errors=o,0===a}function te(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return te.errors=[{params:{type:"object"}}],!1;{const t=a;for(const t in e)if("dataUrlCondition"!==t)return te.errors=[{params:{additionalProperty:t}}],!1;if(t===a&&void 0!==e.dataUrlCondition){let t=e.dataUrlCondition;const n=a;let r=!1;const s=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=a;for(const e in t)if("maxSize"!==e){const t={params:{additionalProperty:e}};null===o?o=[t]:o.push(t),a++;break}if(e===a&&void 0!==t.maxSize&&"number"!=typeof t.maxSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var i=s===a;if(r=r||i,!r){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}i=e===a,r=r||i}if(!r){const e={params:{}};return null===o?o=[e]:o.push(e),a++,te.errors=o,!1}a=n,null!==o&&(n?o.length=n:o=null)}}}return te.errors=o,0===a}function ne(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("__dirname"!==t&&"__filename"!==t&&"global"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.__dirname){let t=e.__dirname;const n=a;if(!1!==t&&!0!==t&&"warn-mock"!==t&&"mock"!==t&&"eval-only"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=n===a}else f=!0;if(f){if(void 0!==e.__filename){let t=e.__filename;const n=a;if(!1!==t&&!0!==t&&"warn-mock"!==t&&"mock"!==t&&"eval-only"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0;if(f)if(void 0!==e.global){let t=e.global;const n=a;if(!1!==t&&!0!==t&&"warn"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ne.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ne.errors=o,0===a}function re(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return re.errors=[{params:{type:"object"}}],!1;if(void 0!==e.amd){let t=e.amd;const n=a,r=a;let s=!1;const p=a;if(!1!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(s=s||i,!s){const e=a;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}i=e===a,s=s||i}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var l=n===a}else l=!0;if(l){if(void 0!==e.browserify){const t=a;if("boolean"!=typeof e.browserify)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.commonjs){const t=a;if("boolean"!=typeof e.commonjs)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.commonjsMagicComments){const t=a;if("boolean"!=typeof e.commonjsMagicComments)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exportsPresence){let t=e.exportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.exprContextCritical){const t=a;if("boolean"!=typeof e.exprContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exprContextRecursive){const t=a;if("boolean"!=typeof e.exprContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exprContextRegExp){let t=e.exprContextRegExp;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var p=i===a;if(s=s||p,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}p=e===a,s=s||p}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.exprContextRequest){const t=a;if("string"!=typeof e.exprContextRequest)return re.errors=[{params:{type:"string"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.harmony){const t=a;if("boolean"!=typeof e.harmony)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.import){const t=a;if("boolean"!=typeof e.import)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.importExportsPresence){let t=e.importExportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.importMeta){const t=a;if("boolean"!=typeof e.importMeta)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.node){const n=a;ne(e.node,{instancePath:t+"/node",parentData:e,parentDataProperty:"node",rootData:s})||(o=null===o?ne.errors:o.concat(ne.errors),a=o.length),l=n===a}else l=!0;if(l){if(void 0!==e.reexportExportsPresence){let t=e.reexportExportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.requireContext){const t=a;if("boolean"!=typeof e.requireContext)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireEnsure){const t=a;if("boolean"!=typeof e.requireEnsure)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireInclude){const t=a;if("boolean"!=typeof e.requireInclude)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireJs){const t=a;if("boolean"!=typeof e.requireJs)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.strictExportPresence){const t=a;if("boolean"!=typeof e.strictExportPresence)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.strictThisContextOnImports){const t=a;if("boolean"!=typeof e.strictThisContextOnImports)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.system){const t=a;if("boolean"!=typeof e.system)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextCritical){const t=a;if("boolean"!=typeof e.unknownContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextRecursive){const t=a;if("boolean"!=typeof e.unknownContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextRegExp){let t=e.unknownContextRegExp;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=i===a;if(s=s||u,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}u=e===a,s=s||u}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.unknownContextRequest){const t=a;if("string"!=typeof e.unknownContextRequest)return re.errors=[{params:{type:"string"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.url){let t=e.url;const n=a,r=a;let s=!1;const i=a;if("relative"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=i===a;if(s=s||f,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}f=e===a,s=s||f}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.worker){let t=e.worker;const n=a,r=a;let s=!1;const i=a;if(a===i)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var c=i===a;if(s=s||c,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}c=e===a,s=s||c}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.wrappedContextCritical){const t=a;if("boolean"!=typeof e.wrappedContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.wrappedContextRecursive){const t=a;if("boolean"!=typeof e.wrappedContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l)if(void 0!==e.wrappedContextRegExp){const t=a;if(!(e.wrappedContextRegExp instanceof RegExp))return re.errors=[{params:{}}],!1;l=t===a}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return re.errors=o,0===a}function se(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return se.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("asset"!==t&&"asset/inline"!==t&&"asset/resource"!==t&&"asset/source"!==t&&"javascript"!==t&&"javascript/auto"!==t&&"javascript/dynamic"!==t&&"javascript/esm"!==t){let n=e[t];const r=a;if(a===r&&(!n||"object"!=typeof n||Array.isArray(n)))return se.errors=[{params:{type:"object"}}],!1;if(r!==a)break}if(n===a){if(void 0!==e.asset){const n=a;te(e.asset,{instancePath:t+"/asset",parentData:e,parentDataProperty:"asset",rootData:s})||(o=null===o?te.errors:o.concat(te.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e["asset/inline"]){let t=e["asset/inline"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["asset/resource"]){let t=e["asset/resource"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["asset/source"]){let t=e["asset/source"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e.javascript){const n=a;re(e.javascript,{instancePath:t+"/javascript",parentData:e,parentDataProperty:"javascript",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["javascript/auto"]){const n=a;re(e["javascript/auto"],{instancePath:t+"/javascript~1auto",parentData:e,parentDataProperty:"javascript/auto",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["javascript/dynamic"]){const n=a;re(e["javascript/dynamic"],{instancePath:t+"/javascript~1dynamic",parentData:e,parentDataProperty:"javascript/dynamic",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i)if(void 0!==e["javascript/esm"]){const n=a;re(e["javascript/esm"],{instancePath:t+"/javascript~1esm",parentData:e,parentDataProperty:"javascript/esm",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0}}}}}}}}}return se.errors=o,0===a}function oe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return oe.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(R,e))return oe.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.defaultRules){const e=l,n=l;let s=!1,o=null;const u=l;if(V(t.defaultRules,{instancePath:r+"/defaultRules",parentData:t,parentDataProperty:"defaultRules",rootData:a})||(i=null===i?V.errors:i.concat(V.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null);var p=e===l}else p=!0;if(p){if(void 0!==t.exprContextCritical){const e=l;if("boolean"!=typeof t.exprContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exprContextRecursive){const e=l;if("boolean"!=typeof t.exprContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exprContextRegExp){let e=t.exprContextRegExp;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.exprContextRequest){const e=l;if("string"!=typeof t.exprContextRequest)return oe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.generator){const e=l;ee(t.generator,{instancePath:r+"/generator",parentData:t,parentDataProperty:"generator",rootData:a})||(i=null===i?ee.errors:i.concat(ee.errors),l=i.length),p=e===l}else p=!0;if(p){if(void 0!==t.noParse){let n=t.noParse;const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n))if(n.length<1){const e={params:{limit:1}};null===i?i=[e]:i.push(e),l++}else{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=l,o=l;let a=!1;const p=l;if(!(t instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var f=p===l;if(a=a||f,!a){const n=l;if(l===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(f=n===l,a=a||f,!a){const e=l;if(!(t instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}f=e===l,a=a||f}}if(a)l=o,null!==i&&(o?i.length=o:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(s!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const t=l;if(!(n instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(c=t===l,o=o||c,!o){const t=l;if(l===t)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(c=t===l,o=o||c,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}}}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.parser){const e=l;se(t.parser,{instancePath:r+"/parser",parentData:t,parentDataProperty:"parser",rootData:a})||(i=null===i?se.errors:i.concat(se.errors),l=i.length),p=e===l}else p=!0;if(p){if(void 0!==t.rules){const e=l,n=l;let s=!1,o=null;const u=l;if(V(t.rules,{instancePath:r+"/rules",parentData:t,parentDataProperty:"rules",rootData:a})||(i=null===i?V.errors:i.concat(V.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0;if(p){if(void 0!==t.strictExportPresence){const e=l;if("boolean"!=typeof t.strictExportPresence)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.strictThisContextOnImports){const e=l;if("boolean"!=typeof t.strictThisContextOnImports)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextCritical){const e=l;if("boolean"!=typeof t.unknownContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextRecursive){const e=l;if("boolean"!=typeof t.unknownContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextRegExp){let e=t.unknownContextRegExp;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.unknownContextRequest){const e=l;if("string"!=typeof t.unknownContextRequest)return oe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unsafeCache){let e=t.unsafeCache;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var y=o===l;if(s=s||y,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}y=t===l,s=s||y}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.wrappedContextCritical){const e=l;if("boolean"!=typeof t.wrappedContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.wrappedContextRecursive){const e=l;if("boolean"!=typeof t.wrappedContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p)if(void 0!==t.wrappedContextRegExp){const e=l;if(!(t.wrappedContextRegExp instanceof RegExp))return oe.errors=[{params:{}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}return oe.errors=i,0===l}const ae={checkWasmTypes:{type:"boolean"},chunkIds:{enum:["natural","named","deterministic","size","total-size",!1]},concatenateModules:{type:"boolean"},emitOnErrors:{type:"boolean"},flagIncludedChunks:{type:"boolean"},innerGraph:{type:"boolean"},mangleExports:{anyOf:[{enum:["size","deterministic"]},{type:"boolean"}]},mangleWasmImports:{type:"boolean"},mergeDuplicateChunks:{type:"boolean"},minimize:{type:"boolean"},minimizer:{type:"array",items:{anyOf:[{enum:["..."]},{$ref:"#/definitions/WebpackPluginInstance"},{$ref:"#/definitions/WebpackPluginFunction"}]}},moduleIds:{enum:["natural","named","hashed","deterministic","size",!1]},noEmitOnErrors:{type:"boolean"},nodeEnv:{anyOf:[{enum:[!1]},{type:"string"}]},portableRecords:{type:"boolean"},providedExports:{type:"boolean"},realContentHash:{type:"boolean"},removeAvailableModules:{type:"boolean"},removeEmptyChunks:{type:"boolean"},runtimeChunk:{$ref:"#/definitions/OptimizationRuntimeChunk"},sideEffects:{anyOf:[{enum:["flag"]},{type:"boolean"}]},splitChunks:{anyOf:[{enum:[!1]},{$ref:"#/definitions/OptimizationSplitChunksOptions"}]},usedExports:{anyOf:[{enum:["global"]},{type:"boolean"}]}},ie={automaticNameDelimiter:{type:"string",minLength:1},cacheGroups:{type:"object",additionalProperties:{anyOf:[{enum:[!1]},{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"},{$ref:"#/definitions/OptimizationSplitChunksCacheGroup"}]},not:{type:"object",additionalProperties:!0,properties:{test:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]}},required:["test"]}},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},defaultSizeTypes:{type:"array",items:{type:"string"},minItems:1},enforceSizeThreshold:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},fallbackCacheGroup:{type:"object",additionalProperties:!1,properties:{automaticNameDelimiter:{type:"string",minLength:1},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]}}},filename:{anyOf:[{type:"string",absolutePath:!1,minLength:1},{instanceof:"Function"}]},hidePathInfo:{type:"boolean"},maxAsyncRequests:{type:"number",minimum:1},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialRequests:{type:"number",minimum:1},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minChunks:{type:"number",minimum:1},minRemainingSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},name:{anyOf:[{enum:[!1]},{type:"string"},{instanceof:"Function"}]},usedExports:{type:"boolean"}},le={automaticNameDelimiter:{type:"string",minLength:1},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},enforce:{type:"boolean"},enforceSizeThreshold:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},filename:{anyOf:[{type:"string",absolutePath:!1,minLength:1},{instanceof:"Function"}]},idHint:{type:"string"},layer:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},maxAsyncRequests:{type:"number",minimum:1},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialRequests:{type:"number",minimum:1},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minChunks:{type:"number",minimum:1},minRemainingSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},name:{anyOf:[{enum:[!1]},{type:"string"},{instanceof:"Function"}]},priority:{type:"number"},reuseExistingChunk:{type:"boolean"},test:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},type:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},usedExports:{type:"boolean"}};function pe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return pe.errors=[{params:{type:"object"}}],!1;{const r=l;for(const e in t)if(!n.call(le,e))return pe.errors=[{params:{additionalProperty:e}}],!1;if(r===l){if(void 0!==t.automaticNameDelimiter){let e=t.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof e)return pe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return pe.errors=[{params:{}}],!1}var p=n===l}else p=!0;if(p){if(void 0!==t.chunks){let e=t.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==e&&"async"!==e&&"all"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.enforce){const e=l;if("boolean"!=typeof t.enforce)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.enforceSizeThreshold){let e=t.enforceSizeThreshold;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let c=!1;const m=l;if(l===m)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var f=m===l;if(c=c||f,!c){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}f=t===l,c=c||f}if(c)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.filename){let n=t.filename;const r=l,s=l;let o=!1;const a=l;if(l===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.idHint){const e=l;if("string"!=typeof t.idHint)return pe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.layer){let e=t.layer;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(m=t===l,s=s||m,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncRequests){let e=t.maxAsyncRequests;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncSize){let e=t.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var y=c===l;if(f=f||y,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}y=t===l,f=f||y}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialRequests){let e=t.maxInitialRequests;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialSize){let e=t.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var h=c===l;if(f=f||h,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}h=t===l,f=f||h}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxSize){let e=t.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var d=c===l;if(f=f||d,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}d=t===l,f=f||d}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minChunks){let e=t.minChunks;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.minRemainingSize){let e=t.minRemainingSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var g=c===l;if(f=f||g,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=t===l,f=f||g}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSize){let e=t.minSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var b=c===l;if(f=f||b,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}b=t===l,f=f||b}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSizeReduction){let e=t.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var v=c===l;if(f=f||v,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}v=t===l,f=f||v}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.name){let e=t.name;const n=l,r=l;let s=!1;const o=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var D=o===l;if(s=s||D,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(D=t===l,s=s||D,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}D=t===l,s=s||D}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.priority){const e=l;if("number"!=typeof t.priority)return pe.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reuseExistingChunk){const e=l;if("boolean"!=typeof t.reuseExistingChunk)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.test){let e=t.test;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var P=o===l;if(s=s||P,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(P=t===l,s=s||P,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}P=t===l,s=s||P}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.type){let e=t.type;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var A=o===l;if(s=s||A,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(A=t===l,s=s||A,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}A=t===l,s=s||A}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p)if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}}}}return pe.errors=i,0===l}function ue(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return ue.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(ie,e))return ue.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.automaticNameDelimiter){let e=t.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof e)return ue.errors=[{params:{type:"string"}}],!1;if(e.length<1)return ue.errors=[{params:{}}],!1}var p=n===l}else p=!0;if(p){if(void 0!==t.cacheGroups){let e=t.cacheGroups;const n=l,s=l,o=l;if(l===o)if(e&&"object"==typeof e&&!Array.isArray(e)){let t;if(void 0===e.test&&(t="test")){const e={};null===i?i=[e]:i.push(e),l++}else if(void 0!==e.test){let t=e.test;const n=l;let r=!1;const s=l;if(!(t instanceof RegExp)){const e={};null===i?i=[e]:i.push(e),l++}var u=s===l;if(r=r||u,!r){const e=l;if("string"!=typeof t){const e={};null===i?i=[e]:i.push(e),l++}if(u=e===l,r=r||u,!r){const e=l;if(!(t instanceof Function)){const e={};null===i?i=[e]:i.push(e),l++}u=e===l,r=r||u}}if(r)l=n,null!==i&&(n?i.length=n:i=null);else{const e={};null===i?i=[e]:i.push(e),l++}}}else{const e={};null===i?i=[e]:i.push(e),l++}if(o===l)return ue.errors=[{params:{}}],!1;if(l=s,null!==i&&(s?i.length=s:i=null),l===n){if(!e||"object"!=typeof e||Array.isArray(e))return ue.errors=[{params:{type:"object"}}],!1;for(const t in e){let n=e[t];const s=l,o=l;let p=!1;const u=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}var f=u===l;if(p=p||f,!p){const s=l;if(!(n instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;if("string"!=typeof n){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;pe(n,{instancePath:r+"/cacheGroups/"+t.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:t,rootData:a})||(i=null===i?pe.errors:i.concat(pe.errors),l=i.length),f=s===l,p=p||f}}}}if(!p){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}if(l=o,null!==i&&(o?i.length=o:i=null),s!==l)break}}p=n===l}else p=!0;if(p){if(void 0!==t.chunks){let e=t.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==e&&"async"!==e&&"all"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=o===l;if(s=s||c,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=t===l,s=s||c}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.defaultSizeTypes){let e=t.defaultSizeTypes;const n=l;if(l===n){if(!Array.isArray(e))return ue.errors=[{params:{type:"array"}}],!1;if(e.length<1)return ue.errors=[{params:{limit:1}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return ue.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}p=n===l}else p=!0;if(p){if(void 0!==t.enforceSizeThreshold){let e=t.enforceSizeThreshold;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var m=c===l;if(f=f||m,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}m=t===l,f=f||m}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.fallbackCacheGroup){let e=t.fallbackCacheGroup;const n=l;if(l===n){if(!e||"object"!=typeof e||Array.isArray(e))return ue.errors=[{params:{type:"object"}}],!1;{const t=l;for(const t in e)if("automaticNameDelimiter"!==t&&"chunks"!==t&&"maxAsyncSize"!==t&&"maxInitialSize"!==t&&"maxSize"!==t&&"minSize"!==t&&"minSizeReduction"!==t)return ue.errors=[{params:{additionalProperty:t}}],!1;if(t===l){if(void 0!==e.automaticNameDelimiter){let t=e.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof t)return ue.errors=[{params:{type:"string"}}],!1;if(t.length<1)return ue.errors=[{params:{}}],!1}var y=n===l}else y=!0;if(y){if(void 0!==e.chunks){let t=e.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==t&&"async"!==t&&"all"!==t){const e={params:{}};null===i?i=[e]:i.push(e),l++}var h=o===l;if(s=s||h,!s){const e=l;if(!(t instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}h=e===l,s=s||h}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxAsyncSize){let t=e.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var d=f===l;if(u=u||d,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}d=e===l,u=u||d}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxInitialSize){let t=e.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var g=f===l;if(u=u||g,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=e===l,u=u||g}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxSize){let t=e.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var b=f===l;if(u=u||b,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}b=e===l,u=u||b}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.minSize){let t=e.minSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var v=f===l;if(u=u||v,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}v=e===l,u=u||v}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y)if(void 0!==e.minSizeReduction){let t=e.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var D=f===l;if(u=u||D,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}D=e===l,u=u||D}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0}}}}}}}}p=n===l}else p=!0;if(p){if(void 0!==t.filename){let n=t.filename;const r=l,s=l;let o=!1;const a=l;if(l===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var P=a===l;if(o=o||P,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}P=e===l,o=o||P}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.hidePathInfo){const e=l;if("boolean"!=typeof t.hidePathInfo)return ue.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.maxAsyncRequests){let e=t.maxAsyncRequests;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncSize){let e=t.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var A=c===l;if(f=f||A,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}A=t===l,f=f||A}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialRequests){let e=t.maxInitialRequests;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialSize){let e=t.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var x=c===l;if(f=f||x,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}x=t===l,f=f||x}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxSize){let e=t.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var k=c===l;if(f=f||k,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}k=t===l,f=f||k}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minChunks){let e=t.minChunks;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.minRemainingSize){let e=t.minRemainingSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var j=c===l;if(f=f||j,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}j=t===l,f=f||j}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSize){let e=t.minSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var S=c===l;if(f=f||S,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}S=t===l,f=f||S}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSizeReduction){let e=t.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var C=c===l;if(f=f||C,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}C=t===l,f=f||C}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.name){let e=t.name;const n=l,r=l;let s=!1;const o=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var O=o===l;if(s=s||O,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(O=t===l,s=s||O,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}O=t===l,s=s||O}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p)if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return ue.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}return ue.errors=i,0===l}function fe(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return fe.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(ae,t))return fe.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.checkWasmTypes){const t=i;if("boolean"!=typeof e.checkWasmTypes)return fe.errors=[{params:{type:"boolean"}}],!1;var l=t===i}else l=!0;if(l){if(void 0!==e.chunkIds){let t=e.chunkIds;const n=i;if("natural"!==t&&"named"!==t&&"deterministic"!==t&&"size"!==t&&"total-size"!==t&&!1!==t)return fe.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.concatenateModules){const t=i;if("boolean"!=typeof e.concatenateModules)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.emitOnErrors){const t=i;if("boolean"!=typeof e.emitOnErrors)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.flagIncludedChunks){const t=i;if("boolean"!=typeof e.flagIncludedChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.innerGraph){const t=i;if("boolean"!=typeof e.innerGraph)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.mangleExports){let t=e.mangleExports;const n=i,r=i;let s=!1;const o=i;if("size"!==t&&"deterministic"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var p=o===i;if(s=s||p,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}p=e===i,s=s||p}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.mangleWasmImports){const t=i;if("boolean"!=typeof e.mangleWasmImports)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.mergeDuplicateChunks){const t=i;if("boolean"!=typeof e.mergeDuplicateChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.minimize){const t=i;if("boolean"!=typeof e.minimize)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.minimizer){let t=e.minimizer;const n=i;if(i===n){if(!Array.isArray(t))return fe.errors=[{params:{type:"array"}}],!1;{const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=i,s=i;let o=!1;const l=i;if("..."!==e){const e={params:{}};null===a?a=[e]:a.push(e),i++}var u=l===i;if(o=o||u,!o){const t=i;if(i==i)if(e&&"object"==typeof e&&!Array.isArray(e)){let t;if(void 0===e.apply&&(t="apply")){const e={params:{missingProperty:t}};null===a?a=[e]:a.push(e),i++}else if(void 0!==e.apply&&!(e.apply instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}if(u=t===i,o=o||u,!o){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=t===i,o=o||u}}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),r!==i)break}}}l=n===i}else l=!0;if(l){if(void 0!==e.moduleIds){let t=e.moduleIds;const n=i;if("natural"!==t&&"named"!==t&&"hashed"!==t&&"deterministic"!==t&&"size"!==t&&!1!==t)return fe.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.noEmitOnErrors){const t=i;if("boolean"!=typeof e.noEmitOnErrors)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.nodeEnv){let t=e.nodeEnv;const n=i,r=i;let s=!1;const o=i;if(!1!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const e=i;if("string"!=typeof t){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}f=e===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.portableRecords){const t=i;if("boolean"!=typeof e.portableRecords)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.providedExports){const t=i;if("boolean"!=typeof e.providedExports)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.realContentHash){const t=i;if("boolean"!=typeof e.realContentHash)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.removeAvailableModules){const t=i;if("boolean"!=typeof e.removeAvailableModules)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.removeEmptyChunks){const t=i;if("boolean"!=typeof e.removeEmptyChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.runtimeChunk){let t=e.runtimeChunk;const n=i,r=i;let s=!1;const o=i;if("single"!==t&&"multiple"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var c=o===i;if(s=s||c,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}if(c=e===i,s=s||c,!s){const e=i;if(i===e)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=i;for(const e in t)if("name"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(e===i&&void 0!==t.name){let e=t.name;const n=i;let r=!1;const s=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var m=s===i;if(r=r||m,!r){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=t===i,r=r||m}if(r)i=n,null!==a&&(n?a.length=n:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}c=e===i,s=s||c}}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.sideEffects){let t=e.sideEffects;const n=i,r=i;let s=!1;const o=i;if("flag"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var y=o===i;if(s=s||y,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}y=e===i,s=s||y}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.splitChunks){let n=e.splitChunks;const r=i,s=i;let p=!1;const u=i;if(!1!==n){const e={params:{}};null===a?a=[e]:a.push(e),i++}var h=u===i;if(p=p||h,!p){const r=i;ue(n,{instancePath:t+"/splitChunks",parentData:e,parentDataProperty:"splitChunks",rootData:o})||(a=null===a?ue.errors:a.concat(ue.errors),i=a.length),h=r===i,p=p||h}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==e.usedExports){let t=e.usedExports;const n=i,r=i;let s=!1;const o=i;if("global"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var d=o===i;if(s=s||d,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}d=e===i,s=s||d}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}return fe.errors=a,0===i}const ce={assetModuleFilename:{$ref:"#/definitions/AssetModuleFilename"},asyncChunks:{type:"boolean"},auxiliaryComment:{oneOf:[{$ref:"#/definitions/AuxiliaryComment"}]},charset:{$ref:"#/definitions/Charset"},chunkFilename:{$ref:"#/definitions/ChunkFilename"},chunkFormat:{$ref:"#/definitions/ChunkFormat"},chunkLoadTimeout:{$ref:"#/definitions/ChunkLoadTimeout"},chunkLoading:{$ref:"#/definitions/ChunkLoading"},chunkLoadingGlobal:{$ref:"#/definitions/ChunkLoadingGlobal"},clean:{$ref:"#/definitions/Clean"},compareBeforeEmit:{$ref:"#/definitions/CompareBeforeEmit"},crossOriginLoading:{$ref:"#/definitions/CrossOriginLoading"},cssChunkFilename:{$ref:"#/definitions/CssChunkFilename"},cssFilename:{$ref:"#/definitions/CssFilename"},devtoolFallbackModuleFilenameTemplate:{$ref:"#/definitions/DevtoolFallbackModuleFilenameTemplate"},devtoolModuleFilenameTemplate:{$ref:"#/definitions/DevtoolModuleFilenameTemplate"},devtoolNamespace:{$ref:"#/definitions/DevtoolNamespace"},enabledChunkLoadingTypes:{$ref:"#/definitions/EnabledChunkLoadingTypes"},enabledLibraryTypes:{$ref:"#/definitions/EnabledLibraryTypes"},enabledWasmLoadingTypes:{$ref:"#/definitions/EnabledWasmLoadingTypes"},environment:{$ref:"#/definitions/Environment"},filename:{$ref:"#/definitions/Filename"},globalObject:{$ref:"#/definitions/GlobalObject"},hashDigest:{$ref:"#/definitions/HashDigest"},hashDigestLength:{$ref:"#/definitions/HashDigestLength"},hashFunction:{$ref:"#/definitions/HashFunction"},hashSalt:{$ref:"#/definitions/HashSalt"},hotUpdateChunkFilename:{$ref:"#/definitions/HotUpdateChunkFilename"},hotUpdateGlobal:{$ref:"#/definitions/HotUpdateGlobal"},hotUpdateMainFilename:{$ref:"#/definitions/HotUpdateMainFilename"},iife:{$ref:"#/definitions/Iife"},importFunctionName:{$ref:"#/definitions/ImportFunctionName"},importMetaName:{$ref:"#/definitions/ImportMetaName"},library:{$ref:"#/definitions/Library"},libraryExport:{oneOf:[{$ref:"#/definitions/LibraryExport"}]},libraryTarget:{oneOf:[{$ref:"#/definitions/LibraryType"}]},module:{$ref:"#/definitions/OutputModule"},path:{$ref:"#/definitions/Path"},pathinfo:{$ref:"#/definitions/Pathinfo"},publicPath:{$ref:"#/definitions/PublicPath"},scriptType:{$ref:"#/definitions/ScriptType"},sourceMapFilename:{$ref:"#/definitions/SourceMapFilename"},sourcePrefix:{$ref:"#/definitions/SourcePrefix"},strictModuleErrorHandling:{$ref:"#/definitions/StrictModuleErrorHandling"},strictModuleExceptionHandling:{$ref:"#/definitions/StrictModuleExceptionHandling"},trustedTypes:{anyOf:[{enum:[!0]},{type:"string",minLength:1},{$ref:"#/definitions/TrustedTypes"}]},umdNamedDefine:{oneOf:[{$ref:"#/definitions/UmdNamedDefine"}]},uniqueName:{$ref:"#/definitions/UniqueName"},wasmLoading:{$ref:"#/definitions/WasmLoading"},webassemblyModuleFilename:{$ref:"#/definitions/WebassemblyModuleFilename"},workerChunkLoading:{$ref:"#/definitions/ChunkLoading"},workerWasmLoading:{$ref:"#/definitions/WasmLoading"}},me={arrowFunction:{type:"boolean"},bigIntLiteral:{type:"boolean"},const:{type:"boolean"},destructuring:{type:"boolean"},dynamicImport:{type:"boolean"},forOf:{type:"boolean"},module:{type:"boolean"},optionalChaining:{type:"boolean"},templateLiteral:{type:"boolean"}};function ye(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,ye.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),ye.errors=a,0===i}function he(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const n=i;if(i==i)if(t&&"object"==typeof t&&!Array.isArray(t)){const n=i;for(const e in t)if("dry"!==e&&"keep"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(n===i){if(void 0!==t.dry){const e=i;if("boolean"!=typeof t.dry){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var c=e===i}else c=!0;if(c)if(void 0!==t.keep){let n=t.keep;const r=i,s=i;let o=!1;const l=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=l===i;if(o=o||m,!o){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=t===i,o=o||m,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,o=o||m}}if(o)i=s,null!==a&&(s?a.length=s:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=r===i}else c=!0}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}f=n===i,p=p||f}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,he.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),he.errors=a,0===i}function de(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,de.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),de.errors=a,0===i}function ge(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,ge.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),ge.errors=a,0===i}function be(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return be.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("jsonp"!==t&&"import-scripts"!==t&&"require"!==t&&"async-node"!==t&&"import"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,be.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return be.errors=o,0===a}function ve(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return ve.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("var"!==t&&"module"!==t&&"assign"!==t&&"assign-properties"!==t&&"this"!==t&&"window"!==t&&"self"!==t&&"global"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"commonjs-module"!==t&&"commonjs-static"!==t&&"amd"!==t&&"amd-require"!==t&&"umd"!==t&&"umd2"!==t&&"jsonp"!==t&&"system"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ve.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return ve.errors=o,0===a}function De(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return De.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("fetch-streaming"!==t&&"fetch"!==t&&"async-node"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,De.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return De.errors=o,0===a}function Pe(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,Pe.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Pe.errors=a,0===i}function Ae(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;u(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?u.errors:o.concat(u.errors),a=o.length);var c=p===a;if(l=l||c,!l){const i=a;f(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?f.errors:o.concat(f.errors),a=o.length),c=i===a,l=l||c}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,Ae.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Ae.errors=o,0===a}function xe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let l=null,u=0;if(0===u){if(!t||"object"!=typeof t||Array.isArray(t))return xe.errors=[{params:{type:"object"}}],!1;{const s=u;for(const e in t)if(!n.call(ce,e))return xe.errors=[{params:{additionalProperty:e}}],!1;if(s===u){if(void 0!==t.assetModuleFilename){let n=t.assetModuleFilename;const r=u,s=u;let o=!1;const a=u;if(u===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var f=a===u;if(o=o||f,!o){const e=u;if(!(n instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}f=e===u,o=o||f}if(!o){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=s,null!==l&&(s?l.length=s:l=null);var y=r===u}else y=!0;if(y){if(void 0!==t.asyncChunks){const e=u;if("boolean"!=typeof t.asyncChunks)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.auxiliaryComment){const e=u,n=u;let s=!1,o=null;const i=u;if(p(t.auxiliaryComment,{instancePath:r+"/auxiliaryComment",parentData:t,parentDataProperty:"auxiliaryComment",rootData:a})||(l=null===l?p.errors:l.concat(p.errors),u=l.length),i===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=n,null!==l&&(n?l.length=n:l=null),y=e===u}else y=!0;if(y){if(void 0!==t.charset){const e=u;if("boolean"!=typeof t.charset)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.chunkFilename){const e=u;ye(t.chunkFilename,{instancePath:r+"/chunkFilename",parentData:t,parentDataProperty:"chunkFilename",rootData:a})||(l=null===l?ye.errors:l.concat(ye.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.chunkFormat){let e=t.chunkFormat;const n=u,r=u;let s=!1;const o=u;if("array-push"!==e&&"commonjs"!==e&&"module"!==e&&!1!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var h=o===u;if(s=s||h,!s){const t=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}h=t===u,s=s||h}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.chunkLoadTimeout){const e=u;if("number"!=typeof t.chunkLoadTimeout)return xe.errors=[{params:{type:"number"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.chunkLoading){const e=u;i(t.chunkLoading,{instancePath:r+"/chunkLoading",parentData:t,parentDataProperty:"chunkLoading",rootData:a})||(l=null===l?i.errors:l.concat(i.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.chunkLoadingGlobal){const e=u;if("string"!=typeof t.chunkLoadingGlobal)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.clean){const e=u;he(t.clean,{instancePath:r+"/clean",parentData:t,parentDataProperty:"clean",rootData:a})||(l=null===l?he.errors:l.concat(he.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.compareBeforeEmit){const e=u;if("boolean"!=typeof t.compareBeforeEmit)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.crossOriginLoading){let e=t.crossOriginLoading;const n=u;if(!1!==e&&"anonymous"!==e&&"use-credentials"!==e)return xe.errors=[{params:{}}],!1;y=n===u}else y=!0;if(y){if(void 0!==t.cssChunkFilename){const e=u;de(t.cssChunkFilename,{instancePath:r+"/cssChunkFilename",parentData:t,parentDataProperty:"cssChunkFilename",rootData:a})||(l=null===l?de.errors:l.concat(de.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.cssFilename){const e=u;ge(t.cssFilename,{instancePath:r+"/cssFilename",parentData:t,parentDataProperty:"cssFilename",rootData:a})||(l=null===l?ge.errors:l.concat(ge.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.devtoolFallbackModuleFilenameTemplate){let e=t.devtoolFallbackModuleFilenameTemplate;const n=u,r=u;let s=!1;const o=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var d=o===u;if(s=s||d,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}d=t===u,s=s||d}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.devtoolModuleFilenameTemplate){let e=t.devtoolModuleFilenameTemplate;const n=u,r=u;let s=!1;const o=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var g=o===u;if(s=s||g,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}g=t===u,s=s||g}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.devtoolNamespace){const e=u;if("string"!=typeof t.devtoolNamespace)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.enabledChunkLoadingTypes){const e=u;be(t.enabledChunkLoadingTypes,{instancePath:r+"/enabledChunkLoadingTypes",parentData:t,parentDataProperty:"enabledChunkLoadingTypes",rootData:a})||(l=null===l?be.errors:l.concat(be.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.enabledLibraryTypes){const e=u;ve(t.enabledLibraryTypes,{instancePath:r+"/enabledLibraryTypes",parentData:t,parentDataProperty:"enabledLibraryTypes",rootData:a})||(l=null===l?ve.errors:l.concat(ve.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.enabledWasmLoadingTypes){const e=u;De(t.enabledWasmLoadingTypes,{instancePath:r+"/enabledWasmLoadingTypes",parentData:t,parentDataProperty:"enabledWasmLoadingTypes",rootData:a})||(l=null===l?De.errors:l.concat(De.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.environment){let e=t.environment;const r=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return xe.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if(!n.call(me,t))return xe.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.arrowFunction){const t=u;if("boolean"!=typeof e.arrowFunction)return xe.errors=[{params:{type:"boolean"}}],!1;var b=t===u}else b=!0;if(b){if(void 0!==e.bigIntLiteral){const t=u;if("boolean"!=typeof e.bigIntLiteral)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.const){const t=u;if("boolean"!=typeof e.const)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.destructuring){const t=u;if("boolean"!=typeof e.destructuring)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.dynamicImport){const t=u;if("boolean"!=typeof e.dynamicImport)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.forOf){const t=u;if("boolean"!=typeof e.forOf)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.module){const t=u;if("boolean"!=typeof e.module)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.optionalChaining){const t=u;if("boolean"!=typeof e.optionalChaining)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b)if(void 0!==e.templateLiteral){const t=u;if("boolean"!=typeof e.templateLiteral)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0}}}}}}}}}}y=r===u}else y=!0;if(y){if(void 0!==t.filename){const e=u;Pe(t.filename,{instancePath:r+"/filename",parentData:t,parentDataProperty:"filename",rootData:a})||(l=null===l?Pe.errors:l.concat(Pe.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.globalObject){let e=t.globalObject;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hashDigest){const e=u;if("string"!=typeof t.hashDigest)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.hashDigestLength){let e=t.hashDigestLength;const n=u;if(u==u){if("number"!=typeof e)return xe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return xe.errors=[{params:{comparison:">=",limit:1}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hashFunction){let e=t.hashFunction;const n=u,r=u;let s=!1;const o=u;if(u===o)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var v=o===u;if(s=s||v,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}v=t===u,s=s||v}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.hashSalt){let e=t.hashSalt;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hotUpdateChunkFilename){let n=t.hotUpdateChunkFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.hotUpdateGlobal){const e=u;if("string"!=typeof t.hotUpdateGlobal)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.hotUpdateMainFilename){let n=t.hotUpdateMainFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.iife){const e=u;if("boolean"!=typeof t.iife)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.importFunctionName){const e=u;if("string"!=typeof t.importFunctionName)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.importMetaName){const e=u;if("string"!=typeof t.importMetaName)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.library){const e=u;Ae(t.library,{instancePath:r+"/library",parentData:t,parentDataProperty:"library",rootData:a})||(l=null===l?Ae.errors:l.concat(Ae.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.libraryExport){let e=t.libraryExport;const n=u,r=u;let s=!1,o=null;const a=u,i=u;let p=!1;const f=u;if(u===f)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u;if(u===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===l?l=[e]:l.push(e),u++}var D=f===u;if(p=p||D,!p){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}D=t===u,p=p||D}if(p)u=i,null!==l&&(i?l.length=i:l=null);else{const e={params:{}};null===l?l=[e]:l.push(e),u++}if(a===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.libraryTarget){let e=t.libraryTarget;const n=u,r=u;let s=!1,o=null;const a=u,i=u;let p=!1;const f=u;if("var"!==e&&"module"!==e&&"assign"!==e&&"assign-properties"!==e&&"this"!==e&&"window"!==e&&"self"!==e&&"global"!==e&&"commonjs"!==e&&"commonjs2"!==e&&"commonjs-module"!==e&&"commonjs-static"!==e&&"amd"!==e&&"amd-require"!==e&&"umd"!==e&&"umd2"!==e&&"jsonp"!==e&&"system"!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var P=f===u;if(p=p||P,!p){const t=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}P=t===u,p=p||P}if(p)u=i,null!==l&&(i?l.length=i:l=null);else{const e={params:{}};null===l?l=[e]:l.push(e),u++}if(a===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.module){const e=u;if("boolean"!=typeof t.module)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.path){let n=t.path;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.pathinfo){let e=t.pathinfo;const n=u,r=u;let s=!1;const o=u;if("verbose"!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var A=o===u;if(s=s||A,!s){const t=u;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===l?l=[e]:l.push(e),u++}A=t===u,s=s||A}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.publicPath){const e=u;c(t.publicPath,{instancePath:r+"/publicPath",parentData:t,parentDataProperty:"publicPath",rootData:a})||(l=null===l?c.errors:l.concat(c.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.scriptType){let e=t.scriptType;const n=u;if(!1!==e&&"text/javascript"!==e&&"module"!==e)return xe.errors=[{params:{}}],!1;y=n===u}else y=!0;if(y){if(void 0!==t.sourceMapFilename){let n=t.sourceMapFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.sourcePrefix){const e=u;if("string"!=typeof t.sourcePrefix)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.strictModuleErrorHandling){const e=u;if("boolean"!=typeof t.strictModuleErrorHandling)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.strictModuleExceptionHandling){const e=u;if("boolean"!=typeof t.strictModuleExceptionHandling)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.trustedTypes){let e=t.trustedTypes;const n=u,r=u;let s=!1;const o=u;if(!0!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var x=o===u;if(s=s||x,!s){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}if(x=t===u,s=s||x,!s){const t=u;if(u==u)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=u;for(const t in e)if("policyName"!==t){const e={params:{additionalProperty:t}};null===l?l=[e]:l.push(e),u++;break}if(t===u&&void 0!==e.policyName){let t=e.policyName;if(u==u)if("string"==typeof t){if(t.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}}}else{const e={params:{type:"object"}};null===l?l=[e]:l.push(e),u++}x=t===u,s=s||x}}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.umdNamedDefine){const e=u,n=u;let r=!1,s=null;const o=u;if("boolean"!=typeof t.umdNamedDefine){const e={params:{type:"boolean"}};null===l?l=[e]:l.push(e),u++}if(o===u&&(r=!0,s=0),!r){const e={params:{passingSchemas:s}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=n,null!==l&&(n?l.length=n:l=null),y=e===u}else y=!0;if(y){if(void 0!==t.uniqueName){let e=t.uniqueName;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.wasmLoading){const e=u;m(t.wasmLoading,{instancePath:r+"/wasmLoading",parentData:t,parentDataProperty:"wasmLoading",rootData:a})||(l=null===l?m.errors:l.concat(m.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.webassemblyModuleFilename){let n=t.webassemblyModuleFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.workerChunkLoading){const e=u;i(t.workerChunkLoading,{instancePath:r+"/workerChunkLoading",parentData:t,parentDataProperty:"workerChunkLoading",rootData:a})||(l=null===l?i.errors:l.concat(i.errors),u=l.length),y=e===u}else y=!0;if(y)if(void 0!==t.workerWasmLoading){const e=u;m(t.workerWasmLoading,{instancePath:r+"/workerWasmLoading",parentData:t,parentDataProperty:"workerWasmLoading",rootData:a})||(l=null===l?m.errors:l.concat(m.errors),u=l.length),y=e===u}else y=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return xe.errors=l,0===u}function ke(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("assetFilter"!==t&&"hints"!==t&&"maxAssetSize"!==t&&"maxEntrypointSize"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.assetFilter){const t=a;if(!(e.assetFilter instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=t===a}else f=!0;if(f){if(void 0!==e.hints){let t=e.hints;const n=a;if(!1!==t&&"warning"!==t&&"error"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0;if(f){if(void 0!==e.maxAssetSize){const t=a;if("number"!=typeof e.maxAssetSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}f=t===a}else f=!0;if(f)if(void 0!==e.maxEntrypointSize){const t=a;if("number"!=typeof e.maxEntrypointSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}f=t===a}else f=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ke.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ke.errors=o,0===a}function je(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return je.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.apply&&(e="apply")){const t={params:{missingProperty:e}};null===o?o=[t]:o.push(t),a++}else if(void 0!==t.apply&&!(t.apply instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,je.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return je.errors=o,0===a}function Se(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(W(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?W.errors:o.concat(W.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,Se.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Se.errors=o,0===a}function Ce(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(W(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?W.errors:o.concat(W.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,Ce.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Ce.errors=o,0===a}const Oe={all:{type:"boolean"},assets:{type:"boolean"},assetsSort:{type:"string"},assetsSpace:{type:"number"},builtAt:{type:"boolean"},cached:{type:"boolean"},cachedAssets:{type:"boolean"},cachedModules:{type:"boolean"},children:{type:"boolean"},chunkGroupAuxiliary:{type:"boolean"},chunkGroupChildren:{type:"boolean"},chunkGroupMaxAssets:{type:"number"},chunkGroups:{type:"boolean"},chunkModules:{type:"boolean"},chunkModulesSpace:{type:"number"},chunkOrigins:{type:"boolean"},chunkRelations:{type:"boolean"},chunks:{type:"boolean"},chunksSort:{type:"string"},colors:{anyOf:[{type:"boolean"},{type:"object",additionalProperties:!1,properties:{bold:{type:"string"},cyan:{type:"string"},green:{type:"string"},magenta:{type:"string"},red:{type:"string"},yellow:{type:"string"}}}]},context:{type:"string",absolutePath:!0},dependentModules:{type:"boolean"},depth:{type:"boolean"},entrypoints:{anyOf:[{enum:["auto"]},{type:"boolean"}]},env:{type:"boolean"},errorDetails:{anyOf:[{enum:["auto"]},{type:"boolean"}]},errorStack:{type:"boolean"},errors:{type:"boolean"},errorsCount:{type:"boolean"},exclude:{anyOf:[{type:"boolean"},{$ref:"#/definitions/ModuleFilterTypes"}]},excludeAssets:{oneOf:[{$ref:"#/definitions/AssetFilterTypes"}]},excludeModules:{anyOf:[{type:"boolean"},{$ref:"#/definitions/ModuleFilterTypes"}]},groupAssetsByChunk:{type:"boolean"},groupAssetsByEmitStatus:{type:"boolean"},groupAssetsByExtension:{type:"boolean"},groupAssetsByInfo:{type:"boolean"},groupAssetsByPath:{type:"boolean"},groupModulesByAttributes:{type:"boolean"},groupModulesByCacheStatus:{type:"boolean"},groupModulesByExtension:{type:"boolean"},groupModulesByLayer:{type:"boolean"},groupModulesByPath:{type:"boolean"},groupModulesByType:{type:"boolean"},groupReasonsByOrigin:{type:"boolean"},hash:{type:"boolean"},ids:{type:"boolean"},logging:{anyOf:[{enum:["none","error","warn","info","log","verbose"]},{type:"boolean"}]},loggingDebug:{anyOf:[{type:"boolean"},{$ref:"#/definitions/FilterTypes"}]},loggingTrace:{type:"boolean"},moduleAssets:{type:"boolean"},moduleTrace:{type:"boolean"},modules:{type:"boolean"},modulesSort:{type:"string"},modulesSpace:{type:"number"},nestedModules:{type:"boolean"},nestedModulesSpace:{type:"number"},optimizationBailout:{type:"boolean"},orphanModules:{type:"boolean"},outputPath:{type:"boolean"},performance:{type:"boolean"},preset:{anyOf:[{type:"boolean"},{type:"string"}]},providedExports:{type:"boolean"},publicPath:{type:"boolean"},reasons:{type:"boolean"},reasonsSpace:{type:"number"},relatedAssets:{type:"boolean"},runtime:{type:"boolean"},runtimeModules:{type:"boolean"},source:{type:"boolean"},timings:{type:"boolean"},usedExports:{type:"boolean"},version:{type:"boolean"},warnings:{type:"boolean"},warningsCount:{type:"boolean"},warningsFilter:{oneOf:[{$ref:"#/definitions/WarningFilterTypes"}]}};function Fe(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Fe.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Fe.errors=a,0===i}function Re(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Re.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Re.errors=a,0===i}function Ee(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Ee.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Ee.errors=a,0===i}function $e(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return $e.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(Oe,e))return $e.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.all){const e=l;if("boolean"!=typeof t.all)return $e.errors=[{params:{type:"boolean"}}],!1;var p=e===l}else p=!0;if(p){if(void 0!==t.assets){const e=l;if("boolean"!=typeof t.assets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.assetsSort){const e=l;if("string"!=typeof t.assetsSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.assetsSpace){const e=l;if("number"!=typeof t.assetsSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.builtAt){const e=l;if("boolean"!=typeof t.builtAt)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cached){const e=l;if("boolean"!=typeof t.cached)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cachedAssets){const e=l;if("boolean"!=typeof t.cachedAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cachedModules){const e=l;if("boolean"!=typeof t.cachedModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.children){const e=l;if("boolean"!=typeof t.children)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupAuxiliary){const e=l;if("boolean"!=typeof t.chunkGroupAuxiliary)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupChildren){const e=l;if("boolean"!=typeof t.chunkGroupChildren)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupMaxAssets){const e=l;if("number"!=typeof t.chunkGroupMaxAssets)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroups){const e=l;if("boolean"!=typeof t.chunkGroups)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkModules){const e=l;if("boolean"!=typeof t.chunkModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkModulesSpace){const e=l;if("number"!=typeof t.chunkModulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkOrigins){const e=l;if("boolean"!=typeof t.chunkOrigins)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkRelations){const e=l;if("boolean"!=typeof t.chunkRelations)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunks){const e=l;if("boolean"!=typeof t.chunks)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunksSort){const e=l;if("string"!=typeof t.chunksSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.colors){let e=t.colors;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=l;for(const t in e)if("bold"!==t&&"cyan"!==t&&"green"!==t&&"magenta"!==t&&"red"!==t&&"yellow"!==t){const e={params:{additionalProperty:t}};null===i?i=[e]:i.push(e),l++;break}if(t===l){if(void 0!==e.bold){const t=l;if("string"!=typeof e.bold){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var f=t===l}else f=!0;if(f){if(void 0!==e.cyan){const t=l;if("string"!=typeof e.cyan){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.green){const t=l;if("string"!=typeof e.green){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.magenta){const t=l;if("string"!=typeof e.magenta){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.red){const t=l;if("string"!=typeof e.red){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f)if(void 0!==e.yellow){const t=l;if("string"!=typeof e.yellow){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0}}}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.context){let n=t.context;const r=l;if(l===r){if("string"!=typeof n)return $e.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return $e.errors=[{params:{}}],!1}p=r===l}else p=!0;if(p){if(void 0!==t.dependentModules){const e=l;if("boolean"!=typeof t.dependentModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.depth){const e=l;if("boolean"!=typeof t.depth)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.entrypoints){let e=t.entrypoints;const n=l,r=l;let s=!1;const o=l;if("auto"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=o===l;if(s=s||c,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}c=t===l,s=s||c}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.env){const e=l;if("boolean"!=typeof t.env)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errorDetails){let e=t.errorDetails;const n=l,r=l;let s=!1;const o=l;if("auto"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.errorStack){const e=l;if("boolean"!=typeof t.errorStack)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errors){const e=l;if("boolean"!=typeof t.errors)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errorsCount){const e=l;if("boolean"!=typeof t.errorsCount)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exclude){let e=t.exclude;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var y=u===l;if(o=o||y,!o){const n=l;Fe(e,{instancePath:r+"/exclude",parentData:t,parentDataProperty:"exclude",rootData:a})||(i=null===i?Fe.errors:i.concat(Fe.errors),l=i.length),y=n===l,o=o||y}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.excludeAssets){const e=l,n=l;let s=!1,o=null;const u=l;if(Re(t.excludeAssets,{instancePath:r+"/excludeAssets",parentData:t,parentDataProperty:"excludeAssets",rootData:a})||(i=null===i?Re.errors:i.concat(Re.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0;if(p){if(void 0!==t.excludeModules){let e=t.excludeModules;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var h=u===l;if(o=o||h,!o){const n=l;Fe(e,{instancePath:r+"/excludeModules",parentData:t,parentDataProperty:"excludeModules",rootData:a})||(i=null===i?Fe.errors:i.concat(Fe.errors),l=i.length),h=n===l,o=o||h}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.groupAssetsByChunk){const e=l;if("boolean"!=typeof t.groupAssetsByChunk)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByEmitStatus){const e=l;if("boolean"!=typeof t.groupAssetsByEmitStatus)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByExtension){const e=l;if("boolean"!=typeof t.groupAssetsByExtension)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByInfo){const e=l;if("boolean"!=typeof t.groupAssetsByInfo)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByPath){const e=l;if("boolean"!=typeof t.groupAssetsByPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByAttributes){const e=l;if("boolean"!=typeof t.groupModulesByAttributes)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByCacheStatus){const e=l;if("boolean"!=typeof t.groupModulesByCacheStatus)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByExtension){const e=l;if("boolean"!=typeof t.groupModulesByExtension)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByLayer){const e=l;if("boolean"!=typeof t.groupModulesByLayer)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByPath){const e=l;if("boolean"!=typeof t.groupModulesByPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByType){const e=l;if("boolean"!=typeof t.groupModulesByType)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupReasonsByOrigin){const e=l;if("boolean"!=typeof t.groupReasonsByOrigin)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.hash){const e=l;if("boolean"!=typeof t.hash)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.ids){const e=l;if("boolean"!=typeof t.ids)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.logging){let e=t.logging;const n=l,r=l;let s=!1;const o=l;if("none"!==e&&"error"!==e&&"warn"!==e&&"info"!==e&&"log"!==e&&"verbose"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var d=o===l;if(s=s||d,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}d=t===l,s=s||d}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.loggingDebug){let e=t.loggingDebug;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var g=u===l;if(o=o||g,!o){const n=l;O(e,{instancePath:r+"/loggingDebug",parentData:t,parentDataProperty:"loggingDebug",rootData:a})||(i=null===i?O.errors:i.concat(O.errors),l=i.length),g=n===l,o=o||g}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.loggingTrace){const e=l;if("boolean"!=typeof t.loggingTrace)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.moduleAssets){const e=l;if("boolean"!=typeof t.moduleAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.moduleTrace){const e=l;if("boolean"!=typeof t.moduleTrace)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modules){const e=l;if("boolean"!=typeof t.modules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modulesSort){const e=l;if("string"!=typeof t.modulesSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modulesSpace){const e=l;if("number"!=typeof t.modulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.nestedModules){const e=l;if("boolean"!=typeof t.nestedModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.nestedModulesSpace){const e=l;if("number"!=typeof t.nestedModulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.optimizationBailout){const e=l;if("boolean"!=typeof t.optimizationBailout)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.orphanModules){const e=l;if("boolean"!=typeof t.orphanModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.outputPath){const e=l;if("boolean"!=typeof t.outputPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.performance){const e=l;if("boolean"!=typeof t.performance)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.preset){let e=t.preset;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var b=o===l;if(s=s||b,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}b=t===l,s=s||b}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.providedExports){const e=l;if("boolean"!=typeof t.providedExports)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.publicPath){const e=l;if("boolean"!=typeof t.publicPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reasons){const e=l;if("boolean"!=typeof t.reasons)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reasonsSpace){const e=l;if("number"!=typeof t.reasonsSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.relatedAssets){const e=l;if("boolean"!=typeof t.relatedAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.runtime){const e=l;if("boolean"!=typeof t.runtime)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.runtimeModules){const e=l;if("boolean"!=typeof t.runtimeModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.source){const e=l;if("boolean"!=typeof t.source)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.timings){const e=l;if("boolean"!=typeof t.timings)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.version){const e=l;if("boolean"!=typeof t.version)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.warnings){const e=l;if("boolean"!=typeof t.warnings)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.warningsCount){const e=l;if("boolean"!=typeof t.warningsCount)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p)if(void 0!==t.warningsFilter){const e=l,n=l;let s=!1,o=null;const u=l;if(Ee(t.warningsFilter,{instancePath:r+"/warningsFilter",parentData:t,parentDataProperty:"warningsFilter",rootData:a})||(i=null===i?Ee.errors:i.concat(Ee.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return $e.errors=i,0===l}function ze(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if("none"!==e&&"summary"!==e&&"errors-only"!==e&&"errors-warnings"!==e&&"minimal"!==e&&"normal"!==e&&"detailed"!==e&&"verbose"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;$e(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?$e.errors:o.concat($e.errors),a=o.length),u=i===a,l=l||u}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ze.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ze.errors=o,0===a}const Le=new RegExp("^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$","u");function we(r,{instancePath:s="",parentData:a,parentDataProperty:i,rootData:l=r}={}){let p=null,u=0;if(0===u){if(!r||"object"!=typeof r||Array.isArray(r))return we.errors=[{params:{type:"object"}}],!1;{const a=u;for(const e in r)if(!n.call(t,e))return we.errors=[{params:{additionalProperty:e}}],!1;if(a===u){if(void 0!==r.amd){let e=r.amd;const t=u,n=u;let s=!1;const o=u;if(!1!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}var f=o===u;if(s=s||f,!s){const t=u;if(!e||"object"!=typeof e||Array.isArray(e)){const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}f=t===u,s=s||f}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null);var c=t===u}else c=!0;if(c){if(void 0!==r.bail){const e=u;if("boolean"!=typeof r.bail)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.cache){const e=u;o(r.cache,{instancePath:s+"/cache",parentData:r,parentDataProperty:"cache",rootData:l})||(p=null===p?o.errors:p.concat(o.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.context){let t=r.context;const n=u;if(u==u){if("string"!=typeof t)return we.errors=[{params:{type:"string"}}],!1;if(t.includes("!")||!0!==e.test(t))return we.errors=[{params:{}}],!1}c=n===u}else c=!0;if(c){if(void 0!==r.dependencies){let e=r.dependencies;const t=u;if(u==u){if(!Array.isArray(e))return we.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=u;if("string"!=typeof e[n])return we.errors=[{params:{type:"string"}}],!1;if(t!==u)break}}}c=t===u}else c=!0;if(c){if(void 0!==r.devServer){let e=r.devServer;const t=u;if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.devtool){let e=r.devtool;const t=u,n=u;let s=!1;const o=u;if(!1!==e&&"eval"!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}var m=o===u;if(s=s||m,!s){const t=u;if(u===t)if("string"==typeof e){if(!Le.test(e)){const e={params:{pattern:"^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$"}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}m=t===u,s=s||m}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null),c=t===u}else c=!0;if(c){if(void 0!==r.entry){const e=u;b(r.entry,{instancePath:s+"/entry",parentData:r,parentDataProperty:"entry",rootData:l})||(p=null===p?b.errors:p.concat(b.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.experiments){const e=u;k(r.experiments,{instancePath:s+"/experiments",parentData:r,parentDataProperty:"experiments",rootData:l})||(p=null===p?k.errors:p.concat(k.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.externals){const e=u;C(r.externals,{instancePath:s+"/externals",parentData:r,parentDataProperty:"externals",rootData:l})||(p=null===p?C.errors:p.concat(C.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.externalsPresets){let e=r.externalsPresets;const t=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("electron"!==t&&"electronMain"!==t&&"electronPreload"!==t&&"electronRenderer"!==t&&"node"!==t&&"nwjs"!==t&&"web"!==t&&"webAsync"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.electron){const t=u;if("boolean"!=typeof e.electron)return we.errors=[{params:{type:"boolean"}}],!1;var y=t===u}else y=!0;if(y){if(void 0!==e.electronMain){const t=u;if("boolean"!=typeof e.electronMain)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.electronPreload){const t=u;if("boolean"!=typeof e.electronPreload)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.electronRenderer){const t=u;if("boolean"!=typeof e.electronRenderer)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.node){const t=u;if("boolean"!=typeof e.node)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.nwjs){const t=u;if("boolean"!=typeof e.nwjs)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.web){const t=u;if("boolean"!=typeof e.web)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y)if(void 0!==e.webAsync){const t=u;if("boolean"!=typeof e.webAsync)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0}}}}}}}}}c=t===u}else c=!0;if(c){if(void 0!==r.externalsType){let e=r.externalsType;const t=u;if("var"!==e&&"module"!==e&&"assign"!==e&&"this"!==e&&"window"!==e&&"self"!==e&&"global"!==e&&"commonjs"!==e&&"commonjs2"!==e&&"commonjs-module"!==e&&"commonjs-static"!==e&&"amd"!==e&&"amd-require"!==e&&"umd"!==e&&"umd2"!==e&&"jsonp"!==e&&"system"!==e&&"promise"!==e&&"import"!==e&&"script"!==e&&"node-commonjs"!==e)return we.errors=[{params:{}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.ignoreWarnings){let e=r.ignoreWarnings;const t=u;if(u==u){if(!Array.isArray(e))return we.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u,s=u;let o=!1;const a=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var h=a===u;if(o=o||h,!o){const e=u;if(u===e)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=u;for(const e in t)if("file"!==e&&"message"!==e&&"module"!==e){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(e===u){if(void 0!==t.file){const e=u;if(!(t.file instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var d=e===u}else d=!0;if(d){if(void 0!==t.message){const e=u;if(!(t.message instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d)if(void 0!==t.module){const e=u;if(!(t.module instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}if(h=e===u,o=o||h,!o){const e=u;if(!(t instanceof Function)){const e={params:{}};null===p?p=[e]:p.push(e),u++}h=e===u,o=o||h}}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=s,null!==p&&(s?p.length=s:p=null),r!==u)break}}}c=t===u}else c=!0;if(c){if(void 0!==r.infrastructureLogging){const e=u;F(r.infrastructureLogging,{instancePath:s+"/infrastructureLogging",parentData:r,parentDataProperty:"infrastructureLogging",rootData:l})||(p=null===p?F.errors:p.concat(F.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.loader){let e=r.loader;const t=u;if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.mode){let e=r.mode;const t=u;if("development"!==e&&"production"!==e&&"none"!==e)return we.errors=[{params:{}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.module){const e=u;oe(r.module,{instancePath:s+"/module",parentData:r,parentDataProperty:"module",rootData:l})||(p=null===p?oe.errors:p.concat(oe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.name){const e=u;if("string"!=typeof r.name)return we.errors=[{params:{type:"string"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.node){const e=u;ne(r.node,{instancePath:s+"/node",parentData:r,parentDataProperty:"node",rootData:l})||(p=null===p?ne.errors:p.concat(ne.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.optimization){const e=u;fe(r.optimization,{instancePath:s+"/optimization",parentData:r,parentDataProperty:"optimization",rootData:l})||(p=null===p?fe.errors:p.concat(fe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.output){const e=u;xe(r.output,{instancePath:s+"/output",parentData:r,parentDataProperty:"output",rootData:l})||(p=null===p?xe.errors:p.concat(xe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.parallelism){let e=r.parallelism;const t=u;if(u==u){if("number"!=typeof e)return we.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return we.errors=[{params:{comparison:">=",limit:1}}],!1}c=t===u}else c=!0;if(c){if(void 0!==r.performance){const e=u;ke(r.performance,{instancePath:s+"/performance",parentData:r,parentDataProperty:"performance",rootData:l})||(p=null===p?ke.errors:p.concat(ke.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.plugins){const e=u;je(r.plugins,{instancePath:s+"/plugins",parentData:r,parentDataProperty:"plugins",rootData:l})||(p=null===p?je.errors:p.concat(je.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.profile){const e=u;if("boolean"!=typeof r.profile)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.recordsInputPath){let t=r.recordsInputPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var g=a===u;if(o=o||g,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=n===u,o=o||g}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.recordsOutputPath){let t=r.recordsOutputPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var v=a===u;if(o=o||v,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}v=n===u,o=o||v}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.recordsPath){let t=r.recordsPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var D=a===u;if(o=o||D,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}D=n===u,o=o||D}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.resolve){const e=u;Se(r.resolve,{instancePath:s+"/resolve",parentData:r,parentDataProperty:"resolve",rootData:l})||(p=null===p?Se.errors:p.concat(Se.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.resolveLoader){const e=u;Ce(r.resolveLoader,{instancePath:s+"/resolveLoader",parentData:r,parentDataProperty:"resolveLoader",rootData:l})||(p=null===p?Ce.errors:p.concat(Ce.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.snapshot){let t=r.snapshot;const n=u;if(u==u){if(!t||"object"!=typeof t||Array.isArray(t))return we.errors=[{params:{type:"object"}}],!1;{const n=u;for(const e in t)if("buildDependencies"!==e&&"immutablePaths"!==e&&"managedPaths"!==e&&"module"!==e&&"resolve"!==e&&"resolveBuildDependencies"!==e)return we.errors=[{params:{additionalProperty:e}}],!1;if(n===u){if(void 0!==t.buildDependencies){let e=t.buildDependencies;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var P=t===u}else P=!0;if(P)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;P=t===u}else P=!0}}}var A=n===u}else A=!0;if(A){if(void 0!==t.immutablePaths){let n=t.immutablePaths;const r=u;if(u===r){if(!Array.isArray(n))return we.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var x=i===u;if(a=a||x,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}x=n===u,a=a||x}if(!a){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=o,null!==p&&(o?p.length=o:p=null),s!==u)break}}}A=r===u}else A=!0;if(A){if(void 0!==t.managedPaths){let n=t.managedPaths;const r=u;if(u===r){if(!Array.isArray(n))return we.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var j=i===u;if(a=a||j,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}j=n===u,a=a||j}if(!a){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=o,null!==p&&(o?p.length=o:p=null),s!==u)break}}}A=r===u}else A=!0;if(A){if(void 0!==t.module){let e=t.module;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var S=t===u}else S=!0;if(S)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;S=t===u}else S=!0}}}A=n===u}else A=!0;if(A){if(void 0!==t.resolve){let e=t.resolve;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var O=t===u}else O=!0;if(O)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;O=t===u}else O=!0}}}A=n===u}else A=!0;if(A)if(void 0!==t.resolveBuildDependencies){let e=t.resolveBuildDependencies;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var R=t===u}else R=!0;if(R)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;R=t===u}else R=!0}}}A=n===u}else A=!0}}}}}}}c=n===u}else c=!0;if(c){if(void 0!==r.stats){const e=u;ze(r.stats,{instancePath:s+"/stats",parentData:r,parentDataProperty:"stats",rootData:l})||(p=null===p?ze.errors:p.concat(ze.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.target){let e=r.target;const t=u,n=u;let s=!1;const o=u;if(u===o)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u;if(u===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var E=o===u;if(s=s||E,!s){const t=u;if(!1!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}if(E=t===u,s=s||E,!s){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}E=t===u,s=s||E}}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null),c=t===u}else c=!0;if(c){if(void 0!==r.watch){const e=u;if("boolean"!=typeof r.watch)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c)if(void 0!==r.watchOptions){let e=r.watchOptions;const t=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("aggregateTimeout"!==t&&"followSymlinks"!==t&&"ignored"!==t&&"poll"!==t&&"stdin"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.aggregateTimeout){const t=u;if("number"!=typeof e.aggregateTimeout)return we.errors=[{params:{type:"number"}}],!1;var $=t===u}else $=!0;if($){if(void 0!==e.followSymlinks){const t=u;if("boolean"!=typeof e.followSymlinks)return we.errors=[{params:{type:"boolean"}}],!1;$=t===u}else $=!0;if($){if(void 0!==e.ignored){let t=e.ignored;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var z=o===u;if(s=s||z,!s){const e=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}if(z=e===u,s=s||z,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}z=e===u,s=s||z}}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),$=n===u}else $=!0;if($){if(void 0!==e.poll){let t=e.poll;const n=u,r=u;let s=!1;const o=u;if("number"!=typeof t){const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}var L=o===u;if(s=s||L,!s){const e=u;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}L=e===u,s=s||L}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),$=n===u}else $=!0;if($)if(void 0!==e.stdin){const t=u;if("boolean"!=typeof e.stdin)return we.errors=[{params:{type:"boolean"}}],!1;$=t===u}else $=!0}}}}}}c=t===u}else c=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return we.errors=p,0===u}
diff --git a/a.js b/b.js
@@ -13,10 +13,13 @@ describe("#identifier", () => {
A blob:4d3e691b111c67587d7bc37e0235f8d214e4c9ec
	let contextModule;
	let request;
	beforeEach(() => {
		request = "/some/request";
	});
	describe("#identifier", () => {
		it("returns an safe identifier for this module", () => {
			contextModule = new ContextModule(() => {}, {
				type: "javascript/auto",
				request,
				mode: "lazy",
				regExp: /a|b/
			});
			expect(contextModule.identifier()).toContain("/a%7Cb/");
		});
	});
});

diff --git a/a.js b/b.js
@@ -119,5 +119,42 @@ describe("resolveDependencies", () => {
A blob:5ecc9bab59fdf2c3c5a0b537ef550fb0a297b611

const { createFsFromVolume, Volume } = require("memfs");
const ContextModuleFactory = require("../lib/ContextModuleFactory");

describe("ContextModuleFactory", () => {
	describe("resolveDependencies", () => {
		let factory, memfs;
		beforeEach(() => {
			factory = new ContextModuleFactory([]);
			memfs = createFsFromVolume(new Volume());
		});
		it("should not report an error when ENOENT errors happen", done => {
			memfs.readdir = (dir, callback) => {
				setTimeout(() => callback(null, ["/file"]));
			};
			memfs.stat = (file, callback) => {
				let err = new Error("fake ENOENT error");
				err.code = "ENOENT";
				setTimeout(() => callback(err, null));
			};
			factory.resolveDependencies(
				memfs,
				{
					resource: "/",
					recursive: true,
					regExp: /.*/
				},
				(err, res) => {
					expect(err).toBeFalsy();
					expect(Array.isArray(res)).toBe(true);
					expect(res.length).toBe(0);
					done();
				}
			);
		});
		it("should report an error when non-ENOENT errors happen", done => {
			memfs.readdir = (dir, callback) => {
				setTimeout(() => callback(null, ["/file"]));
			};
			memfs.stat = (file, callback) => {
				let err = new Error("fake EACCES error");
				err.code = "EACCES";
				setTimeout(() => callback(err, null));
			};
			factory.resolveDependencies(
				memfs,
				{
					resource: "/",
					recursive: true,
					regExp: /.*/
				},
				(err, res) => {
					expect(err).toBeInstanceOf(Error);
					expect(res).toBeFalsy();
					done();
				}
			);
		});
		it("should return callback with [] if circular symlinks exist", done => {
			let statDirStatus = 0;
			memfs.readdir = (dir, callback) => {
				statDirStatus++;
				setTimeout(() => callback(null, ["/A"]));
			};
			memfs.stat = (file, callback) => {
				const resolvedValue = {
					isDirectory: () => statDirStatus === 1,
					isFile: () => statDirStatus !== 1
				};
				setTimeout(() => callback(null, resolvedValue));
			};
			memfs.realpath = (dir, callback) => {
				const realPath = dir.split("/");
				setTimeout(() => callback(null, realPath[realPath.length - 1]));
			};
			factory.resolveDependencies(
				memfs,
				{
					resource: "/A",
					recursive: true,
					regExp: /.*/
				},
				(err, res) => {
					expect(res).toStrictEqual([]);
					done();
				}
			);
		});
		it("should not return callback with [] if there are no circular symlinks", done => {
			let statDirStatus = 0;
			memfs.readdir = (dir, callback) => {
				statDirStatus++;
				setTimeout(() => callback(null, ["/B"]));
			};
			memfs.stat = (file, callback) => {
				const resolvedValue = {
					isDirectory: () => statDirStatus === 1,
					isFile: () => statDirStatus !== 1
				};
				setTimeout(() => callback(null, resolvedValue));
			};
			memfs.realpath = (dir, callback) => {
				const realPath = dir.split("/");
				setTimeout(() => callback(null, realPath[realPath.length - 1]));
			};
			factory.resolveDependencies(
				memfs,
				{
					resource: "/A",
					recursive: true,
					regExp: /.*/
				},
				(err, res) => {
					expect(res).not.toStrictEqual([]);
					expect(Array.isArray(res)).toBe(true);
					expect(res.length).toBe(1);
					done();
				}
			);
		});
	});
});

diff --git a/a.js b/b.js
@@ -5,6 +5,17 @@ expect(function() {
A blob:65aa0c58c1df473450b111122f9c3360c099e12e
it("should not bundle context requires with asyncMode === 'weak'", function() {
	var contextRequire = require.context(".", false, /two/, "weak");
	expect(function() {
		contextRequire("./two")
	}).toThrowError(/not available/);
});

it("should find module with asyncMode === 'weak' when required elsewhere", function() {
	var contextRequire = require.context(".", false, /.+/, "weak");
	expect(contextRequire("./three")).toBe(3);
	require("./three"); // in a real app would be served as a separate chunk
diff --git a/a.js b/b.js
@@ -1,2 +1,4 @@
A blob:8881119dd17a52aa352e6f2acb0e2a0b59afae6d
console.log("test");
import("./chunk");

diff --git a/a.js b/b.js
@@ -1,8 +1,13 @@
A blob:a28c4df55ecdecba76f901519da262e826b2cf4d
const path = require("path");

const base = {
	mode: "production",
	devtool: "source-map",
	module: {
		rules: [
			{
				test: /chunk/,
diff --git a/a.js b/b.js
@@ -17,115 +22,37 @@
A blob:a28c4df55ecdecba76f901519da262e826b2cf4d
		]
	},
	stats: {
		relatedAssets: true
	},
	experiments: {
		layers: true
	}
};

const base2 = {
	...base,
	devtool: "eval-source-map"
};

const base3 = {
	...base,
	devtool: "eval"
};

/** @type {import("../../../").Configuration[]} */
module.exports = [
	{
		...base,
		entry: {
			main: {
				import: "./index",
				layer: path.resolve(__dirname, "a")
			}
		},
		context: path.resolve(__dirname, "a"),
		output: {
			path: path.resolve(__dirname, "../../js/stats/context-independence/a"),
			filename: "[name]-[chunkhash].js"
		}
	},
	{
		...base,
		entry: {
			main: {
				import: "./index",
				layer: path.resolve(__dirname, "b")
			}
		},
		context: path.resolve(__dirname, "b"),
		output: {
			path: path.resolve(__dirname, "../../js/stats/context-independence/b"),
			filename: "[name]-[chunkhash].js"
		}
	},
	{
		...base2,
		entry: {
			main: {
				import: "./index",
				layer: path.resolve(__dirname, "a")
			}
		},
		context: path.resolve(__dirname, "a"),
		output: {
			path: path.resolve(
				__dirname,
				"../../js/stats/context-independence/eval-source-map-a"
			),
			filename: "[name]-[chunkhash].js"
		}
	},
	{
		...base2,
		entry: {
			main: {
				import: "./index",
				layer: path.resolve(__dirname, "b")
			}
		},
		context: path.resolve(__dirname, "b"),
		output: {
			path: path.resolve(
				__dirname,
				"../../js/stats/context-independence/eval-source-map-b"
			),
			filename: "[name]-[chunkhash].js"
		}
	},
	{
		...base3,
		entry: {
			main: {
				import: "./index",
				layer: path.resolve(__dirname, "a")
			}
		},
		context: path.resolve(__dirname, "a"),
		output: {
			path: path.resolve(
				__dirname,
				"../../js/stats/context-independence/eval-a"
			),
			filename: "[name]-[chunkhash].js"
		}
	},
	{
		...base3,
		entry: {
			main: {
				import: "./index",
				layer: path.resolve(__dirname, "b")
			}
		},
		context: path.resolve(__dirname, "b"),
		output: {
			path: path.resolve(
				__dirname,
				"../../js/stats/context-independence/eval-b"
			),
			filename: "[name]-[chunkhash].js"
		}
	}
];

diff --git a/a.js b/b.js
@@ -19,7 +19,11 @@
A blob:abf8ed365edb4a6e84123c68fd78f09108dbe4d1
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder,
	compareModulesById
} = require("./util/comparators");
const { contextify, parseResource } = require("./util/identifier");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptions */
diff --git a/a.js b/b.js
@@ -1066,9 +1070,21 @@ getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
A blob:abf8ed365edb4a6e84123c68fd78f09108dbe4d1
	/**
	 * @param {string} asyncMode module mode
	 * @param {CodeGenerationContext} context context info
	 * @returns {string} the source code
	 */
	getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
		const id = chunkGraph.getModuleId(this);
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(block, block.dependencies, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getWeakSyncSource(this.dependencies, id, chunkGraph);
			}
		}
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

diff --git a/a.js b/b.js
@@ -1078,11 +1094,14 @@ getSource(sourceString) {
A blob:abf8ed365edb4a6e84123c68fd78f09108dbe4d1
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration(context) {
		const { chunkGraph } = context;
		const sources = new Map();
		sources.set(
			"javascript",
			this.getSource(this.getSourceString(this.options.mode, context))
		);
		const set = new Set();
		const allDeps = /** @type {ContextElementDependency[]} */ (
			this.dependencies.concat(this.blocks.map(b => b.dependencies[0]))
diff --git a/a.js b/b.js
@@ -10,7 +10,6 @@
A blob:f32c1a9e67f283c634805ee8f5ccf992969aa97d
"use strict";

const HotModuleReplacementPlugin = require("../HotModuleReplacementPlugin");
const InnerGraph = require("../optimize/InnerGraph");
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes } = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
diff --git a/a.js b/b.js
@@ -84,6 +83,18 @@ constructor(options) {
A blob:f32c1a9e67f283c634805ee8f5ccf992969aa97d

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.exportsPresence)
				: options.strictExportPresence
				? ExportPresenceModes.ERROR
				: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
diff --git a/a.js b/b.js
@@ -132,43 +143,6 @@ apply(parser) {
A blob:f32c1a9e67f283c634805ee8f5ccf992969aa97d

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in"
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
diff --git a/a.js b/b.js
@@ -192,51 +166,83 @@ apply(parser) {
A blob:f32c1a9e67f283c634805ee8f5ccf992969aa97d

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in"
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const { arguments: args, callee } = expr;
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					callee.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.directImport = members.length === 0;
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(callee.range[0]);
				// only in case when we strictly follow the spec we need a special case here
				dep.namespaceObjectAsContext =
					members.length > 0 && this.strictThisContextOnImports;
				dep.loc = callee.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		const { hotAcceptCallback, hotAcceptWithoutCallback } =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
diff --git a/a.js b/b.js
@@ -10,7 +10,6 @@
A blob:618eb94ae220c3dc8b52a2db9744c1d6fd5279a0
"use strict";

const HotModuleReplacementPlugin = require("../HotModuleReplacementPlugin");
const InnerGraph = require("../optimize/InnerGraph");
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes } = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
diff --git a/a.js b/b.js
@@ -84,6 +83,18 @@ constructor(options) {
A blob:618eb94ae220c3dc8b52a2db9744c1d6fd5279a0

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.exportsPresence)
				: options.strictExportPresence
				? ExportPresenceModes.ERROR
				: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
diff --git a/a.js b/b.js
@@ -132,45 +143,6 @@ apply(parser) {
A blob:618eb94ae220c3dc8b52a2db9744c1d6fd5279a0

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in",
					leftPart,
					rightPart.range
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
diff --git a/a.js b/b.js
@@ -194,51 +166,83 @@ apply(parser) {
A blob:618eb94ae220c3dc8b52a2db9744c1d6fd5279a0

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in",
					leftPart,
					rightPart.range
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(expression.range[0]);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const { arguments: args, callee } = expr;
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					callee.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.directImport = members.length === 0;
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(callee.range[0]);
				// only in case when we strictly follow the spec we need a special case here
				dep.namespaceObjectAsContext =
					members.length > 0 && this.strictThisContextOnImports;
				dep.loc = callee.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		const { hotAcceptCallback, hotAcceptWithoutCallback } =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
diff --git a/a.js b/b.js
@@ -261,20 +261,14 @@ makeSerializable(
A blob:d9e9c53acf893c8036e47ccc1dec4f9a2d3d0df2
		this.usedByExports = read();
		super.deserialize(context);
	}
}

makeSerializable(
	HarmonyImportSpecifierDependency,
	"webpack/lib/dependencies/HarmonyImportSpecifierDependency"
);

HarmonyImportSpecifierDependency.Template = class HarmonyImportSpecifierDependencyTemplate extends (
	HarmonyImportDependency.Template
) {
	/**
	 * @param {Dependency} dependency the dependency for which the template should be applied
	 * @param {ReplaceSource} source the current replace source which can be modified
	 * @param {DependencyTemplateContext} templateContext the context object
	 * @returns {void}
	 */
	apply(dependency, source, templateContext) {
		const dep = /** @type {HarmonyImportSpecifierDependency} */ (dependency);
		const { moduleGraph, runtime } = templateContext;
		const connection = moduleGraph.getConnection(dep);
		// Skip rendering depending when dependency is conditional
		if (connection && !connection.isTargetActive(runtime)) return;

		const ids = dep.getIds(moduleGraph);
		this._applyForIds(dependency, source, templateContext, ids, dep.range);
	}

	_applyForIds(dependency, source, templateContext, ids, range) {
		const dep = /** @type {HarmonyImportSpecifierDependency} */ (dependency);
		const { moduleGraph, module, runtime, concatenationScope } =
			templateContext;
		const connection = moduleGraph.getConnection(dep);
		let exportExpr;
		if (
			connection &&
			concatenationScope &&
diff --git a/a.js b/b.js
@@ -327,9 +321,9 @@ _applyForIds(dependency, source, templateContext, ids, range) {
A blob:d9e9c53acf893c8036e47ccc1dec4f9a2d3d0df2

		const ids = dep.getIds(moduleGraph);
		this._applyForIds(dependency, source, templateContext, ids, dep.range);
	}

	_applyForIds(dependency, source, templateContext, ids, range) {
		const dep = /** @type {HarmonyImportSpecifierDependency} */ (dependency);
		const { moduleGraph, module, runtime, concatenationScope } =
			templateContext;
		const connection = moduleGraph.getConnection(dep);
		let exportExpr;
		if (
			connection &&
			concatenationScope &&
			concatenationScope.isModuleInScope(connection.module)
		) {
			if (ids.length === 0) {
				exportExpr = concatenationScope.createModuleReference(
					connection.module,
					{
						asiSafe: dep.asiSafe
					}
				);
			} else if (dep.namespaceObjectAsContext && ids.length === 1) {
				exportExpr =
					concatenationScope.createModuleReference(connection.module, {
						asiSafe: dep.asiSafe
					}) + propertyAccess(ids);
			} else {
				exportExpr = concatenationScope.createModuleReference(
					connection.module,
					{
						ids,
						call: dep.call,
						directImport: dep.directImport,
						asiSafe: dep.asiSafe
					}
				);
			}
		} else {
			super.apply(dependency, source, templateContext);

			const { runtimeTemplate, initFragments, runtimeRequirements } =
				templateContext;

			exportExpr = runtimeTemplate.exportFromImport({
				moduleGraph,
				module: moduleGraph.getModule(dep),
				request: dep.request,
				exportName: ids,
				originModule: module,
				asiSafe: dep.shorthand ? true : dep.asiSafe,
				isCall: dep.call,
				callContext: !dep.directImport,
				defaultInterop: true,
				importVar: dep.getImportVar(moduleGraph),
				initFragments,
				runtime,
				runtimeRequirements
			});
		}
		if (dep.shorthand) {
			source.insert(range[1], `: ${exportExpr}`);
		} else {
			source.replace(range[0], range[1] - 1, exportExpr);
		}
	}
};

diff --git a/a.js b/b.js
@@ -5,9 +5,6 @@
A blob:6dad51fa889775b3660f4999284d3ba98b70ff82
"use strict";

import { x, y } from "./a";
import { d2, usedD1, usedD2 } from "./d.js";
import { b1, usedB1, usedB2, usedB3, usedB4 } from "./b.js";
import { usedE1, usedE2 } from "./e.js";
import { h } from "./h.js";
import * as m from "./m";
import * as o from "./o";
import * as p from "./p";

it("namespace export as from commonjs should override named export", function () {
	expect(x).toBe(1);
	expect(y).toBe(3);
diff --git a/a.js b/b.js
@@ -38,19 +35,3 @@ it("complex case should work correctly", () => {
A blob:6dad51fa889775b3660f4999284d3ba98b70ff82
		expect(usedB3).toBe(false);
		expect(usedB4).toBe(false);
	}
});

it("complex case should work correctly", () => {
	expect(h.f1.e.e1).toBe(10);
	expect(h.g1.e1).toBe(10);
	expect(usedE1).toBe(true);
	if (process.env.NODE_ENV === "production") {
		expect(usedE2).toBe(false);
	}
});

it("should handle 'm in n' case", () => {
	const obj = { a: "a" in m };
	expect(obj.a).toBe(true);
	expect("a" in o).toBe(true);
	expect("a" in p).toBe(false);
	expect("c" in m).toBe(false);
	expect("c" in (false ? ({}) : m.d)).toBe(true);
	expect("d" in m.d).toBe(false);
	if (process.env.NODE_ENV === "production") {
		expect(m.d.usedA).toBe(false);
		expect(m.usedB).toBe(false);
		expect(m.usedA).toBe(true);
		expect(m.canMangleA).toBe(true);
	}
});

diff --git a/a.js b/b.js
@@ -19,6 +19,7 @@
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
/** @typedef {import("../declarations/WebpackOptions").CleanOptions} CleanOptions */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./logging/Logger").Logger} Logger */
/** @typedef {import("./util/fs").OutputFileSystem} OutputFileSystem */
/** @typedef {import("./util/fs").StatsCallback} StatsCallback */

/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */
/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */

/**
 * @typedef {Object} CleanPluginCompilationHooks
diff --git a/a.js b/b.js
@@ -40,18 +41,32 @@
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
		};
	},
	{
		name: "Clean Plugin",
		baseDataPath: "options"
	}
);

/**
 * @param {OutputFileSystem} fs filesystem
 * @param {string} outputPath output path
 * @param {Set<string>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)
 * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there
 * @returns {void}
 */
const getDiffToFs = (fs, outputPath, currentAssets, callback) => {
	const directories = new Set();
	// get directories of assets
	for (const asset of currentAssets) {
		directories.add(asset.replace(/(^|\/)[^/]*$/, ""));
	}
	// and all parent directories
	for (const directory of directories) {
diff --git a/a.js b/b.js
@@ -91,13 +106,15 @@ const getDiffToFs = (fs, outputPath, currentAssets, callback) => {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
 * @param {string} outputPath output path
 * @param {Set<string>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)
 * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there
 * @returns {void}
 */
const getDiffToFs = (fs, outputPath, currentAssets, callback) => {
	const directories = new Set();
	// get directories of assets
	for (const asset of currentAssets) {
		directories.add(asset.replace(/(^|\/)[^/]*$/, ""));
	}
	// and all parent directories
	for (const directory of directories) {
		directories.add(directory.replace(/(^|\/)[^/]*$/, ""));
	}
	const diff = new Set();
	asyncLib.forEachLimit(
		directories,
		10,
		(directory, callback) => {
			fs.readdir(join(fs, outputPath, directory), (err, entries) => {
				if (err) {
					if (err.code === "ENOENT") return callback();
					if (err.code === "ENOTDIR") {
						diff.add(directory);
						return callback();
					}
					return callback(err);
				}
				for (const entry of entries) {
					const file = /** @type {string} */ (entry);
					const filename = directory ? `${directory}/${file}` : file;
					if (!directories.has(filename) && !currentAssets.has(filename)) {
						diff.add(filename);
					}
				}
				callback();
			});
		},
		err => {
			if (err) return callback(err);

			callback(null, diff);
		}
	);
};

/**
 * @param {Set<string>} currentAssets assets list
 * @param {Set<string>} oldAssets old assets list
 * @returns {Set<string>} diff
 */
const getDiffToOldAssets = (currentAssets, oldAssets) => {
	const diff = new Set();
	for (const asset of oldAssets) {
		if (!currentAssets.has(asset)) diff.add(asset);
	}
	return diff;
};
diff --git a/a.js b/b.js
@@ -124,7 +141,7 @@ const doStat = (fs, filename, callback) => {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
 * @param {OutputFileSystem} fs filesystem
 * @param {string} filename path to file
 * @param {StatsCallback} callback callback for provided filename
 * @returns {void}
 */
const doStat = (fs, filename, callback) => {
	if ("lstat" in fs) {
		fs.lstat(filename, callback);
	} else {
		fs.stat(filename, callback);
	}
};

/**
 * @param {OutputFileSystem} fs filesystem
 * @param {string} outputPath output path
 * @param {boolean} dry only log instead of fs modification
 * @param {Logger} logger logger
 * @param {Set<string>} diff filenames of the assets that shouldn't be there
 * @param {function(string): boolean} isKept check if the entry is ignored
 * @param {function(Error=): void} callback callback
 * @returns {void}
 */
const applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {
	const log = msg => {
diff --git a/a.js b/b.js
@@ -137,11 +154,13 @@ const applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
 * @param {Set<string>} diff filenames of the assets that shouldn't be there
 * @param {function(string): boolean} isKept check if the entry is ignored
 * @param {function(Error=): void} callback callback
 * @returns {void}
 */
const applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {
	const log = msg => {
		if (dry) {
			logger.info(msg);
		} else {
			logger.log(msg);
		}
	};
	/** @typedef {{ type: "check" | "unlink" | "rmdir", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */
	/** @type {Job[]} */
	const jobs = Array.from(diff, filename => ({
		type: "check",
		filename,
		parent: undefined
	}));
	processAsyncTree(
		jobs,
		10,
		({ type, filename, parent }, push, callback) => {
diff --git a/a.js b/b.js
@@ -161,6 +180,7 @@ processAsyncTree(
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
	const jobs = Array.from(diff, filename => ({
		type: "check",
		filename,
		parent: undefined
	}));
	processAsyncTree(
		jobs,
		10,
		({ type, filename, parent }, push, callback) => {
			const handleError = err => {
				if (err.code === "ENOENT") {
					log(`${filename} was removed during cleaning by something else`);
					handleParent();
					return callback();
				}
				return callback(err);
			};
			const handleParent = () => {
				if (parent && --parent.remaining === 0) push(parent.job);
			};
			const path = join(fs, outputPath, filename);
			switch (type) {
				case "check":
					if (isKept(filename)) {
						// do not decrement parent entry as we don't want to delete the parent
						log(`${filename} will be kept`);
						return process.nextTick(callback);
					}
diff --git a/a.js b/b.js
@@ -247,7 +267,10 @@ processAsyncTree(
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
	const jobs = Array.from(diff, filename => ({
		type: "check",
		filename,
		parent: undefined
	}));
	processAsyncTree(
		jobs,
		10,
		({ type, filename, parent }, push, callback) => {
			const handleError = err => {
				if (err.code === "ENOENT") {
					log(`${filename} was removed during cleaning by something else`);
					handleParent();
					return callback();
				}
				return callback(err);
			};
			const handleParent = () => {
				if (parent && --parent.remaining === 0) push(parent.job);
			};
			const path = join(fs, outputPath, filename);
			switch (type) {
				case "check":
					if (isKept(filename)) {
						// do not decrement parent entry as we don't want to delete the parent
						log(`${filename} will be kept`);
						return process.nextTick(callback);
					}
					doStat(fs, path, (err, stats) => {
						if (err) return handleError(err);
						if (!stats.isDirectory()) {
							push({
								type: "unlink",
								filename,
								parent
							});
							return callback();
						}
						fs.readdir(path, (err, entries) => {
							if (err) return handleError(err);
							/** @type {Job} */
							const deleteJob = {
								type: "rmdir",
								filename,
								parent
							};
							if (entries.length === 0) {
								push(deleteJob);
							} else {
								const parentToken = {
									remaining: entries.length,
									job: deleteJob
								};
								for (const entry of entries) {
									const file = /** @type {string} */ (entry);
									if (file.startsWith(".")) {
										log(
											`${filename} will be kept (dot-files will never be removed)`
										);
										continue;
									}
									push({
										type: "check",
										filename: `${filename}/${file}`,
										parent: parentToken
									});
								}
							}
							return callback();
						});
					});
					break;
				case "rmdir":
					log(`${filename} will be removed`);
					if (dry) {
						handleParent();
						return process.nextTick(callback);
					}
					if (!fs.rmdir) {
						logger.warn(
							`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`
						);
						return process.nextTick(callback);
					}
					fs.rmdir(path, err => {
						if (err) return handleError(err);
						handleParent();
						callback();
					});
					break;
				case "unlink":
					log(`${filename} will be removed`);
					if (dry) {
						handleParent();
						return process.nextTick(callback);
					}
					if (!fs.unlink) {
						logger.warn(
							`${filename} can't be removed because output file system doesn't support removing files (rmdir)`
						);
						return process.nextTick(callback);
					}
					fs.unlink(path, err => {
						if (err) return handleError(err);
						handleParent();
						callback();
					});
					break;
			}
		},
		callback
	);
};

/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */
diff --git a/a.js b/b.js
@@ -302,6 +325,7 @@ apply(compiler) {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const { dry, keep } = this.options;

		const keepFn =
			typeof keep === "function"
				? keep
				: typeof keep === "string"
				? path => path.startsWith(keep)
				: typeof keep === "object" && keep.test
				? path => keep.test(path)
				: () => false;

		// We assume that no external modification happens while the compiler is active
		// So we can store the old assets and only diff to them to avoid fs access on
		// incremental builds
		let oldAssets;

		compiler.hooks.emit.tapAsync(
			{
diff --git a/a.js b/b.js
@@ -322,7 +346,9 @@ apply(compiler) {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const { dry, keep } = this.options;

		const keepFn =
			typeof keep === "function"
				? keep
				: typeof keep === "string"
				? path => path.startsWith(keep)
				: typeof keep === "object" && keep.test
				? path => keep.test(path)
				: () => false;

		// We assume that no external modification happens while the compiler is active
		// So we can store the old assets and only diff to them to avoid fs access on
		// incremental builds
		let oldAssets;

		compiler.hooks.emit.tapAsync(
			{
				name: "CleanPlugin",
				stage: 100
			},
			(compilation, callback) => {
				const hooks = CleanPlugin.getCompilationHooks(compilation);
				const logger = compilation.getLogger("webpack.CleanPlugin");
				const fs = compiler.outputFileSystem;

				if (!fs.readdir) {
					return callback(
						new Error(
							"CleanPlugin: Output filesystem doesn't support listing directories (readdir)"
						)
					);
				}

				const currentAssets = new Set();
				for (const asset of Object.keys(compilation.assets)) {
					if (/^[A-Za-z]:\\|^\/|^\\\\/.test(asset)) continue;
					let normalizedAsset;
					let newNormalizedAsset = asset.replace(/\\/g, "/");
diff --git a/a.js b/b.js
@@ -335,7 +361,12 @@ apply(compiler) {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const { dry, keep } = this.options;

		const keepFn =
			typeof keep === "function"
				? keep
				: typeof keep === "string"
				? path => path.startsWith(keep)
				: typeof keep === "object" && keep.test
				? path => keep.test(path)
				: () => false;

		// We assume that no external modification happens while the compiler is active
		// So we can store the old assets and only diff to them to avoid fs access on
		// incremental builds
		let oldAssets;

		compiler.hooks.emit.tapAsync(
			{
				name: "CleanPlugin",
				stage: 100
			},
			(compilation, callback) => {
				const hooks = CleanPlugin.getCompilationHooks(compilation);
				const logger = compilation.getLogger("webpack.CleanPlugin");
				const fs = compiler.outputFileSystem;

				if (!fs.readdir) {
					return callback(
						new Error(
							"CleanPlugin: Output filesystem doesn't support listing directories (readdir)"
						)
					);
				}

				const currentAssets = new Set();
				for (const asset of Object.keys(compilation.assets)) {
					if (/^[A-Za-z]:\\|^\/|^\\\\/.test(asset)) continue;
					let normalizedAsset;
					let newNormalizedAsset = asset.replace(/\\/g, "/");
					do {
						normalizedAsset = newNormalizedAsset;
						newNormalizedAsset = normalizedAsset.replace(
							/(^|\/)(?!\.\.)[^/]+\/\.\.\//g,
							"$1"
						);
					} while (newNormalizedAsset !== normalizedAsset);
					if (normalizedAsset.startsWith("../")) continue;
					currentAssets.add(normalizedAsset);
				}

				const outputPath = compilation.getPath(compiler.outputPath, {});

diff --git a/a.js b/b.js
@@ -346,19 +377,34 @@ apply(compiler) {
A blob:074b90bf4507306d0d307cd8b249f2fd4151c34d
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const { dry, keep } = this.options;

		const keepFn =
			typeof keep === "function"
				? keep
				: typeof keep === "string"
				? path => path.startsWith(keep)
				: typeof keep === "object" && keep.test
				? path => keep.test(path)
				: () => false;

		// We assume that no external modification happens while the compiler is active
		// So we can store the old assets and only diff to them to avoid fs access on
		// incremental builds
		let oldAssets;

		compiler.hooks.emit.tapAsync(
			{
				name: "CleanPlugin",
				stage: 100
			},
			(compilation, callback) => {
				const hooks = CleanPlugin.getCompilationHooks(compilation);
				const logger = compilation.getLogger("webpack.CleanPlugin");
				const fs = compiler.outputFileSystem;

				if (!fs.readdir) {
					return callback(
						new Error(
							"CleanPlugin: Output filesystem doesn't support listing directories (readdir)"
						)
					);
				}

				const currentAssets = new Set();
				for (const asset of Object.keys(compilation.assets)) {
					if (/^[A-Za-z]:\\|^\/|^\\\\/.test(asset)) continue;
					let normalizedAsset;
					let newNormalizedAsset = asset.replace(/\\/g, "/");
					do {
						normalizedAsset = newNormalizedAsset;
						newNormalizedAsset = normalizedAsset.replace(
							/(^|\/)(?!\.\.)[^/]+\/\.\.\//g,
							"$1"
						);
					} while (newNormalizedAsset !== normalizedAsset);
					if (normalizedAsset.startsWith("../")) continue;
					currentAssets.add(normalizedAsset);
				}

				const outputPath = compilation.getPath(compiler.outputPath, {});

				const isKept = path => {
					const result = hooks.keep.call(path);
					if (result !== undefined) return result;
					return keepFn(path);
				};

				const diffCallback = (err, diff) => {
					if (err) {
						oldAssets = undefined;
						return callback(err);
					}
					applyDiff(fs, outputPath, dry, logger, diff, isKept, err => {
						if (err) {
							oldAssets = undefined;
						} else {
							oldAssets = currentAssets;
						}
						callback(err);
					});
				};

				if (oldAssets) {
					diffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));
diff --git a/a.js b/b.js
@@ -43,6 +43,7 @@
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
	tryRunOrWebpackError
} = require("./HookWebpackError");
const MainTemplate = require("./MainTemplate");
const Module = require("./Module");
const ModuleDependencyError = require("./ModuleDependencyError");
const ModuleDependencyWarning = require("./ModuleDependencyWarning");
const ModuleGraph = require("./ModuleGraph");
const ModuleNotFoundError = require("./ModuleNotFoundError");
const ModuleProfile = require("./ModuleProfile");
const ModuleRestoreError = require("./ModuleRestoreError");
const ModuleStoreError = require("./ModuleStoreError");
diff --git a/a.js b/b.js
@@ -3884,6 +3885,7 @@ createModuleHashes() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
diff --git a/a.js b/b.js
@@ -3894,7 +3896,7 @@ createModuleHashes() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
diff --git a/a.js b/b.js
@@ -3908,13 +3910,20 @@ createModuleHashes() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
				}
				statModulesHashed++;
				const digest = this._createModuleHash(
					module,
					chunkGraph,
					runtime,
					hashFunction,
					runtimeTemplate,
					hashDigest,
					hashDigestLength
				);
				if (memCache) {
					memCache.set(`moduleHash-${getRuntimeKey(runtime)}`, digest);
				}
			}
		}
		this.logger.log(
			`${statModulesHashed} modules hashed, ${statModulesFromCache} from cache (${
				Math.round(
					(100 * (statModulesHashed + statModulesFromCache)) / this.modules.size
diff --git a/a.js b/b.js
@@ -3931,22 +3940,27 @@ _createModuleHash(
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
				) / 100
			} variants per module in average)`
		);
	}

	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength
	) {
		const moduleHash = createHash(hashFunction);
		module.updateHash(moduleHash, {
			chunkGraph,
			runtime,
			runtimeTemplate
		});
		const moduleHashDigest = /** @type {string} */ (
			moduleHash.digest(hashDigest)
		);
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

diff --git a/a.js b/b.js
@@ -4092,6 +4106,7 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
diff --git a/a.js b/b.js
@@ -4106,7 +4121,8 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
diff --git a/a.js b/b.js
@@ -4130,9 +4146,9 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
diff --git a/a.js b/b.js
@@ -4148,7 +4164,7 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
diff --git a/a.js b/b.js
@@ -4163,13 +4179,19 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
diff --git a/a.js b/b.js
@@ -4189,7 +4211,7 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
diff --git a/a.js b/b.js
@@ -4200,7 +4222,7 @@ createHash() {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest = /** @type {string} */ (
				chunkHash.digest(hashDigest)
			);
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd("hashing: process full hash modules");
		return codeGenerationJobs;
diff --git a/a.js b/b.js
@@ -4802,6 +4824,9 @@ executeModule(module, options, callback) {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
diff --git a/a.js b/b.js
@@ -4811,15 +4836,14 @@ executeModule(module, options, callback) {
A blob:7c98ef773896634c80a7617b8527fb4a2981bc80
	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
				}

				const codeGenerationResults = new CodeGenerationResults(
					this.outputOptions.hashFunction
				);
				/** @type {WebpackError[]} */
				const errors = [];
				/**
				 * @param {Module} module the module
				 * @param {Callback} callback callback
				 * @returns {void}
diff --git a/a.js b/b.js
@@ -65,7 +65,7 @@
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e
 * @property {string=} typePrefix
 * @property {string=} category
 * @property {string[][]=} referencedExports exports referenced from modules (won't be mangled)
 */

/**
 * @typedef {Object} ContextModuleOptionsExtras
 * @property {string|string[]} resource
 * @property {string=} resourceQuery
 * @property {string=} resourceFragment
 * @property {TODO} resolveOptions
 */
diff --git a/a.js b/b.js
@@ -174,8 +174,9 @@ _prettyRegExp(regexString, stripSlash = true) {
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e
	cleanupForCache() {
		super.cleanupForCache();
		this.resolveDependencies = undefined;
	}

	_prettyRegExp(regexString, stripSlash = true) {
		const str = (regexString + "").replace(/!/g, "%21").replace(/\|/g, "%7C");
		return stripSlash ? str.substring(1, str.length - 1) : str;
	}

	_createIdentifier() {
		let identifier =
			this.context ||
			(typeof this.options.resource === "string"
				? this.options.resource
				: this.options.resource.join("|"));
		if (this.options.resourceQuery) {
			identifier += `|${this.options.resourceQuery}`;
		}
diff --git a/a.js b/b.js
@@ -244,8 +245,11 @@ readableIdentifier(requestShortener) {
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e

	/**
	 * @param {RequestShortener} requestShortener the request shortener
	 * @returns {string} a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		let identifier;
		if (this.context) {
			identifier = requestShortener.shorten(this.context) + "/";
		} else if (typeof this.options.resource === "string") {
			identifier = requestShortener.shorten(this.options.resource) + "/";
		} else {
			identifier = this.options.resource
				.map(r => requestShortener.shorten(r) + "/")
				.join(" ");
diff --git a/a.js b/b.js
@@ -314,14 +318,14 @@ libIdent(options) {
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let identifier;

		if (this.context) {
			identifier = contextify(
				options.context,
				this.context,
				options.associatedObjectForCache
			);
		} else if (typeof this.options.resource === "string") {
			identifier = contextify(
				options.context,
				this.options.resource,
				options.associatedObjectForCache
			);
		} else {
			const arr = [];
			for (const res of this.options.resource) {
				arr.push(
					contextify(options.context, res, options.associatedObjectForCache)
				);
			}
			identifier = arr.join(" ");
		}

		if (this.layer) identifier = `(${this.layer})/${identifier}`;
		if (this.options.mode) {
diff --git a/a.js b/b.js
@@ -372,8 +376,9 @@ needBuild({ fileSystemInfo }, callback) {
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e
	/**
	 * @param {NeedBuildContext} context context info
	 * @param {function((WebpackError | null)=, boolean=): void} callback callback function, returns true, if the module needs a rebuild
	 * @returns {void}
	 */
	needBuild({ fileSystemInfo }, callback) {
		// build if enforced
		if (this._forceBuild) return callback(null, true);

		// always build when we have no snapshot
		if (!this.buildInfo.snapshot) return callback(null, true);

		fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {
			callback(err, !valid);
		});
diff --git a/a.js b/b.js
@@ -488,6 +493,8 @@ build(options, compilation, resolver, fs, callback) {
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {function(WebpackError=): void} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		/** @type {BuildMeta} */
		this.buildMeta = {
			exportsType: "default",
			defaultObject: "redirect-warn"
		};
		this.buildInfo = {
			snapshot: undefined
		};
		this.dependencies.length = 0;
		this.blocks.length = 0;
		const startTime = Date.now();
		this.resolveDependencies(fs, this.options, (err, dependencies) => {
			if (err) {
				return callback(
					makeWebpackError(err, "ContextModule.resolveDependencies")
				);
			}

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			}

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}
			dependencies.sort(
				concatComparators(
					compareSelect(a => a.loc, compareLocations),
					keepOriginalOrder(this.dependencies)
				)
			);

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy-once") {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock({
						...this.options.groupOptions,
						name: this.options.chunkName
					});
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy") {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						}
						chunkName = chunkName.replace(/\[index\]/g, `${index++}`);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						{
							...this.options.groupOptions,
							name: chunkName
						},
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new WebpackError(`Unsupported mode "${this.options.mode}" in context`)
				);
				return;
			}
			compilation.fileSystemInfo.createSnapshot(
				startTime,
				null,
				this.context
diff --git a/a.js b/b.js
@@ -495,7 +502,7 @@ build(options, compilation, resolver, fs, callback) {
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {function(WebpackError=): void} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		/** @type {BuildMeta} */
		this.buildMeta = {
			exportsType: "default",
			defaultObject: "redirect-warn"
		};
		this.buildInfo = {
			snapshot: undefined
		};
		this.dependencies.length = 0;
		this.blocks.length = 0;
		const startTime = Date.now();
		this.resolveDependencies(fs, this.options, (err, dependencies) => {
			if (err) {
				return callback(
					makeWebpackError(err, "ContextModule.resolveDependencies")
				);
			}

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			}

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}
			dependencies.sort(
				concatComparators(
					compareSelect(a => a.loc, compareLocations),
					keepOriginalOrder(this.dependencies)
				)
			);

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy-once") {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock({
						...this.options.groupOptions,
						name: this.options.chunkName
					});
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy") {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						}
						chunkName = chunkName.replace(/\[index\]/g, `${index++}`);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						{
							...this.options.groupOptions,
							name: chunkName
						},
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new WebpackError(`Unsupported mode "${this.options.mode}" in context`)
				);
				return;
			}
			compilation.fileSystemInfo.createSnapshot(
				startTime,
				null,
				this.context
					? [this.context]
					: typeof this.options.resource === "string"
					? [this.options.resource]
					: this.options.resource,
				null,
				SNAPSHOT_OPTIONS,
				(err, snapshot) => {
					if (err) return callback(err);
diff --git a/a.js b/b.js
@@ -523,6 +530,8 @@ addCacheDependencies(
A blob:8039aa423f29e811a9d68809605cc3ee1da4198e
	 * @param {LazySet<string>} fileDependencies set where file dependencies are added to
	 * @param {LazySet<string>} contextDependencies set where context dependencies are added to
	 * @param {LazySet<string>} missingDependencies set where missing dependencies are added to
	 * @param {LazySet<string>} buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {
		if (this.context) {
			contextDependencies.add(this.context);
		} else if (typeof this.options.resource === "string") {
			contextDependencies.add(this.options.resource);
		} else {
			for (const res of this.options.resource) contextDependencies.add(res);
		}
	}
diff --git a/a.js b/b.js
@@ -128,7 +128,7 @@ create(data, callback) {
A blob:31b75b4ba7a74a8220a3e7a1346f0c12512451dc
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
diff --git a/a.js b/b.js
@@ -138,7 +138,7 @@ create(data, callback) {
A blob:31b75b4ba7a74a8220a3e7a1346f0c12512451dc
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
diff --git a/a.js b/b.js
@@ -146,7 +146,7 @@ create(data, callback) {
A blob:31b75b4ba7a74a8220a3e7a1346f0c12512451dc
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}
diff --git a/a.js b/b.js
@@ -217,7 +217,12 @@ create(data, callback) {
A blob:31b75b4ba7a74a8220a3e7a1346f0c12512451dc
	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {function(Error=, ModuleFactoryResult=): void} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context: context,
				dependencies: dependencies,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					"context",
					dependencies.length > 0
						? cachedSetProperty(
								resolveOptions || EMPTY_RESOLVE_OPTIONS,
								"dependencyType",
								dependencies[0].category
						  )
						: resolveOptions
				);
				const loaderResolver = this.resolverFactory.get("loader");

				asyncLib.parallel(
					[
						callback => {
							const results = [];
							const yield_ = obj => results.push(obj);

							contextResolver.resolve(
								{},
								context,
								resource,
								{
									fileDependencies,
									missingDependencies,
									contextDependencies,
									yield: yield_
								},
								err => {
									if (err) return callback(err);
									callback(null, results);
								}
							);
						},
						callback => {
							asyncLib.map(
								loaders,
								(loader, callback) => {
									loaderResolver.resolve(
										{},
										context,
										loader,
										{
											fileDependencies,
											missingDependencies,
											contextDependencies
										},
										(err, result) => {
											if (err) return callback(err);
											callback(null, result);
										}
									);
								},
								callback
							);
						}
					],
					(err, result) => {
						if (err) {
							return callback(err, {
								fileDependencies,
								missingDependencies,
								contextDependencies
							});
						}
						const [contextResult, loaderResult] = result;
						this.hooks.afterResolve.callAsync(
							{
								addon:
									loadersPrefix +
diff --git a/a.js b/b.js
@@ -343,7 +348,7 @@ resolveDependencies(fs, options, callback) {
A blob:31b75b4ba7a74a8220a3e7a1346f0c12512451dc
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix
		} = options;
		if (!regExp || !resource) return callback(null, []);

		let severalContexts = false;
		const addDirectoryChecked = (ctx, directory, visited, callback) => {
			fs.realpath(directory, (err, realPath) => {
				if (err) return callback(err);
				if (visited.has(realPath)) return callback(null, []);
				let recursionStack;
				addDirectory(
					ctx,
					directory,
					(_, dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(ctx, dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		const addDirectory = (ctx, directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file => file.normalize("NFC"))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(ctx, subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: ctx,
										request:
											"." + subResource.substr(ctx.length).replace(/\\/g, "/")
									};

									this.hooks.alternativeRequests.callAsync(
										[obj],
diff --git a/a.js b/b.js
@@ -62,6 +62,7 @@ static entryDescriptionToOptions(compiler, name, desc) {
A blob:e6cf840a7699f75935457b5850fe1410bf9f637e
	 * @param {Compiler} compiler the compiler
	 * @param {string} name entry name
	 * @param {EntryDescription} desc entry description
	 * @returns {EntryOptions} options for the entry
	 */
	static entryDescriptionToOptions(compiler, name, desc) {
		/** @type {EntryOptions} */
		const options = {
			name,
			filename: desc.filename,
			runtime: desc.runtime,
			layer: desc.layer,
			dependOn: desc.dependOn,
			publicPath: desc.publicPath,
			chunkLoading: desc.chunkLoading,
			asyncChunks: desc.asyncChunks,
			wasmLoading: desc.wasmLoading,
diff --git a/a.js b/b.js
@@ -38,6 +38,7 @@
A blob:710388abd72e7fdc7640608033f4562a1798fa18
 */

/**
 * @typedef {Object} UpdateHashContext
 * @property {NormalModule} module the module
 * @property {ChunkGraph} chunkGraph
 * @property {RuntimeSpec} runtime
 */

/**
 *
diff --git a/a.js b/b.js
@@ -69,6 +69,16 @@ apply(compiler) {
A blob:46bd0156c58a85dcf4953d876f43f37fe1486a65
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"NodeStuffPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					if (parserOptions.node === false) return;

					let localOptions = options;
					if (parserOptions.node) {
						localOptions = { ...localOptions, ...parserOptions.node };
					}

					if (localOptions.global !== false) {
						const withWarning = localOptions.global === "warn";
						parser.hooks.expression
							.for("global")
							.tap("NodeStuffPlugin", expr => {
								const dep = new ConstDependency(
									RuntimeGlobals.global,
									expr.range,
									[RuntimeGlobals.global]
								);
								dep.loc = expr.loc;
								parser.state.module.addPresentationalDependency(dep);

								// TODO webpack 6 remove
								if (withWarning) {
									parser.state.module.addWarning(
										new NodeStuffInWebError(
											dep.loc,
											"global",
											"The global namespace object is Node.js feature and doesn't present in browser."
										)
									);
								}
							});
					}

					const setModuleConstant = (expressionName, fn, warning) => {
						parser.hooks.expression
diff --git a/a.js b/b.js
@@ -50,6 +50,7 @@
A blob:1acdd3f3d1e7f567cee3557cf4d41a6033d7fe7e
} = require("./util/identifier");
const makeSerializable = require("./util/makeSerializable");
const memoize = require("./util/memoize");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../declarations/LoaderContext").NormalModuleLoaderContext} NormalModuleLoaderContext */
/** @typedef {import("../declarations/WebpackOptions").Mode} Mode */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import("./ChunkGraph")} ChunkGraph */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Dependency").UpdateHashContext} UpdateHashContext */
diff --git a/a.js b/b.js
@@ -194,6 +195,25 @@ makeSerializable(
A blob:1acdd3f3d1e7f567cee3557cf4d41a6033d7fe7e
		this.name = "NonErrorEmittedError";
		this.message = "(Emitted value instead of an instance of Error) " + error;
	}
}

makeSerializable(
	NonErrorEmittedError,
	"webpack/lib/NormalModule",
	"NonErrorEmittedError"
);

/**
 * @typedef {Object} NormalModuleCompilationHooks
 * @property {SyncHook<[object, NormalModule]>} loader
 * @property {SyncHook<[LoaderItem[], NormalModule, object]>} beforeLoaders
 * @property {SyncHook<[NormalModule]>} beforeParse
 * @property {SyncHook<[NormalModule]>} beforeSnapshot
 * @property {HookMap<AsyncSeriesBailHook<[string, NormalModule], string | Buffer>>} readResourceForScheme
 * @property {HookMap<AsyncSeriesBailHook<[object], string | Buffer>>} readResource
 * @property {AsyncSeriesBailHook<[NormalModule, NeedBuildContext], boolean>} needBuild
 */

/** @type {WeakMap<Compilation, NormalModuleCompilationHooks>} */
const compilationHooksMap = new WeakMap();

class NormalModule extends Module {
diff --git a/a.js b/b.js
@@ -246,22 +266,7 @@ static getCompilationHooks(compilation) {
A blob:1acdd3f3d1e7f567cee3557cf4d41a6033d7fe7e
class NormalModule extends Module {
	/**
	 * @param {Compilation} compilation the compilation
	 * @returns {NormalModuleCompilationHooks} the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				"The 'compilation' argument must be an instance of Compilation"
			);
		}
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				loader: new SyncHook(["loaderContext", "module"]),
				beforeLoaders: new SyncHook(["loaders", "module", "loaderContext"]),
				beforeParse: new SyncHook(["module"]),
				beforeSnapshot: new SyncHook(["module"]),
				// TODO webpack 6 deprecate
				readResourceForScheme: new HookMap(scheme => {
					const hook = hooks.readResource.for(scheme);
					return createFakeHook(
						/** @type {AsyncSeriesBailHook<[string, NormalModule], string | Buffer>} */ ({
							tap: (options, fn) =>
								hook.tap(options, loaderContext =>
									fn(loaderContext.resource, loaderContext._module)
								),
							tapAsync: (options, fn) =>
								hook.tapAsync(options, (loaderContext, callback) =>
									fn(loaderContext.resource, loaderContext._module, callback)
								),
							tapPromise: (options, fn) =>
								hook.tapPromise(options, loaderContext =>
									fn(loaderContext.resource, loaderContext._module)
								)
						})
					);
				}),
				readResource: new HookMap(
					() => new AsyncSeriesBailHook(["loaderContext"])
				),
				needBuild: new AsyncSeriesBailHook(["module", "context"])
			};
			compilationHooksMap.set(compilation, hooks);
		}
		return hooks;
	}

	/**
	 * @param {Object} options options object
	 * @param {string=} options.layer an optional layer in which the module is
	 * @param {string} options.type module type
	 * @param {string} options.request request string
	 * @param {string} options.userRequest request intended by user (without loaders from config)
	 * @param {string} options.rawRequest request without resolving
	 * @param {LoaderItem[]} options.loaders list of loaders
	 * @param {string} options.resource path + query of the real resource
	 * @param {Record<string, any>=} options.resourceResolveData resource resolve data
	 * @param {string} options.context context directory for resolving
	 * @param {string | undefined} options.matchResource path + query of the matched resource (virtual)
	 * @param {Parser} options.parser the parser used
	 * @param {object} options.parserOptions the options of the parser used
	 * @param {Generator} options.generator the generator used
	 * @param {object} options.generatorOptions the options of the generator used
	 * @param {Object} options.resolveOptions options used for resolving requests from this module
	 */
	constructor({
		layer,
		type,
diff --git a/a.js b/b.js
@@ -370,7 +375,7 @@ libIdent(options) {
A blob:1acdd3f3d1e7f567cee3557cf4d41a6033d7fe7e

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let ident = contextify(
			options.context,
			this.userRequest,
			options.associatedObjectForCache
		);
		if (this.layer) ident = `(${this.layer})/${ident}`;
		return ident;
	}

	/**
	 * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)
	 */
	nameForCondition() {
		const resource = this.matchResource || this.resource;
		const idx = resource.indexOf("?");
		if (idx >= 0) return resource.substr(0, idx);
		return resource;
	}

	/**
diff --git a/a.js b/b.js
@@ -553,7 +558,7 @@ _createLoaderContext(resolver, options, compilation, fs, hooks) {
A blob:1acdd3f3d1e7f567cee3557cf4d41a6033d7fe7e
	 * @param {Compilation} compilation the compilation
	 * @param {InputFileSystem} fs file system from reading
	 * @param {NormalModuleCompilationHooks} hooks the hooks
	 * @returns {NormalModuleLoaderContext} loader context
	 */
	_createLoaderContext(resolver, options, compilation, fs, hooks) {
		const { requestShortener } = compilation.runtimeTemplate;
		const getCurrentLoaderName = () => {
			const currentLoader = this.getCurrentLoader(loaderContext);
			if (!currentLoader) return "(not in loader scope)";
			return requestShortener.shorten(currentLoader.loader);
		};
		const getResolveContext = () => {
			return {
				fileDependencies: {
					add: d => loaderContext.addDependency(d)
				},
				contextDependencies: {
					add: d => loaderContext.addContextDependency(d)
				},
				missingDependencies: {
					add: d => loaderContext.addMissingDependency(d)
				}
			};
		};
		const getAbsolutify = memoize(() =>
			absolutify.bindCache(compilation.compiler.root)
		);
		const getAbsolutifyInContext = memoize(() =>
			absolutify.bindContextCache(this.context, compilation.compiler.root)
		);
		const getContextify = memoize(() =>
			contextify.bindCache(compilation.compiler.root)
		);
		const getContextifyInContext = memoize(() =>
			contextify.bindContextCache(this.context, compilation.compiler.root)
		);
		const utils = {
			absolutify: (context, request) => {
				return context === this.context
					? getAbsolutifyInContext()(request)
					: getAbsolutify()(context, request);
			},
			contextify: (context, request) => {
				return context === this.context
					? getContextifyInContext()(request)
					: getContextify()(context, request);
			},
			createHash: type => {
				return createHash(type || compilation.outputOptions.hashFunction);
			}
		};
		const loaderContext = {
			version: 2,
			getOptions: schema => {
				const loader = this.getCurrentLoader(loaderContext);

				let { options } = loader;

				if (typeof options === "string") {
					if (options.substr(0, 1) === "{" && options.substr(-1) === "}") {
						try {
							options = parseJson(options);
						} catch (e) {
							throw new Error(`Cannot parse string options: ${e.message}`);
diff --git a/a.js b/b.js
@@ -34,14 +34,19 @@
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
const { join } = require("./util/fs");
const {
	parseResource,
	parseResourceWithoutFragment
} = require("./util/identifier");

/** @typedef {import("../declarations/WebpackOptions").ModuleOptionsNormalized} ModuleOptions */
/** @typedef {import("./Generator")} Generator */
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./Parser")} Parser */
/** @typedef {import("./ResolverFactory")} ResolverFactory */
/** @typedef {import("./dependencies/ModuleDependency")} ModuleDependency */
/** @typedef {import("./util/fs").InputFileSystem} InputFileSystem */

/**
 * @typedef {Object} ResolveData
 * @property {ModuleFactoryCreateData["contextInfo"]} contextInfo
 * @property {ModuleFactoryCreateData["resolveOptions"]} resolveOptions
diff --git a/a.js b/b.js
@@ -51,7 +56,7 @@
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
 * @property {ModuleFactoryCreateData["contextInfo"]} contextInfo
 * @property {ModuleFactoryCreateData["resolveOptions"]} resolveOptions
 * @property {string} context
 * @property {string} request
 * @property {Record<string, any> | undefined} assertions
 * @property {ModuleDependency[]} dependencies
 * @property {string} dependencyType
 * @property {Object} createData
 * @property {LazySet<string>} fileDependencies
 * @property {LazySet<string>} missingDependencies
 * @property {LazySet<string>} contextDependencies
 * @property {boolean} cacheable allow to use the unsafe cache
diff --git a/a.js b/b.js
@@ -199,7 +204,7 @@ constructor({
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
diff --git a/a.js b/b.js
@@ -209,15 +214,15 @@ constructor({
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
diff --git a/a.js b/b.js
@@ -301,7 +306,9 @@ constructor({
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);
		const cachedParseResourceWithoutFragment =
			parseResourceWithoutFragment.bindCache(associatedObjectForCache);
		this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment;

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
diff --git a/a.js b/b.js
@@ -372,7 +379,7 @@ constructor({
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);
		const cachedParseResourceWithoutFragment =
			parseResourceWithoutFragment.bindCache(associatedObjectForCache);
		this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment;

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {ParsedLoaderRequest[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

diff --git a/a.js b/b.js
@@ -430,7 +437,7 @@ constructor({
A blob:d7fc5480c2351306711fba1fccd588a4787b1e24
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);
		const cachedParseResourceWithoutFragment =
			parseResourceWithoutFragment.bindCache(associatedObjectForCache);
		this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment;

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {ParsedLoaderRequest[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

					scheme = getScheme(requestWithoutMatchResource);

					if (!scheme && !contextScheme) {
						const firstChar = requestWithoutMatchResource.charCodeAt(0);
						const secondChar = requestWithoutMatchResource.charCodeAt(1);
						noPreAutoLoaders = firstChar === 45 && secondChar === 33; // startsWith "-!"
						noAutoLoaders = noPreAutoLoaders || firstChar === 33; // startsWith "!"
						noPrePostAutoLoaders = firstChar === 33 && secondChar === 33; // startsWith "!!";
						const rawElements = requestWithoutMatchResource
							.slice(
								noPreAutoLoaders || noPrePostAutoLoaders
									? 2
									: noAutoLoaders
									? 1
									: 0
							)
							.split(/!+/);
						unresolvedResource = rawElements.pop();
						elements = rawElements.map(el => {
							const { path, query } = cachedParseResourceWithoutFragment(el);
							return {
								loader: path,
								options: query ? query.slice(1) : undefined
							};
						});
						scheme = getScheme(unresolvedResource);
					} else {
						unresolvedResource = requestWithoutMatchResource;
						elements = EMPTY_ELEMENTS;
					}
				} else {
					unresolvedResource = request;
					elements = EMPTY_ELEMENTS;
				}

				const resolveContext = {
					fileDependencies,
					missingDependencies,
					contextDependencies
				};

				/** @type {ResourceDataWithData} */
				let resourceData;

				let loaders;

				const continueCallback = needCalls(2, err => {
					if (err) return callback(err);

					// translate option idents
					try {
						for (const item of loaders) {
							if (typeof item.options === "string" && item.options[0] === "?") {
								const ident = item.options.substr(1);
								if (ident === "[[missing ident]]") {
									throw new Error(
										"No ident is provided by referenced loader. " +
											"When using a function for Rule.use in config you need to " +
diff --git a/a.js b/b.js
@@ -531,15 +531,14 @@ _applyOnCompiler(compiler, handler) {
A blob:9391f2e8b8f7245281824f6c9d18de1dd424e60d
	/**
	 * @param {Compiler} compiler webpack compiler
	 * @param {HandlerFunction} handler function that executes for every progress step
	 * @returns {void}
	 */
	_applyOnCompiler(compiler, handler) {
		const showEntries = this.showEntries;
		const showModules = this.showModules;
		const showDependencies = this.showDependencies;
		const showActiveModules = this.showActiveModules;
		let lastActiveModule = "";
		let currentLoader = "";
		let lastModulesCount = 0;
		let lastDependenciesCount = 0;
		let lastEntriesCount = 0;
		let modulesCount = 0;
		let dependenciesCount = 0;
		let entriesCount = 1;
		let doneModules = 0;
		let doneDependencies = 0;
		let doneEntries = 0;
		const activeModules = new Set();
		let lastUpdate = 0;

		const updateThrottled = () => {
			if (lastUpdate + 500 < Date.now()) update();
		};

		const update = () => {
			/** @type {string[]} */
			const items = [];
			const percentByModules =
				doneModules /
				Math.max(lastModulesCount || this.modulesCount || 1, modulesCount);
			const percentByEntries =
				doneEntries /
				Math.max(lastEntriesCount || this.dependenciesCount || 1, entriesCount);
			const percentByDependencies =
				doneDependencies /
				Math.max(lastDependenciesCount || 1, dependenciesCount);
			let percentageFactor;

			switch (this.percentBy) {
				case "entries":
					percentageFactor = percentByEntries;
					break;
				case "dependencies":
					percentageFactor = percentByDependencies;
					break;
				case "modules":
					percentageFactor = percentByModules;
					break;
				default:
					percentageFactor = median3(
						percentByModules,
						percentByEntries,
						percentByDependencies
					);
			}

			const percentage = 0.1 + percentageFactor * 0.55;

			if (currentLoader) {
				items.push(
					`import loader ${contextify(
						compiler.context,
						currentLoader,
						compiler.root
					)}`
				);
			} else {
				const statItems = [];
				if (showEntries) {
					statItems.push(`${doneEntries}/${entriesCount} entries`);
				}
				if (showDependencies) {
					statItems.push(
						`${doneDependencies}/${dependenciesCount} dependencies`
					);
				}
				if (showModules) {
					statItems.push(`${doneModules}/${modulesCount} modules`);
				}
				if (showActiveModules) {
					statItems.push(`${activeModules.size} active`);
				}
				if (statItems.length > 0) {
					items.push(statItems.join(" "));
				}
				if (showActiveModules) {
					items.push(lastActiveModule);
				}
			}
			handler(percentage, "building", ...items);
			lastUpdate = Date.now();
		};

		const factorizeAdd = () => {
			dependenciesCount++;
			if (dependenciesCount < 50 || dependenciesCount % 100 === 0)
				updateThrottled();
		};

		const factorizeDone = () => {
			doneDependencies++;
			if (doneDependencies < 50 || doneDependencies % 100 === 0)
				updateThrottled();
		};

		const moduleAdd = () => {
			modulesCount++;
			if (modulesCount < 50 || modulesCount % 100 === 0) updateThrottled();
		};

		// only used when showActiveModules is set
		const moduleBuild = module => {
			const ident = module.identifier();
			if (ident) {
				activeModules.add(ident);
				lastActiveModule = ident;
				update();
			}
		};

		const entryAdd = (entry, options) => {
			entriesCount++;
			if (entriesCount < 5 || entriesCount % 10 === 0) updateThrottled();
		};

		const moduleDone = module => {
			doneModules++;
			if (showActiveModules) {
				const ident = module.identifier();
				if (ident) {
					activeModules.delete(ident);
					if (lastActiveModule === ident) {
						lastActiveModule = "";
						for (const m of activeModules) {
							lastActiveModule = m;
						}
						update();
						return;
					}
				}
			}
			if (doneModules < 50 || doneModules % 100 === 0) updateThrottled();
		};

		const entryDone = (entry, options) => {
			doneEntries++;
			update();
		};

		const cache = compiler
			.getCache("ProgressPlugin")
			.getItemCache("counts", null);

		let cacheGetPromise;

		compiler.hooks.beforeCompile.tap("ProgressPlugin", () => {
			if (!cacheGetPromise) {
				cacheGetPromise = cache.getPromise().then(
					data => {
						if (data) {
							lastModulesCount = lastModulesCount || data.modulesCount;
							lastDependenciesCount =
								lastDependenciesCount || data.dependenciesCount;
						}
						return data;
					},
					err => {
						// Ignore error
					}
				);
			}
		});

		compiler.hooks.afterCompile.tapPromise("ProgressPlugin", compilation => {
			if (compilation.compiler.isChild()) return Promise.resolve();
			return cacheGetPromise.then(async oldData => {
				if (
					!oldData ||
					oldData.modulesCount !== modulesCount ||
					oldData.dependenciesCount !== dependenciesCount
				) {
					await cache.storePromise({ modulesCount, dependenciesCount });
				}
			});
		});

		compiler.hooks.compilation.tap("ProgressPlugin", compilation => {
			if (compilation.compiler.isChild()) return;
			lastModulesCount = modulesCount;
			lastEntriesCount = entriesCount;
			lastDependenciesCount = dependenciesCount;
			modulesCount = dependenciesCount = entriesCount = 0;
			doneModules = doneDependencies = doneEntries = 0;

			compilation.factorizeQueue.hooks.added.tap(
				"ProgressPlugin",
				factorizeAdd
			);
			compilation.factorizeQueue.hooks.result.tap(
				"ProgressPlugin",
				factorizeDone
			);

			compilation.addModuleQueue.hooks.added.tap("ProgressPlugin", moduleAdd);
			compilation.processDependenciesQueue.hooks.result.tap(
				"ProgressPlugin",
				moduleDone
			);

			if (showActiveModules) {
				compilation.hooks.buildModule.tap("ProgressPlugin", moduleBuild);
			}

			compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd);
			compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone);
			compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);

			// avoid dynamic require if bundled with webpack
			// @ts-expect-error
			if (typeof __webpack_require__ !== "function") {
				const requiredLoaders = new Set();
				NormalModule.getCompilationHooks(compilation).beforeLoaders.tap(
					"ProgressPlugin",
					loaders => {
						for (const loader of loaders) {
							if (
								loader.type !== "module" &&
								!requiredLoaders.has(loader.loader)
							) {
								requiredLoaders.add(loader.loader);
								currentLoader = loader.loader;
								update();
								require(loader.loader);
							}
						}
						if (currentLoader) {
							currentLoader = "";
							update();
						}
					}
				);
			}

			const hooks = {
				finishModules: "finish module graph",
				seal: "plugins",
				optimizeDependencies: "dependencies optimization",
				afterOptimizeDependencies: "after dependencies optimization",
				beforeChunks: "chunk graph",
				afterChunks: "after chunk graph",
				optimize: "optimizing",
				optimizeModules: "module optimization",
				afterOptimizeModules: "after module optimization",
				optimizeChunks: "chunk optimization",
				afterOptimizeChunks: "after chunk optimization",
				optimizeTree: "module and chunk tree optimization",
				afterOptimizeTree: "after module and chunk tree optimization",
				optimizeChunkModules: "chunk modules optimization",
				afterOptimizeChunkModules: "after chunk modules optimization",
				reviveModules: "module reviving",
				beforeModuleIds: "before module ids",
				moduleIds: "module ids",
				optimizeModuleIds: "module id optimization",
				afterOptimizeModuleIds: "module id optimization",
				reviveChunks: "chunk reviving",
				beforeChunkIds: "before chunk ids",
				chunkIds: "chunk ids",
				optimizeChunkIds: "chunk id optimization",
				afterOptimizeChunkIds: "after chunk id optimization",
				recordModules: "record modules",
				recordChunks: "record chunks",
				beforeModuleHash: "module hashing",
				beforeCodeGeneration: "code generation",
				beforeRuntimeRequirements: "runtime requirements",
				beforeHash: "hashing",
				afterHash: "after hashing",
				recordHash: "record hash",
				beforeModuleAssets: "module assets processing",
				beforeChunkAssets: "chunk assets processing",
				processAssets: "asset processing",
				afterProcessAssets: "after asset optimization",
				record: "recording",
				afterSeal: "after seal"
			};
			const numberOfHooks = Object.keys(hooks).length;
			Object.keys(hooks).forEach((name, idx) => {
				const title = hooks[name];
				const percentage = (idx / numberOfHooks) * 0.25 + 0.7;
				compilation.hooks[name].intercept({
					name: "ProgressPlugin",
					call() {
						handler(percentage, "sealing", title);
					},
					done() {
						progressReporters.set(compiler, undefined);
						handler(percentage, "sealing", title);
					},
					result() {
						handler(percentage, "sealing", title);
					},
					error() {
						handler(percentage, "sealing", title);
					},
					tap(tap) {
						// p is percentage from 0 to 1
						// args is any number of messages in a hierarchical matter
						progressReporters.set(compilation.compiler, (p, ...args) => {
							handler(percentage, "sealing", title, tap.name, ...args);
						});
						handler(percentage, "sealing", title, tap.name);
					}
				});
			});
		});
		compiler.hooks.make.intercept({
			name: "ProgressPlugin",
			call() {
				handler(0.1, "building");
			},
			done() {
				handler(0.65, "building");
			}
		});
		const interceptHook = (hook, progress, category, name) => {
			hook.intercept({
				name: "ProgressPlugin",
				call() {
					handler(progress, category, name);
				},
				done() {
					progressReporters.set(compiler, undefined);
					handler(progress, category, name);
				},
				result() {
					handler(progress, category, name);
				},
				error() {
					handler(progress, category, name);
				},
				tap(tap) {
					progressReporters.set(compiler, (p, ...args) => {
						handler(progress, category, name, tap.name, ...args);
					});
					handler(progress, category, name, tap.name);
				}
			});
		};
		compiler.cache.hooks.endIdle.intercept({
			name: "ProgressPlugin",
			call() {
				handler(0, "");
			}
		});
		interceptHook(compiler.cache.hooks.endIdle, 0.01, "cache", "end idle");
		compiler.hooks.initialize.intercept({
			name: "ProgressPlugin",
			call() {
				handler(0, "");
			}
		});
		interceptHook(compiler.hooks.initialize, 0.01, "setup", "initialize");
		interceptHook(compiler.hooks.beforeRun, 0.02, "setup", "before run");
		interceptHook(compiler.hooks.run, 0.03, "setup", "run");
		interceptHook(compiler.hooks.watchRun, 0.03, "setup", "watch run");
		interceptHook(
			compiler.hooks.normalModuleFactory,
			0.04,
diff --git a/a.js b/b.js
@@ -83,6 +83,7 @@ constructor(compilation, outputOptions, requestShortener) {
A blob:77859a08aa4de61f01d8179dce2d18fd378f78ee
	/**
	 * @param {Compilation} compilation the compilation
	 * @param {OutputOptions} outputOptions the compilation output options
	 * @param {RequestShortener} requestShortener the request shortener
	 */
	constructor(compilation, outputOptions, requestShortener) {
		this.compilation = compilation;
		this.outputOptions = outputOptions || {};
		this.requestShortener = requestShortener;
		this.globalObject = getGlobalObject(outputOptions.globalObject);
	}

	isIIFE() {
		return this.outputOptions.iife;
diff --git a/a.js b/b.js
@@ -113,6 +113,7 @@ const decodeDataUriContent = (encoding, content) => {
A blob:a14440e09900046a102d83619b1a1440da4dce35
	}

	return encodedContent;
};

const decodeDataUriContent = (encoding, content) => {
	const isBase64 = encoding === "base64";
	return isBase64
		? Buffer.from(content, "base64")
		: Buffer.from(decodeURIComponent(content), "ascii");
};

const JS_TYPES = new Set(["javascript"]);
const JS_AND_ASSET_TYPES = new Set(["javascript", "asset"]);

class AssetGenerator extends Generator {
	/**
	 * @param {AssetGeneratorOptions["dataUrl"]=} dataUrlOptions the options for the data url
diff --git a/a.js b/b.js
@@ -131,6 +132,65 @@ constructor(dataUrlOptions, filename, publicPath, outputPath, emit) {
A blob:a14440e09900046a102d83619b1a1440da4dce35
	 * @param {string=} filename override for output.assetModuleFilename
	 * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath
	 * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import
	 * @param {boolean=} emit generate output asset
	 */
	constructor(dataUrlOptions, filename, publicPath, outputPath, emit) {
		super();
		this.dataUrlOptions = dataUrlOptions;
		this.filename = filename;
		this.publicPath = publicPath;
		this.outputPath = outputPath;
		this.emit = emit;
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {GenerateContext} generateContext context for generate
	 * @returns {Source} generated code
diff --git a/a.js b/b.js
@@ -170,31 +230,9 @@ generate(
A blob:a14440e09900046a102d83619b1a1440da4dce35
	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {GenerateContext} generateContext context for generate
	 * @returns {Source} generated code
	 */
	generate(
		module,
		{ runtime, chunkGraph, runtimeTemplate, runtimeRequirements, type, getData }
	) {
		switch (type) {
			case "asset":
				return module.originalSource();
			default: {
				runtimeRequirements.add(RuntimeGlobals.module);

				const originalSource = module.originalSource();
				if (module.buildInfo.dataUrl) {
					let encodedSource;
					if (typeof this.dataUrlOptions === "function") {
						encodedSource = this.dataUrlOptions.call(
							null,
							originalSource.source(),
							{
								filename: module.matchResource || module.resource,
								module
							}
						);
					} else {
						/** @type {string | false | undefined} */
						let encoding = this.dataUrlOptions.encoding;
						if (encoding === undefined) {
							if (
								module.resourceResolveData &&
								module.resourceResolveData.encoding !== undefined
							) {
								encoding = module.resourceResolveData.encoding;
							}
						}
						if (encoding === undefined) {
							encoding = "base64";
						}
						let ext;
						let mimeType = this.dataUrlOptions.mimetype;
						if (mimeType === undefined) {
							ext = path.extname(module.nameForCondition());
							if (
								module.resourceResolveData &&
								module.resourceResolveData.mimetype !== undefined
							) {
								mimeType =
									module.resourceResolveData.mimetype +
									module.resourceResolveData.parameters;
							} else if (ext) {
								mimeType = mimeTypes.lookup(ext);
							}
						}
						if (typeof mimeType !== "string") {
							throw new Error(
								"DataUrl can't be generated automatically, " +
									`because there is no mimetype for "${ext}" in mimetype database. ` +
									'Either pass a mimetype via "generator.mimetype" or ' +
									'use type: "asset/resource" to create a resource file instead of a DataUrl'
							);
						}

						let encodedContent;

						if (
diff --git a/a.js b/b.js
@@ -238,11 +276,10 @@ generate(
A blob:a14440e09900046a102d83619b1a1440da4dce35
	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {GenerateContext} generateContext context for generate
	 * @returns {Source} generated code
	 */
	generate(
		module,
		{ runtime, chunkGraph, runtimeTemplate, runtimeRequirements, type, getData }
	) {
		switch (type) {
			case "asset":
				return module.originalSource();
			default: {
				runtimeRequirements.add(RuntimeGlobals.module);

				const originalSource = module.originalSource();
				if (module.buildInfo.dataUrl) {
					let encodedSource;
					if (typeof this.dataUrlOptions === "function") {
						encodedSource = this.dataUrlOptions.call(
							null,
							originalSource.source(),
							{
								filename: module.matchResource || module.resource,
								module
							}
						);
					} else {
						/** @type {string | false | undefined} */
						let encoding = this.dataUrlOptions.encoding;
						if (encoding === undefined) {
							if (
								module.resourceResolveData &&
								module.resourceResolveData.encoding !== undefined
							) {
								encoding = module.resourceResolveData.encoding;
							}
						}
						if (encoding === undefined) {
							encoding = "base64";
						}
						let ext;
						let mimeType = this.dataUrlOptions.mimetype;
						if (mimeType === undefined) {
							ext = path.extname(module.nameForCondition());
							if (
								module.resourceResolveData &&
								module.resourceResolveData.mimetype !== undefined
							) {
								mimeType =
									module.resourceResolveData.mimetype +
									module.resourceResolveData.parameters;
							} else if (ext) {
								mimeType = mimeTypes.lookup(ext);
							}
						}
						if (typeof mimeType !== "string") {
							throw new Error(
								"DataUrl can't be generated automatically, " +
									`because there is no mimetype for "${ext}" in mimetype database. ` +
									'Either pass a mimetype via "generator.mimetype" or ' +
									'use type: "asset/resource" to create a resource file instead of a DataUrl'
							);
						}

						let encodedContent;

						if (
							module.resourceResolveData &&
							module.resourceResolveData.encoding === encoding &&
							decodeDataUriContent(
								module.resourceResolveData.encoding,
								module.resourceResolveData.encodedContent
							).equals(originalSource.buffer())
						) {
							encodedContent = module.resourceResolveData.encodedContent;
						} else {
							encodedContent = encodeDataUri(encoding, originalSource);
						}

						encodedSource = `data:${mimeType}${
							encoding ? `;${encoding}` : ""
						},${encodedContent}`;
					}
					const data = getData();
					data.set("url", Buffer.from(encodedSource));
					return new RawSource(
						`${RuntimeGlobals.module}.exports = ${JSON.stringify(
							encodedSource
						)};`
					);
				} else {
					const assetModuleFilename =
						this.filename || runtimeTemplate.outputOptions.assetModuleFilename;
					const hash = createHash(runtimeTemplate.outputOptions.hashFunction);
					if (runtimeTemplate.outputOptions.hashSalt) {
						hash.update(runtimeTemplate.outputOptions.hashSalt);
					}
					hash.update(originalSource.buffer());
					const fullHash = /** @type {string} */ (
						hash.digest(runtimeTemplate.outputOptions.hashDigest)
					);
					const contentHash = nonNumericOnlyHash(
						fullHash,
						runtimeTemplate.outputOptions.hashDigestLength
					);
					module.buildInfo.fullContentHash = fullHash;
					const sourceFilename = makePathsRelative(
						runtimeTemplate.compilation.compiler.context,
						module.matchResource || module.resource,
						runtimeTemplate.compilation.compiler.root
					).replace(/^\.\//, "");
					let { path: filename, info: assetInfo } =
						runtimeTemplate.compilation.getAssetPathWithInfo(
							assetModuleFilename,
							{
diff --git a/a.js b/b.js
@@ -368,8 +405,59 @@ getSize(module, type) {
A blob:a14440e09900046a102d83619b1a1440da4dce35
	/**
	 * @param {NormalModule} module the module
	 * @param {string=} type source type
	 * @returns {number} estimate size of the module
	 */
	getSize(module, type) {
		switch (type) {
			case "asset": {
				const originalSource = module.originalSource();

				if (!originalSource) {
					return 0;
				}

				return originalSource.size();
			}
			default:
				if (module.buildInfo && module.buildInfo.dataUrl) {
					const originalSource = module.originalSource();

					if (!originalSource) {
						return 0;
					}

					// roughly for data url
					// Example: m.exports="data:image/png;base64,ag82/f+2=="
					// 4/3 = base64 encoding
					// 34 = ~ data url header + footer + rounding
					return originalSource.size() * 1.34 + 36;
				} else {
					// it's only estimated so this number is probably fine
					// Example: m.exports=r.p+"0123456789012345678901.ext"
					return 42;
				}
		}
	}

	/**
	 * @param {Hash} hash hash that will be modified
	 * @param {UpdateHashContext} updateHashContext context for updating hash
	 */
	updateHash(hash, { module }) {
		hash.update(module.buildInfo.dataUrl ? "data-url" : "resource");
	}
}

module.exports = AssetGenerator;
diff --git a/a.js b/b.js
@@ -129,8 +129,10 @@ apply(compiler) {
A blob:7af5e848f0c1f85237a114765581c4a44dfdadae
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			let yieldResult;
			if (typeof newResolveContext.yield === "function") {
				yieldResult = [];
				newResolveContext.yield = obj => yieldResult.push(obj);
			}
			const propagate = key => {
				if (resolveContext[key]) {
diff --git a/a.js b/b.js
@@ -160,7 +162,10 @@ apply(compiler) {
A blob:7af5e848f0c1f85237a114765581c4a44dfdadae
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			let yieldResult;
			if (typeof newResolveContext.yield === "function") {
				yieldResult = [];
				newResolveContext.yield = obj => yieldResult.push(obj);
			}
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						fileDependencies,
						contextDependencies,
						missingDependencies,
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							const resolveResult = result || yieldResult;
							if (!snapshot) {
								if (resolveResult) return callback(null, resolveResult);
								return callback();
							}
diff --git a/a.js b/b.js
@@ -242,11 +247,15 @@ apply(compiler) {
A blob:7af5e848f0c1f85237a114765581c4a44dfdadae
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache("ResolverCachePlugin");
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap("ResolverCachePlugin", compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap("ResolverCachePlugin", () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger("webpack.ResolverCachePlugin");
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});
		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {Object} resolveContext context for resolving meta info
		 * @param {Object} request the request info object
		 * @param {function((Error | null)=, Object=): void} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest = {
				_ResolverCachePluginCacheMiss: true,
				...request
			};
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				missingDependencies: new LazySet(),
				fileDependencies: new LazySet(),
				contextDependencies: new LazySet()
			};
			let yieldResult;
			if (typeof newResolveContext.yield === "function") {
				yieldResult = [];
				newResolveContext.yield = obj => yieldResult.push(obj);
			}
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(resolveContext[key], newResolveContext[key]);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						fileDependencies,
						contextDependencies,
						missingDependencies,
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							const resolveResult = result || yieldResult;
							if (!snapshot) {
								if (resolveResult) return callback(null, resolveResult);
								return callback();
							}
							itemCache.store(
								new CacheEntry(resolveResult, snapshot),
								storeErr => {
									if (storeErr) return callback(storeErr);
									if (resolveResult) return callback(null, resolveResult);
									callback();
								}
							);
						}
					);
				}
			);
		};
		compiler.resolverFactory.hooks.resolver.intercept({
			factory(type, hook) {
				/** @type {Map<string, (function(Error=, Object=): void)[]>} */
				const activeRequests = new Map();
				/** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */
				const activeRequestsWithYield = new Map();
				hook.tap(
					"ResolverCachePlugin",
					/**
					 * @param {Resolver} resolver the resolver
					 * @param {Object} options resolve options
					 * @param {Object} userOptions resolve options passed by the user
					 * @returns {void}
					 */
					(resolver, options, userOptions) => {
						if (options.cache !== true) return;
						const optionsIdent = objectToString(userOptions, false);
						const cacheWithContext =
							options.cacheWithContext !== undefined
								? options.cacheWithContext
								: false;
						resolver.hooks.resolve.tapAsync(
							{
								name: "ResolverCachePlugin",
								stage: -100
							},
							(request, resolveContext, callback) => {
								if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {
									return callback();
								}
								const withYield = typeof resolveContext.yield === "function";
								const identifier = `${type}${
									withYield ? "|yield" : "|default"
								}${optionsIdent}${objectToString(request, !cacheWithContext)}`;

								if (withYield) {
									const activeRequest = activeRequestsWithYield.get(identifier);
									if (activeRequest) {
										activeRequest[0].push(callback);
										activeRequest[1].push(resolveContext.yield);
										return;
									}
								} else {
									const activeRequest = activeRequests.get(identifier);
									if (activeRequest) {
										activeRequest.push(callback);
										return;
									}
								}
								const itemCache = cache.getItemCache(identifier, null);
								let callbacks, yields;
								const done = withYield
									? (err, result) => {
											if (callbacks === undefined) {
												if (err) {
													callback(err);
												} else {
													if (result)
														for (const r of result) resolveContext.yield(r);
													callback(null, null);
												}
												yields = undefined;
												callbacks = false;
											} else {
												for (let i = 0; i < callbacks.length; i++) {
													const cb = callbacks[i];
													const yield_ = yields[i];
													if (result) for (const r of result) yield_(r);
													cb(null, null);
												}
												activeRequestsWithYield.delete(identifier);
												yields = undefined;
												callbacks = false;
diff --git a/a.js b/b.js
@@ -121,8 +121,7 @@ const resolve = browsers => {
A blob:cc5c1c885b9de2172495f854d7938261dc89d581

/**
 * @param {string[]} browsers supported browsers list
 * @returns {EcmaTargetProperties & PlatformTargetProperties & ApiTargetProperties} target properties
 */
const resolve = browsers => {
	/**
	 * Checks all against a version number
	 * @param {Record<string, number | [number, number]>} versions first supported version
	 * @returns {boolean} true if supports
	 */
	const rawChecker = versions => {
		return browsers.every(v => {
			const [name, parsedVersion] = v.split(" ");
			if (!name) return false;
			const requiredVersion = versions[name];
			if (!requiredVersion) return false;
			const [parsedMajor, parserMinor] =
				// safari TP supports all features for normal safari
				parsedVersion === "TP"
					? [Infinity, Infinity]
					: parsedVersion.split(".");
			if (typeof requiredVersion === "number") {
				return +parsedMajor >= requiredVersion;
			}
			return requiredVersion[0] === +parsedMajor
				? +parserMinor >= requiredVersion[1]
				: +parsedMajor > requiredVersion[0];
		});
	};
	const anyNode = browsers.some(b => /^node /.test(b));
	const anyBrowser = browsers.some(b => /^(?!node)/.test(b));
	const browserProperty = !anyBrowser ? false : anyNode ? null : true;
	const nodeProperty = !anyNode ? false : anyBrowser ? null : true;
	// Internet Explorer Mobile, Blackberry browser and Opera Mini are very old browsers, they do not support new features
	const es6DynamicImport = rawChecker({
		chrome: 63,
		and_chr: 63,
		edge: 79,
		firefox: 67,
		and_ff: 67,
		// ie: Not supported
		opera: 50,
		op_mob: 46,
		safari: [11, 1],
		ios_saf: [11, 3],
		samsung: [8, 2],
		android: 63,
		and_qq: [10, 4],
		// baidu: Not supported
		// and_uc: Not supported
		// kaios: Not supported
		// Since Node.js 13.14.0 no warning about usage, but it was added 8.5.0 with some limitations and it was improved in 12.0.0 and 13.2.0
		node: [13, 14]
	});

	return {
		const: rawChecker({
diff --git a/a.js b/b.js
@@ -248,8 +247,7 @@ const resolve = browsers => {
A blob:cc5c1c885b9de2172495f854d7938261dc89d581

/**
 * @param {string[]} browsers supported browsers list
 * @returns {EcmaTargetProperties & PlatformTargetProperties & ApiTargetProperties} target properties
 */
const resolve = browsers => {
	/**
	 * Checks all against a version number
	 * @param {Record<string, number | [number, number]>} versions first supported version
	 * @returns {boolean} true if supports
	 */
	const rawChecker = versions => {
		return browsers.every(v => {
			const [name, parsedVersion] = v.split(" ");
			if (!name) return false;
			const requiredVersion = versions[name];
			if (!requiredVersion) return false;
			const [parsedMajor, parserMinor] =
				// safari TP supports all features for normal safari
				parsedVersion === "TP"
					? [Infinity, Infinity]
					: parsedVersion.split(".");
			if (typeof requiredVersion === "number") {
				return +parsedMajor >= requiredVersion;
			}
			return requiredVersion[0] === +parsedMajor
				? +parserMinor >= requiredVersion[1]
				: +parsedMajor > requiredVersion[0];
		});
	};
	const anyNode = browsers.some(b => /^node /.test(b));
	const anyBrowser = browsers.some(b => /^(?!node)/.test(b));
	const browserProperty = !anyBrowser ? false : anyNode ? null : true;
	const nodeProperty = !anyNode ? false : anyBrowser ? null : true;
	// Internet Explorer Mobile, Blackberry browser and Opera Mini are very old browsers, they do not support new features
	const es6DynamicImport = rawChecker({
		chrome: 63,
		and_chr: 63,
		edge: 79,
		firefox: 67,
		and_ff: 67,
		// ie: Not supported
		opera: 50,
		op_mob: 46,
		safari: [11, 1],
		ios_saf: [11, 3],
		samsung: [8, 2],
		android: 63,
		and_qq: [10, 4],
		// baidu: Not supported
		// and_uc: Not supported
		// kaios: Not supported
		// Since Node.js 13.14.0 no warning about usage, but it was added 8.5.0 with some limitations and it was improved in 12.0.0 and 13.2.0
		node: [13, 14]
	});

	return {
		const: rawChecker({
			chrome: 49,
			and_chr: 49,
			edge: 12,
			// Prior to Firefox 13, <code>const</code> is implemented, but re-assignment is not failing.
			// Prior to Firefox 46, a <code>TypeError</code> was thrown on redeclaration instead of a <code>SyntaxError</code>.
			firefox: 36,
			and_ff: 36,
			// Not supported in for-in and for-of loops
			// ie: Not supported
			opera: 36,
			op_mob: 36,
			safari: [10, 0],
			ios_saf: [10, 0],
			// Before 5.0 supported correctly in strict mode, otherwise supported without block scope
			samsung: [5, 0],
			android: 37,
			and_qq: [10, 4],
			// Supported correctly in strict mode, otherwise supported without block scope
			// baidu: Not supported
			and_uc: [12, 12],
			kaios: [2, 5],
			node: [6, 0]
		}),
		arrowFunction: rawChecker({
			chrome: 45,
			and_chr: 45,
			edge: 12,
			// The initial implementation of arrow functions in Firefox made them automatically strict. This has been changed as of Firefox 24. The use of <code>'use strict';</code> is now required.
			// Prior to Firefox 39, a line terminator (<code>\\n</code>) was incorrectly allowed after arrow function arguments. This has been fixed to conform to the ES2015 specification and code like <code>() \\n => {}</code> will now throw a <code>SyntaxError</code> in this and later versions.
			firefox: 39,
			and_ff: 39,
			// ie: Not supported,
			opera: 32,
			op_mob: 32,
			safari: 10,
			ios_saf: 10,
			samsung: [5, 0],
			android: 45,
			and_qq: [10, 4],
			baidu: [7, 12],
			and_uc: [12, 12],
			kaios: [2, 5],
			node: [6, 0]
		}),
		forOf: rawChecker({
			chrome: 38,
			and_chr: 38,
			edge: 12,
			// Prior to Firefox 51, using the for...of loop construct with the const keyword threw a SyntaxError ("missing = in const declaration").
			firefox: 51,
			and_ff: 51,
			// ie: Not supported,
			opera: 25,
			op_mob: 25,
			safari: 7,
			ios_saf: 7,
			samsung: [3, 0],
			android: 38,
			// and_qq: Unknown support
			// baidu: Unknown support
			// and_uc: Unknown support
			// kaios: Unknown support
			node: [0, 12]
		}),
		destructuring: rawChecker({
			chrome: 49,
			and_chr: 49,
			edge: 14,
			firefox: 41,
			and_ff: 41,
			// ie: Not supported,
			opera: 36,
			op_mob: 36,
			safari: 8,
			ios_saf: 8,
			samsung: [5, 0],
			android: 49,
			// and_qq: Unknown support
			// baidu: Unknown support
			// and_uc: Unknown support
			// kaios: Unknown support
			node: [6, 0]
		}),
		bigIntLiteral: rawChecker({
			chrome: 67,
			and_chr: 67,
			edge: 79,
			firefox: 68,
			and_ff: 68,
			// ie: Not supported,
			opera: 54,
			op_mob: 48,
			safari: 14,
			ios_saf: 14,
			samsung: [9, 2],
			android: 67,
			// and_qq: Not supported
			// baidu: Not supported
			// and_uc: Not supported
			// kaios: Not supported
			node: [10, 4]
		}),
		// Support syntax `import` and `export` and no limitations and bugs on Node.js
		// Not include `export * as namespace`
		module: rawChecker({
			chrome: 61,
			and_chr: 61,
			edge: 16,
			firefox: 60,
			and_ff: 60,
			// ie: Not supported,
			opera: 48,
			op_mob: 45,
			safari: [10, 1],
			ios_saf: [10, 3],
			samsung: [8, 0],
			android: 61,
			and_qq: [10, 4],
			// baidu: Not supported
			// and_uc: Not supported
			// kaios: Not supported
			// Since Node.js 13.14.0 no warning about usage, but it was added 8.5.0 with some limitations and it was improved in 12.0.0 and 13.2.0
			node: [13, 14]
		}),
		dynamicImport: es6DynamicImport,
		dynamicImportInWorker: es6DynamicImport && !anyNode,
		// browserslist does not have info about globalThis
diff --git a/a.js b/b.js
@@ -272,7 +270,7 @@ const resolve = browsers => {
A blob:cc5c1c885b9de2172495f854d7938261dc89d581

/**
 * @param {string[]} browsers supported browsers list
 * @returns {EcmaTargetProperties & PlatformTargetProperties & ApiTargetProperties} target properties
 */
const resolve = browsers => {
	/**
	 * Checks all against a version number
	 * @param {Record<string, number | [number, number]>} versions first supported version
	 * @returns {boolean} true if supports
	 */
	const rawChecker = versions => {
		return browsers.every(v => {
			const [name, parsedVersion] = v.split(" ");
			if (!name) return false;
			const requiredVersion = versions[name];
			if (!requiredVersion) return false;
			const [parsedMajor, parserMinor] =
				// safari TP supports all features for normal safari
				parsedVersion === "TP"
					? [Infinity, Infinity]
					: parsedVersion.split(".");
			if (typeof requiredVersion === "number") {
				return +parsedMajor >= requiredVersion;
			}
			return requiredVersion[0] === +parsedMajor
				? +parserMinor >= requiredVersion[1]
				: +parsedMajor > requiredVersion[0];
		});
	};
	const anyNode = browsers.some(b => /^node /.test(b));
	const anyBrowser = browsers.some(b => /^(?!node)/.test(b));
	const browserProperty = !anyBrowser ? false : anyNode ? null : true;
	const nodeProperty = !anyNode ? false : anyBrowser ? null : true;
	// Internet Explorer Mobile, Blackberry browser and Opera Mini are very old browsers, they do not support new features
	const es6DynamicImport = rawChecker({
		chrome: 63,
		and_chr: 63,
		edge: 79,
		firefox: 67,
		and_ff: 67,
		// ie: Not supported
		opera: 50,
		op_mob: 46,
		safari: [11, 1],
		ios_saf: [11, 3],
		samsung: [8, 2],
		android: 63,
		and_qq: [10, 4],
		// baidu: Not supported
		// and_uc: Not supported
		// kaios: Not supported
		// Since Node.js 13.14.0 no warning about usage, but it was added 8.5.0 with some limitations and it was improved in 12.0.0 and 13.2.0
		node: [13, 14]
	});

	return {
		const: rawChecker({
			chrome: 49,
			and_chr: 49,
			edge: 12,
			// Prior to Firefox 13, <code>const</code> is implemented, but re-assignment is not failing.
			// Prior to Firefox 46, a <code>TypeError</code> was thrown on redeclaration instead of a <code>SyntaxError</code>.
			firefox: 36,
			and_ff: 36,
			// Not supported in for-in and for-of loops
			// ie: Not supported
			opera: 36,
			op_mob: 36,
			safari: [10, 0],
			ios_saf: [10, 0],
			// Before 5.0 supported correctly in strict mode, otherwise supported without block scope
			samsung: [5, 0],
			android: 37,
			and_qq: [10, 4],
			// Supported correctly in strict mode, otherwise supported without block scope
			// baidu: Not supported
			and_uc: [12, 12],
			kaios: [2, 5],
			node: [6, 0]
		}),
		arrowFunction: rawChecker({
			chrome: 45,
			and_chr: 45,
			edge: 12,
			// The initial implementation of arrow functions in Firefox made them automatically strict. This has been changed as of Firefox 24. The use of <code>'use strict';</code> is now required.
			// Prior to Firefox 39, a line terminator (<code>\\n</code>) was incorrectly allowed after arrow function arguments. This has been fixed to conform to the ES2015 specification and code like <code>() \\n => {}</code> will now throw a <code>SyntaxError</code> in this and later versions.
			firefox: 39,
			and_ff: 39,
			// ie: Not supported,
			opera: 32,
			op_mob: 32,
			safari: 10,
			ios_saf: 10,
			samsung: [5, 0],
			android: 45,
			and_qq: [10, 4],
			baidu: [7, 12],
			and_uc: [12, 12],
			kaios: [2, 5],
			node: [6, 0]
		}),
		forOf: rawChecker({
			chrome: 38,
			and_chr: 38,
			edge: 12,
			// Prior to Firefox 51, using the for...of loop construct with the const keyword threw a SyntaxError ("missing = in const declaration").
			firefox: 51,
			and_ff: 51,
			// ie: Not supported,
			opera: 25,
			op_mob: 25,
			safari: 7,
			ios_saf: 7,
			samsung: [3, 0],
			android: 38,
			// and_qq: Unknown support
			// baidu: Unknown support
			// and_uc: Unknown support
			// kaios: Unknown support
			node: [0, 12]
		}),
		destructuring: rawChecker({
			chrome: 49,
			and_chr: 49,
			edge: 14,
			firefox: 41,
			and_ff: 41,
			// ie: Not supported,
			opera: 36,
			op_mob: 36,
			safari: 8,
			ios_saf: 8,
			samsung: [5, 0],
			android: 49,
			// and_qq: Unknown support
			// baidu: Unknown support
			// and_uc: Unknown support
			// kaios: Unknown support
			node: [6, 0]
		}),
		bigIntLiteral: rawChecker({
			chrome: 67,
			and_chr: 67,
			edge: 79,
			firefox: 68,
			and_ff: 68,
			// ie: Not supported,
			opera: 54,
			op_mob: 48,
			safari: 14,
			ios_saf: 14,
			samsung: [9, 2],
			android: 67,
			// and_qq: Not supported
			// baidu: Not supported
			// and_uc: Not supported
			// kaios: Not supported
			node: [10, 4]
		}),
		// Support syntax `import` and `export` and no limitations and bugs on Node.js
		// Not include `export * as namespace`
		module: rawChecker({
			chrome: 61,
			and_chr: 61,
			edge: 16,
			firefox: 60,
			and_ff: 60,
			// ie: Not supported,
			opera: 48,
			op_mob: 45,
			safari: [10, 1],
			ios_saf: [10, 3],
			samsung: [8, 0],
			android: 61,
			and_qq: [10, 4],
			// baidu: Not supported
			// and_uc: Not supported
			// kaios: Not supported
			// Since Node.js 13.14.0 no warning about usage, but it was added 8.5.0 with some limitations and it was improved in 12.0.0 and 13.2.0
			node: [13, 14]
		}),
		dynamicImport: es6DynamicImport,
		dynamicImportInWorker: es6DynamicImport && !anyNode,
		// browserslist does not have info about globalThis
		// so this is based on mdn-browser-compat-data
		globalThis: rawChecker({
			chrome: 71,
			and_chr: 71,
			edge: 79,
			firefox: 65,
			and_ff: 65,
			// ie: Not supported,
			opera: 58,
			op_mob: 50,
			safari: [12, 1],
			ios_saf: [12, 2],
			samsung: [10, 1],
			android: 71,
			// and_qq: Unknown support
			// baidu: Unknown support
			// and_uc: Unknown support
			// kaios: Unknown support
			node: [12, 0]
		}),
		optionalChaining: rawChecker({
			chrome: 80,
			and_chr: 80,
diff --git a/a.js b/b.js
@@ -488,6 +488,7 @@ const getNormalizedEntryStatic = entry => {
A blob:d4d8ff15cc321a960222905c5f43e1d766109fc7

/**
 * @param {EntryStatic} entry static entry options
 * @returns {EntryStaticNormalized} normalized static entry options
 */
const getNormalizedEntryStatic = entry => {
	if (typeof entry === "string") {
		return {
			main: {
				import: [entry]
			}
		};
	}
	if (Array.isArray(entry)) {
		return {
			main: {
				import: entry
			}
		};
	}
	/** @type {EntryStaticNormalized} */
	const result = {};
	for (const key of Object.keys(entry)) {
		const value = entry[key];
		if (typeof value === "string") {
			result[key] = {
				import: [value]
			};
		} else if (Array.isArray(value)) {
			result[key] = {
				import: value
			};
		} else {
			result[key] = {
				import:
					value.import &&
					(Array.isArray(value.import) ? value.import : [value.import]),
				filename: value.filename,
				layer: value.layer,
				runtime: value.runtime,
				publicPath: value.publicPath,
				chunkLoading: value.chunkLoading,
				asyncChunks: value.asyncChunks,
				wasmLoading: value.wasmLoading,
diff --git a/a.js b/b.js
@@ -7,6 +7,7 @@
A blob:12040a4ee0284d9677edf2adc92b4e1328921f50
	Author Tobias Koppers @sokra
*/

"use strict";

const makeSerializable = require("../util/makeSerializable");
const HarmonyImportDependency = require("./HarmonyImportDependency");

/** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
/** @typedef {import("../Dependency")} Dependency */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext} DependencyTemplateContext */
diff --git a/a.js b/b.js
@@ -28,8 +29,9 @@ makeSerializable(
A blob:12040a4ee0284d9677edf2adc92b4e1328921f50
	get type() {
		return "harmony accept";
	}
}

makeSerializable(
	HarmonyAcceptImportDependency,
	"webpack/lib/dependencies/HarmonyAcceptImportDependency"
);

HarmonyAcceptImportDependency.Template = class HarmonyAcceptImportDependencyTemplate extends (
	HarmonyImportDependency.Template
) {};

module.exports = HarmonyAcceptImportDependency;

diff --git a/a.js b/b.js
@@ -145,7 +145,10 @@ getContent({ runtimeTemplate, runtimeRequirements }) {
A blob:6ad9260e69071aab959aa8ceac94cb037826eba5

	/**
	 * @param {Context} context context
	 * @returns {string|Source} the source code that will be included as initialization code
	 */
	getContent({ runtimeTemplate, runtimeRequirements }) {
		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);

		const unusedPart =
			this.unusedExports.size > 1
				? `/* unused harmony exports ${joinIterableWithComma(
						this.unusedExports
				  )} */\n`
				: this.unusedExports.size > 0
				? `/* unused harmony export ${first(this.unusedExports)} */\n`
				: "";
		const definitions = [];
		for (const [key, value] of this.exportMap) {
			definitions.push(
				`\n/* harmony export */   ${JSON.stringify(
					key
				)}: ${runtimeTemplate.returningFunction(value)}`
diff --git a/a.js b/b.js
@@ -32,6 +32,7 @@
A blob:cba0f59ebf23e99e67445767e735457b3fb81802
 * @param {any=} exports exports of the evaluated module
 */

/**
 * @typedef {Object} ImportModuleOptions
 * @property {string=} layer the target layer
 * @property {string=} publicPath the target public path
 */

class LoaderPlugin {
	/**
diff --git a/a.js b/b.js
@@ -199,6 +200,7 @@ apply(compiler) {
A blob:cba0f59ebf23e99e67445767e735457b3fb81802
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"LoaderPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					LoaderDependency,
					normalModuleFactory
				);
				compilation.dependencyFactories.set(
					LoaderImportDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.compilation.tap("LoaderPlugin", compilation => {
			const moduleGraph = compilation.moduleGraph;
			NormalModule.getCompilationHooks(compilation).loader.tap(
				"LoaderPlugin",
				loaderContext => {
					/**
					 * @param {string} request the request string to load the module from
					 * @param {LoadModuleCallback} callback callback returning the loaded module or error
					 * @returns {void}
					 */
					loaderContext.loadModule = (request, callback) => {
						const dep = new LoaderDependency(request);
						dep.loc = {
							name: request
						};
						const factory = compilation.dependencyFactories.get(
							/** @type {DepConstructor} */ (dep.constructor)
						);
						if (factory === undefined) {
							return callback(
								new Error(
									`No module factory available for dependency type: ${dep.constructor.name}`
								)
							);
						}
						compilation.buildQueue.increaseParallelism();
						compilation.handleModuleCreation(
							{
								factory,
								dependencies: [dep],
								originModule: loaderContext._module,
								context: loaderContext.context,
								recursive: false
							},
							err => {
								compilation.buildQueue.decreaseParallelism();
								if (err) {
									return callback(err);
								}
								const referencedModule = moduleGraph.getModule(dep);
								if (!referencedModule) {
									return callback(new Error("Cannot load the module"));
								}
								if (referencedModule.getNumberOfErrors() > 0) {
									return callback(
										new Error("The loaded module contains errors")
									);
								}
								const moduleSource = referencedModule.originalSource();
								if (!moduleSource) {
									return callback(
										new Error(
											"The module created for a LoaderDependency must have an original source"
										)
									);
								}
								let source, map;
								if (moduleSource.sourceAndMap) {
									const sourceAndMap = moduleSource.sourceAndMap();
									map = sourceAndMap.map;
									source = sourceAndMap.source;
								} else {
									map = moduleSource.map();
									source = moduleSource.source();
								}
								const fileDependencies = new LazySet();
								const contextDependencies = new LazySet();
								const missingDependencies = new LazySet();
								const buildDependencies = new LazySet();
								referencedModule.addCacheDependencies(
									fileDependencies,
									contextDependencies,
									missingDependencies,
									buildDependencies
								);

								for (const d of fileDependencies) {
									loaderContext.addDependency(d);
								}
								for (const d of contextDependencies) {
									loaderContext.addContextDependency(d);
								}
								for (const d of missingDependencies) {
									loaderContext.addMissingDependency(d);
								}
								for (const d of buildDependencies) {
									loaderContext.addBuildDependency(d);
								}
								return callback(null, source, map, referencedModule);
							}
						);
					};

					/**
					 * @param {string} request the request string to load the module from
					 * @param {ImportModuleOptions=} options options
					 * @param {ImportModuleCallback=} callback callback returning the exports
					 * @returns {void}
					 */
					const importModule = (request, options, callback) => {
						const dep = new LoaderImportDependency(request);
						dep.loc = {
							name: request
						};
						const factory = compilation.dependencyFactories.get(
							/** @type {DepConstructor} */ (dep.constructor)
						);
						if (factory === undefined) {
							return callback(
								new Error(
									`No module factory available for dependency type: ${dep.constructor.name}`
								)
							);
						}
						compilation.buildQueue.increaseParallelism();
						compilation.handleModuleCreation(
							{
								factory,
								dependencies: [dep],
								originModule: loaderContext._module,
								contextInfo: {
									issuerLayer: options.layer
								},
								context: loaderContext.context,
								connectOrigin: false
							},
							err => {
								compilation.buildQueue.decreaseParallelism();
								if (err) {
									return callback(err);
								}
								const referencedModule = moduleGraph.getModule(dep);
								if (!referencedModule) {
									return callback(new Error("Cannot load the module"));
								}
								compilation.executeModule(
									referencedModule,
									{
										entryOptions: {
											publicPath: options.publicPath
										}
									},
									(err, result) => {
diff --git a/a.js b/b.js
@@ -55,15 +55,35 @@ constructor(runtimeRequirements) {
A blob:9cb54029b2a38b564b414fb35d0d22daab25e2c0
			compilationHooksMap.set(compilation, hooks);
		}
		return hooks;
	}

	constructor(runtimeRequirements) {
		super("import chunk loading", RuntimeModule.STAGE_ATTACH);
		this._runtimeRequirements = runtimeRequirements;
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { compilation, chunk } = this;
		const {
			runtimeTemplate,
			chunkGraph,
			outputOptions: { importFunctionName, importMetaName }
		} = compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withExternalInstallChunk = this._runtimeRequirements.has(
diff --git a/a.js b/b.js
@@ -102,11 +122,7 @@ generate() {
A blob:9cb54029b2a38b564b414fb35d0d22daab25e2c0
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { compilation, chunk } = this;
		const {
			runtimeTemplate,
			chunkGraph,
			outputOptions: { importFunctionName, importMetaName }
		} = compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withExternalInstallChunk = this._runtimeRequirements.has(
			RuntimeGlobals.externalInstallChunk
		);
		const withLoading = this._runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withOnChunkLoad = this._runtimeRequirements.has(
			RuntimeGlobals.onChunksLoaded
		);
		const withHmr = this._runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs);
		const hasJsMatcher = compileBooleanMatcher(conditionMap);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const outputName = this.compilation.getPath(
			getChunkFilenameTemplate(chunk, this.compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			}
		);
		const rootOutputDir = getUndoPath(
			outputName,
			this.compilation.outputOptions.path,
			true
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_module`
			: undefined;

		return Template.asString([
			withBaseURI
				? Template.asString([
						`${RuntimeGlobals.baseURI} = new URL(${JSON.stringify(
							rootOutputDir
						)}, ${importMetaName}.url);`
				  ])
				: "// no baseURI",
			"",
			"// object to store loaded and loading chunks",
			"// undefined = chunk not loaded, null = chunk preloaded/prefetched",
diff --git a/a.js b/b.js
@@ -15,12 +15,33 @@
A blob:36dd485088f602187b8493550164f45710cd0f25
	chunkHasJs,
	getChunkFilenameTemplate
} = require("../javascript/JavascriptModulesPlugin");
const { getInitialChunkIds } = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath } = require("../util/identifier");

class ReadFileChunkLoadingRuntimeModule extends RuntimeModule {
	constructor(runtimeRequirements) {
		super("readFile chunk loading", RuntimeModule.STAGE_ATTACH);
		this.runtimeRequirements = runtimeRequirements;
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
diff --git a/a.js b/b.js
@@ -67,13 +88,7 @@ generate() {
A blob:36dd485088f602187b8493550164f45710cd0f25
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { chunkGraph, chunk } = this;
		const { runtimeTemplate } = this.compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withExternalInstallChunk = this.runtimeRequirements.has(
			RuntimeGlobals.externalInstallChunk
		);
		const withOnChunkLoad = this.runtimeRequirements.has(
			RuntimeGlobals.onChunksLoaded
		);
		const withLoading = this.runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withHmr = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const withHmrManifest = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadManifest
		);
		const conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs);
		const hasJsMatcher = compileBooleanMatcher(conditionMap);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const outputName = this.compilation.getPath(
			getChunkFilenameTemplate(chunk, this.compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			}
		);
		const rootOutputDir = getUndoPath(
			outputName,
			this.compilation.outputOptions.path,
			false
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_readFileVm`
			: undefined;

		return Template.asString([
			withBaseURI
				? Template.asString([
						`${RuntimeGlobals.baseURI} = require("url").pathToFileURL(${
							rootOutputDir
								? `__dirname + ${JSON.stringify("/" + rootOutputDir)}`
								: "__filename"
						});`
				  ])
				: "// no baseURI",
			"",
			"// object to store loaded chunks",
			'// "0" means "already loaded", Promise means loading',
diff --git a/a.js b/b.js
@@ -15,12 +15,33 @@
A blob:de19305de95a789a828c6e61dbf2855a9221d76d
	chunkHasJs,
	getChunkFilenameTemplate
} = require("../javascript/JavascriptModulesPlugin");
const { getInitialChunkIds } = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath } = require("../util/identifier");

class RequireChunkLoadingRuntimeModule extends RuntimeModule {
	constructor(runtimeRequirements) {
		super("require chunk loading", RuntimeModule.STAGE_ATTACH);
		this.runtimeRequirements = runtimeRequirements;
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
diff --git a/a.js b/b.js
@@ -67,13 +88,7 @@ generate() {
A blob:de19305de95a789a828c6e61dbf2855a9221d76d
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { chunkGraph, chunk } = this;
		const { runtimeTemplate } = this.compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withExternalInstallChunk = this.runtimeRequirements.has(
			RuntimeGlobals.externalInstallChunk
		);
		const withOnChunkLoad = this.runtimeRequirements.has(
			RuntimeGlobals.onChunksLoaded
		);
		const withLoading = this.runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withHmr = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const withHmrManifest = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadManifest
		);
		const conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs);
		const hasJsMatcher = compileBooleanMatcher(conditionMap);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const outputName = this.compilation.getPath(
			getChunkFilenameTemplate(chunk, this.compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			}
		);
		const rootOutputDir = getUndoPath(
			outputName,
			this.compilation.outputOptions.path,
			true
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_require`
			: undefined;

		return Template.asString([
			withBaseURI
				? Template.asString([
						`${RuntimeGlobals.baseURI} = require("url").pathToFileURL(${
							rootOutputDir !== "./"
								? `__dirname + ${JSON.stringify("/" + rootOutputDir)}`
								: "__filename"
						});`
				  ])
				: "// no baseURI",
			"",
			"// object to store loaded chunks",
			'// "1" means "loaded", otherwise not loaded yet',
diff --git a/a.js b/b.js
@@ -5,6 +5,7 @@
A blob:a742ebcf92db46c04b304f36d0356b0298055302
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { extname, basename } = require("path");
const { URL } = require("url");
const { createGunzip, createBrotliDecompress, createInflate } = require("zlib");
const NormalModule = require("../NormalModule");
diff --git a/a.js b/b.js
@@ -19,6 +20,44 @@
A blob:a742ebcf92db46c04b304f36d0356b0298055302
const memoize = require("../util/memoize");

/** @typedef {import("../../declarations/plugins/schemes/HttpUriPlugin").HttpUriPluginOptions} HttpUriPluginOptions */
/** @typedef {import("../Compiler")} Compiler */

const getHttp = memoize(() => require("http"));
const getHttps = memoize(() => require("https"));

/** @type {(() => void)[] | undefined} */
let inProgressWrite = undefined;

diff --git a/a.js b/b.js
@@ -274,6 +313,7 @@ constructor(options) {
A blob:a742ebcf92db46c04b304f36d0356b0298055302

class HttpUriPlugin {
	/**
	 * @param {HttpUriPluginOptions} options options
	 */
	constructor(options) {
		validate(options);
		this._lockfileLocation = options.lockfileLocation;
		this._cacheLocation = options.cacheLocation;
		this._upgrade = options.upgrade;
		this._frozen = options.frozen;
		this._allowedUris = options.allowedUris;
	}

	/**
	 * Apply the plugin
diff --git a/a.js b/b.js
@@ -282,15 +322,16 @@ constructor(options) {
A blob:a742ebcf92db46c04b304f36d0356b0298055302

class HttpUriPlugin {
	/**
	 * @param {HttpUriPluginOptions} options options
	 */
	constructor(options) {
		validate(options);
		this._lockfileLocation = options.lockfileLocation;
		this._cacheLocation = options.cacheLocation;
		this._upgrade = options.upgrade;
		this._frozen = options.frozen;
		this._allowedUris = options.allowedUris;
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const schemes = [
			{
				scheme: "http",
				fetch: (url, options, callback) => getHttp().get(url, options, callback)
			},
			{
				scheme: "https",
				fetch: (url, options, callback) =>
					getHttps().get(url, options, callback)
			}
		];
		let lockfileCache;
		compiler.hooks.compilation.tap(
diff --git a/a.js b/b.js
@@ -126,6 +126,8 @@
A blob:9264c1c00c86658123e3f5ad447505d45a57f2d0
		require("../dependencies/ModuleHotAcceptDependency"),
	"dependencies/ModuleHotDeclineDependency": () =>
		require("../dependencies/ModuleHotDeclineDependency"),
	"dependencies/ImportMetaHotAcceptDependency": () =>
		require("../dependencies/ImportMetaHotAcceptDependency"),
	"dependencies/ImportMetaHotDeclineDependency": () =>
		require("../dependencies/ImportMetaHotDeclineDependency"),
	"dependencies/ProvidedDependency": () =>
		require("../dependencies/ProvidedDependency"),
	"dependencies/PureExpressionDependency": () =>
		require("../dependencies/PureExpressionDependency"),
diff --git a/a.js b/b.js
@@ -51,6 +51,20 @@ constructor(runtimeRequirements) {
A blob:40434da2f9a1f30cf6560b4831e88373bac1d742
			compilationHooksMap.set(compilation, hooks);
		}
		return hooks;
	}

	constructor(runtimeRequirements) {
		super("jsonp chunk loading", RuntimeModule.STAGE_ATTACH);
		this._runtimeRequirements = runtimeRequirements;
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
diff --git a/a.js b/b.js
@@ -103,11 +117,7 @@ generate() {
A blob:40434da2f9a1f30cf6560b4831e88373bac1d742
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { chunkGraph, compilation, chunk } = this;
		const {
			runtimeTemplate,
			outputOptions: {
				chunkLoadingGlobal,
				hotUpdateGlobal,
				crossOriginLoading,
				scriptType
			}
		} = compilation;
		const globalObject = runtimeTemplate.globalObject;
		const { linkPreload, linkPrefetch } =
			JsonpChunkLoadingRuntimeModule.getCompilationHooks(compilation);
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withLoading = this._runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withCallback = this._runtimeRequirements.has(
			RuntimeGlobals.chunkCallback
		);
		const withOnChunkLoad = this._runtimeRequirements.has(
			RuntimeGlobals.onChunksLoaded
		);
		const withHmr = this._runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const withHmrManifest = this._runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadManifest
		);
		const withPrefetch = this._runtimeRequirements.has(
			RuntimeGlobals.prefetchChunkHandlers
		);
		const withPreload = this._runtimeRequirements.has(
			RuntimeGlobals.preloadChunkHandlers
		);
		const chunkLoadingGlobalExpr = `${globalObject}[${JSON.stringify(
			chunkLoadingGlobal
		)}]`;
		const conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs);
		const hasJsMatcher = compileBooleanMatcher(conditionMap);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_jsonp`
			: undefined;

		return Template.asString([
			withBaseURI
				? Template.asString([
						`${RuntimeGlobals.baseURI} = document.baseURI || self.location.href;`
				  ])
				: "// no baseURI",
			"",
			"// object to store loaded and loading chunks",
			"// undefined = chunk not loaded, null = chunk preloaded/prefetched",
			"// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded",
diff --git a/a.js b/b.js
@@ -15,6 +15,8 @@
A blob:0f27d34081dfa9b2225e23d391a64c5427e7b160
	getChunkFilenameTemplate,
	chunkHasJs
} = require("../javascript/JavascriptModulesPlugin");
const { getInitialChunkIds } = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath } = require("../util/identifier");

class ImportScriptsChunkLoadingRuntimeModule extends RuntimeModule {
	constructor(runtimeRequirements, withCreateScriptUrl) {
		super("importScripts chunk loading", RuntimeModule.STAGE_ATTACH);
		this.runtimeRequirements = runtimeRequirements;
diff --git a/a.js b/b.js
@@ -22,6 +24,33 @@ constructor(runtimeRequirements, withCreateScriptUrl) {
A blob:0f27d34081dfa9b2225e23d391a64c5427e7b160
const { getInitialChunkIds } = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath } = require("../util/identifier");

class ImportScriptsChunkLoadingRuntimeModule extends RuntimeModule {
	constructor(runtimeRequirements, withCreateScriptUrl) {
		super("importScripts chunk loading", RuntimeModule.STAGE_ATTACH);
		this.runtimeRequirements = runtimeRequirements;
		this._withCreateScriptUrl = withCreateScriptUrl;
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
diff --git a/a.js b/b.js
@@ -55,31 +84,12 @@ generate() {
A blob:0f27d34081dfa9b2225e23d391a64c5427e7b160
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const {
			chunk,
			chunkGraph,
			compilation: {
				runtimeTemplate,
				outputOptions: { chunkLoadingGlobal, hotUpdateGlobal }
			},
			_withCreateScriptUrl: withCreateScriptUrl
		} = this;
		const globalObject = runtimeTemplate.globalObject;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withLoading = this.runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withHmr = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const withHmrManifest = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadManifest
		);
		const chunkLoadingGlobalExpr = `${globalObject}[${JSON.stringify(
			chunkLoadingGlobal
		)}]`;
		const hasJsMatcher = compileBooleanMatcher(
			chunkGraph.getChunkConditionMap(chunk, chunkHasJs)
		);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const outputName = this.compilation.getPath(
			getChunkFilenameTemplate(chunk, this.compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			}
		);
		const rootOutputDir = getUndoPath(
			outputName,
			this.compilation.outputOptions.path,
			false
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_importScripts`
			: undefined;

		return Template.asString([
			withBaseURI
				? Template.asString([
						`${RuntimeGlobals.baseURI} = self.location + ${JSON.stringify(
							rootOutputDir ? "/../" + rootOutputDir : ""
						)};`
				  ])
				: "// no baseURI",
			"",
			"// object to store loaded chunks",
			'// "1" means "already loaded"',
			`var installedChunks = ${
diff --git a/a.js b/b.js
@@ -3,4 +3,4 @@
A blob:2fbe20fd7e608caddd009108f3f2ccdda7e5ada5
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
const e=/^(?:[A-Za-z]:[\\/]|\\\\|\/)/;module.exports=we,module.exports.default=we;const t={amd:{$ref:"#/definitions/Amd"},bail:{$ref:"#/definitions/Bail"},cache:{$ref:"#/definitions/CacheOptions"},context:{$ref:"#/definitions/Context"},dependencies:{$ref:"#/definitions/Dependencies"},devServer:{$ref:"#/definitions/DevServer"},devtool:{$ref:"#/definitions/DevTool"},entry:{$ref:"#/definitions/Entry"},experiments:{$ref:"#/definitions/Experiments"},externals:{$ref:"#/definitions/Externals"},externalsPresets:{$ref:"#/definitions/ExternalsPresets"},externalsType:{$ref:"#/definitions/ExternalsType"},ignoreWarnings:{$ref:"#/definitions/IgnoreWarnings"},infrastructureLogging:{$ref:"#/definitions/InfrastructureLogging"},loader:{$ref:"#/definitions/Loader"},mode:{$ref:"#/definitions/Mode"},module:{$ref:"#/definitions/ModuleOptions"},name:{$ref:"#/definitions/Name"},node:{$ref:"#/definitions/Node"},optimization:{$ref:"#/definitions/Optimization"},output:{$ref:"#/definitions/Output"},parallelism:{$ref:"#/definitions/Parallelism"},performance:{$ref:"#/definitions/Performance"},plugins:{$ref:"#/definitions/Plugins"},profile:{$ref:"#/definitions/Profile"},recordsInputPath:{$ref:"#/definitions/RecordsInputPath"},recordsOutputPath:{$ref:"#/definitions/RecordsOutputPath"},recordsPath:{$ref:"#/definitions/RecordsPath"},resolve:{$ref:"#/definitions/Resolve"},resolveLoader:{$ref:"#/definitions/ResolveLoader"},snapshot:{$ref:"#/definitions/SnapshotOptions"},stats:{$ref:"#/definitions/StatsValue"},target:{$ref:"#/definitions/Target"},watch:{$ref:"#/definitions/Watch"},watchOptions:{$ref:"#/definitions/WatchOptions"}},n=Object.prototype.hasOwnProperty,r={allowCollectingMemory:{type:"boolean"},buildDependencies:{type:"object",additionalProperties:{type:"array",items:{type:"string",minLength:1}}},cacheDirectory:{type:"string",absolutePath:!0},cacheLocation:{type:"string",absolutePath:!0},compression:{enum:[!1,"gzip","brotli"]},hashAlgorithm:{type:"string"},idleTimeout:{type:"number",minimum:0},idleTimeoutAfterLargeChanges:{type:"number",minimum:0},idleTimeoutForInitialStore:{type:"number",minimum:0},immutablePaths:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},managedPaths:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},maxAge:{type:"number",minimum:0},maxMemoryGenerations:{type:"number",minimum:0},memoryCacheUnaffected:{type:"boolean"},name:{type:"string"},profile:{type:"boolean"},store:{enum:["pack"]},type:{enum:["filesystem"]},version:{type:"string"}};function s(t,{instancePath:o="",parentData:a,parentDataProperty:i,rootData:l=t}={}){let p=null,u=0;const f=u;let c=!1;const m=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var y=m===u;if(c=c||y,!c){const s=u;if(u==u)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.type&&(e="type")){const t={params:{missingProperty:e}};null===p?p=[t]:p.push(t),u++}else{const e=u;for(const e in t)if("cacheUnaffected"!==e&&"maxGenerations"!==e&&"type"!==e){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(e===u){if(void 0!==t.cacheUnaffected){const e=u;if("boolean"!=typeof t.cacheUnaffected){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}var h=e===u}else h=!0;if(h){if(void 0!==t.maxGenerations){let e=t.maxGenerations;const n=u;if(u===n)if("number"==typeof e){if(e<1||isNaN(e)){const e={params:{comparison:">=",limit:1}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}h=n===u}else h=!0;if(h)if(void 0!==t.type){const e=u;if("memory"!==t.type){const e={params:{}};null===p?p=[e]:p.push(e),u++}h=e===u}else h=!0}}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}if(y=s===u,c=c||y,!c){const s=u;if(u==u)if(t&&"object"==typeof t&&!Array.isArray(t)){let s;if(void 0===t.type&&(s="type")){const e={params:{missingProperty:s}};null===p?p=[e]:p.push(e),u++}else{const s=u;for(const e in t)if(!n.call(r,e)){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(s===u){if(void 0!==t.allowCollectingMemory){const e=u;if("boolean"!=typeof t.allowCollectingMemory){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}var d=e===u}else d=!0;if(d){if(void 0!==t.buildDependencies){let e=t.buildDependencies;const n=u;if(u===n)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=u;if(u===r)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.cacheDirectory){let n=t.cacheDirectory;const r=u;if(u===r)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.cacheLocation){let n=t.cacheLocation;const r=u;if(u===r)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.compression){let e=t.compression;const n=u;if(!1!==e&&"gzip"!==e&&"brotli"!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.hashAlgorithm){const e=u;if("string"!=typeof t.hashAlgorithm){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.idleTimeout){let e=t.idleTimeout;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.idleTimeoutAfterLargeChanges){let e=t.idleTimeoutAfterLargeChanges;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.idleTimeoutForInitialStore){let e=t.idleTimeoutForInitialStore;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.immutablePaths){let n=t.immutablePaths;const r=u;if(u===r)if(Array.isArray(n)){const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var g=i===u;if(a=a||g,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=n===u,a=a||g}if(a)u=o,null!==p&&(o?p.length=o:p=null);else{const e={params:{}};null===p?p=[e]:p.push(e),u++}if(s!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.managedPaths){let n=t.managedPaths;const r=u;if(u===r)if(Array.isArray(n)){const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var b=i===u;if(a=a||b,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}b=n===u,a=a||b}if(a)u=o,null!==p&&(o?p.length=o:p=null);else{const e={params:{}};null===p?p=[e]:p.push(e),u++}if(s!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.maxAge){let e=t.maxAge;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.maxMemoryGenerations){let e=t.maxMemoryGenerations;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.memoryCacheUnaffected){const e=u;if("boolean"!=typeof t.memoryCacheUnaffected){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.name){const e=u;if("string"!=typeof t.name){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.profile){const e=u;if("boolean"!=typeof t.profile){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.store){const e=u;if("pack"!==t.store){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.type){const e=u;if("filesystem"!==t.type){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d)if(void 0!==t.version){const e=u;if("string"!=typeof t.version){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0}}}}}}}}}}}}}}}}}}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}y=s===u,c=c||y}}if(!c){const e={params:{}};return null===p?p=[e]:p.push(e),u++,s.errors=p,!1}return u=f,null!==p&&(f?p.length=f:p=null),s.errors=p,0===u}function o(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:a=e}={}){let i=null,l=0;const p=l;let u=!1;const f=l;if(!0!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=f===l;if(u=u||c,!u){const o=l;s(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:a})||(i=null===i?s.errors:i.concat(s.errors),l=i.length),c=o===l,u=u||c}if(!u){const e={params:{}};return null===i?i=[e]:i.push(e),l++,o.errors=i,!1}return l=p,null!==i&&(p?i.length=p:i=null),o.errors=i,0===l}const a={asyncChunks:{type:"boolean"},chunkLoading:{$ref:"#/definitions/ChunkLoading"},dependOn:{anyOf:[{type:"array",items:{type:"string",minLength:1},minItems:1,uniqueItems:!0},{type:"string",minLength:1}]},filename:{$ref:"#/definitions/EntryFilename"},import:{$ref:"#/definitions/EntryItem"},layer:{$ref:"#/definitions/Layer"},library:{$ref:"#/definitions/LibraryOptions"},publicPath:{$ref:"#/definitions/PublicPath"},runtime:{$ref:"#/definitions/EntryRuntime"},wasmLoading:{$ref:"#/definitions/WasmLoading"}};function i(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const l=a;let p=!1;const u=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=u===a;if(p=p||f,!p){const t=a,n=a;let r=!1;const s=a;if("jsonp"!==e&&"import-scripts"!==e&&"require"!==e&&"async-node"!==e&&"import"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var c=s===a;if(r=r||c,!r){const t=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a,r=r||c}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,p=p||f}if(!p){const e={params:{}};return null===o?o=[e]:o.push(e),a++,i.errors=o,!1}return a=l,null!==o&&(l?o.length=l:o=null),i.errors=o,0===a}function l(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const p=i;let u=!1,f=null;const c=i,m=i;let y=!1;const h=i;if(i===h)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var d=h===i;if(y=y||d,!y){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}d=e===i,y=y||d}if(y)i=m,null!==a&&(m?a.length=m:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(c===i&&(u=!0,f=0),!u){const e={params:{passingSchemas:f}};return null===a?a=[e]:a.push(e),i++,l.errors=a,!1}return i=p,null!==a&&(p?a.length=p:a=null),l.errors=a,0===i}function p(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const u=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=u===a;if(l=l||f,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("amd"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"root"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.amd){const t=a;if("string"!=typeof e.amd){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var c=t===a}else c=!0;if(c){if(void 0!==e.commonjs){const t=a;if("string"!=typeof e.commonjs){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0;if(c){if(void 0!==e.commonjs2){const t=a;if("string"!=typeof e.commonjs2){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0;if(c)if(void 0!==e.root){const t=a;if("string"!=typeof e.root){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,p.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),p.errors=o,0===a}function u(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a;if(a===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var f=p===a;if(l=l||f,!l){const t=a;if(a===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=t===a,l=l||f,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("amd"!==t&&"commonjs"!==t&&"root"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.amd){let t=e.amd;const n=a;if(a===n)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var c=n===a}else c=!0;if(c){if(void 0!==e.commonjs){let t=e.commonjs;const n=a;if(a===n)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=n===a}else c=!0;if(c)if(void 0!==e.root){let t=e.root;const n=a,r=a;let s=!1;const i=a;if(a===i)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var m=i===a;if(s=s||m,!s){const e=a;if(a===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}m=e===a,s=s||m}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}c=n===a}else c=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,u.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),u.errors=o,0===a}function f(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return f.errors=[{params:{type:"object"}}],!1;{let n;if(void 0===e.type&&(n="type"))return f.errors=[{params:{missingProperty:n}}],!1;{const n=a;for(const t in e)if("auxiliaryComment"!==t&&"export"!==t&&"name"!==t&&"type"!==t&&"umdNamedDefine"!==t)return f.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.auxiliaryComment){const n=a;p(e.auxiliaryComment,{instancePath:t+"/auxiliaryComment",parentData:e,parentDataProperty:"auxiliaryComment",rootData:s})||(o=null===o?p.errors:o.concat(p.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e.export){let t=e.export;const n=a,r=a;let s=!1;const p=a;if(a===p)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var l=p===a;if(s=s||l,!s){const e=a;if(a===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}l=e===a,s=s||l}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,f.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i){if(void 0!==e.name){const n=a;u(e.name,{instancePath:t+"/name",parentData:e,parentDataProperty:"name",rootData:s})||(o=null===o?u.errors:o.concat(u.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e.type){let t=e.type;const n=a,r=a;let s=!1;const l=a;if("var"!==t&&"module"!==t&&"assign"!==t&&"assign-properties"!==t&&"this"!==t&&"window"!==t&&"self"!==t&&"global"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"commonjs-module"!==t&&"commonjs-static"!==t&&"amd"!==t&&"amd-require"!==t&&"umd"!==t&&"umd2"!==t&&"jsonp"!==t&&"system"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var c=l===a;if(s=s||c,!s){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=e===a,s=s||c}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,f.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.umdNamedDefine){const t=a;if("boolean"!=typeof e.umdNamedDefine)return f.errors=[{params:{type:"boolean"}}],!1;i=t===a}else i=!0}}}}}}}return f.errors=o,0===a}function c(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if("auto"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a,n=a;let r=!1;const s=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=s===a;if(r=r||f,!r){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,r=r||f}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,c.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),c.errors=o,0===a}function m(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a,n=a;let r=!1;const s=a;if("fetch-streaming"!==e&&"fetch"!==e&&"async-node"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=s===a;if(r=r||f,!r){const t=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}f=t===a,r=r||f}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,m.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),m.errors=o,0===a}function y(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let p=null,u=0;if(0===u){if(!e||"object"!=typeof e||Array.isArray(e))return y.errors=[{params:{type:"object"}}],!1;{let r;if(void 0===e.import&&(r="import"))return y.errors=[{params:{missingProperty:r}}],!1;{const r=u;for(const t in e)if(!n.call(a,t))return y.errors=[{params:{additionalProperty:t}}],!1;if(r===u){if(void 0!==e.asyncChunks){const t=u;if("boolean"!=typeof e.asyncChunks)return y.errors=[{params:{type:"boolean"}}],!1;var h=t===u}else h=!0;if(h){if(void 0!==e.chunkLoading){const n=u;i(e.chunkLoading,{instancePath:t+"/chunkLoading",parentData:e,parentDataProperty:"chunkLoading",rootData:o})||(p=null===p?i.errors:p.concat(i.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.dependOn){let t=e.dependOn;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t))if(t.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{var d=!0;const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(!(d=r===u))break}if(d){let e,n=t.length;if(n>1){const r={};for(;n--;){let s=t[n];if("string"==typeof s){if("number"==typeof r[s]){e=r[s];const t={params:{i:n,j:e}};null===p?p=[t]:p.push(t),u++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var g=o===u;if(s=s||g,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=e===u,s=s||g}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.filename){const n=u;l(e.filename,{instancePath:t+"/filename",parentData:e,parentDataProperty:"filename",rootData:o})||(p=null===p?l.errors:p.concat(l.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.import){let t=e.import;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t))if(t.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{var b=!0;const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(!(b=r===u))break}if(b){let e,n=t.length;if(n>1){const r={};for(;n--;){let s=t[n];if("string"==typeof s){if("number"==typeof r[s]){e=r[s];const t={params:{i:n,j:e}};null===p?p=[t]:p.push(t),u++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var v=o===u;if(s=s||v,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}v=e===u,s=s||v}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.layer){let t=e.layer;const n=u,r=u;let s=!1;const o=u;if(null!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var D=o===u;if(s=s||D,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}D=e===u,s=s||D}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.library){const n=u;f(e.library,{instancePath:t+"/library",parentData:e,parentDataProperty:"library",rootData:o})||(p=null===p?f.errors:p.concat(f.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.publicPath){const n=u;c(e.publicPath,{instancePath:t+"/publicPath",parentData:e,parentDataProperty:"publicPath",rootData:o})||(p=null===p?c.errors:p.concat(c.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.runtime){let t=e.runtime;const n=u,r=u;let s=!1;const o=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var P=o===u;if(s=s||P,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}P=e===u,s=s||P}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h)if(void 0!==e.wasmLoading){const n=u;m(e.wasmLoading,{instancePath:t+"/wasmLoading",parentData:e,parentDataProperty:"wasmLoading",rootData:o})||(p=null===p?m.errors:p.concat(m.errors),u=p.length),h=n===u}else h=!0}}}}}}}}}}}}return y.errors=p,0===u}function h(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return h.errors=[{params:{type:"object"}}],!1;for(const n in e){let r=e[n];const u=a,f=a;let c=!1;const m=a,d=a;let g=!1;const b=a;if(a===b)if(Array.isArray(r))if(r.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{var i=!0;const e=r.length;for(let t=0;t<e;t++){let e=r[t];const n=a;if(a===n)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(!(i=n===a))break}if(i){let e,t=r.length;if(t>1){const n={};for(;t--;){let s=r[t];if("string"==typeof s){if("number"==typeof n[s]){e=n[s];const r={params:{i:t,j:e}};null===o?o=[r]:o.push(r),a++;break}n[s]=t}}}}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var l=b===a;if(g=g||l,!g){const e=a;if(a===e)if("string"==typeof r){if(r.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}l=e===a,g=g||l}if(g)a=d,null!==o&&(d?o.length=d:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}var p=m===a;if(c=c||p,!c){const i=a;y(r,{instancePath:t+"/"+n.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:n,rootData:s})||(o=null===o?y.errors:o.concat(y.errors),a=o.length),p=i===a,c=c||p}if(!c){const e={params:{}};return null===o?o=[e]:o.push(e),a++,h.errors=o,!1}if(a=f,null!==o&&(f?o.length=f:o=null),u!==a)break}}return h.errors=o,0===a}function d(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a,f=a;let c=!1;const m=a;if(a===m)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{var y=!0;const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a;if(a===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(!(y=r===a))break}if(y){let t,n=e.length;if(n>1){const r={};for(;n--;){let s=e[n];if("string"==typeof s){if("number"==typeof r[s]){t=r[s];const e={params:{i:n,j:t}};null===o?o=[e]:o.push(e),a++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var h=m===a;if(c=c||h,!c){const t=a;if(a===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}h=t===a,c=c||h}if(c)a=f,null!==o&&(f?o.length=f:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,d.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),d.errors=o,0===a}function g(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;h(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?h.errors:o.concat(h.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;d(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?d.errors:o.concat(d.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,g.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),g.errors=o,0===a}function b(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;g(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?g.errors:o.concat(g.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,b.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),b.errors=o,0===a}const v={asyncWebAssembly:{type:"boolean"},backCompat:{type:"boolean"},buildHttp:{anyOf:[{$ref:"#/definitions/HttpUriAllowedUris"},{$ref:"#/definitions/HttpUriOptions"}]},cacheUnaffected:{type:"boolean"},css:{anyOf:[{type:"boolean"},{$ref:"#/definitions/CssExperimentOptions"}]},futureDefaults:{type:"boolean"},layers:{type:"boolean"},lazyCompilation:{anyOf:[{type:"boolean"},{$ref:"#/definitions/LazyCompilationOptions"}]},outputModule:{type:"boolean"},syncWebAssembly:{type:"boolean"},topLevelAwait:{type:"boolean"}},D=new RegExp("^https?://","u");function P(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(a==a)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let i=!1;const l=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=l===a;if(i=i||f,!i){const e=a;if(a===e)if("string"==typeof t){if(!D.test(t)){const e={params:{pattern:"^https?://"}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=e===a,i=i||f}}if(i)a=s,null!==o&&(s?o.length=s:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}if(u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,P.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),P.errors=o,0===a}function A(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return A.errors=[{params:{type:"object"}}],!1;{let n;if(void 0===t.allowedUris&&(n="allowedUris"))return A.errors=[{params:{missingProperty:n}}],!1;{const n=i;for(const e in t)if("allowedUris"!==e&&"cacheLocation"!==e&&"frozen"!==e&&"lockfileLocation"!==e&&"upgrade"!==e)return A.errors=[{params:{additionalProperty:e}}],!1;if(n===i){if(void 0!==t.allowedUris){let e=t.allowedUris;const n=i;if(i==i){if(!Array.isArray(e))return A.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=i,s=i;let o=!1;const p=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var l=p===i;if(o=o||l,!o){const e=i;if(i===e)if("string"==typeof t){if(!D.test(t)){const e={params:{pattern:"^https?://"}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(l=e===i,o=o||l,!o){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}l=e===i,o=o||l}}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,A.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),r!==i)break}}}var p=n===i}else p=!0;if(p){if(void 0!==t.cacheLocation){let n=t.cacheLocation;const r=i,s=i;let o=!1;const l=i;if(!1!==n){const e={params:{}};null===a?a=[e]:a.push(e),i++}var u=l===i;if(o=o||u,!o){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}u=t===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,A.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),p=r===i}else p=!0;if(p){if(void 0!==t.frozen){const e=i;if("boolean"!=typeof t.frozen)return A.errors=[{params:{type:"boolean"}}],!1;p=e===i}else p=!0;if(p){if(void 0!==t.lockfileLocation){let n=t.lockfileLocation;const r=i;if(i===r){if("string"!=typeof n)return A.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return A.errors=[{params:{}}],!1}p=r===i}else p=!0;if(p)if(void 0!==t.upgrade){const e=i;if("boolean"!=typeof t.upgrade)return A.errors=[{params:{type:"boolean"}}],!1;p=e===i}else p=!0}}}}}}}return A.errors=a,0===i}function x(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return x.errors=[{params:{type:"object"}}],!1;{const t=a;for(const t in e)if("backend"!==t&&"entries"!==t&&"imports"!==t&&"test"!==t)return x.errors=[{params:{additionalProperty:t}}],!1;if(t===a){if(void 0!==e.backend){let t=e.backend;const n=a,r=a;let s=!1;const m=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=m===a;if(s=s||i,!s){const e=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=a;for(const e in t)if("client"!==e&&"listen"!==e&&"protocol"!==e&&"server"!==e){const t={params:{additionalProperty:e}};null===o?o=[t]:o.push(t),a++;break}if(e===a){if(void 0!==t.client){const e=a;if("string"!=typeof t.client){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var l=e===a}else l=!0;if(l){if(void 0!==t.listen){let e=t.listen;const n=a,r=a;let s=!1;const i=a;if("number"!=typeof e){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}var p=i===a;if(s=s||p,!s){const t=a;if(a===t)if(e&&"object"==typeof e&&!Array.isArray(e)){if(void 0!==e.host){const t=a;if("string"!=typeof e.host){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var u=t===a}else u=!0;if(u)if(void 0!==e.port){const t=a;if("number"!=typeof e.port){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}u=t===a}else u=!0}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}if(p=t===a,s=s||p,!s){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}p=t===a,s=s||p}}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0;if(l){if(void 0!==t.protocol){let e=t.protocol;const n=a;if("http"!==e&&"https"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0;if(l)if(void 0!==t.server){let e=t.server;const n=a,r=a;let s=!1;const i=a;if(a===i)if(e&&"object"==typeof e&&!Array.isArray(e));else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var f=i===a;if(s=s||f,!s){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,s=s||f}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}i=e===a,s=s||i}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,x.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var c=n===a}else c=!0;if(c){if(void 0!==e.entries){const t=a;if("boolean"!=typeof e.entries)return x.errors=[{params:{type:"boolean"}}],!1;c=t===a}else c=!0;if(c){if(void 0!==e.imports){const t=a;if("boolean"!=typeof e.imports)return x.errors=[{params:{type:"boolean"}}],!1;c=t===a}else c=!0;if(c)if(void 0!==e.test){let t=e.test;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var m=i===a;if(s=s||m,!s){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(m=e===a,s=s||m,!s){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}m=e===a,s=s||m}}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,x.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),c=n===a}else c=!0}}}}}return x.errors=o,0===a}function k(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return k.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(v,t))return k.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.asyncWebAssembly){const t=i;if("boolean"!=typeof e.asyncWebAssembly)return k.errors=[{params:{type:"boolean"}}],!1;var l=t===i}else l=!0;if(l){if(void 0!==e.backCompat){const t=i;if("boolean"!=typeof e.backCompat)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.buildHttp){let n=e.buildHttp;const r=i,s=i;let u=!1;const f=i;P(n,{instancePath:t+"/buildHttp",parentData:e,parentDataProperty:"buildHttp",rootData:o})||(a=null===a?P.errors:a.concat(P.errors),i=a.length);var p=f===i;if(u=u||p,!u){const r=i;A(n,{instancePath:t+"/buildHttp",parentData:e,parentDataProperty:"buildHttp",rootData:o})||(a=null===a?A.errors:a.concat(A.errors),i=a.length),p=r===i,u=u||p}if(!u){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.cacheUnaffected){const t=i;if("boolean"!=typeof e.cacheUnaffected)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.css){let t=e.css;const n=i,r=i;let s=!1;const o=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var u=o===i;if(s=s||u,!s){const e=i;if(i==i)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=i;for(const e in t)if("exportsOnly"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(e===i&&void 0!==t.exportsOnly&&"boolean"!=typeof t.exportsOnly){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}u=e===i,s=s||u}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.futureDefaults){const t=i;if("boolean"!=typeof e.futureDefaults)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.layers){const t=i;if("boolean"!=typeof e.layers)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.lazyCompilation){let n=e.lazyCompilation;const r=i,s=i;let p=!1;const u=i;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const r=i;x(n,{instancePath:t+"/lazyCompilation",parentData:e,parentDataProperty:"lazyCompilation",rootData:o})||(a=null===a?x.errors:a.concat(x.errors),i=a.length),f=r===i,p=p||f}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.outputModule){const t=i;if("boolean"!=typeof e.outputModule)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.syncWebAssembly){const t=i;if("boolean"!=typeof e.syncWebAssembly)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l)if(void 0!==e.topLevelAwait){const t=i;if("boolean"!=typeof e.topLevelAwait)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0}}}}}}}}}}}}return k.errors=a,0===i}const j={validate:S};function S(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const n=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(u=n===a,l=l||u,!l){const n=a;if(a===n)if(e&&"object"==typeof e&&!Array.isArray(e)){const n=a;for(const t in e)if("byLayer"!==t){let n=e[t];const r=a,s=a;let i=!1;const l=a;if(a===l)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var f=l===a;if(i=i||f,!i){const e=a;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if("string"!=typeof n){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if(!n||"object"!=typeof n||Array.isArray(n)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=e===a,i=i||f}}}if(i)a=s,null!==o&&(s?o.length=s:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}if(n===a&&void 0!==e.byLayer){let n=e.byLayer;const r=a;let i=!1;const l=a;if(a===l)if(n&&"object"==typeof n&&!Array.isArray(n))for(const e in n){const r=a;if(j.validate(n[e],{instancePath:t+"/byLayer/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:s})||(o=null===o?j.validate.errors:o.concat(j.validate.errors),a=o.length),r!==a)break}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var c=l===a;if(i=i||c,!i){const e=a;if(!(n instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}c=e===a,i=i||c}if(i)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}if(u=n===a,l=l||u,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,S.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),S.errors=o,0===a}function C(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e)){const n=e.length;for(let r=0;r<n;r++){const n=a;if(S(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?S.errors:o.concat(S.errors),a=o.length),n!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;S(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?S.errors:o.concat(S.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,C.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),C.errors=o,0===a}function O(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,O.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),O.errors=a,0===i}function F(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return F.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("appendOnly"!==t&&"colors"!==t&&"console"!==t&&"debug"!==t&&"level"!==t&&"stream"!==t)return F.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.appendOnly){const t=a;if("boolean"!=typeof e.appendOnly)return F.errors=[{params:{type:"boolean"}}],!1;var i=t===a}else i=!0;if(i){if(void 0!==e.colors){const t=a;if("boolean"!=typeof e.colors)return F.errors=[{params:{type:"boolean"}}],!1;i=t===a}else i=!0;if(i){if(void 0!==e.debug){let n=e.debug;const r=a,p=a;let u=!1;const f=a;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}var l=f===a;if(u=u||l,!u){const r=a;O(n,{instancePath:t+"/debug",parentData:e,parentDataProperty:"debug",rootData:s})||(o=null===o?O.errors:o.concat(O.errors),a=o.length),l=r===a,u=u||l}if(!u){const e={params:{}};return null===o?o=[e]:o.push(e),a++,F.errors=o,!1}a=p,null!==o&&(p?o.length=p:o=null),i=r===a}else i=!0;if(i)if(void 0!==e.level){let t=e.level;const n=a;if("none"!==t&&"error"!==t&&"warn"!==t&&"info"!==t&&"log"!==t&&"verbose"!==t)return F.errors=[{params:{}}],!1;i=n===a}else i=!0}}}}}return F.errors=o,0===a}const R={defaultRules:{oneOf:[{$ref:"#/definitions/RuleSetRules"}]},exprContextCritical:{type:"boolean"},exprContextRecursive:{type:"boolean"},exprContextRegExp:{anyOf:[{instanceof:"RegExp"},{type:"boolean"}]},exprContextRequest:{type:"string"},generator:{$ref:"#/definitions/GeneratorOptionsByModuleType"},noParse:{$ref:"#/definitions/NoParse"},parser:{$ref:"#/definitions/ParserOptionsByModuleType"},rules:{oneOf:[{$ref:"#/definitions/RuleSetRules"}]},strictExportPresence:{type:"boolean"},strictThisContextOnImports:{type:"boolean"},unknownContextCritical:{type:"boolean"},unknownContextRecursive:{type:"boolean"},unknownContextRegExp:{anyOf:[{instanceof:"RegExp"},{type:"boolean"}]},unknownContextRequest:{type:"string"},unsafeCache:{anyOf:[{type:"boolean"},{instanceof:"Function"}]},wrappedContextCritical:{type:"boolean"},wrappedContextRecursive:{type:"boolean"},wrappedContextRegExp:{instanceof:"RegExp"}},E={assert:{type:"object",additionalProperties:{$ref:"#/definitions/RuleSetConditionOrConditions"}},compiler:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},dependency:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},descriptionData:{type:"object",additionalProperties:{$ref:"#/definitions/RuleSetConditionOrConditions"}},enforce:{enum:["pre","post"]},exclude:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},generator:{type:"object"},include:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},issuer:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},issuerLayer:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},layer:{type:"string"},loader:{oneOf:[{$ref:"#/definitions/RuleSetLoader"}]},mimetype:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},oneOf:{type:"array",items:{oneOf:[{$ref:"#/definitions/RuleSetRule"}]}},options:{oneOf:[{$ref:"#/definitions/RuleSetLoaderOptions"}]},parser:{type:"object",additionalProperties:!0},realResource:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},resolve:{type:"object",oneOf:[{$ref:"#/definitions/ResolveOptions"}]},resource:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},resourceFragment:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},resourceQuery:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},rules:{type:"array",items:{oneOf:[{$ref:"#/definitions/RuleSetRule"}]}},scheme:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},sideEffects:{type:"boolean"},test:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},type:{type:"string"},use:{oneOf:[{$ref:"#/definitions/RuleSetUse"}]}},$={validate:w};function z(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return z.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if($.validate(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?$.validate.errors:o.concat($.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,z.errors=o,!1}if(a=i,null!==o&&(i?o.length=i:o=null),n!==a)break}}}return z.errors=o,0===a}function L(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return L.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("and"!==t&&"not"!==t&&"or"!==t)return L.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.and){const n=a,r=a;let l=!1,p=null;const u=a;if(z(e.and,{instancePath:t+"/and",parentData:e,parentDataProperty:"and",rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var i=n===a}else i=!0;if(i){if(void 0!==e.not){const n=a,r=a;let l=!1,p=null;const u=a;if($.validate(e.not,{instancePath:t+"/not",parentData:e,parentDataProperty:"not",rootData:s})||(o=null===o?$.validate.errors:o.concat($.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.or){const n=a,r=a;let l=!1,p=null;const u=a;if(z(e.or,{instancePath:t+"/or",parentData:e,parentDataProperty:"or",rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0}}}}return L.errors=o,0===a}function w(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;if(L(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?L.errors:o.concat(L.errors),a=o.length),u=i===a,l=l||u,!l){const i=a;z(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u=i===a,l=l||u}}}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,w.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),w.errors=o,0===a}function M(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;w(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?w.errors:o.concat(w.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;z(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,M.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),M.errors=o,0===a}const N={validate:B};function T(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return T.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if(N.validate(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?N.validate.errors:o.concat(N.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,T.errors=o,!1}if(a=i,null!==o&&(i?o.length=i:o=null),n!==a)break}}}return T.errors=o,0===a}function I(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return I.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("and"!==t&&"not"!==t&&"or"!==t)return I.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.and){const n=a,r=a;let l=!1,p=null;const u=a;if(T(e.and,{instancePath:t+"/and",parentData:e,parentDataProperty:"and",rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var i=n===a}else i=!0;if(i){if(void 0!==e.not){const n=a,r=a;let l=!1,p=null;const u=a;if(N.validate(e.not,{instancePath:t+"/not",parentData:e,parentDataProperty:"not",rootData:s})||(o=null===o?N.validate.errors:o.concat(N.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.or){const n=a,r=a;let l=!1,p=null;const u=a;if(T(e.or,{instancePath:t+"/or",parentData:e,parentDataProperty:"or",rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0}}}}return I.errors=o,0===a}function B(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const l=i;if(i===l)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=l===i,p=p||f,!p){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f=e===i,p=p||f,!p){const e=i;if(I(t,{instancePath:n,parentData:r,parentDataProperty:s,rootData:o})||(a=null===a?I.errors:a.concat(I.errors),i=a.length),f=e===i,p=p||f,!p){const e=i;T(t,{instancePath:n,parentData:r,parentDataProperty:s,rootData:o})||(a=null===a?T.errors:a.concat(T.errors),i=a.length),f=e===i,p=p||f}}}}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,B.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),B.errors=a,0===i}function U(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;B(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?B.errors:o.concat(B.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;T(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,U.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),U.errors=o,0===a}const q={alias:{$ref:"#/definitions/ResolveAlias"},aliasFields:{type:"array",items:{anyOf:[{type:"array",items:{type:"string",minLength:1}},{type:"string",minLength:1}]}},byDependency:{type:"object",additionalProperties:{oneOf:[{$ref:"#/definitions/ResolveOptions"}]}},cache:{type:"boolean"},cachePredicate:{instanceof:"Function"},cacheWithContext:{type:"boolean"},conditionNames:{type:"array",items:{type:"string"}},descriptionFiles:{type:"array",items:{type:"string",minLength:1}},enforceExtension:{type:"boolean"},exportsFields:{type:"array",items:{type:"string"}},extensions:{type:"array",items:{type:"string"}},fallback:{oneOf:[{$ref:"#/definitions/ResolveAlias"}]},fileSystem:{},fullySpecified:{type:"boolean"},importsFields:{type:"array",items:{type:"string"}},mainFields:{type:"array",items:{anyOf:[{type:"array",items:{type:"string",minLength:1}},{type:"string",minLength:1}]}},mainFiles:{type:"array",items:{type:"string",minLength:1}},modules:{type:"array",items:{type:"string",minLength:1}},plugins:{type:"array",items:{anyOf:[{enum:["..."]},{$ref:"#/definitions/ResolvePluginInstance"}]}},preferAbsolute:{type:"boolean"},preferRelative:{type:"boolean"},resolver:{},restrictions:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},roots:{type:"array",items:{type:"string"}},symlinks:{type:"boolean"},unsafeCache:{anyOf:[{type:"boolean"},{type:"object",additionalProperties:!0}]},useSyncFileSystemCalls:{type:"boolean"}},G={validate:W};function W(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return W.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(q,e))return W.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.alias&&(e="alias")||void 0===t.name&&(e="name")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else{const e=l;for(const e in t)if("alias"!==e&&"name"!==e&&"onlyModule"!==e){const t={params:{additionalProperty:e}};null===i?i=[t]:i.push(t),l++;break}if(e===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var p=o===l;if(s=s||p,!s){const t=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(p=t===l,s=s||p,!s){const t=l;if(l===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}p=t===l,s=s||p}}if(s)l=r,null!==i&&(r?i.length=r:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=n===l}else u=!0;if(u){if(void 0!==t.name){const e=l;if("string"!=typeof t.name){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}u=e===l}else u=!0;if(u)if(void 0!==t.onlyModule){const e=l;if("boolean"!=typeof t.onlyModule){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}u=e===l}else u=!0}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var f=o===l;if(s=s||f,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const e=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(c=e===l,o=o||c,!o){const e=l;if(l===e)if("string"==typeof n){if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}}if(o)l=s,null!==i&&(s?i.length=s:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}f=t===l,s=s||f}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null);var m=n===l}else m=!0;if(m){if(void 0!==t.aliasFields){let e=t.aliasFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var y=a===l;if(o=o||y,!o){const e=l;if(l===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}y=e===l,o=o||y}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.byDependency){let e=t.byDependency;const n=l;if(l===n){if(!e||"object"!=typeof e||Array.isArray(e))return W.errors=[{params:{type:"object"}}],!1;for(const t in e){const n=l,s=l;let o=!1,p=null;const u=l;if(G.validate(e[t],{instancePath:r+"/byDependency/"+t.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:t,rootData:a})||(i=null===i?G.validate.errors:i.concat(G.validate.errors),l=i.length),u===l&&(o=!0,p=0),!o){const e={params:{passingSchemas:p}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),n!==l)break}}m=n===l}else m=!0;if(m){if(void 0!==t.cache){const e=l;if("boolean"!=typeof t.cache)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.cachePredicate){const e=l;if(!(t.cachePredicate instanceof Function))return W.errors=[{params:{}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.cacheWithContext){const e=l;if("boolean"!=typeof t.cacheWithContext)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.conditionNames){let e=t.conditionNames;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.descriptionFiles){let e=t.descriptionFiles;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.enforceExtension){const e=l;if("boolean"!=typeof t.enforceExtension)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.exportsFields){let e=t.exportsFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.extensions){let e=t.extensions;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.fallback){let e=t.fallback;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.alias&&(e="alias")||void 0===t.name&&(e="name")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else{const e=l;for(const e in t)if("alias"!==e&&"name"!==e&&"onlyModule"!==e){const t={params:{additionalProperty:e}};null===i?i=[t]:i.push(t),l++;break}if(e===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var h=o===l;if(s=s||h,!s){const t=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(h=t===l,s=s||h,!s){const t=l;if(l===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}h=t===l,s=s||h}}if(s)l=r,null!==i&&(r?i.length=r:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}var d=n===l}else d=!0;if(d){if(void 0!==t.name){const e=l;if("string"!=typeof t.name){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}d=e===l}else d=!0;if(d)if(void 0!==t.onlyModule){const e=l;if("boolean"!=typeof t.onlyModule){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}d=e===l}else d=!0}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var g=f===l;if(u=u||g,!u){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var b=a===l;if(o=o||b,!o){const e=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(b=e===l,o=o||b,!o){const e=l;if(l===e)if("string"==typeof n){if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}b=e===l,o=o||b}}if(o)l=s,null!==i&&(s?i.length=s:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=t===l,u=u||g}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),m=n===l}else m=!0;if(m){if(void 0!==t.fullySpecified){const e=l;if("boolean"!=typeof t.fullySpecified)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.importsFields){let e=t.importsFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.mainFields){let e=t.mainFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var v=a===l;if(o=o||v,!o){const e=l;if(l===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}v=e===l,o=o||v}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.mainFiles){let e=t.mainFiles;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.modules){let e=t.modules;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.plugins){let e=t.plugins;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if("..."!==t){const e={params:{}};null===i?i=[e]:i.push(e),l++}var D=a===l;if(o=o||D,!o){const e=l;if(l==l)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.apply&&(e="apply")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else if(void 0!==t.apply&&!(t.apply instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}D=e===l,o=o||D}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.preferAbsolute){const e=l;if("boolean"!=typeof t.preferAbsolute)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.preferRelative){const e=l;if("boolean"!=typeof t.preferRelative)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.restrictions){let n=t.restrictions;const r=l;if(l===r){if(!Array.isArray(n))return W.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=l,o=l;let a=!1;const p=l;if(!(t instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var P=p===l;if(a=a||P,!a){const n=l;if(l===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}P=n===l,a=a||P}if(!a){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=o,null!==i&&(o?i.length=o:i=null),s!==l)break}}}m=r===l}else m=!0;if(m){if(void 0!==t.roots){let e=t.roots;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.symlinks){const e=l;if("boolean"!=typeof t.symlinks)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.unsafeCache){let e=t.unsafeCache;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var A=o===l;if(s=s||A,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e));else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}A=t===l,s=s||A}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),m=n===l}else m=!0;if(m)if(void 0!==t.useSyncFileSystemCalls){const e=l;if("boolean"!=typeof t.useSyncFileSystemCalls)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0}}}}}}}}}}}}}}}}}}}}}}}}}}return W.errors=i,0===l}function H(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("ident"!==t&&"loader"!==t&&"options"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.ident){const t=a;if("string"!=typeof e.ident){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var u=t===a}else u=!0;if(u){if(void 0!==e.loader){let t=e.loader;const n=a,r=a;let s=!1,i=null;const l=a;if(a==a)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(l===a&&(s=!0,i=0),s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{passingSchemas:i}};null===o?o=[e]:o.push(e),a++}u=n===a}else u=!0;if(u)if(void 0!==e.options){let t=e.options;const n=a,r=a;let s=!1,i=null;const l=a,p=a;let c=!1;const m=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=m===a;if(c=c||f,!c){const e=a;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=e===a,c=c||f}if(c)a=p,null!==o&&(p?o.length=p:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(l===a&&(s=!0,i=0),s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{passingSchemas:i}};null===o?o=[e]:o.push(e),a++}u=n===a}else u=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var c=p===a;if(l=l||c,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(c=t===a,l=l||c,!l){const t=a;if(a==a)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a,l=l||c}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,H.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),H.errors=o,0===a}function _(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e)){const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if(H(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?H.errors:o.concat(H.errors),a=o.length),u===a&&(l=!0,p=0),l)a=i,null!==o&&(i?o.length=i:o=null);else{const e={params:{passingSchemas:p}};null===o?o=[e]:o.push(e),a++}if(n!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;H(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?H.errors:o.concat(H.errors),a=o.length),u=i===a,l=l||u}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,_.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),_.errors=o,0===a}const Q={validate:J};function J(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return J.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(E,t))return J.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.assert){let n=e.assert;const r=i;if(i===r){if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;for(const e in n){const r=i;if(M(n[e],{instancePath:t+"/assert/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),r!==i)break}}var l=r===i}else l=!0;if(l){if(void 0!==e.compiler){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.compiler,{instancePath:t+"/compiler",parentData:e,parentDataProperty:"compiler",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.dependency){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.dependency,{instancePath:t+"/dependency",parentData:e,parentDataProperty:"dependency",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.descriptionData){let n=e.descriptionData;const r=i;if(i===r){if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;for(const e in n){const r=i;if(M(n[e],{instancePath:t+"/descriptionData/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),r!==i)break}}l=r===i}else l=!0;if(l){if(void 0!==e.enforce){let t=e.enforce;const n=i;if("pre"!==t&&"post"!==t)return J.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.exclude){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.exclude,{instancePath:t+"/exclude",parentData:e,parentDataProperty:"exclude",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.generator){let t=e.generator;const n=i;if(!t||"object"!=typeof t||Array.isArray(t))return J.errors=[{params:{type:"object"}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.include){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.include,{instancePath:t+"/include",parentData:e,parentDataProperty:"include",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.issuer){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.issuer,{instancePath:t+"/issuer",parentData:e,parentDataProperty:"issuer",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.issuerLayer){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.issuerLayer,{instancePath:t+"/issuerLayer",parentData:e,parentDataProperty:"issuerLayer",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.layer){const t=i;if("string"!=typeof e.layer)return J.errors=[{params:{type:"string"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.loader){let t=e.loader;const n=i,r=i;let s=!1,o=null;const p=i;if(i==i)if("string"==typeof t){if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(p===i&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.mimetype){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.mimetype,{instancePath:t+"/mimetype",parentData:e,parentDataProperty:"mimetype",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.oneOf){let n=e.oneOf;const r=i;if(i===r){if(!Array.isArray(n))return J.errors=[{params:{type:"array"}}],!1;{const e=n.length;for(let r=0;r<e;r++){const e=i,s=i;let l=!1,p=null;const u=i;if(Q.validate(n[r],{instancePath:t+"/oneOf/"+r,parentData:n,parentDataProperty:r,rootData:o})||(a=null===a?Q.validate.errors:a.concat(Q.validate.errors),i=a.length),u===i&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),e!==i)break}}}l=r===i}else l=!0;if(l){if(void 0!==e.options){let t=e.options;const n=i,r=i;let s=!1,o=null;const u=i,f=i;let c=!1;const m=i;if("string"!=typeof t){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=m===i;if(c=c||p,!c){const e=i;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}p=e===i,c=c||p}if(c)i=f,null!==a&&(f?a.length=f:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.parser){let t=e.parser;const n=i;if(i===n&&(!t||"object"!=typeof t||Array.isArray(t)))return J.errors=[{params:{type:"object"}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.realResource){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.realResource,{instancePath:t+"/realResource",parentData:e,parentDataProperty:"realResource",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resolve){let n=e.resolve;const r=i;if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;const s=i;let p=!1,u=null;const f=i;if(W(n,{instancePath:t+"/resolve",parentData:e,parentDataProperty:"resolve",rootData:o})||(a=null===a?W.errors:a.concat(W.errors),i=a.length),f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.resource){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.resource,{instancePath:t+"/resource",parentData:e,parentDataProperty:"resource",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resourceFragment){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.resourceFragment,{instancePath:t+"/resourceFragment",parentData:e,parentDataProperty:"resourceFragment",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resourceQuery){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.resourceQuery,{instancePath:t+"/resourceQuery",parentData:e,parentDataProperty:"resourceQuery",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.rules){let n=e.rules;const r=i;if(i===r){if(!Array.isArray(n))return J.errors=[{params:{type:"array"}}],!1;{const e=n.length;for(let r=0;r<e;r++){const e=i,s=i;let l=!1,p=null;const u=i;if(Q.validate(n[r],{instancePath:t+"/rules/"+r,parentData:n,parentDataProperty:r,rootData:o})||(a=null===a?Q.validate.errors:a.concat(Q.validate.errors),i=a.length),u===i&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),e!==i)break}}}l=r===i}else l=!0;if(l){if(void 0!==e.scheme){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.scheme,{instancePath:t+"/scheme",parentData:e,parentDataProperty:"scheme",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.sideEffects){const t=i;if("boolean"!=typeof e.sideEffects)return J.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.test){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.test,{instancePath:t+"/test",parentData:e,parentDataProperty:"test",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.type){const t=i;if("string"!=typeof e.type)return J.errors=[{params:{type:"string"}}],!1;l=t===i}else l=!0;if(l)if(void 0!==e.use){const n=i,r=i;let s=!1,p=null;const u=i;if(_(e.use,{instancePath:t+"/use",parentData:e,parentDataProperty:"use",rootData:o})||(a=null===a?_.errors:a.concat(_.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}return J.errors=a,0===i}function V(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return V.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){let n=e[r];const l=a,p=a;let u=!1;const f=a;if("..."!==n){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=f===a;if(u=u||i,!u){const l=a;J(n,{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?J.errors:o.concat(J.errors),a=o.length),i=l===a,u=u||i}if(!u){const e={params:{}};return null===o?o=[e]:o.push(e),a++,V.errors=o,!1}if(a=p,null!==o&&(p?o.length=p:o=null),l!==a)break}}}return V.errors=o,0===a}function Z(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("encoding"!==t&&"mimetype"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.encoding){let t=e.encoding;const n=a;if(!1!==t&&"base64"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=n===a}else u=!0;if(u)if(void 0!==e.mimetype){const t=a;if("string"!=typeof e.mimetype){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}u=t===a}else u=!0}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var f=p===a;if(l=l||f,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,Z.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Z.errors=o,0===a}function K(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return K.errors=[{params:{type:"object"}}],!1;{const r=i;for(const e in t)if("dataUrl"!==e&&"emit"!==e&&"filename"!==e&&"outputPath"!==e&&"publicPath"!==e)return K.errors=[{params:{additionalProperty:e}}],!1;if(r===i){if(void 0!==t.dataUrl){const e=i;Z(t.dataUrl,{instancePath:n+"/dataUrl",parentData:t,parentDataProperty:"dataUrl",rootData:o})||(a=null===a?Z.errors:a.concat(Z.errors),i=a.length);var l=e===i}else l=!0;if(l){if(void 0!==t.emit){const e=i;if("boolean"!=typeof t.emit)return K.errors=[{params:{type:"boolean"}}],!1;l=e===i}else l=!0;if(l){if(void 0!==t.filename){let n=t.filename;const r=i,s=i;let o=!1;const u=i;if(i===u)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(n.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=u===i;if(o=o||p,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}p=e===i,o=o||p}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==t.outputPath){let n=t.outputPath;const r=i,s=i;let o=!1;const p=i;if(i===p)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var u=p===i;if(o=o||u,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=e===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==t.publicPath){let e=t.publicPath;const n=i,r=i;let s=!1;const o=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=t===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}return K.errors=a,0===i}function X(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return X.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("dataUrl"!==t)return X.errors=[{params:{additionalProperty:t}}],!1;n===a&&void 0!==e.dataUrl&&(Z(e.dataUrl,{instancePath:t+"/dataUrl",parentData:e,parentDataProperty:"dataUrl",rootData:s})||(o=null===o?Z.errors:o.concat(Z.errors),a=o.length))}}return X.errors=o,0===a}function Y(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return Y.errors=[{params:{type:"object"}}],!1;{const n=i;for(const e in t)if("emit"!==e&&"filename"!==e&&"outputPath"!==e&&"publicPath"!==e)return Y.errors=[{params:{additionalProperty:e}}],!1;if(n===i){if(void 0!==t.emit){const e=i;if("boolean"!=typeof t.emit)return Y.errors=[{params:{type:"boolean"}}],!1;var l=e===i}else l=!0;if(l){if(void 0!==t.filename){let n=t.filename;const r=i,s=i;let o=!1;const u=i;if(i===u)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(n.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=u===i;if(o=o||p,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}p=e===i,o=o||p}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==t.outputPath){let n=t.outputPath;const r=i,s=i;let o=!1;const p=i;if(i===p)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var u=p===i;if(o=o||u,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=e===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==t.publicPath){let e=t.publicPath;const n=i,r=i;let s=!1;const o=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=t===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}return Y.errors=a,0===i}function ee(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return ee.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("asset"!==t&&"asset/inline"!==t&&"asset/resource"!==t&&"javascript"!==t&&"javascript/auto"!==t&&"javascript/dynamic"!==t&&"javascript/esm"!==t){let n=e[t];const r=a;if(a===r&&(!n||"object"!=typeof n||Array.isArray(n)))return ee.errors=[{params:{type:"object"}}],!1;if(r!==a)break}if(n===a){if(void 0!==e.asset){const n=a;K(e.asset,{instancePath:t+"/asset",parentData:e,parentDataProperty:"asset",rootData:s})||(o=null===o?K.errors:o.concat(K.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e["asset/inline"]){const n=a;X(e["asset/inline"],{instancePath:t+"/asset~1inline",parentData:e,parentDataProperty:"asset/inline",rootData:s})||(o=null===o?X.errors:o.concat(X.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["asset/resource"]){const n=a;Y(e["asset/resource"],{instancePath:t+"/asset~1resource",parentData:e,parentDataProperty:"asset/resource",rootData:s})||(o=null===o?Y.errors:o.concat(Y.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e.javascript){let t=e.javascript;const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["javascript/auto"]){let t=e["javascript/auto"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["javascript/dynamic"]){let t=e["javascript/dynamic"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i)if(void 0!==e["javascript/esm"]){let t=e["javascript/esm"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0}}}}}}}}return ee.errors=o,0===a}function te(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return te.errors=[{params:{type:"object"}}],!1;{const t=a;for(const t in e)if("dataUrlCondition"!==t)return te.errors=[{params:{additionalProperty:t}}],!1;if(t===a&&void 0!==e.dataUrlCondition){let t=e.dataUrlCondition;const n=a;let r=!1;const s=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=a;for(const e in t)if("maxSize"!==e){const t={params:{additionalProperty:e}};null===o?o=[t]:o.push(t),a++;break}if(e===a&&void 0!==t.maxSize&&"number"!=typeof t.maxSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var i=s===a;if(r=r||i,!r){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}i=e===a,r=r||i}if(!r){const e={params:{}};return null===o?o=[e]:o.push(e),a++,te.errors=o,!1}a=n,null!==o&&(n?o.length=n:o=null)}}}return te.errors=o,0===a}function ne(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("__dirname"!==t&&"__filename"!==t&&"global"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.__dirname){let t=e.__dirname;const n=a;if(!1!==t&&!0!==t&&"warn-mock"!==t&&"mock"!==t&&"eval-only"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=n===a}else f=!0;if(f){if(void 0!==e.__filename){let t=e.__filename;const n=a;if(!1!==t&&!0!==t&&"warn-mock"!==t&&"mock"!==t&&"eval-only"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0;if(f)if(void 0!==e.global){let t=e.global;const n=a;if(!1!==t&&!0!==t&&"warn"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ne.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ne.errors=o,0===a}function re(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return re.errors=[{params:{type:"object"}}],!1;if(void 0!==e.amd){let t=e.amd;const n=a,r=a;let s=!1;const p=a;if(!1!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(s=s||i,!s){const e=a;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}i=e===a,s=s||i}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var l=n===a}else l=!0;if(l){if(void 0!==e.browserify){const t=a;if("boolean"!=typeof e.browserify)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.commonjs){const t=a;if("boolean"!=typeof e.commonjs)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.commonjsMagicComments){const t=a;if("boolean"!=typeof e.commonjsMagicComments)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exportsPresence){let t=e.exportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.exprContextCritical){const t=a;if("boolean"!=typeof e.exprContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exprContextRecursive){const t=a;if("boolean"!=typeof e.exprContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exprContextRegExp){let t=e.exprContextRegExp;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var p=i===a;if(s=s||p,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}p=e===a,s=s||p}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.exprContextRequest){const t=a;if("string"!=typeof e.exprContextRequest)return re.errors=[{params:{type:"string"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.harmony){const t=a;if("boolean"!=typeof e.harmony)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.import){const t=a;if("boolean"!=typeof e.import)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.importExportsPresence){let t=e.importExportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.importMeta){const t=a;if("boolean"!=typeof e.importMeta)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.node){const n=a;ne(e.node,{instancePath:t+"/node",parentData:e,parentDataProperty:"node",rootData:s})||(o=null===o?ne.errors:o.concat(ne.errors),a=o.length),l=n===a}else l=!0;if(l){if(void 0!==e.reexportExportsPresence){let t=e.reexportExportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.requireContext){const t=a;if("boolean"!=typeof e.requireContext)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireEnsure){const t=a;if("boolean"!=typeof e.requireEnsure)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireInclude){const t=a;if("boolean"!=typeof e.requireInclude)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireJs){const t=a;if("boolean"!=typeof e.requireJs)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.strictExportPresence){const t=a;if("boolean"!=typeof e.strictExportPresence)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.strictThisContextOnImports){const t=a;if("boolean"!=typeof e.strictThisContextOnImports)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.system){const t=a;if("boolean"!=typeof e.system)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextCritical){const t=a;if("boolean"!=typeof e.unknownContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextRecursive){const t=a;if("boolean"!=typeof e.unknownContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextRegExp){let t=e.unknownContextRegExp;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=i===a;if(s=s||u,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}u=e===a,s=s||u}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.unknownContextRequest){const t=a;if("string"!=typeof e.unknownContextRequest)return re.errors=[{params:{type:"string"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.url){let t=e.url;const n=a,r=a;let s=!1;const i=a;if("relative"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=i===a;if(s=s||f,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}f=e===a,s=s||f}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.worker){let t=e.worker;const n=a,r=a;let s=!1;const i=a;if(a===i)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var c=i===a;if(s=s||c,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}c=e===a,s=s||c}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.wrappedContextCritical){const t=a;if("boolean"!=typeof e.wrappedContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.wrappedContextRecursive){const t=a;if("boolean"!=typeof e.wrappedContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l)if(void 0!==e.wrappedContextRegExp){const t=a;if(!(e.wrappedContextRegExp instanceof RegExp))return re.errors=[{params:{}}],!1;l=t===a}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return re.errors=o,0===a}function se(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return se.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("asset"!==t&&"asset/inline"!==t&&"asset/resource"!==t&&"asset/source"!==t&&"javascript"!==t&&"javascript/auto"!==t&&"javascript/dynamic"!==t&&"javascript/esm"!==t){let n=e[t];const r=a;if(a===r&&(!n||"object"!=typeof n||Array.isArray(n)))return se.errors=[{params:{type:"object"}}],!1;if(r!==a)break}if(n===a){if(void 0!==e.asset){const n=a;te(e.asset,{instancePath:t+"/asset",parentData:e,parentDataProperty:"asset",rootData:s})||(o=null===o?te.errors:o.concat(te.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e["asset/inline"]){let t=e["asset/inline"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["asset/resource"]){let t=e["asset/resource"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["asset/source"]){let t=e["asset/source"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e.javascript){const n=a;re(e.javascript,{instancePath:t+"/javascript",parentData:e,parentDataProperty:"javascript",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["javascript/auto"]){const n=a;re(e["javascript/auto"],{instancePath:t+"/javascript~1auto",parentData:e,parentDataProperty:"javascript/auto",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["javascript/dynamic"]){const n=a;re(e["javascript/dynamic"],{instancePath:t+"/javascript~1dynamic",parentData:e,parentDataProperty:"javascript/dynamic",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i)if(void 0!==e["javascript/esm"]){const n=a;re(e["javascript/esm"],{instancePath:t+"/javascript~1esm",parentData:e,parentDataProperty:"javascript/esm",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0}}}}}}}}}return se.errors=o,0===a}function oe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return oe.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(R,e))return oe.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.defaultRules){const e=l,n=l;let s=!1,o=null;const u=l;if(V(t.defaultRules,{instancePath:r+"/defaultRules",parentData:t,parentDataProperty:"defaultRules",rootData:a})||(i=null===i?V.errors:i.concat(V.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null);var p=e===l}else p=!0;if(p){if(void 0!==t.exprContextCritical){const e=l;if("boolean"!=typeof t.exprContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exprContextRecursive){const e=l;if("boolean"!=typeof t.exprContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exprContextRegExp){let e=t.exprContextRegExp;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.exprContextRequest){const e=l;if("string"!=typeof t.exprContextRequest)return oe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.generator){const e=l;ee(t.generator,{instancePath:r+"/generator",parentData:t,parentDataProperty:"generator",rootData:a})||(i=null===i?ee.errors:i.concat(ee.errors),l=i.length),p=e===l}else p=!0;if(p){if(void 0!==t.noParse){let n=t.noParse;const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n))if(n.length<1){const e={params:{limit:1}};null===i?i=[e]:i.push(e),l++}else{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=l,o=l;let a=!1;const p=l;if(!(t instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var f=p===l;if(a=a||f,!a){const n=l;if(l===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(f=n===l,a=a||f,!a){const e=l;if(!(t instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}f=e===l,a=a||f}}if(a)l=o,null!==i&&(o?i.length=o:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(s!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const t=l;if(!(n instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(c=t===l,o=o||c,!o){const t=l;if(l===t)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(c=t===l,o=o||c,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}}}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.parser){const e=l;se(t.parser,{instancePath:r+"/parser",parentData:t,parentDataProperty:"parser",rootData:a})||(i=null===i?se.errors:i.concat(se.errors),l=i.length),p=e===l}else p=!0;if(p){if(void 0!==t.rules){const e=l,n=l;let s=!1,o=null;const u=l;if(V(t.rules,{instancePath:r+"/rules",parentData:t,parentDataProperty:"rules",rootData:a})||(i=null===i?V.errors:i.concat(V.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0;if(p){if(void 0!==t.strictExportPresence){const e=l;if("boolean"!=typeof t.strictExportPresence)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.strictThisContextOnImports){const e=l;if("boolean"!=typeof t.strictThisContextOnImports)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextCritical){const e=l;if("boolean"!=typeof t.unknownContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextRecursive){const e=l;if("boolean"!=typeof t.unknownContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextRegExp){let e=t.unknownContextRegExp;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.unknownContextRequest){const e=l;if("string"!=typeof t.unknownContextRequest)return oe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unsafeCache){let e=t.unsafeCache;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var y=o===l;if(s=s||y,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}y=t===l,s=s||y}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.wrappedContextCritical){const e=l;if("boolean"!=typeof t.wrappedContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.wrappedContextRecursive){const e=l;if("boolean"!=typeof t.wrappedContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p)if(void 0!==t.wrappedContextRegExp){const e=l;if(!(t.wrappedContextRegExp instanceof RegExp))return oe.errors=[{params:{}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}return oe.errors=i,0===l}const ae={checkWasmTypes:{type:"boolean"},chunkIds:{enum:["natural","named","deterministic","size","total-size",!1]},concatenateModules:{type:"boolean"},emitOnErrors:{type:"boolean"},flagIncludedChunks:{type:"boolean"},innerGraph:{type:"boolean"},mangleExports:{anyOf:[{enum:["size","deterministic"]},{type:"boolean"}]},mangleWasmImports:{type:"boolean"},mergeDuplicateChunks:{type:"boolean"},minimize:{type:"boolean"},minimizer:{type:"array",items:{anyOf:[{enum:["..."]},{$ref:"#/definitions/WebpackPluginInstance"},{$ref:"#/definitions/WebpackPluginFunction"}]}},moduleIds:{enum:["natural","named","hashed","deterministic","size",!1]},noEmitOnErrors:{type:"boolean"},nodeEnv:{anyOf:[{enum:[!1]},{type:"string"}]},portableRecords:{type:"boolean"},providedExports:{type:"boolean"},realContentHash:{type:"boolean"},removeAvailableModules:{type:"boolean"},removeEmptyChunks:{type:"boolean"},runtimeChunk:{$ref:"#/definitions/OptimizationRuntimeChunk"},sideEffects:{anyOf:[{enum:["flag"]},{type:"boolean"}]},splitChunks:{anyOf:[{enum:[!1]},{$ref:"#/definitions/OptimizationSplitChunksOptions"}]},usedExports:{anyOf:[{enum:["global"]},{type:"boolean"}]}},ie={automaticNameDelimiter:{type:"string",minLength:1},cacheGroups:{type:"object",additionalProperties:{anyOf:[{enum:[!1]},{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"},{$ref:"#/definitions/OptimizationSplitChunksCacheGroup"}]},not:{type:"object",additionalProperties:!0,properties:{test:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]}},required:["test"]}},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},defaultSizeTypes:{type:"array",items:{type:"string"},minItems:1},enforceSizeThreshold:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},fallbackCacheGroup:{type:"object",additionalProperties:!1,properties:{automaticNameDelimiter:{type:"string",minLength:1},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]}}},filename:{anyOf:[{type:"string",absolutePath:!1,minLength:1},{instanceof:"Function"}]},hidePathInfo:{type:"boolean"},maxAsyncRequests:{type:"number",minimum:1},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialRequests:{type:"number",minimum:1},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minChunks:{type:"number",minimum:1},minRemainingSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},name:{anyOf:[{enum:[!1]},{type:"string"},{instanceof:"Function"}]},usedExports:{type:"boolean"}},le={automaticNameDelimiter:{type:"string",minLength:1},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},enforce:{type:"boolean"},enforceSizeThreshold:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},filename:{anyOf:[{type:"string",absolutePath:!1,minLength:1},{instanceof:"Function"}]},idHint:{type:"string"},layer:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},maxAsyncRequests:{type:"number",minimum:1},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialRequests:{type:"number",minimum:1},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minChunks:{type:"number",minimum:1},minRemainingSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},name:{anyOf:[{enum:[!1]},{type:"string"},{instanceof:"Function"}]},priority:{type:"number"},reuseExistingChunk:{type:"boolean"},test:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},type:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},usedExports:{type:"boolean"}};function pe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return pe.errors=[{params:{type:"object"}}],!1;{const r=l;for(const e in t)if(!n.call(le,e))return pe.errors=[{params:{additionalProperty:e}}],!1;if(r===l){if(void 0!==t.automaticNameDelimiter){let e=t.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof e)return pe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return pe.errors=[{params:{}}],!1}var p=n===l}else p=!0;if(p){if(void 0!==t.chunks){let e=t.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==e&&"async"!==e&&"all"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.enforce){const e=l;if("boolean"!=typeof t.enforce)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.enforceSizeThreshold){let e=t.enforceSizeThreshold;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let c=!1;const m=l;if(l===m)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var f=m===l;if(c=c||f,!c){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}f=t===l,c=c||f}if(c)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.filename){let n=t.filename;const r=l,s=l;let o=!1;const a=l;if(l===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.idHint){const e=l;if("string"!=typeof t.idHint)return pe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.layer){let e=t.layer;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(m=t===l,s=s||m,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncRequests){let e=t.maxAsyncRequests;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncSize){let e=t.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var y=c===l;if(f=f||y,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}y=t===l,f=f||y}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialRequests){let e=t.maxInitialRequests;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialSize){let e=t.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var h=c===l;if(f=f||h,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}h=t===l,f=f||h}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxSize){let e=t.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var d=c===l;if(f=f||d,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}d=t===l,f=f||d}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minChunks){let e=t.minChunks;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.minRemainingSize){let e=t.minRemainingSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var g=c===l;if(f=f||g,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=t===l,f=f||g}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSize){let e=t.minSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var b=c===l;if(f=f||b,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}b=t===l,f=f||b}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSizeReduction){let e=t.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var v=c===l;if(f=f||v,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}v=t===l,f=f||v}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.name){let e=t.name;const n=l,r=l;let s=!1;const o=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var D=o===l;if(s=s||D,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(D=t===l,s=s||D,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}D=t===l,s=s||D}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.priority){const e=l;if("number"!=typeof t.priority)return pe.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reuseExistingChunk){const e=l;if("boolean"!=typeof t.reuseExistingChunk)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.test){let e=t.test;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var P=o===l;if(s=s||P,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(P=t===l,s=s||P,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}P=t===l,s=s||P}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.type){let e=t.type;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var A=o===l;if(s=s||A,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(A=t===l,s=s||A,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}A=t===l,s=s||A}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p)if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}}}}return pe.errors=i,0===l}function ue(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return ue.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(ie,e))return ue.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.automaticNameDelimiter){let e=t.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof e)return ue.errors=[{params:{type:"string"}}],!1;if(e.length<1)return ue.errors=[{params:{}}],!1}var p=n===l}else p=!0;if(p){if(void 0!==t.cacheGroups){let e=t.cacheGroups;const n=l,s=l,o=l;if(l===o)if(e&&"object"==typeof e&&!Array.isArray(e)){let t;if(void 0===e.test&&(t="test")){const e={};null===i?i=[e]:i.push(e),l++}else if(void 0!==e.test){let t=e.test;const n=l;let r=!1;const s=l;if(!(t instanceof RegExp)){const e={};null===i?i=[e]:i.push(e),l++}var u=s===l;if(r=r||u,!r){const e=l;if("string"!=typeof t){const e={};null===i?i=[e]:i.push(e),l++}if(u=e===l,r=r||u,!r){const e=l;if(!(t instanceof Function)){const e={};null===i?i=[e]:i.push(e),l++}u=e===l,r=r||u}}if(r)l=n,null!==i&&(n?i.length=n:i=null);else{const e={};null===i?i=[e]:i.push(e),l++}}}else{const e={};null===i?i=[e]:i.push(e),l++}if(o===l)return ue.errors=[{params:{}}],!1;if(l=s,null!==i&&(s?i.length=s:i=null),l===n){if(!e||"object"!=typeof e||Array.isArray(e))return ue.errors=[{params:{type:"object"}}],!1;for(const t in e){let n=e[t];const s=l,o=l;let p=!1;const u=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}var f=u===l;if(p=p||f,!p){const s=l;if(!(n instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;if("string"!=typeof n){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;pe(n,{instancePath:r+"/cacheGroups/"+t.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:t,rootData:a})||(i=null===i?pe.errors:i.concat(pe.errors),l=i.length),f=s===l,p=p||f}}}}if(!p){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}if(l=o,null!==i&&(o?i.length=o:i=null),s!==l)break}}p=n===l}else p=!0;if(p){if(void 0!==t.chunks){let e=t.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==e&&"async"!==e&&"all"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=o===l;if(s=s||c,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=t===l,s=s||c}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.defaultSizeTypes){let e=t.defaultSizeTypes;const n=l;if(l===n){if(!Array.isArray(e))return ue.errors=[{params:{type:"array"}}],!1;if(e.length<1)return ue.errors=[{params:{limit:1}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return ue.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}p=n===l}else p=!0;if(p){if(void 0!==t.enforceSizeThreshold){let e=t.enforceSizeThreshold;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var m=c===l;if(f=f||m,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}m=t===l,f=f||m}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.fallbackCacheGroup){let e=t.fallbackCacheGroup;const n=l;if(l===n){if(!e||"object"!=typeof e||Array.isArray(e))return ue.errors=[{params:{type:"object"}}],!1;{const t=l;for(const t in e)if("automaticNameDelimiter"!==t&&"chunks"!==t&&"maxAsyncSize"!==t&&"maxInitialSize"!==t&&"maxSize"!==t&&"minSize"!==t&&"minSizeReduction"!==t)return ue.errors=[{params:{additionalProperty:t}}],!1;if(t===l){if(void 0!==e.automaticNameDelimiter){let t=e.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof t)return ue.errors=[{params:{type:"string"}}],!1;if(t.length<1)return ue.errors=[{params:{}}],!1}var y=n===l}else y=!0;if(y){if(void 0!==e.chunks){let t=e.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==t&&"async"!==t&&"all"!==t){const e={params:{}};null===i?i=[e]:i.push(e),l++}var h=o===l;if(s=s||h,!s){const e=l;if(!(t instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}h=e===l,s=s||h}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxAsyncSize){let t=e.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var d=f===l;if(u=u||d,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}d=e===l,u=u||d}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxInitialSize){let t=e.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var g=f===l;if(u=u||g,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=e===l,u=u||g}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxSize){let t=e.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var b=f===l;if(u=u||b,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}b=e===l,u=u||b}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.minSize){let t=e.minSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var v=f===l;if(u=u||v,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}v=e===l,u=u||v}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y)if(void 0!==e.minSizeReduction){let t=e.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var D=f===l;if(u=u||D,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}D=e===l,u=u||D}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0}}}}}}}}p=n===l}else p=!0;if(p){if(void 0!==t.filename){let n=t.filename;const r=l,s=l;let o=!1;const a=l;if(l===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var P=a===l;if(o=o||P,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}P=e===l,o=o||P}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.hidePathInfo){const e=l;if("boolean"!=typeof t.hidePathInfo)return ue.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.maxAsyncRequests){let e=t.maxAsyncRequests;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncSize){let e=t.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var A=c===l;if(f=f||A,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}A=t===l,f=f||A}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialRequests){let e=t.maxInitialRequests;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialSize){let e=t.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var x=c===l;if(f=f||x,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}x=t===l,f=f||x}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxSize){let e=t.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var k=c===l;if(f=f||k,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}k=t===l,f=f||k}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minChunks){let e=t.minChunks;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.minRemainingSize){let e=t.minRemainingSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var j=c===l;if(f=f||j,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}j=t===l,f=f||j}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSize){let e=t.minSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var S=c===l;if(f=f||S,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}S=t===l,f=f||S}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSizeReduction){let e=t.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var C=c===l;if(f=f||C,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}C=t===l,f=f||C}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.name){let e=t.name;const n=l,r=l;let s=!1;const o=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var O=o===l;if(s=s||O,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(O=t===l,s=s||O,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}O=t===l,s=s||O}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p)if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return ue.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}return ue.errors=i,0===l}function fe(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return fe.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(ae,t))return fe.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.checkWasmTypes){const t=i;if("boolean"!=typeof e.checkWasmTypes)return fe.errors=[{params:{type:"boolean"}}],!1;var l=t===i}else l=!0;if(l){if(void 0!==e.chunkIds){let t=e.chunkIds;const n=i;if("natural"!==t&&"named"!==t&&"deterministic"!==t&&"size"!==t&&"total-size"!==t&&!1!==t)return fe.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.concatenateModules){const t=i;if("boolean"!=typeof e.concatenateModules)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.emitOnErrors){const t=i;if("boolean"!=typeof e.emitOnErrors)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.flagIncludedChunks){const t=i;if("boolean"!=typeof e.flagIncludedChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.innerGraph){const t=i;if("boolean"!=typeof e.innerGraph)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.mangleExports){let t=e.mangleExports;const n=i,r=i;let s=!1;const o=i;if("size"!==t&&"deterministic"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var p=o===i;if(s=s||p,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}p=e===i,s=s||p}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.mangleWasmImports){const t=i;if("boolean"!=typeof e.mangleWasmImports)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.mergeDuplicateChunks){const t=i;if("boolean"!=typeof e.mergeDuplicateChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.minimize){const t=i;if("boolean"!=typeof e.minimize)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.minimizer){let t=e.minimizer;const n=i;if(i===n){if(!Array.isArray(t))return fe.errors=[{params:{type:"array"}}],!1;{const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=i,s=i;let o=!1;const l=i;if("..."!==e){const e={params:{}};null===a?a=[e]:a.push(e),i++}var u=l===i;if(o=o||u,!o){const t=i;if(i==i)if(e&&"object"==typeof e&&!Array.isArray(e)){let t;if(void 0===e.apply&&(t="apply")){const e={params:{missingProperty:t}};null===a?a=[e]:a.push(e),i++}else if(void 0!==e.apply&&!(e.apply instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}if(u=t===i,o=o||u,!o){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=t===i,o=o||u}}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),r!==i)break}}}l=n===i}else l=!0;if(l){if(void 0!==e.moduleIds){let t=e.moduleIds;const n=i;if("natural"!==t&&"named"!==t&&"hashed"!==t&&"deterministic"!==t&&"size"!==t&&!1!==t)return fe.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.noEmitOnErrors){const t=i;if("boolean"!=typeof e.noEmitOnErrors)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.nodeEnv){let t=e.nodeEnv;const n=i,r=i;let s=!1;const o=i;if(!1!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const e=i;if("string"!=typeof t){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}f=e===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.portableRecords){const t=i;if("boolean"!=typeof e.portableRecords)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.providedExports){const t=i;if("boolean"!=typeof e.providedExports)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.realContentHash){const t=i;if("boolean"!=typeof e.realContentHash)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.removeAvailableModules){const t=i;if("boolean"!=typeof e.removeAvailableModules)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.removeEmptyChunks){const t=i;if("boolean"!=typeof e.removeEmptyChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.runtimeChunk){let t=e.runtimeChunk;const n=i,r=i;let s=!1;const o=i;if("single"!==t&&"multiple"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var c=o===i;if(s=s||c,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}if(c=e===i,s=s||c,!s){const e=i;if(i===e)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=i;for(const e in t)if("name"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(e===i&&void 0!==t.name){let e=t.name;const n=i;let r=!1;const s=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var m=s===i;if(r=r||m,!r){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=t===i,r=r||m}if(r)i=n,null!==a&&(n?a.length=n:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}c=e===i,s=s||c}}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.sideEffects){let t=e.sideEffects;const n=i,r=i;let s=!1;const o=i;if("flag"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var y=o===i;if(s=s||y,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}y=e===i,s=s||y}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.splitChunks){let n=e.splitChunks;const r=i,s=i;let p=!1;const u=i;if(!1!==n){const e={params:{}};null===a?a=[e]:a.push(e),i++}var h=u===i;if(p=p||h,!p){const r=i;ue(n,{instancePath:t+"/splitChunks",parentData:e,parentDataProperty:"splitChunks",rootData:o})||(a=null===a?ue.errors:a.concat(ue.errors),i=a.length),h=r===i,p=p||h}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==e.usedExports){let t=e.usedExports;const n=i,r=i;let s=!1;const o=i;if("global"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var d=o===i;if(s=s||d,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}d=e===i,s=s||d}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}return fe.errors=a,0===i}const ce={assetModuleFilename:{$ref:"#/definitions/AssetModuleFilename"},asyncChunks:{type:"boolean"},auxiliaryComment:{oneOf:[{$ref:"#/definitions/AuxiliaryComment"}]},charset:{$ref:"#/definitions/Charset"},chunkFilename:{$ref:"#/definitions/ChunkFilename"},chunkFormat:{$ref:"#/definitions/ChunkFormat"},chunkLoadTimeout:{$ref:"#/definitions/ChunkLoadTimeout"},chunkLoading:{$ref:"#/definitions/ChunkLoading"},chunkLoadingGlobal:{$ref:"#/definitions/ChunkLoadingGlobal"},clean:{$ref:"#/definitions/Clean"},compareBeforeEmit:{$ref:"#/definitions/CompareBeforeEmit"},crossOriginLoading:{$ref:"#/definitions/CrossOriginLoading"},cssChunkFilename:{$ref:"#/definitions/CssChunkFilename"},cssFilename:{$ref:"#/definitions/CssFilename"},devtoolFallbackModuleFilenameTemplate:{$ref:"#/definitions/DevtoolFallbackModuleFilenameTemplate"},devtoolModuleFilenameTemplate:{$ref:"#/definitions/DevtoolModuleFilenameTemplate"},devtoolNamespace:{$ref:"#/definitions/DevtoolNamespace"},enabledChunkLoadingTypes:{$ref:"#/definitions/EnabledChunkLoadingTypes"},enabledLibraryTypes:{$ref:"#/definitions/EnabledLibraryTypes"},enabledWasmLoadingTypes:{$ref:"#/definitions/EnabledWasmLoadingTypes"},environment:{$ref:"#/definitions/Environment"},filename:{$ref:"#/definitions/Filename"},globalObject:{$ref:"#/definitions/GlobalObject"},hashDigest:{$ref:"#/definitions/HashDigest"},hashDigestLength:{$ref:"#/definitions/HashDigestLength"},hashFunction:{$ref:"#/definitions/HashFunction"},hashSalt:{$ref:"#/definitions/HashSalt"},hotUpdateChunkFilename:{$ref:"#/definitions/HotUpdateChunkFilename"},hotUpdateGlobal:{$ref:"#/definitions/HotUpdateGlobal"},hotUpdateMainFilename:{$ref:"#/definitions/HotUpdateMainFilename"},iife:{$ref:"#/definitions/Iife"},importFunctionName:{$ref:"#/definitions/ImportFunctionName"},importMetaName:{$ref:"#/definitions/ImportMetaName"},library:{$ref:"#/definitions/Library"},libraryExport:{oneOf:[{$ref:"#/definitions/LibraryExport"}]},libraryTarget:{oneOf:[{$ref:"#/definitions/LibraryType"}]},module:{$ref:"#/definitions/OutputModule"},path:{$ref:"#/definitions/Path"},pathinfo:{$ref:"#/definitions/Pathinfo"},publicPath:{$ref:"#/definitions/PublicPath"},scriptType:{$ref:"#/definitions/ScriptType"},sourceMapFilename:{$ref:"#/definitions/SourceMapFilename"},sourcePrefix:{$ref:"#/definitions/SourcePrefix"},strictModuleErrorHandling:{$ref:"#/definitions/StrictModuleErrorHandling"},strictModuleExceptionHandling:{$ref:"#/definitions/StrictModuleExceptionHandling"},trustedTypes:{anyOf:[{enum:[!0]},{type:"string",minLength:1},{$ref:"#/definitions/TrustedTypes"}]},umdNamedDefine:{oneOf:[{$ref:"#/definitions/UmdNamedDefine"}]},uniqueName:{$ref:"#/definitions/UniqueName"},wasmLoading:{$ref:"#/definitions/WasmLoading"},webassemblyModuleFilename:{$ref:"#/definitions/WebassemblyModuleFilename"},workerChunkLoading:{$ref:"#/definitions/ChunkLoading"},workerWasmLoading:{$ref:"#/definitions/WasmLoading"}},me={arrowFunction:{type:"boolean"},bigIntLiteral:{type:"boolean"},const:{type:"boolean"},destructuring:{type:"boolean"},dynamicImport:{type:"boolean"},forOf:{type:"boolean"},module:{type:"boolean"},optionalChaining:{type:"boolean"},templateLiteral:{type:"boolean"}};function ye(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,ye.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),ye.errors=a,0===i}function he(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const n=i;if(i==i)if(t&&"object"==typeof t&&!Array.isArray(t)){const n=i;for(const e in t)if("dry"!==e&&"keep"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(n===i){if(void 0!==t.dry){const e=i;if("boolean"!=typeof t.dry){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var c=e===i}else c=!0;if(c)if(void 0!==t.keep){let n=t.keep;const r=i,s=i;let o=!1;const l=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=l===i;if(o=o||m,!o){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=t===i,o=o||m,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,o=o||m}}if(o)i=s,null!==a&&(s?a.length=s:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=r===i}else c=!0}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}f=n===i,p=p||f}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,he.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),he.errors=a,0===i}function de(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,de.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),de.errors=a,0===i}function ge(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,ge.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),ge.errors=a,0===i}function be(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return be.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("jsonp"!==t&&"import-scripts"!==t&&"require"!==t&&"async-node"!==t&&"import"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,be.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return be.errors=o,0===a}function ve(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return ve.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("var"!==t&&"module"!==t&&"assign"!==t&&"assign-properties"!==t&&"this"!==t&&"window"!==t&&"self"!==t&&"global"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"commonjs-module"!==t&&"commonjs-static"!==t&&"amd"!==t&&"amd-require"!==t&&"umd"!==t&&"umd2"!==t&&"jsonp"!==t&&"system"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ve.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return ve.errors=o,0===a}function De(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return De.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("fetch-streaming"!==t&&"fetch"!==t&&"async-node"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,De.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return De.errors=o,0===a}function Pe(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,Pe.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Pe.errors=a,0===i}function Ae(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;u(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?u.errors:o.concat(u.errors),a=o.length);var c=p===a;if(l=l||c,!l){const i=a;f(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?f.errors:o.concat(f.errors),a=o.length),c=i===a,l=l||c}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,Ae.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Ae.errors=o,0===a}function xe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let l=null,u=0;if(0===u){if(!t||"object"!=typeof t||Array.isArray(t))return xe.errors=[{params:{type:"object"}}],!1;{const s=u;for(const e in t)if(!n.call(ce,e))return xe.errors=[{params:{additionalProperty:e}}],!1;if(s===u){if(void 0!==t.assetModuleFilename){let n=t.assetModuleFilename;const r=u,s=u;let o=!1;const a=u;if(u===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var f=a===u;if(o=o||f,!o){const e=u;if(!(n instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}f=e===u,o=o||f}if(!o){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=s,null!==l&&(s?l.length=s:l=null);var y=r===u}else y=!0;if(y){if(void 0!==t.asyncChunks){const e=u;if("boolean"!=typeof t.asyncChunks)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.auxiliaryComment){const e=u,n=u;let s=!1,o=null;const i=u;if(p(t.auxiliaryComment,{instancePath:r+"/auxiliaryComment",parentData:t,parentDataProperty:"auxiliaryComment",rootData:a})||(l=null===l?p.errors:l.concat(p.errors),u=l.length),i===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=n,null!==l&&(n?l.length=n:l=null),y=e===u}else y=!0;if(y){if(void 0!==t.charset){const e=u;if("boolean"!=typeof t.charset)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.chunkFilename){const e=u;ye(t.chunkFilename,{instancePath:r+"/chunkFilename",parentData:t,parentDataProperty:"chunkFilename",rootData:a})||(l=null===l?ye.errors:l.concat(ye.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.chunkFormat){let e=t.chunkFormat;const n=u,r=u;let s=!1;const o=u;if("array-push"!==e&&"commonjs"!==e&&"module"!==e&&!1!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var h=o===u;if(s=s||h,!s){const t=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}h=t===u,s=s||h}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.chunkLoadTimeout){const e=u;if("number"!=typeof t.chunkLoadTimeout)return xe.errors=[{params:{type:"number"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.chunkLoading){const e=u;i(t.chunkLoading,{instancePath:r+"/chunkLoading",parentData:t,parentDataProperty:"chunkLoading",rootData:a})||(l=null===l?i.errors:l.concat(i.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.chunkLoadingGlobal){const e=u;if("string"!=typeof t.chunkLoadingGlobal)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.clean){const e=u;he(t.clean,{instancePath:r+"/clean",parentData:t,parentDataProperty:"clean",rootData:a})||(l=null===l?he.errors:l.concat(he.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.compareBeforeEmit){const e=u;if("boolean"!=typeof t.compareBeforeEmit)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.crossOriginLoading){let e=t.crossOriginLoading;const n=u;if(!1!==e&&"anonymous"!==e&&"use-credentials"!==e)return xe.errors=[{params:{}}],!1;y=n===u}else y=!0;if(y){if(void 0!==t.cssChunkFilename){const e=u;de(t.cssChunkFilename,{instancePath:r+"/cssChunkFilename",parentData:t,parentDataProperty:"cssChunkFilename",rootData:a})||(l=null===l?de.errors:l.concat(de.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.cssFilename){const e=u;ge(t.cssFilename,{instancePath:r+"/cssFilename",parentData:t,parentDataProperty:"cssFilename",rootData:a})||(l=null===l?ge.errors:l.concat(ge.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.devtoolFallbackModuleFilenameTemplate){let e=t.devtoolFallbackModuleFilenameTemplate;const n=u,r=u;let s=!1;const o=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var d=o===u;if(s=s||d,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}d=t===u,s=s||d}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.devtoolModuleFilenameTemplate){let e=t.devtoolModuleFilenameTemplate;const n=u,r=u;let s=!1;const o=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var g=o===u;if(s=s||g,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}g=t===u,s=s||g}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.devtoolNamespace){const e=u;if("string"!=typeof t.devtoolNamespace)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.enabledChunkLoadingTypes){const e=u;be(t.enabledChunkLoadingTypes,{instancePath:r+"/enabledChunkLoadingTypes",parentData:t,parentDataProperty:"enabledChunkLoadingTypes",rootData:a})||(l=null===l?be.errors:l.concat(be.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.enabledLibraryTypes){const e=u;ve(t.enabledLibraryTypes,{instancePath:r+"/enabledLibraryTypes",parentData:t,parentDataProperty:"enabledLibraryTypes",rootData:a})||(l=null===l?ve.errors:l.concat(ve.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.enabledWasmLoadingTypes){const e=u;De(t.enabledWasmLoadingTypes,{instancePath:r+"/enabledWasmLoadingTypes",parentData:t,parentDataProperty:"enabledWasmLoadingTypes",rootData:a})||(l=null===l?De.errors:l.concat(De.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.environment){let e=t.environment;const r=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return xe.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if(!n.call(me,t))return xe.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.arrowFunction){const t=u;if("boolean"!=typeof e.arrowFunction)return xe.errors=[{params:{type:"boolean"}}],!1;var b=t===u}else b=!0;if(b){if(void 0!==e.bigIntLiteral){const t=u;if("boolean"!=typeof e.bigIntLiteral)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.const){const t=u;if("boolean"!=typeof e.const)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.destructuring){const t=u;if("boolean"!=typeof e.destructuring)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.dynamicImport){const t=u;if("boolean"!=typeof e.dynamicImport)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.forOf){const t=u;if("boolean"!=typeof e.forOf)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.module){const t=u;if("boolean"!=typeof e.module)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.optionalChaining){const t=u;if("boolean"!=typeof e.optionalChaining)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b)if(void 0!==e.templateLiteral){const t=u;if("boolean"!=typeof e.templateLiteral)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0}}}}}}}}}}y=r===u}else y=!0;if(y){if(void 0!==t.filename){const e=u;Pe(t.filename,{instancePath:r+"/filename",parentData:t,parentDataProperty:"filename",rootData:a})||(l=null===l?Pe.errors:l.concat(Pe.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.globalObject){let e=t.globalObject;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hashDigest){const e=u;if("string"!=typeof t.hashDigest)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.hashDigestLength){let e=t.hashDigestLength;const n=u;if(u==u){if("number"!=typeof e)return xe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return xe.errors=[{params:{comparison:">=",limit:1}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hashFunction){let e=t.hashFunction;const n=u,r=u;let s=!1;const o=u;if(u===o)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var v=o===u;if(s=s||v,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}v=t===u,s=s||v}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.hashSalt){let e=t.hashSalt;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hotUpdateChunkFilename){let n=t.hotUpdateChunkFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.hotUpdateGlobal){const e=u;if("string"!=typeof t.hotUpdateGlobal)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.hotUpdateMainFilename){let n=t.hotUpdateMainFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.iife){const e=u;if("boolean"!=typeof t.iife)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.importFunctionName){const e=u;if("string"!=typeof t.importFunctionName)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.importMetaName){const e=u;if("string"!=typeof t.importMetaName)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.library){const e=u;Ae(t.library,{instancePath:r+"/library",parentData:t,parentDataProperty:"library",rootData:a})||(l=null===l?Ae.errors:l.concat(Ae.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.libraryExport){let e=t.libraryExport;const n=u,r=u;let s=!1,o=null;const a=u,i=u;let p=!1;const f=u;if(u===f)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u;if(u===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===l?l=[e]:l.push(e),u++}var D=f===u;if(p=p||D,!p){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}D=t===u,p=p||D}if(p)u=i,null!==l&&(i?l.length=i:l=null);else{const e={params:{}};null===l?l=[e]:l.push(e),u++}if(a===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.libraryTarget){let e=t.libraryTarget;const n=u,r=u;let s=!1,o=null;const a=u,i=u;let p=!1;const f=u;if("var"!==e&&"module"!==e&&"assign"!==e&&"assign-properties"!==e&&"this"!==e&&"window"!==e&&"self"!==e&&"global"!==e&&"commonjs"!==e&&"commonjs2"!==e&&"commonjs-module"!==e&&"commonjs-static"!==e&&"amd"!==e&&"amd-require"!==e&&"umd"!==e&&"umd2"!==e&&"jsonp"!==e&&"system"!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var P=f===u;if(p=p||P,!p){const t=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}P=t===u,p=p||P}if(p)u=i,null!==l&&(i?l.length=i:l=null);else{const e={params:{}};null===l?l=[e]:l.push(e),u++}if(a===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.module){const e=u;if("boolean"!=typeof t.module)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.path){let n=t.path;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.pathinfo){let e=t.pathinfo;const n=u,r=u;let s=!1;const o=u;if("verbose"!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var A=o===u;if(s=s||A,!s){const t=u;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===l?l=[e]:l.push(e),u++}A=t===u,s=s||A}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.publicPath){const e=u;c(t.publicPath,{instancePath:r+"/publicPath",parentData:t,parentDataProperty:"publicPath",rootData:a})||(l=null===l?c.errors:l.concat(c.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.scriptType){let e=t.scriptType;const n=u;if(!1!==e&&"text/javascript"!==e&&"module"!==e)return xe.errors=[{params:{}}],!1;y=n===u}else y=!0;if(y){if(void 0!==t.sourceMapFilename){let n=t.sourceMapFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.sourcePrefix){const e=u;if("string"!=typeof t.sourcePrefix)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.strictModuleErrorHandling){const e=u;if("boolean"!=typeof t.strictModuleErrorHandling)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.strictModuleExceptionHandling){const e=u;if("boolean"!=typeof t.strictModuleExceptionHandling)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.trustedTypes){let e=t.trustedTypes;const n=u,r=u;let s=!1;const o=u;if(!0!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var x=o===u;if(s=s||x,!s){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}if(x=t===u,s=s||x,!s){const t=u;if(u==u)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=u;for(const t in e)if("policyName"!==t){const e={params:{additionalProperty:t}};null===l?l=[e]:l.push(e),u++;break}if(t===u&&void 0!==e.policyName){let t=e.policyName;if(u==u)if("string"==typeof t){if(t.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}}}else{const e={params:{type:"object"}};null===l?l=[e]:l.push(e),u++}x=t===u,s=s||x}}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.umdNamedDefine){const e=u,n=u;let r=!1,s=null;const o=u;if("boolean"!=typeof t.umdNamedDefine){const e={params:{type:"boolean"}};null===l?l=[e]:l.push(e),u++}if(o===u&&(r=!0,s=0),!r){const e={params:{passingSchemas:s}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=n,null!==l&&(n?l.length=n:l=null),y=e===u}else y=!0;if(y){if(void 0!==t.uniqueName){let e=t.uniqueName;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.wasmLoading){const e=u;m(t.wasmLoading,{instancePath:r+"/wasmLoading",parentData:t,parentDataProperty:"wasmLoading",rootData:a})||(l=null===l?m.errors:l.concat(m.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.webassemblyModuleFilename){let n=t.webassemblyModuleFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.workerChunkLoading){const e=u;i(t.workerChunkLoading,{instancePath:r+"/workerChunkLoading",parentData:t,parentDataProperty:"workerChunkLoading",rootData:a})||(l=null===l?i.errors:l.concat(i.errors),u=l.length),y=e===u}else y=!0;if(y)if(void 0!==t.workerWasmLoading){const e=u;m(t.workerWasmLoading,{instancePath:r+"/workerWasmLoading",parentData:t,parentDataProperty:"workerWasmLoading",rootData:a})||(l=null===l?m.errors:l.concat(m.errors),u=l.length),y=e===u}else y=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return xe.errors=l,0===u}function ke(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("assetFilter"!==t&&"hints"!==t&&"maxAssetSize"!==t&&"maxEntrypointSize"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.assetFilter){const t=a;if(!(e.assetFilter instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=t===a}else f=!0;if(f){if(void 0!==e.hints){let t=e.hints;const n=a;if(!1!==t&&"warning"!==t&&"error"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0;if(f){if(void 0!==e.maxAssetSize){const t=a;if("number"!=typeof e.maxAssetSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}f=t===a}else f=!0;if(f)if(void 0!==e.maxEntrypointSize){const t=a;if("number"!=typeof e.maxEntrypointSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}f=t===a}else f=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ke.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ke.errors=o,0===a}function je(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return je.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.apply&&(e="apply")){const t={params:{missingProperty:e}};null===o?o=[t]:o.push(t),a++}else if(void 0!==t.apply&&!(t.apply instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,je.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return je.errors=o,0===a}function Se(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(W(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?W.errors:o.concat(W.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,Se.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Se.errors=o,0===a}function Ce(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(W(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?W.errors:o.concat(W.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,Ce.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Ce.errors=o,0===a}const Oe={all:{type:"boolean"},assets:{type:"boolean"},assetsSort:{type:"string"},assetsSpace:{type:"number"},builtAt:{type:"boolean"},cached:{type:"boolean"},cachedAssets:{type:"boolean"},cachedModules:{type:"boolean"},children:{type:"boolean"},chunkGroupAuxiliary:{type:"boolean"},chunkGroupChildren:{type:"boolean"},chunkGroupMaxAssets:{type:"number"},chunkGroups:{type:"boolean"},chunkModules:{type:"boolean"},chunkModulesSpace:{type:"number"},chunkOrigins:{type:"boolean"},chunkRelations:{type:"boolean"},chunks:{type:"boolean"},chunksSort:{type:"string"},colors:{anyOf:[{type:"boolean"},{type:"object",additionalProperties:!1,properties:{bold:{type:"string"},cyan:{type:"string"},green:{type:"string"},magenta:{type:"string"},red:{type:"string"},yellow:{type:"string"}}}]},context:{type:"string",absolutePath:!0},dependentModules:{type:"boolean"},depth:{type:"boolean"},entrypoints:{anyOf:[{enum:["auto"]},{type:"boolean"}]},env:{type:"boolean"},errorDetails:{anyOf:[{enum:["auto"]},{type:"boolean"}]},errorStack:{type:"boolean"},errors:{type:"boolean"},errorsCount:{type:"boolean"},exclude:{anyOf:[{type:"boolean"},{$ref:"#/definitions/ModuleFilterTypes"}]},excludeAssets:{oneOf:[{$ref:"#/definitions/AssetFilterTypes"}]},excludeModules:{anyOf:[{type:"boolean"},{$ref:"#/definitions/ModuleFilterTypes"}]},groupAssetsByChunk:{type:"boolean"},groupAssetsByEmitStatus:{type:"boolean"},groupAssetsByExtension:{type:"boolean"},groupAssetsByInfo:{type:"boolean"},groupAssetsByPath:{type:"boolean"},groupModulesByAttributes:{type:"boolean"},groupModulesByCacheStatus:{type:"boolean"},groupModulesByExtension:{type:"boolean"},groupModulesByLayer:{type:"boolean"},groupModulesByPath:{type:"boolean"},groupModulesByType:{type:"boolean"},groupReasonsByOrigin:{type:"boolean"},hash:{type:"boolean"},ids:{type:"boolean"},logging:{anyOf:[{enum:["none","error","warn","info","log","verbose"]},{type:"boolean"}]},loggingDebug:{anyOf:[{type:"boolean"},{$ref:"#/definitions/FilterTypes"}]},loggingTrace:{type:"boolean"},moduleAssets:{type:"boolean"},moduleTrace:{type:"boolean"},modules:{type:"boolean"},modulesSort:{type:"string"},modulesSpace:{type:"number"},nestedModules:{type:"boolean"},nestedModulesSpace:{type:"number"},optimizationBailout:{type:"boolean"},orphanModules:{type:"boolean"},outputPath:{type:"boolean"},performance:{type:"boolean"},preset:{anyOf:[{type:"boolean"},{type:"string"}]},providedExports:{type:"boolean"},publicPath:{type:"boolean"},reasons:{type:"boolean"},reasonsSpace:{type:"number"},relatedAssets:{type:"boolean"},runtime:{type:"boolean"},runtimeModules:{type:"boolean"},source:{type:"boolean"},timings:{type:"boolean"},usedExports:{type:"boolean"},version:{type:"boolean"},warnings:{type:"boolean"},warningsCount:{type:"boolean"},warningsFilter:{oneOf:[{$ref:"#/definitions/WarningFilterTypes"}]}};function Fe(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Fe.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Fe.errors=a,0===i}function Re(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Re.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Re.errors=a,0===i}function Ee(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Ee.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Ee.errors=a,0===i}function $e(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return $e.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(Oe,e))return $e.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.all){const e=l;if("boolean"!=typeof t.all)return $e.errors=[{params:{type:"boolean"}}],!1;var p=e===l}else p=!0;if(p){if(void 0!==t.assets){const e=l;if("boolean"!=typeof t.assets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.assetsSort){const e=l;if("string"!=typeof t.assetsSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.assetsSpace){const e=l;if("number"!=typeof t.assetsSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.builtAt){const e=l;if("boolean"!=typeof t.builtAt)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cached){const e=l;if("boolean"!=typeof t.cached)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cachedAssets){const e=l;if("boolean"!=typeof t.cachedAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cachedModules){const e=l;if("boolean"!=typeof t.cachedModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.children){const e=l;if("boolean"!=typeof t.children)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupAuxiliary){const e=l;if("boolean"!=typeof t.chunkGroupAuxiliary)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupChildren){const e=l;if("boolean"!=typeof t.chunkGroupChildren)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupMaxAssets){const e=l;if("number"!=typeof t.chunkGroupMaxAssets)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroups){const e=l;if("boolean"!=typeof t.chunkGroups)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkModules){const e=l;if("boolean"!=typeof t.chunkModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkModulesSpace){const e=l;if("number"!=typeof t.chunkModulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkOrigins){const e=l;if("boolean"!=typeof t.chunkOrigins)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkRelations){const e=l;if("boolean"!=typeof t.chunkRelations)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunks){const e=l;if("boolean"!=typeof t.chunks)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunksSort){const e=l;if("string"!=typeof t.chunksSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.colors){let e=t.colors;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=l;for(const t in e)if("bold"!==t&&"cyan"!==t&&"green"!==t&&"magenta"!==t&&"red"!==t&&"yellow"!==t){const e={params:{additionalProperty:t}};null===i?i=[e]:i.push(e),l++;break}if(t===l){if(void 0!==e.bold){const t=l;if("string"!=typeof e.bold){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var f=t===l}else f=!0;if(f){if(void 0!==e.cyan){const t=l;if("string"!=typeof e.cyan){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.green){const t=l;if("string"!=typeof e.green){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.magenta){const t=l;if("string"!=typeof e.magenta){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.red){const t=l;if("string"!=typeof e.red){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f)if(void 0!==e.yellow){const t=l;if("string"!=typeof e.yellow){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0}}}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.context){let n=t.context;const r=l;if(l===r){if("string"!=typeof n)return $e.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return $e.errors=[{params:{}}],!1}p=r===l}else p=!0;if(p){if(void 0!==t.dependentModules){const e=l;if("boolean"!=typeof t.dependentModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.depth){const e=l;if("boolean"!=typeof t.depth)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.entrypoints){let e=t.entrypoints;const n=l,r=l;let s=!1;const o=l;if("auto"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=o===l;if(s=s||c,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}c=t===l,s=s||c}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.env){const e=l;if("boolean"!=typeof t.env)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errorDetails){let e=t.errorDetails;const n=l,r=l;let s=!1;const o=l;if("auto"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.errorStack){const e=l;if("boolean"!=typeof t.errorStack)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errors){const e=l;if("boolean"!=typeof t.errors)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errorsCount){const e=l;if("boolean"!=typeof t.errorsCount)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exclude){let e=t.exclude;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var y=u===l;if(o=o||y,!o){const n=l;Fe(e,{instancePath:r+"/exclude",parentData:t,parentDataProperty:"exclude",rootData:a})||(i=null===i?Fe.errors:i.concat(Fe.errors),l=i.length),y=n===l,o=o||y}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.excludeAssets){const e=l,n=l;let s=!1,o=null;const u=l;if(Re(t.excludeAssets,{instancePath:r+"/excludeAssets",parentData:t,parentDataProperty:"excludeAssets",rootData:a})||(i=null===i?Re.errors:i.concat(Re.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0;if(p){if(void 0!==t.excludeModules){let e=t.excludeModules;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var h=u===l;if(o=o||h,!o){const n=l;Fe(e,{instancePath:r+"/excludeModules",parentData:t,parentDataProperty:"excludeModules",rootData:a})||(i=null===i?Fe.errors:i.concat(Fe.errors),l=i.length),h=n===l,o=o||h}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.groupAssetsByChunk){const e=l;if("boolean"!=typeof t.groupAssetsByChunk)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByEmitStatus){const e=l;if("boolean"!=typeof t.groupAssetsByEmitStatus)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByExtension){const e=l;if("boolean"!=typeof t.groupAssetsByExtension)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByInfo){const e=l;if("boolean"!=typeof t.groupAssetsByInfo)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByPath){const e=l;if("boolean"!=typeof t.groupAssetsByPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByAttributes){const e=l;if("boolean"!=typeof t.groupModulesByAttributes)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByCacheStatus){const e=l;if("boolean"!=typeof t.groupModulesByCacheStatus)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByExtension){const e=l;if("boolean"!=typeof t.groupModulesByExtension)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByLayer){const e=l;if("boolean"!=typeof t.groupModulesByLayer)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByPath){const e=l;if("boolean"!=typeof t.groupModulesByPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByType){const e=l;if("boolean"!=typeof t.groupModulesByType)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupReasonsByOrigin){const e=l;if("boolean"!=typeof t.groupReasonsByOrigin)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.hash){const e=l;if("boolean"!=typeof t.hash)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.ids){const e=l;if("boolean"!=typeof t.ids)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.logging){let e=t.logging;const n=l,r=l;let s=!1;const o=l;if("none"!==e&&"error"!==e&&"warn"!==e&&"info"!==e&&"log"!==e&&"verbose"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var d=o===l;if(s=s||d,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}d=t===l,s=s||d}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.loggingDebug){let e=t.loggingDebug;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var g=u===l;if(o=o||g,!o){const n=l;O(e,{instancePath:r+"/loggingDebug",parentData:t,parentDataProperty:"loggingDebug",rootData:a})||(i=null===i?O.errors:i.concat(O.errors),l=i.length),g=n===l,o=o||g}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.loggingTrace){const e=l;if("boolean"!=typeof t.loggingTrace)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.moduleAssets){const e=l;if("boolean"!=typeof t.moduleAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.moduleTrace){const e=l;if("boolean"!=typeof t.moduleTrace)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modules){const e=l;if("boolean"!=typeof t.modules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modulesSort){const e=l;if("string"!=typeof t.modulesSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modulesSpace){const e=l;if("number"!=typeof t.modulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.nestedModules){const e=l;if("boolean"!=typeof t.nestedModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.nestedModulesSpace){const e=l;if("number"!=typeof t.nestedModulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.optimizationBailout){const e=l;if("boolean"!=typeof t.optimizationBailout)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.orphanModules){const e=l;if("boolean"!=typeof t.orphanModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.outputPath){const e=l;if("boolean"!=typeof t.outputPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.performance){const e=l;if("boolean"!=typeof t.performance)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.preset){let e=t.preset;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var b=o===l;if(s=s||b,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}b=t===l,s=s||b}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.providedExports){const e=l;if("boolean"!=typeof t.providedExports)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.publicPath){const e=l;if("boolean"!=typeof t.publicPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reasons){const e=l;if("boolean"!=typeof t.reasons)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reasonsSpace){const e=l;if("number"!=typeof t.reasonsSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.relatedAssets){const e=l;if("boolean"!=typeof t.relatedAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.runtime){const e=l;if("boolean"!=typeof t.runtime)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.runtimeModules){const e=l;if("boolean"!=typeof t.runtimeModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.source){const e=l;if("boolean"!=typeof t.source)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.timings){const e=l;if("boolean"!=typeof t.timings)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.version){const e=l;if("boolean"!=typeof t.version)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.warnings){const e=l;if("boolean"!=typeof t.warnings)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.warningsCount){const e=l;if("boolean"!=typeof t.warningsCount)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p)if(void 0!==t.warningsFilter){const e=l,n=l;let s=!1,o=null;const u=l;if(Ee(t.warningsFilter,{instancePath:r+"/warningsFilter",parentData:t,parentDataProperty:"warningsFilter",rootData:a})||(i=null===i?Ee.errors:i.concat(Ee.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return $e.errors=i,0===l}function ze(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if("none"!==e&&"summary"!==e&&"errors-only"!==e&&"errors-warnings"!==e&&"minimal"!==e&&"normal"!==e&&"detailed"!==e&&"verbose"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;$e(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?$e.errors:o.concat($e.errors),a=o.length),u=i===a,l=l||u}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ze.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ze.errors=o,0===a}const Le=new RegExp("^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$","u");function we(r,{instancePath:s="",parentData:a,parentDataProperty:i,rootData:l=r}={}){let p=null,u=0;if(0===u){if(!r||"object"!=typeof r||Array.isArray(r))return we.errors=[{params:{type:"object"}}],!1;{const a=u;for(const e in r)if(!n.call(t,e))return we.errors=[{params:{additionalProperty:e}}],!1;if(a===u){if(void 0!==r.amd){let e=r.amd;const t=u,n=u;let s=!1;const o=u;if(!1!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}var f=o===u;if(s=s||f,!s){const t=u;if(!e||"object"!=typeof e||Array.isArray(e)){const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}f=t===u,s=s||f}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null);var c=t===u}else c=!0;if(c){if(void 0!==r.bail){const e=u;if("boolean"!=typeof r.bail)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.cache){const e=u;o(r.cache,{instancePath:s+"/cache",parentData:r,parentDataProperty:"cache",rootData:l})||(p=null===p?o.errors:p.concat(o.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.context){let t=r.context;const n=u;if(u==u){if("string"!=typeof t)return we.errors=[{params:{type:"string"}}],!1;if(t.includes("!")||!0!==e.test(t))return we.errors=[{params:{}}],!1}c=n===u}else c=!0;if(c){if(void 0!==r.dependencies){let e=r.dependencies;const t=u;if(u==u){if(!Array.isArray(e))return we.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=u;if("string"!=typeof e[n])return we.errors=[{params:{type:"string"}}],!1;if(t!==u)break}}}c=t===u}else c=!0;if(c){if(void 0!==r.devServer){let e=r.devServer;const t=u;if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.devtool){let e=r.devtool;const t=u,n=u;let s=!1;const o=u;if(!1!==e&&"eval"!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}var m=o===u;if(s=s||m,!s){const t=u;if(u===t)if("string"==typeof e){if(!Le.test(e)){const e={params:{pattern:"^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$"}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}m=t===u,s=s||m}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null),c=t===u}else c=!0;if(c){if(void 0!==r.entry){const e=u;b(r.entry,{instancePath:s+"/entry",parentData:r,parentDataProperty:"entry",rootData:l})||(p=null===p?b.errors:p.concat(b.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.experiments){const e=u;k(r.experiments,{instancePath:s+"/experiments",parentData:r,parentDataProperty:"experiments",rootData:l})||(p=null===p?k.errors:p.concat(k.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.externals){const e=u;C(r.externals,{instancePath:s+"/externals",parentData:r,parentDataProperty:"externals",rootData:l})||(p=null===p?C.errors:p.concat(C.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.externalsPresets){let e=r.externalsPresets;const t=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("electron"!==t&&"electronMain"!==t&&"electronPreload"!==t&&"electronRenderer"!==t&&"node"!==t&&"nwjs"!==t&&"web"!==t&&"webAsync"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.electron){const t=u;if("boolean"!=typeof e.electron)return we.errors=[{params:{type:"boolean"}}],!1;var y=t===u}else y=!0;if(y){if(void 0!==e.electronMain){const t=u;if("boolean"!=typeof e.electronMain)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.electronPreload){const t=u;if("boolean"!=typeof e.electronPreload)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.electronRenderer){const t=u;if("boolean"!=typeof e.electronRenderer)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.node){const t=u;if("boolean"!=typeof e.node)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.nwjs){const t=u;if("boolean"!=typeof e.nwjs)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.web){const t=u;if("boolean"!=typeof e.web)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y)if(void 0!==e.webAsync){const t=u;if("boolean"!=typeof e.webAsync)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0}}}}}}}}}c=t===u}else c=!0;if(c){if(void 0!==r.externalsType){let e=r.externalsType;const t=u;if("var"!==e&&"module"!==e&&"assign"!==e&&"this"!==e&&"window"!==e&&"self"!==e&&"global"!==e&&"commonjs"!==e&&"commonjs2"!==e&&"commonjs-module"!==e&&"commonjs-static"!==e&&"amd"!==e&&"amd-require"!==e&&"umd"!==e&&"umd2"!==e&&"jsonp"!==e&&"system"!==e&&"promise"!==e&&"import"!==e&&"script"!==e&&"node-commonjs"!==e)return we.errors=[{params:{}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.ignoreWarnings){let e=r.ignoreWarnings;const t=u;if(u==u){if(!Array.isArray(e))return we.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u,s=u;let o=!1;const a=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var h=a===u;if(o=o||h,!o){const e=u;if(u===e)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=u;for(const e in t)if("file"!==e&&"message"!==e&&"module"!==e){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(e===u){if(void 0!==t.file){const e=u;if(!(t.file instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var d=e===u}else d=!0;if(d){if(void 0!==t.message){const e=u;if(!(t.message instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d)if(void 0!==t.module){const e=u;if(!(t.module instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}if(h=e===u,o=o||h,!o){const e=u;if(!(t instanceof Function)){const e={params:{}};null===p?p=[e]:p.push(e),u++}h=e===u,o=o||h}}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=s,null!==p&&(s?p.length=s:p=null),r!==u)break}}}c=t===u}else c=!0;if(c){if(void 0!==r.infrastructureLogging){const e=u;F(r.infrastructureLogging,{instancePath:s+"/infrastructureLogging",parentData:r,parentDataProperty:"infrastructureLogging",rootData:l})||(p=null===p?F.errors:p.concat(F.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.loader){let e=r.loader;const t=u;if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.mode){let e=r.mode;const t=u;if("development"!==e&&"production"!==e&&"none"!==e)return we.errors=[{params:{}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.module){const e=u;oe(r.module,{instancePath:s+"/module",parentData:r,parentDataProperty:"module",rootData:l})||(p=null===p?oe.errors:p.concat(oe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.name){const e=u;if("string"!=typeof r.name)return we.errors=[{params:{type:"string"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.node){const e=u;ne(r.node,{instancePath:s+"/node",parentData:r,parentDataProperty:"node",rootData:l})||(p=null===p?ne.errors:p.concat(ne.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.optimization){const e=u;fe(r.optimization,{instancePath:s+"/optimization",parentData:r,parentDataProperty:"optimization",rootData:l})||(p=null===p?fe.errors:p.concat(fe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.output){const e=u;xe(r.output,{instancePath:s+"/output",parentData:r,parentDataProperty:"output",rootData:l})||(p=null===p?xe.errors:p.concat(xe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.parallelism){let e=r.parallelism;const t=u;if(u==u){if("number"!=typeof e)return we.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return we.errors=[{params:{comparison:">=",limit:1}}],!1}c=t===u}else c=!0;if(c){if(void 0!==r.performance){const e=u;ke(r.performance,{instancePath:s+"/performance",parentData:r,parentDataProperty:"performance",rootData:l})||(p=null===p?ke.errors:p.concat(ke.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.plugins){const e=u;je(r.plugins,{instancePath:s+"/plugins",parentData:r,parentDataProperty:"plugins",rootData:l})||(p=null===p?je.errors:p.concat(je.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.profile){const e=u;if("boolean"!=typeof r.profile)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.recordsInputPath){let t=r.recordsInputPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var g=a===u;if(o=o||g,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=n===u,o=o||g}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.recordsOutputPath){let t=r.recordsOutputPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var v=a===u;if(o=o||v,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}v=n===u,o=o||v}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.recordsPath){let t=r.recordsPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var D=a===u;if(o=o||D,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}D=n===u,o=o||D}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.resolve){const e=u;Se(r.resolve,{instancePath:s+"/resolve",parentData:r,parentDataProperty:"resolve",rootData:l})||(p=null===p?Se.errors:p.concat(Se.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.resolveLoader){const e=u;Ce(r.resolveLoader,{instancePath:s+"/resolveLoader",parentData:r,parentDataProperty:"resolveLoader",rootData:l})||(p=null===p?Ce.errors:p.concat(Ce.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.snapshot){let t=r.snapshot;const n=u;if(u==u){if(!t||"object"!=typeof t||Array.isArray(t))return we.errors=[{params:{type:"object"}}],!1;{const n=u;for(const e in t)if("buildDependencies"!==e&&"immutablePaths"!==e&&"managedPaths"!==e&&"module"!==e&&"resolve"!==e&&"resolveBuildDependencies"!==e)return we.errors=[{params:{additionalProperty:e}}],!1;if(n===u){if(void 0!==t.buildDependencies){let e=t.buildDependencies;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var P=t===u}else P=!0;if(P)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;P=t===u}else P=!0}}}var A=n===u}else A=!0;if(A){if(void 0!==t.immutablePaths){let n=t.immutablePaths;const r=u;if(u===r){if(!Array.isArray(n))return we.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var x=i===u;if(a=a||x,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}x=n===u,a=a||x}if(!a){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=o,null!==p&&(o?p.length=o:p=null),s!==u)break}}}A=r===u}else A=!0;if(A){if(void 0!==t.managedPaths){let n=t.managedPaths;const r=u;if(u===r){if(!Array.isArray(n))return we.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var j=i===u;if(a=a||j,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}j=n===u,a=a||j}if(!a){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=o,null!==p&&(o?p.length=o:p=null),s!==u)break}}}A=r===u}else A=!0;if(A){if(void 0!==t.module){let e=t.module;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var S=t===u}else S=!0;if(S)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;S=t===u}else S=!0}}}A=n===u}else A=!0;if(A){if(void 0!==t.resolve){let e=t.resolve;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var O=t===u}else O=!0;if(O)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;O=t===u}else O=!0}}}A=n===u}else A=!0;if(A)if(void 0!==t.resolveBuildDependencies){let e=t.resolveBuildDependencies;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var R=t===u}else R=!0;if(R)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;R=t===u}else R=!0}}}A=n===u}else A=!0}}}}}}}c=n===u}else c=!0;if(c){if(void 0!==r.stats){const e=u;ze(r.stats,{instancePath:s+"/stats",parentData:r,parentDataProperty:"stats",rootData:l})||(p=null===p?ze.errors:p.concat(ze.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.target){let e=r.target;const t=u,n=u;let s=!1;const o=u;if(u===o)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u;if(u===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var E=o===u;if(s=s||E,!s){const t=u;if(!1!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}if(E=t===u,s=s||E,!s){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}E=t===u,s=s||E}}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null),c=t===u}else c=!0;if(c){if(void 0!==r.watch){const e=u;if("boolean"!=typeof r.watch)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c)if(void 0!==r.watchOptions){let e=r.watchOptions;const t=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("aggregateTimeout"!==t&&"followSymlinks"!==t&&"ignored"!==t&&"poll"!==t&&"stdin"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.aggregateTimeout){const t=u;if("number"!=typeof e.aggregateTimeout)return we.errors=[{params:{type:"number"}}],!1;var $=t===u}else $=!0;if($){if(void 0!==e.followSymlinks){const t=u;if("boolean"!=typeof e.followSymlinks)return we.errors=[{params:{type:"boolean"}}],!1;$=t===u}else $=!0;if($){if(void 0!==e.ignored){let t=e.ignored;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var z=o===u;if(s=s||z,!s){const e=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}if(z=e===u,s=s||z,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}z=e===u,s=s||z}}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),$=n===u}else $=!0;if($){if(void 0!==e.poll){let t=e.poll;const n=u,r=u;let s=!1;const o=u;if("number"!=typeof t){const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}var L=o===u;if(s=s||L,!s){const e=u;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}L=e===u,s=s||L}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),$=n===u}else $=!0;if($)if(void 0!==e.stdin){const t=u;if("boolean"!=typeof e.stdin)return we.errors=[{params:{type:"boolean"}}],!1;$=t===u}else $=!0}}}}}}c=t===u}else c=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return we.errors=p,0===u}
diff --git a/a.js b/b.js
@@ -3,4 +3,4 @@
A blob:6fa630d06b734aca19333e159d181ada3b90c74b
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
const r=/^(?:[A-Za-z]:[\\/]|\\\\|\/)/;module.exports=n,module.exports.default=n;const t=new RegExp("^https?://","u");function e(n,{instancePath:o="",parentData:s,parentDataProperty:a,rootData:l=n}={}){let i=null,p=0;if(0===p){if(!n||"object"!=typeof n||Array.isArray(n))return e.errors=[{params:{type:"object"}}],!1;{let o;if(void 0===n.allowedUris&&(o="allowedUris"))return e.errors=[{params:{missingProperty:o}}],!1;{const o=p;for(const r in n)if("allowedUris"!==r&&"cacheLocation"!==r&&"frozen"!==r&&"lockfileLocation"!==r&&"upgrade"!==r)return e.errors=[{params:{additionalProperty:r}}],!1;if(o===p){if(void 0!==n.allowedUris){let r=n.allowedUris;const o=p;if(p==p){if(!Array.isArray(r))return e.errors=[{params:{type:"array"}}],!1;{const n=r.length;for(let o=0;o<n;o++){let n=r[o];const s=p,a=p;let l=!1;const f=p;if(!(n instanceof RegExp)){const r={params:{}};null===i?i=[r]:i.push(r),p++}var c=f===p;if(l=l||c,!l){const r=p;if(p===r)if("string"==typeof n){if(!t.test(n)){const r={params:{pattern:"^https?://"}};null===i?i=[r]:i.push(r),p++}}else{const r={params:{type:"string"}};null===i?i=[r]:i.push(r),p++}if(c=r===p,l=l||c,!l){const r=p;if(!(n instanceof Function)){const r={params:{}};null===i?i=[r]:i.push(r),p++}c=r===p,l=l||c}}if(!l){const r={params:{}};return null===i?i=[r]:i.push(r),p++,e.errors=i,!1}if(p=a,null!==i&&(a?i.length=a:i=null),s!==p)break}}}var f=o===p}else f=!0;if(f){if(void 0!==n.cacheLocation){let t=n.cacheLocation;const o=p,s=p;let a=!1;const l=p;if(!1!==t){const r={params:{}};null===i?i=[r]:i.push(r),p++}var u=l===p;if(a=a||u,!a){const e=p;if(p===e)if("string"==typeof t){if(t.includes("!")||!0!==r.test(t)){const r={params:{}};null===i?i=[r]:i.push(r),p++}}else{const r={params:{type:"string"}};null===i?i=[r]:i.push(r),p++}u=e===p,a=a||u}if(!a){const r={params:{}};return null===i?i=[r]:i.push(r),p++,e.errors=i,!1}p=s,null!==i&&(s?i.length=s:i=null),f=o===p}else f=!0;if(f){if(void 0!==n.frozen){const r=p;if("boolean"!=typeof n.frozen)return e.errors=[{params:{type:"boolean"}}],!1;f=r===p}else f=!0;if(f){if(void 0!==n.lockfileLocation){let t=n.lockfileLocation;const o=p;if(p===o){if("string"!=typeof t)return e.errors=[{params:{type:"string"}}],!1;if(t.includes("!")||!0!==r.test(t))return e.errors=[{params:{}}],!1}f=o===p}else f=!0;if(f)if(void 0!==n.upgrade){const r=p;if("boolean"!=typeof n.upgrade)return e.errors=[{params:{type:"boolean"}}],!1;f=r===p}else f=!0}}}}}}}return e.errors=i,0===p}function n(r,{instancePath:t="",parentData:o,parentDataProperty:s,rootData:a=r}={}){let l=null,i=0;const p=i;let c=!1,f=null;const u=i;if(e(r,{instancePath:t,parentData:o,parentDataProperty:s,rootData:a})||(l=null===l?e.errors:l.concat(e.errors),i=l.length),u===i&&(c=!0,f=0),!c){const r={params:{passingSchemas:f}};return null===l?l=[r]:l.push(r),i++,n.errors=l,!1}return i=p,null!==l&&(p?l.length=p:l=null),n.errors=l,0===i}
diff --git a/a.js b/b.js
@@ -2,25 +2,6 @@
A blob:4fda2fc7cdc7e408997547d4939e46cde72d9fa1
const { describeCases } = require("./ConfigTestCases.template");

describeCases({
	name: "ConfigCacheTestCases",
	infrastructureLogErrors: {
		wasm: {
			// Can not compile wasm module
			["missing-wasm-experiment"]:
				/^Pack got invalid because of write to: Compilation\/modules.+wasm.wasm$/
		},
		parsing: {
			// Module parse failed
			context:
				/^Pack got invalid because of write to: Compilation\/modules|.+dump-file\.txt/
		},
		loaders: {
			// Error in loader
			options: [
				/^Pack got invalid because of write to: Compilation\/modules.+loaders[/\\]options[/\\]error1\.js$/,
				/^Pack got invalid because of write to: Compilation\/modules.+loaders[/\\]options[/\\]error2\.js$/
			]
		}
	},
	cache: {
		type: "filesystem",
		buildDependencies: {
			defaultWebpack: []
diff --git a/a.js b/b.js
@@ -17,7 +17,7 @@
A blob:e199b5abce8ee0791c69d5f523b6816527cc55df
const FakeDocument = require("./helpers/FakeDocument");
const CurrentScript = require("./helpers/CurrentScript");

const prepareOptions = require("./helpers/prepareOptions");
const { parseResource } = require("../lib/util/identifier");
const captureStdio = require("./helpers/captureStdio");
const asModule = require("./helpers/asModule");
const createInfrastructureLogErrorsChecker = require("./helpers/infrastructureLogErrors");

const casesPath = path.join(__dirname, "configCases");
const categories = fs.readdirSync(casesPath).map(cat => {
	return {
diff --git a/a.js b/b.js
@@ -64,11 +64,6 @@ describe(config.name, () => {
A blob:e199b5abce8ee0791c69d5f523b6816527cc55df
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					const infrastructureLogChecker = config.infrastructureLogErrors
						? createInfrastructureLogErrorsChecker(
								config.infrastructureLogErrors
						  )
						: undefined;
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
diff --git a/a.js b/b.js
@@ -211,17 +206,25 @@ describe(config.name, () => {
A blob:e199b5abce8ee0791c69d5f523b6816527cc55df
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					const infrastructureLogChecker = config.infrastructureLogErrors
						? createInfrastructureLogErrorsChecker(
								config.infrastructureLogErrors
						  )
						: undefined;
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const infraStructureLog = [];
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
									options.infrastructureLogging = {
										debug: true,
										console: createLogger(infraStructureLog)
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								infraStructureLog.length = 0;
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (infrastructureLogChecker) {
										const error = infrastructureLogChecker.check(
											category.name,
											testName,
											infraStructureLog,
											{
												run: 1,
												options
											}
										);
										if (error) return done(error);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
diff --git a/a.js b/b.js
@@ -272,17 +275,25 @@ describe(config.name, () => {
A blob:e199b5abce8ee0791c69d5f523b6816527cc55df
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					const infrastructureLogChecker = config.infrastructureLogErrors
						? createInfrastructureLogErrorsChecker(
								config.infrastructureLogErrors
						  )
						: undefined;
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const infraStructureLog = [];
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
									options.infrastructureLogging = {
										debug: true,
										console: createLogger(infraStructureLog)
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								infraStructureLog.length = 0;
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (infrastructureLogChecker) {
										const error = infrastructureLogChecker.check(
											category.name,
											testName,
											infraStructureLog,
											{
												run: 1,
												options
											}
										);
										if (error) return done(error);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
							it(`${testName} should pre-compile to fill disk cache (2nd)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								infraStructureLog.length = 0;
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, (err, stats) => {
									deprecationTracker();
									if (err) return handleFatalError(err, done);
									const { modules, children, errorsCount } = stats.toJson({
										all: false,
										modules: true,
										errorsCount: true
									});
									if (errorsCount === 0) {
										const infrastructureLogging = stderr.toString();
										if (infrastructureLogging) {
											return done(
												new Error(
													"Errors/Warnings during build:\n" +
														infrastructureLogging
												)
											);
										}
										const allModules = children
											? children.reduce(
													(all, { modules }) => all.concat(modules),
													modules || []
											  )
											: modules;
										if (
											allModules.some(
												m => m.type !== "cached modules" && !m.cached
											)
										) {
											return done(
												new Error(
													`Some modules were not cached:\n${stats.toString({
														all: false,
														modules: true,
														modulesSpace: 100
													})}`
												)
											);
										}
									}
									if (infrastructureLogChecker) {
										const error = infrastructureLogChecker.check(
											category.name,
											testName,
											infraStructureLog,
											{
												run: 2,
												options
											}
										);
										if (error) return done(error);
									}
									done();
								});
							}, 40000);
diff --git a/a.js b/b.js
@@ -355,17 +366,25 @@ describe(config.name, () => {
A blob:e199b5abce8ee0791c69d5f523b6816527cc55df
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					const infrastructureLogChecker = config.infrastructureLogErrors
						? createInfrastructureLogErrorsChecker(
								config.infrastructureLogErrors
						  )
						: undefined;
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const infraStructureLog = [];
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
									options.infrastructureLogging = {
										debug: true,
										console: createLogger(infraStructureLog)
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								infraStructureLog.length = 0;
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (infrastructureLogChecker) {
										const error = infrastructureLogChecker.check(
											category.name,
											testName,
											infraStructureLog,
											{
												run: 1,
												options
											}
										);
										if (error) return done(error);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
							it(`${testName} should pre-compile to fill disk cache (2nd)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								infraStructureLog.length = 0;
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, (err, stats) => {
									deprecationTracker();
									if (err) return handleFatalError(err, done);
									const { modules, children, errorsCount } = stats.toJson({
										all: false,
										modules: true,
										errorsCount: true
									});
									if (errorsCount === 0) {
										const infrastructureLogging = stderr.toString();
										if (infrastructureLogging) {
											return done(
												new Error(
													"Errors/Warnings during build:\n" +
														infrastructureLogging
												)
											);
										}
										const allModules = children
											? children.reduce(
													(all, { modules }) => all.concat(modules),
													modules || []
											  )
											: modules;
										if (
											allModules.some(
												m => m.type !== "cached modules" && !m.cached
											)
										) {
											return done(
												new Error(
													`Some modules were not cached:\n${stats.toString({
														all: false,
														modules: true,
														modulesSpace: 100
													})}`
												)
											);
										}
									}
									if (infrastructureLogChecker) {
										const error = infrastructureLogChecker.check(
											category.name,
											testName,
											infraStructureLog,
											{
												run: 2,
												options
											}
										);
										if (error) return done(error);
									}
									done();
								});
							}, 40000);
						}
						it(`${testName} should compile`, done => {
							rimraf.sync(outputDirectory);
							fs.mkdirSync(outputDirectory, { recursive: true });
							infraStructureLog.length = 0;
							const deprecationTracker = deprecationTracking.start();
							const onCompiled = (err, stats) => {
								const deprecations = deprecationTracker();
								if (err) return handleFatalError(err, done);
								const statOptions = {
									preset: "verbose",
									colors: false
								};
								fs.mkdirSync(outputDirectory, { recursive: true });
								fs.writeFileSync(
									path.join(outputDirectory, "stats.txt"),
									stats.toString(statOptions),
									"utf-8"
								);
								const jsonStats = stats.toJson({
									errorDetails: true
								});
								fs.writeFileSync(
									path.join(outputDirectory, "stats.json"),
									JSON.stringify(jsonStats, null, 2),
									"utf-8"
								);
								if (
									checkArrayExpectation(
										testDirectory,
										jsonStats,
										"error",
										"Error",
										done
									)
								) {
									return;
								}
								if (
									checkArrayExpectation(
										testDirectory,
										jsonStats,
										"warning",
										"Warning",
										done
									)
								) {
									return;
								}
								const infrastructureLogging = stderr.toString();
								if (infrastructureLogging) {
									return done(
										new Error(
											"Errors/Warnings during build:\n" + infrastructureLogging
										)
									);
								}
								if (
									checkArrayExpectation(
										testDirectory,
										{ deprecations },
										"deprecation",
										"Deprecation",
										done
									)
								) {
									return;
								}
								if (infrastructureLogChecker) {
									const error = infrastructureLogChecker.check(
										category.name,
										testName,
										infraStructureLog,
										{
											run: 1,
											options
										}
									);
									if (error) return done(error);
								}

								let filesCount = 0;

diff --git a/a.js b/b.js
@@ -13,64 +13,64 @@ const quoteMeta = str => {
A blob:5e6d9d8c01b21a4961cff77339a74e8e6db906ae
/**
 * Escapes regular expression metacharacters
 * @param {string} str String to quote
 * @returns {string} Escaped string
 */
const quoteMeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

describe("Defaults", () => {
	const cwd = process.cwd();
	const cwdRegExp = new RegExp(
		`${quoteMeta(cwd)}((?:\\\\)?(?:[a-zA-Z.\\-_]+\\\\)*)`,
		"g"
	);
	const escapedCwd = JSON.stringify(cwd).slice(1, -1);
	const escapedCwdRegExp = new RegExp(
		`${quoteMeta(escapedCwd)}((?:\\\\\\\\)?(?:[a-zA-Z.\\-_]+\\\\\\\\)*)`,
		"g"
	);
	const normalize = str => {
		if (cwd.startsWith("/")) {
			str = str.replace(new RegExp(quoteMeta(cwd), "g"), "<cwd>");
		} else {
			str = str.replace(cwdRegExp, (m, g) => `<cwd>${g.replace(/\\/g, "/")}`);
			str = str.replace(
				escapedCwdRegExp,
				(m, g) => `<cwd>${g.replace(/\\\\/g, "/")}`
			);
		}
		str = str.replace(/@@ -\d+,\d+ \+\d+,\d+ @@/g, "@@ ... @@");
		return str;
	};

	class Diff {
		constructor(value) {
			this.value = value;
		}
	}

	expect.addSnapshotSerializer({
		test(value) {
			return value instanceof Diff;
		},
		print(received) {
			return normalize(received.value);
		}
	});

	expect.addSnapshotSerializer({
		test(value) {
			return typeof value === "string";
		},
		print(received) {
			return JSON.stringify(normalize(received));
		}
	});

	const getDefaultConfig = config => {
		const { applyWebpackOptionsDefaults, getNormalizedWebpackOptions } =
			require("..").config;
		config = getNormalizedWebpackOptions(config);
		applyWebpackOptionsDefaults(config);
		process.chdir(cwd);
		return config;
	};

	const baseConfig = getDefaultConfig({ mode: "none" });

	it("should have the correct base config", () => {
		expect(baseConfig).toMatchInlineSnapshot(`
diff --git a/a.js b/b.js
@@ -1060,6 +1060,197 @@ test("library", { output: { library: ["myLib", "awesome"] } }, e =>
A blob:5e6d9d8c01b21a4961cff77339a74e8e6db906ae
		@@ ... @@
		-     "filename": "[name].js",
		+     "filename": [Function filename],
	`)
	);
	test("library", { output: { library: ["myLib", "awesome"] } }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received

		@@ ... @@
		-     "chunkLoadingGlobal": "webpackChunkwebpack",
		+     "chunkLoadingGlobal": "webpackChunkmyLib_awesome",
		@@ ... @@
		-     "devtoolNamespace": "webpack",
		+     "devtoolNamespace": "myLib.awesome",
		@@ ... @@
		-     "enabledLibraryTypes": Array [],
		+     "enabledLibraryTypes": Array [
		+       "var",
		+     ],
		@@ ... @@
		-     "hotUpdateGlobal": "webpackHotUpdatewebpack",
		+     "hotUpdateGlobal": "webpackHotUpdatemyLib_awesome",
		@@ ... @@
		-     "library": undefined,
		+     "library": Object {
		+       "auxiliaryComment": undefined,
		+       "export": undefined,
		+       "name": Array [
		+         "myLib",
		+         "awesome",
		+       ],
		+       "type": "var",
		+       "umdNamedDefine": undefined,
		+     },
		@@ ... @@
		-     "uniqueName": "webpack",
		+     "uniqueName": "myLib.awesome",
	`)
	);
	test("target node", { target: "node" }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received
diff --git a/a.js b/b.js
@@ -2018,3 +2209,27 @@ test(
A blob:5e6d9d8c01b21a4961cff77339a74e8e6db906ae
			@@ ... @@
			+       "async-node",
		`)
	);

	test(
		"experiments.futureDefaults",
		{
			experiments: {
				futureDefaults: true
			}
		},
		e =>
			e.toMatchInlineSnapshot(`
			- Expected
			+ Received

			@@ ... @@
			-     "asyncWebAssembly": false,
			-     "backCompat": true,
			+     "asyncWebAssembly": true,
			+     "backCompat": false,
			@@ ... @@
			-     "cacheUnaffected": false,
			-     "css": undefined,
			-     "futureDefaults": false,
			+     "cacheUnaffected": true,
			+     "css": Object {
			+       "exportsOnly": false,
			+     },
			+     "futureDefaults": true,
			@@ ... @@
			-     "topLevelAwait": false,
			+     "topLevelAwait": true,
			@@ ... @@
			+       },
			+       Object {
			+         "rules": Array [
			+           Object {
			+             "descriptionData": Object {
			+               "type": "module",
			+             },
			+             "resolve": Object {
			+               "fullySpecified": true,
			+             },
			+           },
			+         ],
			+         "test": /\\.wasm$/i,
			+         "type": "webassembly/async",
			+       },
			+       Object {
			+         "mimetype": "application/wasm",
			+         "rules": Array [
			+           Object {
			+             "descriptionData": Object {
			+               "type": "module",
			+             },
			+             "resolve": Object {
			+               "fullySpecified": true,
			+             },
			+           },
			+         ],
			+         "type": "webassembly/async",
			+       },
			+       Object {
			+         "oneOf": Array [
			+           Object {
			+             "resolve": Object {
			+               "fullySpecified": true,
			+             },
			+             "test": /\\.module\\.css$/i,
			+             "type": "css/module",
			+           },
			+           Object {
			+             "resolve": Object {
			+               "fullySpecified": true,
			+               "preferRelative": true,
			+             },
			+             "type": "css",
			+           },
			+         ],
			+         "test": /\\.css$/i,
			+       },
			+       Object {
			+         "mimetype": "text/css+module",
			+         "resolve": Object {
			+           "fullySpecified": true,
			+         },
			+         "type": "css/module",
			+       },
			+       Object {
			+         "mimetype": "text/css",
			+         "resolve": Object {
			+           "fullySpecified": true,
			+           "preferRelative": true,
			+         },
			+         "type": "css",
			@@ ... @@
			+         "exportsPresence": "error",
			@@ ... @@
			-     "__dirname": "mock",
			-     "__filename": "mock",
			-     "global": true,
			+     "__dirname": "warn-mock",
			+     "__filename": "warn-mock",
			+     "global": "warn",
			@@ ... @@
			+         "css",
			@@ ... @@
			-     "hashDigestLength": 20,
			-     "hashFunction": "md4",
			+     "hashDigestLength": 16,
			+     "hashFunction": "xxhash64",
			@@ ... @@
			-       "<cwd>/node_modules/",
			+       /^(.+?[\\\\/]node_modules[\\\\/])/,
		`)
	);
});

diff --git a/a.js b/b.js
@@ -99,6 +99,81 @@ it("should not have circular hashes but equal if unmodified", done => {
A blob:dd3fb6c490769ffdfae513ab0562eb50f0d6e8bf

const webpack = require("..");

describe("HotModuleReplacementPlugin", () => {
	jest.setTimeout(20000);
	it("should not have circular hashes but equal if unmodified", done => {
		const entryFile = path.join(
			__dirname,
			"js",
			"HotModuleReplacementPlugin",
			"entry.js"
		);
		const statsFile1 = path.join(
			__dirname,
			"js",
			"HotModuleReplacementPlugin",
			"HotModuleReplacementPlugin.test.stats1.txt"
		);
		const statsFile2 = path.join(
			__dirname,
			"js",
			"HotModuleReplacementPlugin",
			"HotModuleReplacementPlugin.test.stats2.txt"
		);
		const recordsFile = path.join(
			__dirname,
			"js",
			"HotModuleReplacementPlugin",
			"records.json"
		);
		try {
			fs.mkdirSync(path.join(__dirname, "js", "HotModuleReplacementPlugin"), {
				recursive: true
			});
		} catch (e) {
			// empty
		}
		try {
			fs.unlinkSync(recordsFile);
		} catch (e) {
			// empty
		}
		const compiler = webpack({
			cache: false,
			entry: entryFile,
			recordsPath: recordsFile,
			output: {
				path: path.join(__dirname, "js", "HotModuleReplacementPlugin")
			},
			plugins: [new webpack.HotModuleReplacementPlugin()],
			optimization: {
				moduleIds: "size",
				chunkIds: "size"
			}
		});
		fs.writeFileSync(entryFile, "1", "utf-8");
		compiler.run((err, stats) => {
			if (err) throw err;
			const oldHash1 = stats.toJson().hash;
			fs.writeFileSync(statsFile1, stats.toString());
			compiler.run((err, stats) => {
				if (err) throw err;
				const lastHash1 = stats.toJson().hash;
				fs.writeFileSync(statsFile2, stats.toString());
				expect(lastHash1).toBe(oldHash1); // hash shouldn't change when bundle stay equal
				fs.writeFileSync(entryFile, "2", "utf-8");
				compiler.run((err, stats) => {
					if (err) throw err;
					const lastHash2 = stats.toJson().hash;
					fs.writeFileSync(statsFile1, stats.toString());
					expect(lastHash2).not.toBe(lastHash1); // hash should change when bundle changes
					fs.writeFileSync(entryFile, "1", "utf-8");
					compiler.run((err, stats) => {
						if (err) throw err;
						const currentHash1 = stats.toJson().hash;
						fs.writeFileSync(statsFile2, stats.toString());
						expect(currentHash1).not.toBe(lastHash1); // hash shouldn't change to the first hash if bundle changed back to first bundle
						fs.writeFileSync(entryFile, "2", "utf-8");
						compiler.run((err, stats) => {
							if (err) throw err;
							const currentHash2 = stats.toJson().hash;
							fs.writeFileSync(statsFile1, stats.toString());
							compiler.run((err, stats) => {
								if (err) throw err;
								expect(stats.toJson().hash).toBe(currentHash2);
								expect(currentHash2).not.toBe(lastHash2);
								expect(currentHash1).not.toBe(currentHash2);
								expect(lastHash1).not.toBe(lastHash2);
								done();
							});
						});
					});
				});
			});
		});
	}, 120000);

	it("should correct working when entry is Object and key is a number", done => {
		const outputPath = path.join(__dirname, "js", "HotModuleReplacementPlugin");
		const entryFile = path.join(outputPath, "entry.js");
		const statsFile3 = path.join(
diff --git a/a.js b/b.js
@@ -37,16 +37,17 @@ const createSimpleCompiler = progressOptions => {
A blob:d8a2bffadc3e81aceed27cfb484bab7c78b222da
	new webpack.ProgressPlugin(progressOptions).apply(compiler);

	return compiler;
};

const createSimpleCompiler = progressOptions => {
	const compiler = webpack({
		context: path.join(__dirname, "fixtures"),
		entry: "./a.js",
		infrastructureLogging: {
			debug: /Progress/
		}
	});

	compiler.outputFileSystem = createFsFromVolume(new Volume());

	new webpack.ProgressPlugin({
		activeModules: true,
		...progressOptions
	}).apply(compiler);

	return compiler;
};

const createSimpleCompilerWithCustomHandler = options => {
diff --git a/a.js b/b.js
@@ -115,6 +116,15 @@ it(
A blob:d8a2bffadc3e81aceed27cfb484bab7c78b222da
	);
	it(
		"should not contain NaN as a percentage when it is applied to MultiCompiler",
		nanTest(createMultiCompiler)
	);
	it(
		"should not contain NaN as a percentage when it is applied to MultiCompiler (parallelism: 1)",
		nanTest(() => createMultiCompiler(undefined, { parallelism: 1 }))
	);

	it("should print profile information", () => {
		const compiler = createSimpleCompiler({
			profile: true
		});
diff --git a/a.js b/b.js
@@ -11,7 +11,7 @@
A blob:486f1a537663fbd82a058a8239aad3d5b3b563d8
const { pathToFileURL, URL } = require("url");
const rimraf = require("rimraf");
const checkArrayExpectation = require("./checkArrayExpectation");
const createLazyTestEnv = require("./helpers/createLazyTestEnv");
const deprecationTracking = require("./helpers/deprecationTracking");
const captureStdio = require("./helpers/captureStdio");
const asModule = require("./helpers/asModule");
const createInfrastructureLogErrorsChecker = require("./helpers/infrastructureLogErrors");

const casesPath = path.join(__dirname, "cases");
let categories = fs.readdirSync(casesPath);
categories = categories.map(cat => {
diff --git a/a.js b/b.js
@@ -70,11 +70,6 @@ describe(config.name, () => {
A blob:486f1a537663fbd82a058a8239aad3d5b3b563d8
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						let infraStructureLog = [];
						const infrastructureLogChecker = config.infrastructureLogErrors
							? createInfrastructureLogErrorsChecker(
									config.infrastructureLogErrors
							  )
							: undefined;

						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
diff --git a/a.js b/b.js
@@ -245,17 +240,23 @@ describe(config.name, () => {
A blob:486f1a537663fbd82a058a8239aad3d5b3b563d8
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						let infraStructureLog = [];
						const infrastructureLogChecker = config.infrastructureLogErrors
							? createInfrastructureLogErrorsChecker(
									config.infrastructureLogErrors
							  )
							: undefined;

						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								},
								infrastructureLogging: config.cache && {
									debug: true,
									console: createLogger(infraStructureLog)
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 1,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
diff --git a/a.js b/b.js
@@ -277,17 +278,23 @@ describe(config.name, () => {
A blob:486f1a537663fbd82a058a8239aad3d5b3b563d8
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						let infraStructureLog = [];
						const infrastructureLogChecker = config.infrastructureLogErrors
							? createInfrastructureLogErrorsChecker(
									config.infrastructureLogErrors
							  )
							: undefined;

						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								},
								infrastructureLogging: config.cache && {
									debug: true,
									console: createLogger(infraStructureLog)
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 1,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 2,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
diff --git a/a.js b/b.js
@@ -306,17 +313,23 @@ describe(config.name, () => {
A blob:486f1a537663fbd82a058a8239aad3d5b3b563d8
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						let infraStructureLog = [];
						const infrastructureLogChecker = config.infrastructureLogErrors
							? createInfrastructureLogErrorsChecker(
									config.infrastructureLogErrors
							  )
							: undefined;

						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								},
								infrastructureLogging: config.cache && {
									debug: true,
									console: createLogger(infraStructureLog)
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 1,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 2,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
								);
							}
							it(
								testName + " should compile",
								done => {
									infraStructureLog.length = 0;
									const webpack = require("..");
									const compiler = webpack(options);
									const run = () => {
										const deprecationTracker = deprecationTracking.start();
										compiler.run((err, stats) => {
											const deprecations = deprecationTracker();
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 3,
														options
													}
												);
												if (error) return done(error);
											}
											compiler.close(err => {
												if (err) return done(err);
												const statOptions = {
diff --git a/a.js b/b.js
@@ -414,7 +427,7 @@ describe(config.name, () => {
A blob:486f1a537663fbd82a058a8239aad3d5b3b563d8
		status: () => {}
	};
};

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						let infraStructureLog = [];
						const infrastructureLogChecker = config.infrastructureLogErrors
							? createInfrastructureLogErrorsChecker(
									config.infrastructureLogErrors
							  )
							: undefined;

						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								},
								infrastructureLogging: config.cache && {
									debug: true,
									console: createLogger(infraStructureLog)
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 1,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										infraStructureLog.length = 0;
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 2,
														options
													}
												);
												if (error) return done(error);
											}
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
								);
							}
							it(
								testName + " should compile",
								done => {
									infraStructureLog.length = 0;
									const webpack = require("..");
									const compiler = webpack(options);
									const run = () => {
										const deprecationTracker = deprecationTracking.start();
										compiler.run((err, stats) => {
											const deprecations = deprecationTracker();
											if (err) return done(err);
											if (infrastructureLogChecker) {
												const error = infrastructureLogChecker.check(
													category.name,
													testName,
													infraStructureLog,
													{
														run: 3,
														options
													}
												);
												if (error) return done(error);
											}
											compiler.close(err => {
												if (err) return done(err);
												const statOptions = {
													preset: "verbose",
													colors: false,
													modules: true,
													reasonsSpace: 1000
												};
												fs.mkdirSync(outputDirectory, { recursive: true });
												fs.writeFileSync(
													path.join(outputDirectory, "stats.txt"),
													stats.toString(statOptions),
													"utf-8"
												);
												const jsonStats = stats.toJson({
													errorDetails: true,
													modules: false,
													assets: false,
													chunks: false
												});
												if (
													checkArrayExpectation(
														testDirectory,
														jsonStats,
														"error",
														"Error",
														done
													)
												) {
													return;
												}
												if (
													checkArrayExpectation(
														testDirectory,
														jsonStats,
														"warning",
														"Warning",
														done
													)
												) {
													return;
												}
												const infrastructureLogging = stderr.toString();
												if (infrastructureLogging) {
													done(
														new Error(
															"Errors/Warnings during build:\n" +
																infrastructureLogging
														)
													);
												}

												expect(deprecations).toEqual(config.deprecations || []);

												Promise.resolve().then(done);
											});
										});
									};
									if (config.cache) {
										// pre-compile to fill memory cache
										const deprecationTracker = deprecationTracking.start();
										compiler.run(err => {
											deprecationTracker();
											if (err) return done(err);
											run();
										});
									} else {
										run();
									}
								},
								testConfig.cachedTimeout ||
									testConfig.timeout ||
									(config.cache ? 20000 : 60000)
							);

							it(
								testName + " should load the compiled tests",
								done => {
									const esmContext = vm.createContext({
										it: _it,
										expect,
										process,
										global,
										URL,
										Buffer,
										setTimeout,
										setImmediate,
										nsObj: function (m) {
											Object.defineProperty(m, Symbol.toStringTag, {
												value: "Module"
											});
											return m;
										}
									});
									cleanups.push(() => (esmContext.it = undefined));
									function _require(module, esmMode) {
										if (module.substr(0, 2) === "./") {
											const p = path.join(outputDirectory, module);
											const content = fs.readFileSync(p, "utf-8");
											if (p.endsWith(".mjs")) {
												let esm;
diff --git a/a.js b/b.js
@@ -4,33 +4,6 @@
A blob:a5d781893d9584eb5d633602a56d4672e1088408
const path = require("path");
const { describeCases } = require("./TestCases.template");

describe("TestCases", () => {
	describeCases({
		name: "cache pack",
		infrastructureLogErrors: {
			compile: {
				// Module build failed
				["error-hide-stack"]:
					/^Pack got invalid because of write to: Compilation\/modules.+loader\.js!$/
			},
			errors: {
				// load module failed, error in loader
				["load-module-error"]:
					/^Pack got invalid because of write to: Compilation\/modules|json.+error-loader\.js!/
			},
			json: {
				// Module build failed, not a valid JSON
				["import-assertions-type-json"]:
					/^Pack got invalid because of write to: Compilation\/modules|json.+json\/data\/poison$/
			},
			loaders: {
				// Module build failed
				["no-string"]:
					/^Pack got invalid because of write to: Compilation\/modules.+no-string[/\\]loader\.js!.+no-string[/\\]file\.js$/
			},
			parsing: {
				// Module parse failed
				context:
					/^Pack got invalid because of write to: Compilation\/modules|.+dump-file\.txt/
			}
		},
		cache: {
			type: "filesystem",
			buildDependencies: {
				defaultWebpack: []
diff --git a/a.js b/b.js
@@ -1,25 +1,15 @@
A blob:6aa0c3c30cade13e80a09da7399497f612047e56
var fs = require("fs");

var findFile = function(files, regex) {
	return files.find(function(file) {
		if (regex.test(file)) {
			return true;
		}
	});
};

const allFilenameHashes = new Set();
const allChunkHashes = new Set();

module.exports = {
	findBundle: function(i, options) {
		var files = fs.readdirSync(options.output.path);

		const filename = findFile(files, new RegExp(`^bundle${i}`));
		const filenameHash = /\.([a-f0-9]+)\.js$/.exec(filename)[1];
		allFilenameHashes.add(filenameHash);

		const chunk = findFile(files, new RegExp(`^chunk${i}`));
		const chunkHash = /\.([a-f0-9]+)\.js$/.exec(chunk)[1];
		allChunkHashes.add(chunkHash);

		return "./" + filename;
diff --git a/a.js b/b.js
@@ -10,9 +10,9 @@
A blob:7fda0c72cbbf9c12fa07316624a435967377fd88
			compiler.hooks.compilation.tap("Test", compilation => {
				expect(compilation.outputOptions.environment).toMatchInlineSnapshot(`
			Object {
			  "arrowFunction": true,
			  "bigIntLiteral": true,
			  "const": true,
			  "destructuring": true,
			  "dynamicImport": false,
			  "forOf": true,
			  "module": false,
			}
		`);
				expect(compilation.options.externalsPresets).toMatchInlineSnapshot(`
			Object {
diff --git a/a.js b/b.js
@@ -12,68 +12,18 @@ const PERSISTENCE_CACHE_INVALIDATE_ERROR = (log, config) => {
A blob:af7bf81406238c2f516e086faa1a7939412ccb39
"use strict";

const PERSISTENCE_CACHE_INVALIDATE_ERROR = (log, config) => {
	if (config.run < 2) return;
	const match =
		/^\[webpack\.cache\.PackFileCacheStrategy\] Pack got invalid because of write to:(.+)$/.exec(
			log
		);
	if (match) {
		return `Pack got invalid because of write to: ${match[1].trim()}`;
	}
};
const errorsFilter = [PERSISTENCE_CACHE_INVALIDATE_ERROR];

const checkErrors = (logs, config) => {
	const results = [];
	for (const log of logs) {
		for (const filter of errorsFilter) {
			const result = filter(log, config);
			if (result) results.push(result);
		}
	}
	return results;
};

/**
 * @param {{[k: string]: {[k: string]: RegExp|RegExp[]}}} config config
 * @returns {{check(category: string, test: string, log: string[], config: Object): Error|void, restErrors(): string[]}} checker
 */
module.exports = function createInfrastructureLogErrorsChecker(config) {
	const expectedInfrastructureErrorsMap = new Map();
	const restRegexps = new Set();
	for (const category of Object.keys(config)) {
		for (const testName of Object.keys(config[category])) {
			let byCategory = expectedInfrastructureErrorsMap.get(category);
			if (!byCategory) {
				byCategory = new Map();
				expectedInfrastructureErrorsMap.set(category, byCategory);
			}
			const regexps = config[category][testName];
			if (Array.isArray(regexps)) {
				for (const reg of regexps) restRegexps.add(reg);
				byCategory.set(testName, regexps.slice());
			} else {
				restRegexps.add(regexps);
				byCategory.set(testName, [regexps]);
			}
		}
	}

	function check(category, testName, log, config) {
		let results = checkErrors(log, config);
		if (results.length === 0) return;

		const byCategory = expectedInfrastructureErrorsMap.get(category);
		if (!byCategory) return new Error(results[0]);
		const filters = byCategory.get(testName);
		if (!filters) return new Error(results[0]);

		for (const filter of filters) {
			let n = results.length;
			results = results.filter(r => !filter.test(r));
			if (n !== results.length) restRegexps.delete(filter);
		}

		if (results.length !== 0) return new Error(results[0]);
	}

	function restErrors() {
		if (restRegexps.size === 0) return [];
		// make deterministic result based on remaining regexps
		// not on config key order
		return Array.from(restRegexps)
			.map(r => r.toString())
			.sort()[0];
	}

	return { check, restErrors };
};

diff --git a/a.js b/b.js
@@ -97,6 +97,15 @@
A blob:12d51f105b2c028906ea6e1129ea74994b8be363
class RuntimePlugin {
	/**
	 * @param {Compiler} compiler the Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap("RuntimePlugin", compilation => {
			compilation.dependencyTemplates.set(
				RuntimeRequirementsDependency,
				new RuntimeRequirementsDependency.Template()
			);
diff --git a/a.js b/b.js
@@ -417,8 +426,7 @@ apply(compiler) {
A blob:12d51f105b2c028906ea6e1129ea74994b8be363
class RuntimePlugin {
	/**
	 * @param {Compiler} compiler the Compiler
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap("RuntimePlugin", compilation => {
			compilation.dependencyTemplates.set(
				RuntimeRequirementsDependency,
				new RuntimeRequirementsDependency.Template()
			);
			for (const req of GLOBALS_ON_REQUIRE) {
				compilation.hooks.runtimeRequirementInModule
					.for(req)
					.tap("RuntimePlugin", (module, set) => {
						set.add(RuntimeGlobals.requireScope);
					});
				compilation.hooks.runtimeRequirementInTree
					.for(req)
					.tap("RuntimePlugin", (module, set) => {
						set.add(RuntimeGlobals.requireScope);
					});
			}
			for (const req of Object.keys(TREE_DEPENDENCIES)) {
				const deps = TREE_DEPENDENCIES[req];
				compilation.hooks.runtimeRequirementInTree
					.for(req)
					.tap("RuntimePlugin", (chunk, set) => {
						for (const dep of deps) set.add(dep);
					});
			}
			for (const req of Object.keys(MODULE_DEPENDENCIES)) {
				const deps = MODULE_DEPENDENCIES[req];
				compilation.hooks.runtimeRequirementInModule
					.for(req)
					.tap("RuntimePlugin", (chunk, set) => {
						for (const dep of deps) set.add(dep);
					});
			}
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.definePropertyGetters)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new DefinePropertyGettersRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.makeNamespaceObject)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new MakeNamespaceObjectRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.createFakeNamespaceObject)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new CreateFakeNamespaceObjectRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.hasOwnProperty)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new HasOwnPropertyRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.compatGetDefaultExport)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(
						chunk,
						new CompatGetDefaultExportRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.runtimeId)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(chunk, new RuntimeIdRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.publicPath)
				.tap("RuntimePlugin", (chunk, set) => {
					const { outputOptions } = compilation;
					const { publicPath: globalPublicPath, scriptType } = outputOptions;
					const entryOptions = chunk.getEntryOptions();
					const publicPath =
						entryOptions && entryOptions.publicPath !== undefined
							? entryOptions.publicPath
							: globalPublicPath;

					if (publicPath === "auto") {
						const module = new AutoPublicPathRuntimeModule();
						if (scriptType !== "module") set.add(RuntimeGlobals.global);
						compilation.addRuntimeModule(chunk, module);
					} else {
						const module = new PublicPathRuntimeModule(publicPath);

						if (
							typeof publicPath !== "string" ||
							/\[(full)?hash\]/.test(publicPath)
						) {
							module.fullHash = true;
						}

						compilation.addRuntimeModule(chunk, module);
					}
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.global)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(chunk, new GlobalRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.asyncModule)
				.tap("RuntimePlugin", chunk => {
					compilation.addRuntimeModule(chunk, new AsyncModuleRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.systemContext)
				.tap("RuntimePlugin", chunk => {
					const { outputOptions } = compilation;
					const { library: globalLibrary } = outputOptions;
					const entryOptions = chunk.getEntryOptions();
					const libraryType =
						entryOptions && entryOptions.library !== undefined
							? entryOptions.library.type
							: globalLibrary.type;

					if (libraryType === "system") {
						compilation.addRuntimeModule(
							chunk,
							new SystemContextRuntimeModule()
						);
					}
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getChunkScriptFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						typeof compilation.outputOptions.chunkFilename === "string" &&
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.chunkFilename
						)
					) {
						set.add(RuntimeGlobals.getFullHash);
					}
					compilation.addRuntimeModule(
						chunk,
						new GetChunkFilenameRuntimeModule(
							"javascript",
							"javascript",
							RuntimeGlobals.getChunkScriptFilename,
							chunk =>
								chunk.filenameTemplate ||
								(chunk.canBeInitial()
									? compilation.outputOptions.filename
									: compilation.outputOptions.chunkFilename),
							false
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getChunkCssFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						typeof compilation.outputOptions.cssChunkFilename === "string" &&
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.cssChunkFilename
						)
					) {
						set.add(RuntimeGlobals.getFullHash);
					}
					compilation.addRuntimeModule(
						chunk,
						new GetChunkFilenameRuntimeModule(
							"css",
							"css",
							RuntimeGlobals.getChunkCssFilename,
							chunk =>
								getChunkFilenameTemplate(chunk, compilation.outputOptions),
							set.has(RuntimeGlobals.hmrDownloadUpdateHandlers)
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getChunkUpdateScriptFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.hotUpdateChunkFilename
						)
					)
						set.add(RuntimeGlobals.getFullHash);
					compilation.addRuntimeModule(
						chunk,
						new GetChunkFilenameRuntimeModule(
							"javascript",
							"javascript update",
							RuntimeGlobals.getChunkUpdateScriptFilename,
							c => compilation.outputOptions.hotUpdateChunkFilename,
							true
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getUpdateManifestFilename)
				.tap("RuntimePlugin", (chunk, set) => {
					if (
						/\[(full)?hash(:\d+)?\]/.test(
							compilation.outputOptions.hotUpdateMainFilename
						)
					) {
						set.add(RuntimeGlobals.getFullHash);
					}
					compilation.addRuntimeModule(
						chunk,
						new GetMainFilenameRuntimeModule(
							"update manifest",
							RuntimeGlobals.getUpdateManifestFilename,
							compilation.outputOptions.hotUpdateMainFilename
						)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.ensureChunk)
				.tap("RuntimePlugin", (chunk, set) => {
					const hasAsyncChunks = chunk.hasAsyncChunks();
					if (hasAsyncChunks) {
						set.add(RuntimeGlobals.ensureChunkHandlers);
					}
					compilation.addRuntimeModule(
						chunk,
						new EnsureChunkRuntimeModule(set)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.ensureChunkIncludeEntries)
				.tap("RuntimePlugin", (chunk, set) => {
					set.add(RuntimeGlobals.ensureChunkHandlers);
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.shareScopeMap)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(chunk, new ShareRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.loadScript)
				.tap("RuntimePlugin", (chunk, set) => {
					const withCreateScriptUrl = !!compilation.outputOptions.trustedTypes;
					if (withCreateScriptUrl) {
						set.add(RuntimeGlobals.createScriptUrl);
					}
					compilation.addRuntimeModule(
						chunk,
						new LoadScriptRuntimeModule(withCreateScriptUrl)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.createScript)
				.tap("RuntimePlugin", (chunk, set) => {
					if (compilation.outputOptions.trustedTypes) {
						set.add(RuntimeGlobals.getTrustedTypesPolicy);
					}
					compilation.addRuntimeModule(chunk, new CreateScriptRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.createScriptUrl)
				.tap("RuntimePlugin", (chunk, set) => {
					if (compilation.outputOptions.trustedTypes) {
						set.add(RuntimeGlobals.getTrustedTypesPolicy);
					}
					compilation.addRuntimeModule(
						chunk,
						new CreateScriptUrlRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.getTrustedTypesPolicy)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(
						chunk,
						new GetTrustedTypesPolicyRuntimeModule(set)
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.relativeUrl)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(chunk, new RelativeUrlRuntimeModule());
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.onChunksLoaded)
				.tap("RuntimePlugin", (chunk, set) => {
					compilation.addRuntimeModule(
						chunk,
						new OnChunksLoadedRuntimeModule()
					);
					return true;
				});
			compilation.hooks.runtimeRequirementInTree
				.for(RuntimeGlobals.baseURI)
				.tap("RuntimePlugin", chunk => {
					const { chunkLoading } = chunk.getEntryOptions();
					if (chunkLoading === false) {
						compilation.addRuntimeModule(chunk, new BaseUriRuntimeModule());
						return true;
					}
				});
diff --git a/a.js b/b.js
@@ -10,7 +10,6 @@
A blob:d00336ed34bde2e8ed5571e2053a12d9f62e35c6
"use strict";

const HotModuleReplacementPlugin = require("../HotModuleReplacementPlugin");
const InnerGraph = require("../optimize/InnerGraph");
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes } = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
diff --git a/a.js b/b.js
@@ -84,6 +83,18 @@ constructor(options) {
A blob:d00336ed34bde2e8ed5571e2053a12d9f62e35c6

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.exportsPresence)
				: options.strictExportPresence
				? ExportPresenceModes.ERROR
				: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
diff --git a/a.js b/b.js
@@ -132,45 +143,6 @@ apply(parser) {
A blob:d00336ed34bde2e8ed5571e2053a12d9f62e35c6

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in",
					leftPart,
					rightPart.range
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = true;
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
diff --git a/a.js b/b.js
@@ -194,51 +166,83 @@ apply(parser) {
A blob:d00336ed34bde2e8ed5571e2053a12d9f62e35c6

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					settings.assertions,
					"in",
					leftPart,
					rightPart.range
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = true;
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const { arguments: args, callee } = expr;
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					callee.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.directImport = members.length === 0;
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(callee.range[0]);
				// only in case when we strictly follow the spec we need a special case here
				dep.namespaceObjectAsContext =
					members.length > 0 && this.strictThisContextOnImports;
				dep.loc = callee.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		const { hotAcceptCallback, hotAcceptWithoutCallback } =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
diff --git a/a.js b/b.js
@@ -43,6 +43,7 @@
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
	tryRunOrWebpackError
} = require("./HookWebpackError");
const MainTemplate = require("./MainTemplate");
const Module = require("./Module");
const ModuleDependencyError = require("./ModuleDependencyError");
const ModuleDependencyWarning = require("./ModuleDependencyWarning");
const ModuleGraph = require("./ModuleGraph");
const ModuleNotFoundError = require("./ModuleNotFoundError");
const ModuleProfile = require("./ModuleProfile");
const ModuleRestoreError = require("./ModuleRestoreError");
const ModuleStoreError = require("./ModuleStoreError");
diff --git a/a.js b/b.js
@@ -3327,7 +3328,8 @@ _codeGenerationModule(
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
	 * @param {WebpackError[]} errors errors
	 * @param {CodeGenerationResults} results results
	 * @param {function(WebpackError=, boolean=): void} callback callback
	 */
	_codeGenerationModule(
		module,
		runtime,
		runtimes,
		hash,
		dependencyTemplates,
		chunkGraph,
		moduleGraph,
		runtimeTemplate,
		errors,
		results,
		callback
	) {
		let codeGenerated = false;
		const cache = new MultiItemCache(
			runtimes.map(runtime =>
				this._codeGenerationCache.getItemCache(
					`${module.identifier()}|${getRuntimeKey(runtime)}`,
					`${hash}|${dependencyTemplates.getHash()}`
				)
			)
		);
		cache.get((err, cachedResult) => {
			if (err) return callback(err);
			let result;
			if (!cachedResult) {
				try {
					codeGenerated = true;
					this.codeGeneratedModules.add(module);
					result = module.codeGeneration({
						chunkGraph,
						moduleGraph,
						dependencyTemplates,
						runtimeTemplate,
						runtime,
						codeGenerationResults: results
					});
				} catch (err) {
					errors.push(new CodeGenerationError(module, err));
					result = cachedResult = {
diff --git a/a.js b/b.js
@@ -3883,6 +3885,7 @@ createModuleHashes() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
diff --git a/a.js b/b.js
@@ -3893,7 +3896,7 @@ createModuleHashes() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
diff --git a/a.js b/b.js
@@ -3907,13 +3910,20 @@ createModuleHashes() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
				}
				statModulesHashed++;
				const digest = this._createModuleHash(
					module,
					chunkGraph,
					runtime,
					hashFunction,
					runtimeTemplate,
					hashDigest,
					hashDigestLength
				);
				if (memCache) {
					memCache.set(`moduleHash-${getRuntimeKey(runtime)}`, digest);
				}
			}
		}
		this.logger.log(
			`${statModulesHashed} modules hashed, ${statModulesFromCache} from cache (${
				Math.round(
					(100 * (statModulesHashed + statModulesFromCache)) / this.modules.size
diff --git a/a.js b/b.js
@@ -3930,22 +3940,27 @@ _createModuleHash(
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
				) / 100
			} variants per module in average)`
		);
	}

	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength
	) {
		const moduleHash = createHash(hashFunction);
		module.updateHash(moduleHash, {
			chunkGraph,
			runtime,
			runtimeTemplate
		});
		const moduleHashDigest = /** @type {string} */ (
			moduleHash.digest(hashDigest)
		);
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

diff --git a/a.js b/b.js
@@ -4091,6 +4106,7 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
diff --git a/a.js b/b.js
@@ -4105,7 +4121,8 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
diff --git a/a.js b/b.js
@@ -4129,9 +4146,9 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
diff --git a/a.js b/b.js
@@ -4147,7 +4164,7 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
diff --git a/a.js b/b.js
@@ -4162,13 +4179,19 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
diff --git a/a.js b/b.js
@@ -4188,7 +4211,7 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
diff --git a/a.js b/b.js
@@ -4199,7 +4222,7 @@ createHash() {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest = /** @type {string} */ (
				chunkHash.digest(hashDigest)
			);
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd("hashing: process full hash modules");
		return codeGenerationJobs;
diff --git a/a.js b/b.js
@@ -4801,6 +4824,9 @@ executeModule(module, options, callback) {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
diff --git a/a.js b/b.js
@@ -4810,15 +4836,14 @@ executeModule(module, options, callback) {
A blob:066b8c1f29d75b607da24f3aeb8dbad571c06b17
	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
				}

				const codeGenerationResults = new CodeGenerationResults(
					this.outputOptions.hashFunction
				);
				/** @type {WebpackError[]} */
				const errors = [];
				/**
				 * @param {Module} module the module
				 * @param {Callback} callback callback
				 * @returns {void}
diff --git a/a.js b/b.js
@@ -14,7 +14,6 @@
A blob:f6a071cea5c7dc05f702bdc9890d3b8d9c699a53
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes } = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
const HarmonyInOperatorImportSpecifierDependency = require("./HarmonyInOperatorImportSpecifierDependency");

/** @typedef {import("estree").ExportAllDeclaration} ExportAllDeclaration */
/** @typedef {import("estree").ExportNamedDeclaration} ExportNamedDeclaration */
/** @typedef {import("estree").Identifier} Identifier */
diff --git a/a.js b/b.js
@@ -84,6 +83,18 @@ constructor(options) {
A blob:f6a071cea5c7dc05f702bdc9890d3b8d9c699a53

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.exportsPresence)
				: options.strictExportPresence
				? ExportPresenceModes.ERROR
				: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
diff --git a/a.js b/b.js
@@ -132,40 +143,6 @@ apply(parser) {
A blob:f6a071cea5c7dc05f702bdc9890d3b8d9c699a53

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyInOperatorImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					false,
					settings.assertions
				);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
diff --git a/a.js b/b.js
@@ -189,51 +166,83 @@ apply(parser) {
A blob:f6a071cea5c7dc05f702bdc9890d3b8d9c699a53

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const { exportPresenceMode } = this;
		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier} */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				}
			});
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
				const assertions = getAssertions(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.lastHarmonyImportOrder,
					assertions
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					assertions: getAssertions(statement)
				});
				return true;
			}
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPart = parser.evaluateExpression(expression.left).asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = rootInfo.tagInfo.data;
				const members = rightPart.getMembers();
				const dep = new HarmonyInOperatorImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					expression.range,
					false,
					settings.assertions
				);
				dep.loc = expression.loc;
				parser.state.module.addDependency(dep);
				return true;
			}
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					expr.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", (expr, members) => {
				const { arguments: args, callee } = expr;
				const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
				const ids = settings.ids.concat(members);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					ids,
					settings.name,
					callee.range,
					exportPresenceMode,
					settings.assertions
				);
				dep.directImport = members.length === 0;
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(callee.range[0]);
				// only in case when we strictly follow the spec we need a special case here
				dep.namespaceObjectAsContext =
					members.length > 0 && this.strictThisContextOnImports;
				dep.loc = callee.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			});
		const { hotAcceptCallback, hotAcceptWithoutCallback } =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
diff --git a/a.js b/b.js
@@ -14,7 +14,6 @@
A blob:d7ecc3bacbbb2875b6337fedd610602a9bc2351f
const HarmonyCompatibilityDependency = require("./HarmonyCompatibilityDependency");
const HarmonyExportExpressionDependency = require("./HarmonyExportExpressionDependency");
const HarmonyExportHeaderDependency = require("./HarmonyExportHeaderDependency");
const HarmonyExportImportedSpecifierDependency = require("./HarmonyExportImportedSpecifierDependency");
const HarmonyExportSpecifierDependency = require("./HarmonyExportSpecifierDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");
const HarmonyInOperatorImportSpecifierDependency = require("./HarmonyInOperatorImportSpecifierDependency");

const HarmonyDetectionParserPlugin = require("./HarmonyDetectionParserPlugin");
const HarmonyExportDependencyParserPlugin = require("./HarmonyExportDependencyParserPlugin");
const HarmonyImportDependencyParserPlugin = require("./HarmonyImportDependencyParserPlugin");
diff --git a/a.js b/b.js
@@ -60,15 +59,6 @@ apply(compiler) {
A blob:d7ecc3bacbbb2875b6337fedd610602a9bc2351f
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"HarmonyModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyTemplates.set(
					HarmonyCompatibilityDependency,
					new HarmonyCompatibilityDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSideEffectDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSideEffectDependency,
					new HarmonyImportSideEffectDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSpecifierDependency,
					new HarmonyImportSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyInOperatorImportSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyInOperatorImportSpecifierDependency,
					new HarmonyInOperatorImportSpecifierDependency.Template()
				);

				compilation.dependencyTemplates.set(
					HarmonyExportHeaderDependency,
					new HarmonyExportHeaderDependency.Template()
				);
diff --git a/a.js b/b.js
@@ -103,8 +103,6 @@
A blob:09bef3d57d926704dbc6bc78618b7097f305daf8
		require("../dependencies/HarmonyExportImportedSpecifierDependency"),
	"dependencies/HarmonyExportSpecifierDependency": () =>
		require("../dependencies/HarmonyExportSpecifierDependency"),
	"dependencies/HarmonyImportSideEffectDependency": () =>
		require("../dependencies/HarmonyImportSideEffectDependency"),
	"dependencies/HarmonyImportSpecifierDependency": () =>
		require("../dependencies/HarmonyImportSpecifierDependency"),
	"dependencies/HarmonyInOperatorImportSpecifierDependency": () =>
		require("../dependencies/HarmonyInOperatorImportSpecifierDependency"),
	"dependencies/ImportContextDependency": () =>
		require("../dependencies/ImportContextDependency"),
	"dependencies/ImportDependency": () =>
		require("../dependencies/ImportDependency"),
diff --git a/a.js b/b.js
@@ -128,6 +126,8 @@
A blob:09bef3d57d926704dbc6bc78618b7097f305daf8
		require("../dependencies/ModuleHotAcceptDependency"),
	"dependencies/ModuleHotDeclineDependency": () =>
		require("../dependencies/ModuleHotDeclineDependency"),
	"dependencies/ImportMetaHotAcceptDependency": () =>
		require("../dependencies/ImportMetaHotAcceptDependency"),
	"dependencies/ImportMetaHotDeclineDependency": () =>
		require("../dependencies/ImportMetaHotDeclineDependency"),
	"dependencies/ProvidedDependency": () =>
		require("../dependencies/ProvidedDependency"),
	"dependencies/PureExpressionDependency": () =>
		require("../dependencies/PureExpressionDependency"),
diff --git a/a.js b/b.js
@@ -5,7 +5,6 @@
A blob:b1c0ef19313b9f7a97ea0b9eee6d85d7744d5eaa
"use strict";

import { x, y } from "./a";
import { d2, usedD1, usedD2 } from "./d.js";
import { b1, usedB1, usedB2, usedB3, usedB4 } from "./b.js";
import { usedE1, usedE2 } from "./e.js";
import { h } from "./h.js";
import * as m from "./m";

it("namespace export as from commonjs should override named export", function () {
	expect(x).toBe(1);
	expect(y).toBe(3);
diff --git a/a.js b/b.js
@@ -36,16 +35,3 @@ it("complex case should work correctly", () => {
A blob:b1c0ef19313b9f7a97ea0b9eee6d85d7744d5eaa
		expect(usedB3).toBe(false);
		expect(usedB4).toBe(false);
	}
});

it("complex case should work correctly", () => {
	expect(h.f1.e.e1).toBe(10);
	expect(h.g1.e1).toBe(10);
	expect(usedE1).toBe(true);
	if (process.env.NODE_ENV === "production") {
		expect(usedE2).toBe(false);
	}
});

it("should handle 'm in n' case", () => {
	expect("a" in m).toBe(true);
	expect("c" in m).toBe(false);
	expect("c" in (false ? ({}) : m.d)).toBe(true);
	expect("d" in m.d).toBe(false);
	if (process.env.NODE_ENV === "production") {
		expect(m.d.usedA).toBe(false);
		expect(m.usedB).toBe(false);
		expect(m.usedA).toBe(true);
		expect(m.canMangleA).toBe(true);
	}
});

diff --git a/a.js b/b.js
@@ -3,4 +3,4 @@
A blob:a07f550881b2df336d98a6736d8b489ae36fee15
/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */
const e=/^(?:[A-Za-z]:[\\/]|\\\\|\/)/;module.exports=we,module.exports.default=we;const t={amd:{$ref:"#/definitions/Amd"},bail:{$ref:"#/definitions/Bail"},cache:{$ref:"#/definitions/CacheOptions"},context:{$ref:"#/definitions/Context"},dependencies:{$ref:"#/definitions/Dependencies"},devServer:{$ref:"#/definitions/DevServer"},devtool:{$ref:"#/definitions/DevTool"},entry:{$ref:"#/definitions/Entry"},experiments:{$ref:"#/definitions/Experiments"},externals:{$ref:"#/definitions/Externals"},externalsPresets:{$ref:"#/definitions/ExternalsPresets"},externalsType:{$ref:"#/definitions/ExternalsType"},ignoreWarnings:{$ref:"#/definitions/IgnoreWarnings"},infrastructureLogging:{$ref:"#/definitions/InfrastructureLogging"},loader:{$ref:"#/definitions/Loader"},mode:{$ref:"#/definitions/Mode"},module:{$ref:"#/definitions/ModuleOptions"},name:{$ref:"#/definitions/Name"},node:{$ref:"#/definitions/Node"},optimization:{$ref:"#/definitions/Optimization"},output:{$ref:"#/definitions/Output"},parallelism:{$ref:"#/definitions/Parallelism"},performance:{$ref:"#/definitions/Performance"},plugins:{$ref:"#/definitions/Plugins"},profile:{$ref:"#/definitions/Profile"},recordsInputPath:{$ref:"#/definitions/RecordsInputPath"},recordsOutputPath:{$ref:"#/definitions/RecordsOutputPath"},recordsPath:{$ref:"#/definitions/RecordsPath"},resolve:{$ref:"#/definitions/Resolve"},resolveLoader:{$ref:"#/definitions/ResolveLoader"},snapshot:{$ref:"#/definitions/SnapshotOptions"},stats:{$ref:"#/definitions/StatsValue"},target:{$ref:"#/definitions/Target"},watch:{$ref:"#/definitions/Watch"},watchOptions:{$ref:"#/definitions/WatchOptions"}},n=Object.prototype.hasOwnProperty,r={allowCollectingMemory:{type:"boolean"},buildDependencies:{type:"object",additionalProperties:{type:"array",items:{type:"string",minLength:1}}},cacheDirectory:{type:"string",absolutePath:!0},cacheLocation:{type:"string",absolutePath:!0},compression:{enum:[!1,"gzip","brotli"]},hashAlgorithm:{type:"string"},idleTimeout:{type:"number",minimum:0},idleTimeoutAfterLargeChanges:{type:"number",minimum:0},idleTimeoutForInitialStore:{type:"number",minimum:0},immutablePaths:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},managedPaths:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},maxAge:{type:"number",minimum:0},maxMemoryGenerations:{type:"number",minimum:0},memoryCacheUnaffected:{type:"boolean"},name:{type:"string"},profile:{type:"boolean"},store:{enum:["pack"]},type:{enum:["filesystem"]},version:{type:"string"}};function s(t,{instancePath:o="",parentData:a,parentDataProperty:i,rootData:l=t}={}){let p=null,u=0;const f=u;let c=!1;const m=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var y=m===u;if(c=c||y,!c){const s=u;if(u==u)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.type&&(e="type")){const t={params:{missingProperty:e}};null===p?p=[t]:p.push(t),u++}else{const e=u;for(const e in t)if("cacheUnaffected"!==e&&"maxGenerations"!==e&&"type"!==e){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(e===u){if(void 0!==t.cacheUnaffected){const e=u;if("boolean"!=typeof t.cacheUnaffected){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}var h=e===u}else h=!0;if(h){if(void 0!==t.maxGenerations){let e=t.maxGenerations;const n=u;if(u===n)if("number"==typeof e){if(e<1||isNaN(e)){const e={params:{comparison:">=",limit:1}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}h=n===u}else h=!0;if(h)if(void 0!==t.type){const e=u;if("memory"!==t.type){const e={params:{}};null===p?p=[e]:p.push(e),u++}h=e===u}else h=!0}}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}if(y=s===u,c=c||y,!c){const s=u;if(u==u)if(t&&"object"==typeof t&&!Array.isArray(t)){let s;if(void 0===t.type&&(s="type")){const e={params:{missingProperty:s}};null===p?p=[e]:p.push(e),u++}else{const s=u;for(const e in t)if(!n.call(r,e)){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(s===u){if(void 0!==t.allowCollectingMemory){const e=u;if("boolean"!=typeof t.allowCollectingMemory){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}var d=e===u}else d=!0;if(d){if(void 0!==t.buildDependencies){let e=t.buildDependencies;const n=u;if(u===n)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=u;if(u===r)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.cacheDirectory){let n=t.cacheDirectory;const r=u;if(u===r)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.cacheLocation){let n=t.cacheLocation;const r=u;if(u===r)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.compression){let e=t.compression;const n=u;if(!1!==e&&"gzip"!==e&&"brotli"!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.hashAlgorithm){const e=u;if("string"!=typeof t.hashAlgorithm){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.idleTimeout){let e=t.idleTimeout;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.idleTimeoutAfterLargeChanges){let e=t.idleTimeoutAfterLargeChanges;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.idleTimeoutForInitialStore){let e=t.idleTimeoutForInitialStore;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.immutablePaths){let n=t.immutablePaths;const r=u;if(u===r)if(Array.isArray(n)){const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var g=i===u;if(a=a||g,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=n===u,a=a||g}if(a)u=o,null!==p&&(o?p.length=o:p=null);else{const e={params:{}};null===p?p=[e]:p.push(e),u++}if(s!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.managedPaths){let n=t.managedPaths;const r=u;if(u===r)if(Array.isArray(n)){const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var b=i===u;if(a=a||b,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}b=n===u,a=a||b}if(a)u=o,null!==p&&(o?p.length=o:p=null);else{const e={params:{}};null===p?p=[e]:p.push(e),u++}if(s!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}d=r===u}else d=!0;if(d){if(void 0!==t.maxAge){let e=t.maxAge;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.maxMemoryGenerations){let e=t.maxMemoryGenerations;const n=u;if(u===n)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}d=n===u}else d=!0;if(d){if(void 0!==t.memoryCacheUnaffected){const e=u;if("boolean"!=typeof t.memoryCacheUnaffected){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.name){const e=u;if("string"!=typeof t.name){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.profile){const e=u;if("boolean"!=typeof t.profile){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.store){const e=u;if("pack"!==t.store){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d){if(void 0!==t.type){const e=u;if("filesystem"!==t.type){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d)if(void 0!==t.version){const e=u;if("string"!=typeof t.version){const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0}}}}}}}}}}}}}}}}}}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}y=s===u,c=c||y}}if(!c){const e={params:{}};return null===p?p=[e]:p.push(e),u++,s.errors=p,!1}return u=f,null!==p&&(f?p.length=f:p=null),s.errors=p,0===u}function o(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:a=e}={}){let i=null,l=0;const p=l;let u=!1;const f=l;if(!0!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=f===l;if(u=u||c,!u){const o=l;s(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:a})||(i=null===i?s.errors:i.concat(s.errors),l=i.length),c=o===l,u=u||c}if(!u){const e={params:{}};return null===i?i=[e]:i.push(e),l++,o.errors=i,!1}return l=p,null!==i&&(p?i.length=p:i=null),o.errors=i,0===l}const a={asyncChunks:{type:"boolean"},baseUri:{type:"string"},chunkLoading:{$ref:"#/definitions/ChunkLoading"},dependOn:{anyOf:[{type:"array",items:{type:"string",minLength:1},minItems:1,uniqueItems:!0},{type:"string",minLength:1}]},filename:{$ref:"#/definitions/EntryFilename"},import:{$ref:"#/definitions/EntryItem"},layer:{$ref:"#/definitions/Layer"},library:{$ref:"#/definitions/LibraryOptions"},publicPath:{$ref:"#/definitions/PublicPath"},runtime:{$ref:"#/definitions/EntryRuntime"},wasmLoading:{$ref:"#/definitions/WasmLoading"}};function i(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const l=a;let p=!1;const u=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=u===a;if(p=p||f,!p){const t=a,n=a;let r=!1;const s=a;if("jsonp"!==e&&"import-scripts"!==e&&"require"!==e&&"async-node"!==e&&"import"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var c=s===a;if(r=r||c,!r){const t=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a,r=r||c}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,p=p||f}if(!p){const e={params:{}};return null===o?o=[e]:o.push(e),a++,i.errors=o,!1}return a=l,null!==o&&(l?o.length=l:o=null),i.errors=o,0===a}function l(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const p=i;let u=!1,f=null;const c=i,m=i;let y=!1;const h=i;if(i===h)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var d=h===i;if(y=y||d,!y){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}d=e===i,y=y||d}if(y)i=m,null!==a&&(m?a.length=m:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(c===i&&(u=!0,f=0),!u){const e={params:{passingSchemas:f}};return null===a?a=[e]:a.push(e),i++,l.errors=a,!1}return i=p,null!==a&&(p?a.length=p:a=null),l.errors=a,0===i}function p(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const u=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=u===a;if(l=l||f,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("amd"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"root"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.amd){const t=a;if("string"!=typeof e.amd){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var c=t===a}else c=!0;if(c){if(void 0!==e.commonjs){const t=a;if("string"!=typeof e.commonjs){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0;if(c){if(void 0!==e.commonjs2){const t=a;if("string"!=typeof e.commonjs2){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0;if(c)if(void 0!==e.root){const t=a;if("string"!=typeof e.root){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a}else c=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,p.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),p.errors=o,0===a}function u(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a;if(a===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var f=p===a;if(l=l||f,!l){const t=a;if(a===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=t===a,l=l||f,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("amd"!==t&&"commonjs"!==t&&"root"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.amd){let t=e.amd;const n=a;if(a===n)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var c=n===a}else c=!0;if(c){if(void 0!==e.commonjs){let t=e.commonjs;const n=a;if(a===n)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=n===a}else c=!0;if(c)if(void 0!==e.root){let t=e.root;const n=a,r=a;let s=!1;const i=a;if(a===i)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var m=i===a;if(s=s||m,!s){const e=a;if(a===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}m=e===a,s=s||m}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}c=n===a}else c=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,u.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),u.errors=o,0===a}function f(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return f.errors=[{params:{type:"object"}}],!1;{let n;if(void 0===e.type&&(n="type"))return f.errors=[{params:{missingProperty:n}}],!1;{const n=a;for(const t in e)if("auxiliaryComment"!==t&&"export"!==t&&"name"!==t&&"type"!==t&&"umdNamedDefine"!==t)return f.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.auxiliaryComment){const n=a;p(e.auxiliaryComment,{instancePath:t+"/auxiliaryComment",parentData:e,parentDataProperty:"auxiliaryComment",rootData:s})||(o=null===o?p.errors:o.concat(p.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e.export){let t=e.export;const n=a,r=a;let s=!1;const p=a;if(a===p)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var l=p===a;if(s=s||l,!s){const e=a;if(a===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}l=e===a,s=s||l}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,f.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i){if(void 0!==e.name){const n=a;u(e.name,{instancePath:t+"/name",parentData:e,parentDataProperty:"name",rootData:s})||(o=null===o?u.errors:o.concat(u.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e.type){let t=e.type;const n=a,r=a;let s=!1;const l=a;if("var"!==t&&"module"!==t&&"assign"!==t&&"assign-properties"!==t&&"this"!==t&&"window"!==t&&"self"!==t&&"global"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"commonjs-module"!==t&&"commonjs-static"!==t&&"amd"!==t&&"amd-require"!==t&&"umd"!==t&&"umd2"!==t&&"jsonp"!==t&&"system"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var c=l===a;if(s=s||c,!s){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=e===a,s=s||c}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,f.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.umdNamedDefine){const t=a;if("boolean"!=typeof e.umdNamedDefine)return f.errors=[{params:{type:"boolean"}}],!1;i=t===a}else i=!0}}}}}}}return f.errors=o,0===a}function c(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if("auto"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a,n=a;let r=!1;const s=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=s===a;if(r=r||f,!r){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,r=r||f}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,c.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),c.errors=o,0===a}function m(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a,n=a;let r=!1;const s=a;if("fetch-streaming"!==e&&"fetch"!==e&&"async-node"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=s===a;if(r=r||f,!r){const t=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}f=t===a,r=r||f}if(r)a=n,null!==o&&(n?o.length=n:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,m.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),m.errors=o,0===a}function y(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let p=null,u=0;if(0===u){if(!e||"object"!=typeof e||Array.isArray(e))return y.errors=[{params:{type:"object"}}],!1;{let r;if(void 0===e.import&&(r="import"))return y.errors=[{params:{missingProperty:r}}],!1;{const r=u;for(const t in e)if(!n.call(a,t))return y.errors=[{params:{additionalProperty:t}}],!1;if(r===u){if(void 0!==e.asyncChunks){const t=u;if("boolean"!=typeof e.asyncChunks)return y.errors=[{params:{type:"boolean"}}],!1;var h=t===u}else h=!0;if(h){if(void 0!==e.baseUri){const t=u;if("string"!=typeof e.baseUri)return y.errors=[{params:{type:"string"}}],!1;h=t===u}else h=!0;if(h){if(void 0!==e.chunkLoading){const n=u;i(e.chunkLoading,{instancePath:t+"/chunkLoading",parentData:e,parentDataProperty:"chunkLoading",rootData:o})||(p=null===p?i.errors:p.concat(i.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.dependOn){let t=e.dependOn;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t))if(t.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{var d=!0;const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(!(d=r===u))break}if(d){let e,n=t.length;if(n>1){const r={};for(;n--;){let s=t[n];if("string"==typeof s){if("number"==typeof r[s]){e=r[s];const t={params:{i:n,j:e}};null===p?p=[t]:p.push(t),u++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var g=o===u;if(s=s||g,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=e===u,s=s||g}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.filename){const n=u;l(e.filename,{instancePath:t+"/filename",parentData:e,parentDataProperty:"filename",rootData:o})||(p=null===p?l.errors:p.concat(l.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.import){let t=e.import;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t))if(t.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{var b=!0;const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(!(b=r===u))break}if(b){let e,n=t.length;if(n>1){const r={};for(;n--;){let s=t[n];if("string"==typeof s){if("number"==typeof r[s]){e=r[s];const t={params:{i:n,j:e}};null===p?p=[t]:p.push(t),u++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var v=o===u;if(s=s||v,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}v=e===u,s=s||v}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.layer){let t=e.layer;const n=u,r=u;let s=!1;const o=u;if(null!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var D=o===u;if(s=s||D,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}D=e===u,s=s||D}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h){if(void 0!==e.library){const n=u;f(e.library,{instancePath:t+"/library",parentData:e,parentDataProperty:"library",rootData:o})||(p=null===p?f.errors:p.concat(f.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.publicPath){const n=u;c(e.publicPath,{instancePath:t+"/publicPath",parentData:e,parentDataProperty:"publicPath",rootData:o})||(p=null===p?c.errors:p.concat(c.errors),u=p.length),h=n===u}else h=!0;if(h){if(void 0!==e.runtime){let t=e.runtime;const n=u,r=u;let s=!1;const o=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var P=o===u;if(s=s||P,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}P=e===u,s=s||P}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,y.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),h=n===u}else h=!0;if(h)if(void 0!==e.wasmLoading){const n=u;m(e.wasmLoading,{instancePath:t+"/wasmLoading",parentData:e,parentDataProperty:"wasmLoading",rootData:o})||(p=null===p?m.errors:p.concat(m.errors),u=p.length),h=n===u}else h=!0}}}}}}}}}}}}}return y.errors=p,0===u}function h(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return h.errors=[{params:{type:"object"}}],!1;for(const n in e){let r=e[n];const u=a,f=a;let c=!1;const m=a,d=a;let g=!1;const b=a;if(a===b)if(Array.isArray(r))if(r.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{var i=!0;const e=r.length;for(let t=0;t<e;t++){let e=r[t];const n=a;if(a===n)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(!(i=n===a))break}if(i){let e,t=r.length;if(t>1){const n={};for(;t--;){let s=r[t];if("string"==typeof s){if("number"==typeof n[s]){e=n[s];const r={params:{i:t,j:e}};null===o?o=[r]:o.push(r),a++;break}n[s]=t}}}}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var l=b===a;if(g=g||l,!g){const e=a;if(a===e)if("string"==typeof r){if(r.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}l=e===a,g=g||l}if(g)a=d,null!==o&&(d?o.length=d:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}var p=m===a;if(c=c||p,!c){const i=a;y(r,{instancePath:t+"/"+n.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:n,rootData:s})||(o=null===o?y.errors:o.concat(y.errors),a=o.length),p=i===a,c=c||p}if(!c){const e={params:{}};return null===o?o=[e]:o.push(e),a++,h.errors=o,!1}if(a=f,null!==o&&(f?o.length=f:o=null),u!==a)break}}return h.errors=o,0===a}function d(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a,f=a;let c=!1;const m=a;if(a===m)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===o?o=[e]:o.push(e),a++}else{var y=!0;const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a;if(a===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(!(y=r===a))break}if(y){let t,n=e.length;if(n>1){const r={};for(;n--;){let s=e[n];if("string"==typeof s){if("number"==typeof r[s]){t=r[s];const e={params:{i:n,j:t}};null===o?o=[e]:o.push(e),a++;break}r[s]=n}}}}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var h=m===a;if(c=c||h,!c){const t=a;if(a===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}h=t===a,c=c||h}if(c)a=f,null!==o&&(f?o.length=f:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,d.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),d.errors=o,0===a}function g(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;h(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?h.errors:o.concat(h.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;d(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?d.errors:o.concat(d.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,g.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),g.errors=o,0===a}function b(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;g(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?g.errors:o.concat(g.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,b.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),b.errors=o,0===a}const v={asyncWebAssembly:{type:"boolean"},backCompat:{type:"boolean"},buildHttp:{anyOf:[{$ref:"#/definitions/HttpUriAllowedUris"},{$ref:"#/definitions/HttpUriOptions"}]},cacheUnaffected:{type:"boolean"},css:{anyOf:[{type:"boolean"},{$ref:"#/definitions/CssExperimentOptions"}]},futureDefaults:{type:"boolean"},layers:{type:"boolean"},lazyCompilation:{anyOf:[{type:"boolean"},{$ref:"#/definitions/LazyCompilationOptions"}]},outputModule:{type:"boolean"},syncWebAssembly:{type:"boolean"},topLevelAwait:{type:"boolean"}},D=new RegExp("^https?://","u");function P(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(a==a)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let i=!1;const l=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=l===a;if(i=i||f,!i){const e=a;if(a===e)if("string"==typeof t){if(!D.test(t)){const e={params:{pattern:"^https?://"}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=e===a,i=i||f}}if(i)a=s,null!==o&&(s?o.length=s:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}if(u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,P.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),P.errors=o,0===a}function A(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return A.errors=[{params:{type:"object"}}],!1;{let n;if(void 0===t.allowedUris&&(n="allowedUris"))return A.errors=[{params:{missingProperty:n}}],!1;{const n=i;for(const e in t)if("allowedUris"!==e&&"cacheLocation"!==e&&"frozen"!==e&&"lockfileLocation"!==e&&"upgrade"!==e)return A.errors=[{params:{additionalProperty:e}}],!1;if(n===i){if(void 0!==t.allowedUris){let e=t.allowedUris;const n=i;if(i==i){if(!Array.isArray(e))return A.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=i,s=i;let o=!1;const p=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var l=p===i;if(o=o||l,!o){const e=i;if(i===e)if("string"==typeof t){if(!D.test(t)){const e={params:{pattern:"^https?://"}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(l=e===i,o=o||l,!o){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}l=e===i,o=o||l}}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,A.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),r!==i)break}}}var p=n===i}else p=!0;if(p){if(void 0!==t.cacheLocation){let n=t.cacheLocation;const r=i,s=i;let o=!1;const l=i;if(!1!==n){const e={params:{}};null===a?a=[e]:a.push(e),i++}var u=l===i;if(o=o||u,!o){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}u=t===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,A.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),p=r===i}else p=!0;if(p){if(void 0!==t.frozen){const e=i;if("boolean"!=typeof t.frozen)return A.errors=[{params:{type:"boolean"}}],!1;p=e===i}else p=!0;if(p){if(void 0!==t.lockfileLocation){let n=t.lockfileLocation;const r=i;if(i===r){if("string"!=typeof n)return A.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return A.errors=[{params:{}}],!1}p=r===i}else p=!0;if(p)if(void 0!==t.upgrade){const e=i;if("boolean"!=typeof t.upgrade)return A.errors=[{params:{type:"boolean"}}],!1;p=e===i}else p=!0}}}}}}}return A.errors=a,0===i}function x(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return x.errors=[{params:{type:"object"}}],!1;{const t=a;for(const t in e)if("backend"!==t&&"entries"!==t&&"imports"!==t&&"test"!==t)return x.errors=[{params:{additionalProperty:t}}],!1;if(t===a){if(void 0!==e.backend){let t=e.backend;const n=a,r=a;let s=!1;const m=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=m===a;if(s=s||i,!s){const e=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=a;for(const e in t)if("client"!==e&&"listen"!==e&&"protocol"!==e&&"server"!==e){const t={params:{additionalProperty:e}};null===o?o=[t]:o.push(t),a++;break}if(e===a){if(void 0!==t.client){const e=a;if("string"!=typeof t.client){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var l=e===a}else l=!0;if(l){if(void 0!==t.listen){let e=t.listen;const n=a,r=a;let s=!1;const i=a;if("number"!=typeof e){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}var p=i===a;if(s=s||p,!s){const t=a;if(a===t)if(e&&"object"==typeof e&&!Array.isArray(e)){if(void 0!==e.host){const t=a;if("string"!=typeof e.host){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var u=t===a}else u=!0;if(u)if(void 0!==e.port){const t=a;if("number"!=typeof e.port){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}u=t===a}else u=!0}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}if(p=t===a,s=s||p,!s){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}p=t===a,s=s||p}}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0;if(l){if(void 0!==t.protocol){let e=t.protocol;const n=a;if("http"!==e&&"https"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0;if(l)if(void 0!==t.server){let e=t.server;const n=a,r=a;let s=!1;const i=a;if(a===i)if(e&&"object"==typeof e&&!Array.isArray(e));else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var f=i===a;if(s=s||f,!s){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,s=s||f}if(s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}l=n===a}else l=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}i=e===a,s=s||i}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,x.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var c=n===a}else c=!0;if(c){if(void 0!==e.entries){const t=a;if("boolean"!=typeof e.entries)return x.errors=[{params:{type:"boolean"}}],!1;c=t===a}else c=!0;if(c){if(void 0!==e.imports){const t=a;if("boolean"!=typeof e.imports)return x.errors=[{params:{type:"boolean"}}],!1;c=t===a}else c=!0;if(c)if(void 0!==e.test){let t=e.test;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var m=i===a;if(s=s||m,!s){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(m=e===a,s=s||m,!s){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}m=e===a,s=s||m}}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,x.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),c=n===a}else c=!0}}}}}return x.errors=o,0===a}function k(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return k.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(v,t))return k.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.asyncWebAssembly){const t=i;if("boolean"!=typeof e.asyncWebAssembly)return k.errors=[{params:{type:"boolean"}}],!1;var l=t===i}else l=!0;if(l){if(void 0!==e.backCompat){const t=i;if("boolean"!=typeof e.backCompat)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.buildHttp){let n=e.buildHttp;const r=i,s=i;let u=!1;const f=i;P(n,{instancePath:t+"/buildHttp",parentData:e,parentDataProperty:"buildHttp",rootData:o})||(a=null===a?P.errors:a.concat(P.errors),i=a.length);var p=f===i;if(u=u||p,!u){const r=i;A(n,{instancePath:t+"/buildHttp",parentData:e,parentDataProperty:"buildHttp",rootData:o})||(a=null===a?A.errors:a.concat(A.errors),i=a.length),p=r===i,u=u||p}if(!u){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.cacheUnaffected){const t=i;if("boolean"!=typeof e.cacheUnaffected)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.css){let t=e.css;const n=i,r=i;let s=!1;const o=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var u=o===i;if(s=s||u,!s){const e=i;if(i==i)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=i;for(const e in t)if("exportsOnly"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(e===i&&void 0!==t.exportsOnly&&"boolean"!=typeof t.exportsOnly){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}u=e===i,s=s||u}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.futureDefaults){const t=i;if("boolean"!=typeof e.futureDefaults)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.layers){const t=i;if("boolean"!=typeof e.layers)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.lazyCompilation){let n=e.lazyCompilation;const r=i,s=i;let p=!1;const u=i;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const r=i;x(n,{instancePath:t+"/lazyCompilation",parentData:e,parentDataProperty:"lazyCompilation",rootData:o})||(a=null===a?x.errors:a.concat(x.errors),i=a.length),f=r===i,p=p||f}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,k.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.outputModule){const t=i;if("boolean"!=typeof e.outputModule)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.syncWebAssembly){const t=i;if("boolean"!=typeof e.syncWebAssembly)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l)if(void 0!==e.topLevelAwait){const t=i;if("boolean"!=typeof e.topLevelAwait)return k.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0}}}}}}}}}}}}return k.errors=a,0===i}const j={validate:S};function S(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const n=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(u=n===a,l=l||u,!l){const n=a;if(a===n)if(e&&"object"==typeof e&&!Array.isArray(e)){const n=a;for(const t in e)if("byLayer"!==t){let n=e[t];const r=a,s=a;let i=!1;const l=a;if(a===l)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var f=l===a;if(i=i||f,!i){const e=a;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if("string"!=typeof n){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(f=e===a,i=i||f,!i){const e=a;if(!n||"object"!=typeof n||Array.isArray(n)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=e===a,i=i||f}}}if(i)a=s,null!==o&&(s?o.length=s:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}if(n===a&&void 0!==e.byLayer){let n=e.byLayer;const r=a;let i=!1;const l=a;if(a===l)if(n&&"object"==typeof n&&!Array.isArray(n))for(const e in n){const r=a;if(j.validate(n[e],{instancePath:t+"/byLayer/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:s})||(o=null===o?j.validate.errors:o.concat(j.validate.errors),a=o.length),r!==a)break}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var c=l===a;if(i=i||c,!i){const e=a;if(!(n instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}c=e===a,i=i||c}if(i)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}if(u=n===a,l=l||u,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,S.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),S.errors=o,0===a}function C(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e)){const n=e.length;for(let r=0;r<n;r++){const n=a;if(S(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?S.errors:o.concat(S.errors),a=o.length),n!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;S(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?S.errors:o.concat(S.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,C.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),C.errors=o,0===a}function O(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,O.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),O.errors=a,0===i}function F(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return F.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("appendOnly"!==t&&"colors"!==t&&"console"!==t&&"debug"!==t&&"level"!==t&&"stream"!==t)return F.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.appendOnly){const t=a;if("boolean"!=typeof e.appendOnly)return F.errors=[{params:{type:"boolean"}}],!1;var i=t===a}else i=!0;if(i){if(void 0!==e.colors){const t=a;if("boolean"!=typeof e.colors)return F.errors=[{params:{type:"boolean"}}],!1;i=t===a}else i=!0;if(i){if(void 0!==e.debug){let n=e.debug;const r=a,p=a;let u=!1;const f=a;if("boolean"!=typeof n){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}var l=f===a;if(u=u||l,!u){const r=a;O(n,{instancePath:t+"/debug",parentData:e,parentDataProperty:"debug",rootData:s})||(o=null===o?O.errors:o.concat(O.errors),a=o.length),l=r===a,u=u||l}if(!u){const e={params:{}};return null===o?o=[e]:o.push(e),a++,F.errors=o,!1}a=p,null!==o&&(p?o.length=p:o=null),i=r===a}else i=!0;if(i)if(void 0!==e.level){let t=e.level;const n=a;if("none"!==t&&"error"!==t&&"warn"!==t&&"info"!==t&&"log"!==t&&"verbose"!==t)return F.errors=[{params:{}}],!1;i=n===a}else i=!0}}}}}return F.errors=o,0===a}const R={defaultRules:{oneOf:[{$ref:"#/definitions/RuleSetRules"}]},exprContextCritical:{type:"boolean"},exprContextRecursive:{type:"boolean"},exprContextRegExp:{anyOf:[{instanceof:"RegExp"},{type:"boolean"}]},exprContextRequest:{type:"string"},generator:{$ref:"#/definitions/GeneratorOptionsByModuleType"},noParse:{$ref:"#/definitions/NoParse"},parser:{$ref:"#/definitions/ParserOptionsByModuleType"},rules:{oneOf:[{$ref:"#/definitions/RuleSetRules"}]},strictExportPresence:{type:"boolean"},strictThisContextOnImports:{type:"boolean"},unknownContextCritical:{type:"boolean"},unknownContextRecursive:{type:"boolean"},unknownContextRegExp:{anyOf:[{instanceof:"RegExp"},{type:"boolean"}]},unknownContextRequest:{type:"string"},unsafeCache:{anyOf:[{type:"boolean"},{instanceof:"Function"}]},wrappedContextCritical:{type:"boolean"},wrappedContextRecursive:{type:"boolean"},wrappedContextRegExp:{instanceof:"RegExp"}},E={assert:{type:"object",additionalProperties:{$ref:"#/definitions/RuleSetConditionOrConditions"}},compiler:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},dependency:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},descriptionData:{type:"object",additionalProperties:{$ref:"#/definitions/RuleSetConditionOrConditions"}},enforce:{enum:["pre","post"]},exclude:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},generator:{type:"object"},include:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},issuer:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},issuerLayer:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},layer:{type:"string"},loader:{oneOf:[{$ref:"#/definitions/RuleSetLoader"}]},mimetype:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},oneOf:{type:"array",items:{oneOf:[{$ref:"#/definitions/RuleSetRule"}]}},options:{oneOf:[{$ref:"#/definitions/RuleSetLoaderOptions"}]},parser:{type:"object",additionalProperties:!0},realResource:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},resolve:{type:"object",oneOf:[{$ref:"#/definitions/ResolveOptions"}]},resource:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},resourceFragment:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},resourceQuery:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},rules:{type:"array",items:{oneOf:[{$ref:"#/definitions/RuleSetRule"}]}},scheme:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditions"}]},sideEffects:{type:"boolean"},test:{oneOf:[{$ref:"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},type:{type:"string"},use:{oneOf:[{$ref:"#/definitions/RuleSetUse"}]}},$={validate:w};function z(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return z.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if($.validate(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?$.validate.errors:o.concat($.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,z.errors=o,!1}if(a=i,null!==o&&(i?o.length=i:o=null),n!==a)break}}}return z.errors=o,0===a}function L(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return L.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("and"!==t&&"not"!==t&&"or"!==t)return L.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.and){const n=a,r=a;let l=!1,p=null;const u=a;if(z(e.and,{instancePath:t+"/and",parentData:e,parentDataProperty:"and",rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var i=n===a}else i=!0;if(i){if(void 0!==e.not){const n=a,r=a;let l=!1,p=null;const u=a;if($.validate(e.not,{instancePath:t+"/not",parentData:e,parentDataProperty:"not",rootData:s})||(o=null===o?$.validate.errors:o.concat($.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.or){const n=a,r=a;let l=!1,p=null;const u=a;if(z(e.or,{instancePath:t+"/or",parentData:e,parentDataProperty:"or",rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,L.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0}}}}return L.errors=o,0===a}function w(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!(e instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if("string"!=typeof e){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;if(L(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?L.errors:o.concat(L.errors),a=o.length),u=i===a,l=l||u,!l){const i=a;z(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u=i===a,l=l||u}}}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,w.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),w.errors=o,0===a}function M(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;w(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?w.errors:o.concat(w.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;z(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?z.errors:o.concat(z.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,M.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),M.errors=o,0===a}const N={validate:B};function T(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return T.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if(N.validate(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?N.validate.errors:o.concat(N.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,T.errors=o,!1}if(a=i,null!==o&&(i?o.length=i:o=null),n!==a)break}}}return T.errors=o,0===a}function I(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return I.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("and"!==t&&"not"!==t&&"or"!==t)return I.errors=[{params:{additionalProperty:t}}],!1;if(n===a){if(void 0!==e.and){const n=a,r=a;let l=!1,p=null;const u=a;if(T(e.and,{instancePath:t+"/and",parentData:e,parentDataProperty:"and",rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var i=n===a}else i=!0;if(i){if(void 0!==e.not){const n=a,r=a;let l=!1,p=null;const u=a;if(N.validate(e.not,{instancePath:t+"/not",parentData:e,parentDataProperty:"not",rootData:s})||(o=null===o?N.validate.errors:o.concat(N.validate.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0;if(i)if(void 0!==e.or){const n=a,r=a;let l=!1,p=null;const u=a;if(T(e.or,{instancePath:t+"/or",parentData:e,parentDataProperty:"or",rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,I.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),i=n===a}else i=!0}}}}return I.errors=o,0===a}function B(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const l=i;if(i===l)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=l===i,p=p||f,!p){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f=e===i,p=p||f,!p){const e=i;if(I(t,{instancePath:n,parentData:r,parentDataProperty:s,rootData:o})||(a=null===a?I.errors:a.concat(I.errors),i=a.length),f=e===i,p=p||f,!p){const e=i;T(t,{instancePath:n,parentData:r,parentDataProperty:s,rootData:o})||(a=null===a?T.errors:a.concat(T.errors),i=a.length),f=e===i,p=p||f}}}}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,B.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),B.errors=a,0===i}function U(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;B(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?B.errors:o.concat(B.errors),a=o.length);var u=p===a;if(l=l||u,!l){const i=a;T(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?T.errors:o.concat(T.errors),a=o.length),u=i===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,U.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),U.errors=o,0===a}const q={alias:{$ref:"#/definitions/ResolveAlias"},aliasFields:{type:"array",items:{anyOf:[{type:"array",items:{type:"string",minLength:1}},{type:"string",minLength:1}]}},byDependency:{type:"object",additionalProperties:{oneOf:[{$ref:"#/definitions/ResolveOptions"}]}},cache:{type:"boolean"},cachePredicate:{instanceof:"Function"},cacheWithContext:{type:"boolean"},conditionNames:{type:"array",items:{type:"string"}},descriptionFiles:{type:"array",items:{type:"string",minLength:1}},enforceExtension:{type:"boolean"},exportsFields:{type:"array",items:{type:"string"}},extensions:{type:"array",items:{type:"string"}},fallback:{oneOf:[{$ref:"#/definitions/ResolveAlias"}]},fileSystem:{},fullySpecified:{type:"boolean"},importsFields:{type:"array",items:{type:"string"}},mainFields:{type:"array",items:{anyOf:[{type:"array",items:{type:"string",minLength:1}},{type:"string",minLength:1}]}},mainFiles:{type:"array",items:{type:"string",minLength:1}},modules:{type:"array",items:{type:"string",minLength:1}},plugins:{type:"array",items:{anyOf:[{enum:["..."]},{$ref:"#/definitions/ResolvePluginInstance"}]}},preferAbsolute:{type:"boolean"},preferRelative:{type:"boolean"},resolver:{},restrictions:{type:"array",items:{anyOf:[{instanceof:"RegExp"},{type:"string",absolutePath:!0,minLength:1}]}},roots:{type:"array",items:{type:"string"}},symlinks:{type:"boolean"},unsafeCache:{anyOf:[{type:"boolean"},{type:"object",additionalProperties:!0}]},useSyncFileSystemCalls:{type:"boolean"}},G={validate:W};function W(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return W.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(q,e))return W.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.alias&&(e="alias")||void 0===t.name&&(e="name")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else{const e=l;for(const e in t)if("alias"!==e&&"name"!==e&&"onlyModule"!==e){const t={params:{additionalProperty:e}};null===i?i=[t]:i.push(t),l++;break}if(e===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var p=o===l;if(s=s||p,!s){const t=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(p=t===l,s=s||p,!s){const t=l;if(l===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}p=t===l,s=s||p}}if(s)l=r,null!==i&&(r?i.length=r:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=n===l}else u=!0;if(u){if(void 0!==t.name){const e=l;if("string"!=typeof t.name){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}u=e===l}else u=!0;if(u)if(void 0!==t.onlyModule){const e=l;if("boolean"!=typeof t.onlyModule){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}u=e===l}else u=!0}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var f=o===l;if(s=s||f,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const e=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(c=e===l,o=o||c,!o){const e=l;if(l===e)if("string"==typeof n){if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}}if(o)l=s,null!==i&&(s?i.length=s:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}f=t===l,s=s||f}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null);var m=n===l}else m=!0;if(m){if(void 0!==t.aliasFields){let e=t.aliasFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var y=a===l;if(o=o||y,!o){const e=l;if(l===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}y=e===l,o=o||y}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.byDependency){let e=t.byDependency;const n=l;if(l===n){if(!e||"object"!=typeof e||Array.isArray(e))return W.errors=[{params:{type:"object"}}],!1;for(const t in e){const n=l,s=l;let o=!1,p=null;const u=l;if(G.validate(e[t],{instancePath:r+"/byDependency/"+t.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:t,rootData:a})||(i=null===i?G.validate.errors:i.concat(G.validate.errors),l=i.length),u===l&&(o=!0,p=0),!o){const e={params:{passingSchemas:p}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),n!==l)break}}m=n===l}else m=!0;if(m){if(void 0!==t.cache){const e=l;if("boolean"!=typeof t.cache)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.cachePredicate){const e=l;if(!(t.cachePredicate instanceof Function))return W.errors=[{params:{}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.cacheWithContext){const e=l;if("boolean"!=typeof t.cacheWithContext)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.conditionNames){let e=t.conditionNames;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.descriptionFiles){let e=t.descriptionFiles;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.enforceExtension){const e=l;if("boolean"!=typeof t.enforceExtension)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.exportsFields){let e=t.exportsFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.extensions){let e=t.extensions;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.fallback){let e=t.fallback;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.alias&&(e="alias")||void 0===t.name&&(e="name")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else{const e=l;for(const e in t)if("alias"!==e&&"name"!==e&&"onlyModule"!==e){const t={params:{additionalProperty:e}};null===i?i=[t]:i.push(t),l++;break}if(e===l){if(void 0!==t.alias){let e=t.alias;const n=l,r=l;let s=!1;const o=l;if(l===o)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var h=o===l;if(s=s||h,!s){const t=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(h=t===l,s=s||h,!s){const t=l;if(l===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}h=t===l,s=s||h}}if(s)l=r,null!==i&&(r?i.length=r:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}var d=n===l}else d=!0;if(d){if(void 0!==t.name){const e=l;if("string"!=typeof t.name){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}d=e===l}else d=!0;if(d)if(void 0!==t.onlyModule){const e=l;if("boolean"!=typeof t.onlyModule){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}d=e===l}else d=!0}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var g=f===l;if(u=u||g,!u){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){let n=e[t];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n)){const e=n.length;for(let t=0;t<e;t++){let e=n[t];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var b=a===l;if(o=o||b,!o){const e=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(b=e===l,o=o||b,!o){const e=l;if(l===e)if("string"==typeof n){if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}b=e===l,o=o||b}}if(o)l=s,null!==i&&(s?i.length=s:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=t===l,u=u||g}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),m=n===l}else m=!0;if(m){if(void 0!==t.fullySpecified){const e=l;if("boolean"!=typeof t.fullySpecified)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.importsFields){let e=t.importsFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.mainFields){let e=t.mainFields;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=l;if(l===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(r!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var v=a===l;if(o=o||v,!o){const e=l;if(l===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}v=e===l,o=o||v}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.mainFiles){let e=t.mainFiles;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.modules){let e=t.modules;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l;if(l===r){if("string"!=typeof t)return W.errors=[{params:{type:"string"}}],!1;if(t.length<1)return W.errors=[{params:{}}],!1}if(r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.plugins){let e=t.plugins;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=l,s=l;let o=!1;const a=l;if("..."!==t){const e={params:{}};null===i?i=[e]:i.push(e),l++}var D=a===l;if(o=o||D,!o){const e=l;if(l==l)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.apply&&(e="apply")){const t={params:{missingProperty:e}};null===i?i=[t]:i.push(t),l++}else if(void 0!==t.apply&&!(t.apply instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}D=e===l,o=o||D}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=s,null!==i&&(s?i.length=s:i=null),r!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.preferAbsolute){const e=l;if("boolean"!=typeof t.preferAbsolute)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.preferRelative){const e=l;if("boolean"!=typeof t.preferRelative)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.restrictions){let n=t.restrictions;const r=l;if(l===r){if(!Array.isArray(n))return W.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=l,o=l;let a=!1;const p=l;if(!(t instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var P=p===l;if(a=a||P,!a){const n=l;if(l===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(t.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}P=n===l,a=a||P}if(!a){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}if(l=o,null!==i&&(o?i.length=o:i=null),s!==l)break}}}m=r===l}else m=!0;if(m){if(void 0!==t.roots){let e=t.roots;const n=l;if(l===n){if(!Array.isArray(e))return W.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return W.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}m=n===l}else m=!0;if(m){if(void 0!==t.symlinks){const e=l;if("boolean"!=typeof t.symlinks)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0;if(m){if(void 0!==t.unsafeCache){let e=t.unsafeCache;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var A=o===l;if(s=s||A,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e));else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}A=t===l,s=s||A}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,W.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),m=n===l}else m=!0;if(m)if(void 0!==t.useSyncFileSystemCalls){const e=l;if("boolean"!=typeof t.useSyncFileSystemCalls)return W.errors=[{params:{type:"boolean"}}],!1;m=e===l}else m=!0}}}}}}}}}}}}}}}}}}}}}}}}}}return W.errors=i,0===l}function H(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("ident"!==t&&"loader"!==t&&"options"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.ident){const t=a;if("string"!=typeof e.ident){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var u=t===a}else u=!0;if(u){if(void 0!==e.loader){let t=e.loader;const n=a,r=a;let s=!1,i=null;const l=a;if(a==a)if("string"==typeof t){if(t.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(l===a&&(s=!0,i=0),s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{passingSchemas:i}};null===o?o=[e]:o.push(e),a++}u=n===a}else u=!0;if(u)if(void 0!==e.options){let t=e.options;const n=a,r=a;let s=!1,i=null;const l=a,p=a;let c=!1;const m=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}var f=m===a;if(c=c||f,!c){const e=a;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}f=e===a,c=c||f}if(c)a=p,null!==o&&(p?o.length=p:o=null);else{const e={params:{}};null===o?o=[e]:o.push(e),a++}if(l===a&&(s=!0,i=0),s)a=r,null!==o&&(r?o.length=r:o=null);else{const e={params:{passingSchemas:i}};null===o?o=[e]:o.push(e),a++}u=n===a}else u=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var c=p===a;if(l=l||c,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(c=t===a,l=l||c,!l){const t=a;if(a==a)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}c=t===a,l=l||c}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,H.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),H.errors=o,0===a}function _(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a===p)if(Array.isArray(e)){const n=e.length;for(let r=0;r<n;r++){const n=a,i=a;let l=!1,p=null;const u=a;if(H(e[r],{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?H.errors:o.concat(H.errors),a=o.length),u===a&&(l=!0,p=0),l)a=i,null!==o&&(i?o.length=i:o=null);else{const e={params:{passingSchemas:p}};null===o?o=[e]:o.push(e),a++}if(n!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;H(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?H.errors:o.concat(H.errors),a=o.length),u=i===a,l=l||u}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,_.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),_.errors=o,0===a}const Q={validate:J};function J(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return J.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(E,t))return J.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.assert){let n=e.assert;const r=i;if(i===r){if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;for(const e in n){const r=i;if(M(n[e],{instancePath:t+"/assert/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),r!==i)break}}var l=r===i}else l=!0;if(l){if(void 0!==e.compiler){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.compiler,{instancePath:t+"/compiler",parentData:e,parentDataProperty:"compiler",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.dependency){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.dependency,{instancePath:t+"/dependency",parentData:e,parentDataProperty:"dependency",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.descriptionData){let n=e.descriptionData;const r=i;if(i===r){if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;for(const e in n){const r=i;if(M(n[e],{instancePath:t+"/descriptionData/"+e.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:n,parentDataProperty:e,rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),r!==i)break}}l=r===i}else l=!0;if(l){if(void 0!==e.enforce){let t=e.enforce;const n=i;if("pre"!==t&&"post"!==t)return J.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.exclude){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.exclude,{instancePath:t+"/exclude",parentData:e,parentDataProperty:"exclude",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.generator){let t=e.generator;const n=i;if(!t||"object"!=typeof t||Array.isArray(t))return J.errors=[{params:{type:"object"}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.include){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.include,{instancePath:t+"/include",parentData:e,parentDataProperty:"include",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.issuer){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.issuer,{instancePath:t+"/issuer",parentData:e,parentDataProperty:"issuer",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.issuerLayer){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.issuerLayer,{instancePath:t+"/issuerLayer",parentData:e,parentDataProperty:"issuerLayer",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.layer){const t=i;if("string"!=typeof e.layer)return J.errors=[{params:{type:"string"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.loader){let t=e.loader;const n=i,r=i;let s=!1,o=null;const p=i;if(i==i)if("string"==typeof t){if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(p===i&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.mimetype){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.mimetype,{instancePath:t+"/mimetype",parentData:e,parentDataProperty:"mimetype",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.oneOf){let n=e.oneOf;const r=i;if(i===r){if(!Array.isArray(n))return J.errors=[{params:{type:"array"}}],!1;{const e=n.length;for(let r=0;r<e;r++){const e=i,s=i;let l=!1,p=null;const u=i;if(Q.validate(n[r],{instancePath:t+"/oneOf/"+r,parentData:n,parentDataProperty:r,rootData:o})||(a=null===a?Q.validate.errors:a.concat(Q.validate.errors),i=a.length),u===i&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),e!==i)break}}}l=r===i}else l=!0;if(l){if(void 0!==e.options){let t=e.options;const n=i,r=i;let s=!1,o=null;const u=i,f=i;let c=!1;const m=i;if("string"!=typeof t){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=m===i;if(c=c||p,!c){const e=i;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}p=e===i,c=c||p}if(c)i=f,null!==a&&(f?a.length=f:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.parser){let t=e.parser;const n=i;if(i===n&&(!t||"object"!=typeof t||Array.isArray(t)))return J.errors=[{params:{type:"object"}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.realResource){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.realResource,{instancePath:t+"/realResource",parentData:e,parentDataProperty:"realResource",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resolve){let n=e.resolve;const r=i;if(!n||"object"!=typeof n||Array.isArray(n))return J.errors=[{params:{type:"object"}}],!1;const s=i;let p=!1,u=null;const f=i;if(W(n,{instancePath:t+"/resolve",parentData:e,parentDataProperty:"resolve",rootData:o})||(a=null===a?W.errors:a.concat(W.errors),i=a.length),f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==e.resource){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.resource,{instancePath:t+"/resource",parentData:e,parentDataProperty:"resource",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resourceFragment){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.resourceFragment,{instancePath:t+"/resourceFragment",parentData:e,parentDataProperty:"resourceFragment",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.resourceQuery){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.resourceQuery,{instancePath:t+"/resourceQuery",parentData:e,parentDataProperty:"resourceQuery",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.rules){let n=e.rules;const r=i;if(i===r){if(!Array.isArray(n))return J.errors=[{params:{type:"array"}}],!1;{const e=n.length;for(let r=0;r<e;r++){const e=i,s=i;let l=!1,p=null;const u=i;if(Q.validate(n[r],{instancePath:t+"/rules/"+r,parentData:n,parentDataProperty:r,rootData:o})||(a=null===a?Q.validate.errors:a.concat(Q.validate.errors),i=a.length),u===i&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),e!==i)break}}}l=r===i}else l=!0;if(l){if(void 0!==e.scheme){const n=i,r=i;let s=!1,p=null;const u=i;if(M(e.scheme,{instancePath:t+"/scheme",parentData:e,parentDataProperty:"scheme",rootData:o})||(a=null===a?M.errors:a.concat(M.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.sideEffects){const t=i;if("boolean"!=typeof e.sideEffects)return J.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.test){const n=i,r=i;let s=!1,p=null;const u=i;if(U(e.test,{instancePath:t+"/test",parentData:e,parentDataProperty:"test",rootData:o})||(a=null===a?U.errors:a.concat(U.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.type){const t=i;if("string"!=typeof e.type)return J.errors=[{params:{type:"string"}}],!1;l=t===i}else l=!0;if(l)if(void 0!==e.use){const n=i,r=i;let s=!1,p=null;const u=i;if(_(e.use,{instancePath:t+"/use",parentData:e,parentDataProperty:"use",rootData:o})||(a=null===a?_.errors:a.concat(_.errors),i=a.length),u===i&&(s=!0,p=0),!s){const e={params:{passingSchemas:p}};return null===a?a=[e]:a.push(e),i++,J.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}return J.errors=a,0===i}function V(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return V.errors=[{params:{type:"array"}}],!1;{const n=e.length;for(let r=0;r<n;r++){let n=e[r];const l=a,p=a;let u=!1;const f=a;if("..."!==n){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=f===a;if(u=u||i,!u){const l=a;J(n,{instancePath:t+"/"+r,parentData:e,parentDataProperty:r,rootData:s})||(o=null===o?J.errors:o.concat(J.errors),a=o.length),i=l===a,u=u||i}if(!u){const e={params:{}};return null===o?o=[e]:o.push(e),a++,V.errors=o,!1}if(a=p,null!==o&&(p?o.length=p:o=null),l!==a)break}}}return V.errors=o,0===a}function Z(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("encoding"!==t&&"mimetype"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.encoding){let t=e.encoding;const n=a;if(!1!==t&&"base64"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=n===a}else u=!0;if(u)if(void 0!==e.mimetype){const t=a;if("string"!=typeof e.mimetype){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}u=t===a}else u=!0}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var f=p===a;if(l=l||f,!l){const t=a;if(!(e instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=t===a,l=l||f}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,Z.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Z.errors=o,0===a}function K(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return K.errors=[{params:{type:"object"}}],!1;{const r=i;for(const e in t)if("dataUrl"!==e&&"emit"!==e&&"filename"!==e&&"outputPath"!==e&&"publicPath"!==e)return K.errors=[{params:{additionalProperty:e}}],!1;if(r===i){if(void 0!==t.dataUrl){const e=i;Z(t.dataUrl,{instancePath:n+"/dataUrl",parentData:t,parentDataProperty:"dataUrl",rootData:o})||(a=null===a?Z.errors:a.concat(Z.errors),i=a.length);var l=e===i}else l=!0;if(l){if(void 0!==t.emit){const e=i;if("boolean"!=typeof t.emit)return K.errors=[{params:{type:"boolean"}}],!1;l=e===i}else l=!0;if(l){if(void 0!==t.filename){let n=t.filename;const r=i,s=i;let o=!1;const u=i;if(i===u)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(n.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=u===i;if(o=o||p,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}p=e===i,o=o||p}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==t.outputPath){let n=t.outputPath;const r=i,s=i;let o=!1;const p=i;if(i===p)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var u=p===i;if(o=o||u,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=e===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==t.publicPath){let e=t.publicPath;const n=i,r=i;let s=!1;const o=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=t===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,K.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}return K.errors=a,0===i}function X(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return X.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("dataUrl"!==t)return X.errors=[{params:{additionalProperty:t}}],!1;n===a&&void 0!==e.dataUrl&&(Z(e.dataUrl,{instancePath:t+"/dataUrl",parentData:e,parentDataProperty:"dataUrl",rootData:s})||(o=null===o?Z.errors:o.concat(Z.errors),a=o.length))}}return X.errors=o,0===a}function Y(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;if(0===i){if(!t||"object"!=typeof t||Array.isArray(t))return Y.errors=[{params:{type:"object"}}],!1;{const n=i;for(const e in t)if("emit"!==e&&"filename"!==e&&"outputPath"!==e&&"publicPath"!==e)return Y.errors=[{params:{additionalProperty:e}}],!1;if(n===i){if(void 0!==t.emit){const e=i;if("boolean"!=typeof t.emit)return Y.errors=[{params:{type:"boolean"}}],!1;var l=e===i}else l=!0;if(l){if(void 0!==t.filename){let n=t.filename;const r=i,s=i;let o=!1;const u=i;if(i===u)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(n.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var p=u===i;if(o=o||p,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}p=e===i,o=o||p}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l){if(void 0!==t.outputPath){let n=t.outputPath;const r=i,s=i;let o=!1;const p=i;if(i===p)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var u=p===i;if(o=o||u,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=e===i,o=o||u}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==t.publicPath){let e=t.publicPath;const n=i,r=i;let s=!1;const o=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=t===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Y.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}return Y.errors=a,0===i}function ee(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return ee.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("asset"!==t&&"asset/inline"!==t&&"asset/resource"!==t&&"javascript"!==t&&"javascript/auto"!==t&&"javascript/dynamic"!==t&&"javascript/esm"!==t){let n=e[t];const r=a;if(a===r&&(!n||"object"!=typeof n||Array.isArray(n)))return ee.errors=[{params:{type:"object"}}],!1;if(r!==a)break}if(n===a){if(void 0!==e.asset){const n=a;K(e.asset,{instancePath:t+"/asset",parentData:e,parentDataProperty:"asset",rootData:s})||(o=null===o?K.errors:o.concat(K.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e["asset/inline"]){const n=a;X(e["asset/inline"],{instancePath:t+"/asset~1inline",parentData:e,parentDataProperty:"asset/inline",rootData:s})||(o=null===o?X.errors:o.concat(X.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["asset/resource"]){const n=a;Y(e["asset/resource"],{instancePath:t+"/asset~1resource",parentData:e,parentDataProperty:"asset/resource",rootData:s})||(o=null===o?Y.errors:o.concat(Y.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e.javascript){let t=e.javascript;const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["javascript/auto"]){let t=e["javascript/auto"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["javascript/dynamic"]){let t=e["javascript/dynamic"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i)if(void 0!==e["javascript/esm"]){let t=e["javascript/esm"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return ee.errors=[{params:{type:"object"}}],!1;for(const e in t)return ee.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0}}}}}}}}return ee.errors=o,0===a}function te(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return te.errors=[{params:{type:"object"}}],!1;{const t=a;for(const t in e)if("dataUrlCondition"!==t)return te.errors=[{params:{additionalProperty:t}}],!1;if(t===a&&void 0!==e.dataUrlCondition){let t=e.dataUrlCondition;const n=a;let r=!1;const s=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=a;for(const e in t)if("maxSize"!==e){const t={params:{additionalProperty:e}};null===o?o=[t]:o.push(t),a++;break}if(e===a&&void 0!==t.maxSize&&"number"!=typeof t.maxSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var i=s===a;if(r=r||i,!r){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}i=e===a,r=r||i}if(!r){const e={params:{}};return null===o?o=[e]:o.push(e),a++,te.errors=o,!1}a=n,null!==o&&(n?o.length=n:o=null)}}}return te.errors=o,0===a}function ne(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("__dirname"!==t&&"__filename"!==t&&"global"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.__dirname){let t=e.__dirname;const n=a;if(!1!==t&&!0!==t&&"warn-mock"!==t&&"mock"!==t&&"eval-only"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=n===a}else f=!0;if(f){if(void 0!==e.__filename){let t=e.__filename;const n=a;if(!1!==t&&!0!==t&&"warn-mock"!==t&&"mock"!==t&&"eval-only"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0;if(f)if(void 0!==e.global){let t=e.global;const n=a;if(!1!==t&&!0!==t&&"warn"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ne.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ne.errors=o,0===a}function re(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return re.errors=[{params:{type:"object"}}],!1;if(void 0!==e.amd){let t=e.amd;const n=a,r=a;let s=!1;const p=a;if(!1!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(s=s||i,!s){const e=a;if(!t||"object"!=typeof t||Array.isArray(t)){const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}i=e===a,s=s||i}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null);var l=n===a}else l=!0;if(l){if(void 0!==e.browserify){const t=a;if("boolean"!=typeof e.browserify)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.commonjs){const t=a;if("boolean"!=typeof e.commonjs)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.commonjsMagicComments){const t=a;if("boolean"!=typeof e.commonjsMagicComments)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exportsPresence){let t=e.exportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.exprContextCritical){const t=a;if("boolean"!=typeof e.exprContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exprContextRecursive){const t=a;if("boolean"!=typeof e.exprContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.exprContextRegExp){let t=e.exprContextRegExp;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var p=i===a;if(s=s||p,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}p=e===a,s=s||p}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.exprContextRequest){const t=a;if("string"!=typeof e.exprContextRequest)return re.errors=[{params:{type:"string"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.harmony){const t=a;if("boolean"!=typeof e.harmony)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.import){const t=a;if("boolean"!=typeof e.import)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.importExportsPresence){let t=e.importExportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.importMeta){const t=a;if("boolean"!=typeof e.importMeta)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.node){const n=a;ne(e.node,{instancePath:t+"/node",parentData:e,parentDataProperty:"node",rootData:s})||(o=null===o?ne.errors:o.concat(ne.errors),a=o.length),l=n===a}else l=!0;if(l){if(void 0!==e.reexportExportsPresence){let t=e.reexportExportsPresence;const n=a;if("error"!==t&&"warn"!==t&&"auto"!==t&&!1!==t)return re.errors=[{params:{}}],!1;l=n===a}else l=!0;if(l){if(void 0!==e.requireContext){const t=a;if("boolean"!=typeof e.requireContext)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireEnsure){const t=a;if("boolean"!=typeof e.requireEnsure)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireInclude){const t=a;if("boolean"!=typeof e.requireInclude)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.requireJs){const t=a;if("boolean"!=typeof e.requireJs)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.strictExportPresence){const t=a;if("boolean"!=typeof e.strictExportPresence)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.strictThisContextOnImports){const t=a;if("boolean"!=typeof e.strictThisContextOnImports)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.system){const t=a;if("boolean"!=typeof e.system)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextCritical){const t=a;if("boolean"!=typeof e.unknownContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextRecursive){const t=a;if("boolean"!=typeof e.unknownContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.unknownContextRegExp){let t=e.unknownContextRegExp;const n=a,r=a;let s=!1;const i=a;if(!(t instanceof RegExp)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=i===a;if(s=s||u,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}u=e===a,s=s||u}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.unknownContextRequest){const t=a;if("string"!=typeof e.unknownContextRequest)return re.errors=[{params:{type:"string"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.url){let t=e.url;const n=a,r=a;let s=!1;const i=a;if("relative"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=i===a;if(s=s||f,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}f=e===a,s=s||f}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.worker){let t=e.worker;const n=a,r=a;let s=!1;const i=a;if(a===i)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=a;if(a===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}if(r!==a)break}}else{const e={params:{type:"array"}};null===o?o=[e]:o.push(e),a++}var c=i===a;if(s=s||c,!s){const e=a;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}c=e===a,s=s||c}if(!s){const e={params:{}};return null===o?o=[e]:o.push(e),a++,re.errors=o,!1}a=r,null!==o&&(r?o.length=r:o=null),l=n===a}else l=!0;if(l){if(void 0!==e.wrappedContextCritical){const t=a;if("boolean"!=typeof e.wrappedContextCritical)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l){if(void 0!==e.wrappedContextRecursive){const t=a;if("boolean"!=typeof e.wrappedContextRecursive)return re.errors=[{params:{type:"boolean"}}],!1;l=t===a}else l=!0;if(l)if(void 0!==e.wrappedContextRegExp){const t=a;if(!(e.wrappedContextRegExp instanceof RegExp))return re.errors=[{params:{}}],!1;l=t===a}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return re.errors=o,0===a}function se(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!e||"object"!=typeof e||Array.isArray(e))return se.errors=[{params:{type:"object"}}],!1;{const n=a;for(const t in e)if("asset"!==t&&"asset/inline"!==t&&"asset/resource"!==t&&"asset/source"!==t&&"javascript"!==t&&"javascript/auto"!==t&&"javascript/dynamic"!==t&&"javascript/esm"!==t){let n=e[t];const r=a;if(a===r&&(!n||"object"!=typeof n||Array.isArray(n)))return se.errors=[{params:{type:"object"}}],!1;if(r!==a)break}if(n===a){if(void 0!==e.asset){const n=a;te(e.asset,{instancePath:t+"/asset",parentData:e,parentDataProperty:"asset",rootData:s})||(o=null===o?te.errors:o.concat(te.errors),a=o.length);var i=n===a}else i=!0;if(i){if(void 0!==e["asset/inline"]){let t=e["asset/inline"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["asset/resource"]){let t=e["asset/resource"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e["asset/source"]){let t=e["asset/source"];const n=a;if(a==a){if(!t||"object"!=typeof t||Array.isArray(t))return se.errors=[{params:{type:"object"}}],!1;for(const e in t)return se.errors=[{params:{additionalProperty:e}}],!1}i=n===a}else i=!0;if(i){if(void 0!==e.javascript){const n=a;re(e.javascript,{instancePath:t+"/javascript",parentData:e,parentDataProperty:"javascript",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["javascript/auto"]){const n=a;re(e["javascript/auto"],{instancePath:t+"/javascript~1auto",parentData:e,parentDataProperty:"javascript/auto",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i){if(void 0!==e["javascript/dynamic"]){const n=a;re(e["javascript/dynamic"],{instancePath:t+"/javascript~1dynamic",parentData:e,parentDataProperty:"javascript/dynamic",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0;if(i)if(void 0!==e["javascript/esm"]){const n=a;re(e["javascript/esm"],{instancePath:t+"/javascript~1esm",parentData:e,parentDataProperty:"javascript/esm",rootData:s})||(o=null===o?re.errors:o.concat(re.errors),a=o.length),i=n===a}else i=!0}}}}}}}}}return se.errors=o,0===a}function oe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return oe.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(R,e))return oe.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.defaultRules){const e=l,n=l;let s=!1,o=null;const u=l;if(V(t.defaultRules,{instancePath:r+"/defaultRules",parentData:t,parentDataProperty:"defaultRules",rootData:a})||(i=null===i?V.errors:i.concat(V.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null);var p=e===l}else p=!0;if(p){if(void 0!==t.exprContextCritical){const e=l;if("boolean"!=typeof t.exprContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exprContextRecursive){const e=l;if("boolean"!=typeof t.exprContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exprContextRegExp){let e=t.exprContextRegExp;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.exprContextRequest){const e=l;if("string"!=typeof t.exprContextRequest)return oe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.generator){const e=l;ee(t.generator,{instancePath:r+"/generator",parentData:t,parentDataProperty:"generator",rootData:a})||(i=null===i?ee.errors:i.concat(ee.errors),l=i.length),p=e===l}else p=!0;if(p){if(void 0!==t.noParse){let n=t.noParse;const r=l,s=l;let o=!1;const a=l;if(l===a)if(Array.isArray(n))if(n.length<1){const e={params:{limit:1}};null===i?i=[e]:i.push(e),l++}else{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=l,o=l;let a=!1;const p=l;if(!(t instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var f=p===l;if(a=a||f,!a){const n=l;if(l===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(f=n===l,a=a||f,!a){const e=l;if(!(t instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}f=e===l,a=a||f}}if(a)l=o,null!==i&&(o?i.length=o:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(s!==l)break}}else{const e={params:{type:"array"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const t=l;if(!(n instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(c=t===l,o=o||c,!o){const t=l;if(l===t)if("string"==typeof n){if(n.includes("!")||!0!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(c=t===l,o=o||c,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}}}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.parser){const e=l;se(t.parser,{instancePath:r+"/parser",parentData:t,parentDataProperty:"parser",rootData:a})||(i=null===i?se.errors:i.concat(se.errors),l=i.length),p=e===l}else p=!0;if(p){if(void 0!==t.rules){const e=l,n=l;let s=!1,o=null;const u=l;if(V(t.rules,{instancePath:r+"/rules",parentData:t,parentDataProperty:"rules",rootData:a})||(i=null===i?V.errors:i.concat(V.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0;if(p){if(void 0!==t.strictExportPresence){const e=l;if("boolean"!=typeof t.strictExportPresence)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.strictThisContextOnImports){const e=l;if("boolean"!=typeof t.strictThisContextOnImports)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextCritical){const e=l;if("boolean"!=typeof t.unknownContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextRecursive){const e=l;if("boolean"!=typeof t.unknownContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unknownContextRegExp){let e=t.unknownContextRegExp;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.unknownContextRequest){const e=l;if("string"!=typeof t.unknownContextRequest)return oe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.unsafeCache){let e=t.unsafeCache;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var y=o===l;if(s=s||y,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}y=t===l,s=s||y}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,oe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.wrappedContextCritical){const e=l;if("boolean"!=typeof t.wrappedContextCritical)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.wrappedContextRecursive){const e=l;if("boolean"!=typeof t.wrappedContextRecursive)return oe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p)if(void 0!==t.wrappedContextRegExp){const e=l;if(!(t.wrappedContextRegExp instanceof RegExp))return oe.errors=[{params:{}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}return oe.errors=i,0===l}const ae={checkWasmTypes:{type:"boolean"},chunkIds:{enum:["natural","named","deterministic","size","total-size",!1]},concatenateModules:{type:"boolean"},emitOnErrors:{type:"boolean"},flagIncludedChunks:{type:"boolean"},innerGraph:{type:"boolean"},mangleExports:{anyOf:[{enum:["size","deterministic"]},{type:"boolean"}]},mangleWasmImports:{type:"boolean"},mergeDuplicateChunks:{type:"boolean"},minimize:{type:"boolean"},minimizer:{type:"array",items:{anyOf:[{enum:["..."]},{$ref:"#/definitions/WebpackPluginInstance"},{$ref:"#/definitions/WebpackPluginFunction"}]}},moduleIds:{enum:["natural","named","hashed","deterministic","size",!1]},noEmitOnErrors:{type:"boolean"},nodeEnv:{anyOf:[{enum:[!1]},{type:"string"}]},portableRecords:{type:"boolean"},providedExports:{type:"boolean"},realContentHash:{type:"boolean"},removeAvailableModules:{type:"boolean"},removeEmptyChunks:{type:"boolean"},runtimeChunk:{$ref:"#/definitions/OptimizationRuntimeChunk"},sideEffects:{anyOf:[{enum:["flag"]},{type:"boolean"}]},splitChunks:{anyOf:[{enum:[!1]},{$ref:"#/definitions/OptimizationSplitChunksOptions"}]},usedExports:{anyOf:[{enum:["global"]},{type:"boolean"}]}},ie={automaticNameDelimiter:{type:"string",minLength:1},cacheGroups:{type:"object",additionalProperties:{anyOf:[{enum:[!1]},{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"},{$ref:"#/definitions/OptimizationSplitChunksCacheGroup"}]},not:{type:"object",additionalProperties:!0,properties:{test:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]}},required:["test"]}},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},defaultSizeTypes:{type:"array",items:{type:"string"},minItems:1},enforceSizeThreshold:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},fallbackCacheGroup:{type:"object",additionalProperties:!1,properties:{automaticNameDelimiter:{type:"string",minLength:1},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]}}},filename:{anyOf:[{type:"string",absolutePath:!1,minLength:1},{instanceof:"Function"}]},hidePathInfo:{type:"boolean"},maxAsyncRequests:{type:"number",minimum:1},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialRequests:{type:"number",minimum:1},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minChunks:{type:"number",minimum:1},minRemainingSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},name:{anyOf:[{enum:[!1]},{type:"string"},{instanceof:"Function"}]},usedExports:{type:"boolean"}},le={automaticNameDelimiter:{type:"string",minLength:1},chunks:{anyOf:[{enum:["initial","async","all"]},{instanceof:"Function"}]},enforce:{type:"boolean"},enforceSizeThreshold:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},filename:{anyOf:[{type:"string",absolutePath:!1,minLength:1},{instanceof:"Function"}]},idHint:{type:"string"},layer:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},maxAsyncRequests:{type:"number",minimum:1},maxAsyncSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxInitialRequests:{type:"number",minimum:1},maxInitialSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},maxSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minChunks:{type:"number",minimum:1},minRemainingSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSize:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},minSizeReduction:{oneOf:[{$ref:"#/definitions/OptimizationSplitChunksSizes"}]},name:{anyOf:[{enum:[!1]},{type:"string"},{instanceof:"Function"}]},priority:{type:"number"},reuseExistingChunk:{type:"boolean"},test:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},type:{anyOf:[{instanceof:"RegExp"},{type:"string"},{instanceof:"Function"}]},usedExports:{type:"boolean"}};function pe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return pe.errors=[{params:{type:"object"}}],!1;{const r=l;for(const e in t)if(!n.call(le,e))return pe.errors=[{params:{additionalProperty:e}}],!1;if(r===l){if(void 0!==t.automaticNameDelimiter){let e=t.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof e)return pe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return pe.errors=[{params:{}}],!1}var p=n===l}else p=!0;if(p){if(void 0!==t.chunks){let e=t.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==e&&"async"!==e&&"all"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.enforce){const e=l;if("boolean"!=typeof t.enforce)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.enforceSizeThreshold){let e=t.enforceSizeThreshold;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let c=!1;const m=l;if(l===m)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var f=m===l;if(c=c||f,!c){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}f=t===l,c=c||f}if(c)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.filename){let n=t.filename;const r=l,s=l;let o=!1;const a=l;if(l===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var c=a===l;if(o=o||c,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=e===l,o=o||c}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.idHint){const e=l;if("string"!=typeof t.idHint)return pe.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.layer){let e=t.layer;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(m=t===l,s=s||m,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncRequests){let e=t.maxAsyncRequests;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncSize){let e=t.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var y=c===l;if(f=f||y,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}y=t===l,f=f||y}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialRequests){let e=t.maxInitialRequests;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialSize){let e=t.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var h=c===l;if(f=f||h,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}h=t===l,f=f||h}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxSize){let e=t.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var d=c===l;if(f=f||d,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}d=t===l,f=f||d}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minChunks){let e=t.minChunks;const n=l;if(l===n){if("number"!=typeof e)return pe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return pe.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.minRemainingSize){let e=t.minRemainingSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var g=c===l;if(f=f||g,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=t===l,f=f||g}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSize){let e=t.minSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var b=c===l;if(f=f||b,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}b=t===l,f=f||b}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSizeReduction){let e=t.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var v=c===l;if(f=f||v,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}v=t===l,f=f||v}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.name){let e=t.name;const n=l,r=l;let s=!1;const o=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var D=o===l;if(s=s||D,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(D=t===l,s=s||D,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}D=t===l,s=s||D}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.priority){const e=l;if("number"!=typeof t.priority)return pe.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reuseExistingChunk){const e=l;if("boolean"!=typeof t.reuseExistingChunk)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.test){let e=t.test;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var P=o===l;if(s=s||P,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(P=t===l,s=s||P,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}P=t===l,s=s||P}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.type){let e=t.type;const n=l,r=l;let s=!1;const o=l;if(!(e instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}var A=o===l;if(s=s||A,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(A=t===l,s=s||A,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}A=t===l,s=s||A}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,pe.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p)if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return pe.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}}}}return pe.errors=i,0===l}function ue(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return ue.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(ie,e))return ue.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.automaticNameDelimiter){let e=t.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof e)return ue.errors=[{params:{type:"string"}}],!1;if(e.length<1)return ue.errors=[{params:{}}],!1}var p=n===l}else p=!0;if(p){if(void 0!==t.cacheGroups){let e=t.cacheGroups;const n=l,s=l,o=l;if(l===o)if(e&&"object"==typeof e&&!Array.isArray(e)){let t;if(void 0===e.test&&(t="test")){const e={};null===i?i=[e]:i.push(e),l++}else if(void 0!==e.test){let t=e.test;const n=l;let r=!1;const s=l;if(!(t instanceof RegExp)){const e={};null===i?i=[e]:i.push(e),l++}var u=s===l;if(r=r||u,!r){const e=l;if("string"!=typeof t){const e={};null===i?i=[e]:i.push(e),l++}if(u=e===l,r=r||u,!r){const e=l;if(!(t instanceof Function)){const e={};null===i?i=[e]:i.push(e),l++}u=e===l,r=r||u}}if(r)l=n,null!==i&&(n?i.length=n:i=null);else{const e={};null===i?i=[e]:i.push(e),l++}}}else{const e={};null===i?i=[e]:i.push(e),l++}if(o===l)return ue.errors=[{params:{}}],!1;if(l=s,null!==i&&(s?i.length=s:i=null),l===n){if(!e||"object"!=typeof e||Array.isArray(e))return ue.errors=[{params:{type:"object"}}],!1;for(const t in e){let n=e[t];const s=l,o=l;let p=!1;const u=l;if(!1!==n){const e={params:{}};null===i?i=[e]:i.push(e),l++}var f=u===l;if(p=p||f,!p){const s=l;if(!(n instanceof RegExp)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;if("string"!=typeof n){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}if(f=s===l,p=p||f,!p){const s=l;pe(n,{instancePath:r+"/cacheGroups/"+t.replace(/~/g,"~0").replace(/\//g,"~1"),parentData:e,parentDataProperty:t,rootData:a})||(i=null===i?pe.errors:i.concat(pe.errors),l=i.length),f=s===l,p=p||f}}}}if(!p){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}if(l=o,null!==i&&(o?i.length=o:i=null),s!==l)break}}p=n===l}else p=!0;if(p){if(void 0!==t.chunks){let e=t.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==e&&"async"!==e&&"all"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=o===l;if(s=s||c,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}c=t===l,s=s||c}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.defaultSizeTypes){let e=t.defaultSizeTypes;const n=l;if(l===n){if(!Array.isArray(e))return ue.errors=[{params:{type:"array"}}],!1;if(e.length<1)return ue.errors=[{params:{limit:1}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=l;if("string"!=typeof e[n])return ue.errors=[{params:{type:"string"}}],!1;if(t!==l)break}}}p=n===l}else p=!0;if(p){if(void 0!==t.enforceSizeThreshold){let e=t.enforceSizeThreshold;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var m=c===l;if(f=f||m,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}m=t===l,f=f||m}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.fallbackCacheGroup){let e=t.fallbackCacheGroup;const n=l;if(l===n){if(!e||"object"!=typeof e||Array.isArray(e))return ue.errors=[{params:{type:"object"}}],!1;{const t=l;for(const t in e)if("automaticNameDelimiter"!==t&&"chunks"!==t&&"maxAsyncSize"!==t&&"maxInitialSize"!==t&&"maxSize"!==t&&"minSize"!==t&&"minSizeReduction"!==t)return ue.errors=[{params:{additionalProperty:t}}],!1;if(t===l){if(void 0!==e.automaticNameDelimiter){let t=e.automaticNameDelimiter;const n=l;if(l===n){if("string"!=typeof t)return ue.errors=[{params:{type:"string"}}],!1;if(t.length<1)return ue.errors=[{params:{}}],!1}var y=n===l}else y=!0;if(y){if(void 0!==e.chunks){let t=e.chunks;const n=l,r=l;let s=!1;const o=l;if("initial"!==t&&"async"!==t&&"all"!==t){const e={params:{}};null===i?i=[e]:i.push(e),l++}var h=o===l;if(s=s||h,!s){const e=l;if(!(t instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}h=e===l,s=s||h}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxAsyncSize){let t=e.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var d=f===l;if(u=u||d,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}d=e===l,u=u||d}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxInitialSize){let t=e.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var g=f===l;if(u=u||g,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}g=e===l,u=u||g}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.maxSize){let t=e.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var b=f===l;if(u=u||b,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}b=e===l,u=u||b}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y){if(void 0!==e.minSize){let t=e.minSize;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var v=f===l;if(u=u||v,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}v=e===l,u=u||v}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0;if(y)if(void 0!==e.minSizeReduction){let t=e.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,p=l;let u=!1;const f=l;if(l===f)if("number"==typeof t){if(t<0||isNaN(t)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var D=f===l;if(u=u||D,!u){const e=l;if(l===e)if(t&&"object"==typeof t&&!Array.isArray(t))for(const e in t){const n=l;if("number"!=typeof t[e]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}D=e===l,u=u||D}if(u)l=p,null!==i&&(p?i.length=p:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),y=n===l}else y=!0}}}}}}}}p=n===l}else p=!0;if(p){if(void 0!==t.filename){let n=t.filename;const r=l,s=l;let o=!1;const a=l;if(l===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===i?i=[e]:i.push(e),l++}else if(n.length<1){const e={params:{}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var P=a===l;if(o=o||P,!o){const e=l;if(!(n instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}P=e===l,o=o||P}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=r===l}else p=!0;if(p){if(void 0!==t.hidePathInfo){const e=l;if("boolean"!=typeof t.hidePathInfo)return ue.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.maxAsyncRequests){let e=t.maxAsyncRequests;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxAsyncSize){let e=t.maxAsyncSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var A=c===l;if(f=f||A,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}A=t===l,f=f||A}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialRequests){let e=t.maxInitialRequests;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.maxInitialSize){let e=t.maxInitialSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var x=c===l;if(f=f||x,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}x=t===l,f=f||x}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.maxSize){let e=t.maxSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var k=c===l;if(f=f||k,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}k=t===l,f=f||k}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minChunks){let e=t.minChunks;const n=l;if(l===n){if("number"!=typeof e)return ue.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return ue.errors=[{params:{comparison:">=",limit:1}}],!1}p=n===l}else p=!0;if(p){if(void 0!==t.minRemainingSize){let e=t.minRemainingSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var j=c===l;if(f=f||j,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}j=t===l,f=f||j}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSize){let e=t.minSize;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var S=c===l;if(f=f||S,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}S=t===l,f=f||S}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.minSizeReduction){let e=t.minSizeReduction;const n=l,r=l;let s=!1,o=null;const a=l,u=l;let f=!1;const c=l;if(l===c)if("number"==typeof e){if(e<0||isNaN(e)){const e={params:{comparison:">=",limit:0}};null===i?i=[e]:i.push(e),l++}}else{const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}var C=c===l;if(f=f||C,!f){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e))for(const t in e){const n=l;if("number"!=typeof e[t]){const e={params:{type:"number"}};null===i?i=[e]:i.push(e),l++}if(n!==l)break}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}C=t===l,f=f||C}if(f)l=u,null!==i&&(u?i.length=u:i=null);else{const e={params:{}};null===i?i=[e]:i.push(e),l++}if(a===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.name){let e=t.name;const n=l,r=l;let s=!1;const o=l;if(!1!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var O=o===l;if(s=s||O,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}if(O=t===l,s=s||O,!s){const t=l;if(!(e instanceof Function)){const e={params:{}};null===i?i=[e]:i.push(e),l++}O=t===l,s=s||O}}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,ue.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p)if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return ue.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}return ue.errors=i,0===l}function fe(e,{instancePath:t="",parentData:r,parentDataProperty:s,rootData:o=e}={}){let a=null,i=0;if(0===i){if(!e||"object"!=typeof e||Array.isArray(e))return fe.errors=[{params:{type:"object"}}],!1;{const r=i;for(const t in e)if(!n.call(ae,t))return fe.errors=[{params:{additionalProperty:t}}],!1;if(r===i){if(void 0!==e.checkWasmTypes){const t=i;if("boolean"!=typeof e.checkWasmTypes)return fe.errors=[{params:{type:"boolean"}}],!1;var l=t===i}else l=!0;if(l){if(void 0!==e.chunkIds){let t=e.chunkIds;const n=i;if("natural"!==t&&"named"!==t&&"deterministic"!==t&&"size"!==t&&"total-size"!==t&&!1!==t)return fe.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.concatenateModules){const t=i;if("boolean"!=typeof e.concatenateModules)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.emitOnErrors){const t=i;if("boolean"!=typeof e.emitOnErrors)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.flagIncludedChunks){const t=i;if("boolean"!=typeof e.flagIncludedChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.innerGraph){const t=i;if("boolean"!=typeof e.innerGraph)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.mangleExports){let t=e.mangleExports;const n=i,r=i;let s=!1;const o=i;if("size"!==t&&"deterministic"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var p=o===i;if(s=s||p,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}p=e===i,s=s||p}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.mangleWasmImports){const t=i;if("boolean"!=typeof e.mangleWasmImports)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.mergeDuplicateChunks){const t=i;if("boolean"!=typeof e.mergeDuplicateChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.minimize){const t=i;if("boolean"!=typeof e.minimize)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.minimizer){let t=e.minimizer;const n=i;if(i===n){if(!Array.isArray(t))return fe.errors=[{params:{type:"array"}}],!1;{const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=i,s=i;let o=!1;const l=i;if("..."!==e){const e={params:{}};null===a?a=[e]:a.push(e),i++}var u=l===i;if(o=o||u,!o){const t=i;if(i==i)if(e&&"object"==typeof e&&!Array.isArray(e)){let t;if(void 0===e.apply&&(t="apply")){const e={params:{missingProperty:t}};null===a?a=[e]:a.push(e),i++}else if(void 0!==e.apply&&!(e.apply instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}if(u=t===i,o=o||u,!o){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}u=t===i,o=o||u}}if(!o){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}if(i=s,null!==a&&(s?a.length=s:a=null),r!==i)break}}}l=n===i}else l=!0;if(l){if(void 0!==e.moduleIds){let t=e.moduleIds;const n=i;if("natural"!==t&&"named"!==t&&"hashed"!==t&&"deterministic"!==t&&"size"!==t&&!1!==t)return fe.errors=[{params:{}}],!1;l=n===i}else l=!0;if(l){if(void 0!==e.noEmitOnErrors){const t=i;if("boolean"!=typeof e.noEmitOnErrors)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.nodeEnv){let t=e.nodeEnv;const n=i,r=i;let s=!1;const o=i;if(!1!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=o===i;if(s=s||f,!s){const e=i;if("string"!=typeof t){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}f=e===i,s=s||f}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.portableRecords){const t=i;if("boolean"!=typeof e.portableRecords)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.providedExports){const t=i;if("boolean"!=typeof e.providedExports)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.realContentHash){const t=i;if("boolean"!=typeof e.realContentHash)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.removeAvailableModules){const t=i;if("boolean"!=typeof e.removeAvailableModules)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.removeEmptyChunks){const t=i;if("boolean"!=typeof e.removeEmptyChunks)return fe.errors=[{params:{type:"boolean"}}],!1;l=t===i}else l=!0;if(l){if(void 0!==e.runtimeChunk){let t=e.runtimeChunk;const n=i,r=i;let s=!1;const o=i;if("single"!==t&&"multiple"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var c=o===i;if(s=s||c,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}if(c=e===i,s=s||c,!s){const e=i;if(i===e)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=i;for(const e in t)if("name"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(e===i&&void 0!==t.name){let e=t.name;const n=i;let r=!1;const s=i;if("string"!=typeof e){const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var m=s===i;if(r=r||m,!r){const t=i;if(!(e instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=t===i,r=r||m}if(r)i=n,null!==a&&(n?a.length=n:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}c=e===i,s=s||c}}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.sideEffects){let t=e.sideEffects;const n=i,r=i;let s=!1;const o=i;if("flag"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var y=o===i;if(s=s||y,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}y=e===i,s=s||y}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0;if(l){if(void 0!==e.splitChunks){let n=e.splitChunks;const r=i,s=i;let p=!1;const u=i;if(!1!==n){const e={params:{}};null===a?a=[e]:a.push(e),i++}var h=u===i;if(p=p||h,!p){const r=i;ue(n,{instancePath:t+"/splitChunks",parentData:e,parentDataProperty:"splitChunks",rootData:o})||(a=null===a?ue.errors:a.concat(ue.errors),i=a.length),h=r===i,p=p||h}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=s,null!==a&&(s?a.length=s:a=null),l=r===i}else l=!0;if(l)if(void 0!==e.usedExports){let t=e.usedExports;const n=i,r=i;let s=!1;const o=i;if("global"!==t){const e={params:{}};null===a?a=[e]:a.push(e),i++}var d=o===i;if(s=s||d,!s){const e=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}d=e===i,s=s||d}if(!s){const e={params:{}};return null===a?a=[e]:a.push(e),i++,fe.errors=a,!1}i=r,null!==a&&(r?a.length=r:a=null),l=n===i}else l=!0}}}}}}}}}}}}}}}}}}}}}}}}return fe.errors=a,0===i}const ce={assetModuleFilename:{$ref:"#/definitions/AssetModuleFilename"},asyncChunks:{type:"boolean"},auxiliaryComment:{oneOf:[{$ref:"#/definitions/AuxiliaryComment"}]},charset:{$ref:"#/definitions/Charset"},chunkFilename:{$ref:"#/definitions/ChunkFilename"},chunkFormat:{$ref:"#/definitions/ChunkFormat"},chunkLoadTimeout:{$ref:"#/definitions/ChunkLoadTimeout"},chunkLoading:{$ref:"#/definitions/ChunkLoading"},chunkLoadingGlobal:{$ref:"#/definitions/ChunkLoadingGlobal"},clean:{$ref:"#/definitions/Clean"},compareBeforeEmit:{$ref:"#/definitions/CompareBeforeEmit"},crossOriginLoading:{$ref:"#/definitions/CrossOriginLoading"},cssChunkFilename:{$ref:"#/definitions/CssChunkFilename"},cssFilename:{$ref:"#/definitions/CssFilename"},devtoolFallbackModuleFilenameTemplate:{$ref:"#/definitions/DevtoolFallbackModuleFilenameTemplate"},devtoolModuleFilenameTemplate:{$ref:"#/definitions/DevtoolModuleFilenameTemplate"},devtoolNamespace:{$ref:"#/definitions/DevtoolNamespace"},enabledChunkLoadingTypes:{$ref:"#/definitions/EnabledChunkLoadingTypes"},enabledLibraryTypes:{$ref:"#/definitions/EnabledLibraryTypes"},enabledWasmLoadingTypes:{$ref:"#/definitions/EnabledWasmLoadingTypes"},environment:{$ref:"#/definitions/Environment"},filename:{$ref:"#/definitions/Filename"},globalObject:{$ref:"#/definitions/GlobalObject"},hashDigest:{$ref:"#/definitions/HashDigest"},hashDigestLength:{$ref:"#/definitions/HashDigestLength"},hashFunction:{$ref:"#/definitions/HashFunction"},hashSalt:{$ref:"#/definitions/HashSalt"},hotUpdateChunkFilename:{$ref:"#/definitions/HotUpdateChunkFilename"},hotUpdateGlobal:{$ref:"#/definitions/HotUpdateGlobal"},hotUpdateMainFilename:{$ref:"#/definitions/HotUpdateMainFilename"},iife:{$ref:"#/definitions/Iife"},importFunctionName:{$ref:"#/definitions/ImportFunctionName"},importMetaName:{$ref:"#/definitions/ImportMetaName"},library:{$ref:"#/definitions/Library"},libraryExport:{oneOf:[{$ref:"#/definitions/LibraryExport"}]},libraryTarget:{oneOf:[{$ref:"#/definitions/LibraryType"}]},module:{$ref:"#/definitions/OutputModule"},path:{$ref:"#/definitions/Path"},pathinfo:{$ref:"#/definitions/Pathinfo"},publicPath:{$ref:"#/definitions/PublicPath"},scriptType:{$ref:"#/definitions/ScriptType"},sourceMapFilename:{$ref:"#/definitions/SourceMapFilename"},sourcePrefix:{$ref:"#/definitions/SourcePrefix"},strictModuleErrorHandling:{$ref:"#/definitions/StrictModuleErrorHandling"},strictModuleExceptionHandling:{$ref:"#/definitions/StrictModuleExceptionHandling"},trustedTypes:{anyOf:[{enum:[!0]},{type:"string",minLength:1},{$ref:"#/definitions/TrustedTypes"}]},umdNamedDefine:{oneOf:[{$ref:"#/definitions/UmdNamedDefine"}]},uniqueName:{$ref:"#/definitions/UniqueName"},wasmLoading:{$ref:"#/definitions/WasmLoading"},webassemblyModuleFilename:{$ref:"#/definitions/WebassemblyModuleFilename"},workerChunkLoading:{$ref:"#/definitions/ChunkLoading"},workerWasmLoading:{$ref:"#/definitions/WasmLoading"}},me={arrowFunction:{type:"boolean"},bigIntLiteral:{type:"boolean"},const:{type:"boolean"},destructuring:{type:"boolean"},dynamicImport:{type:"boolean"},forOf:{type:"boolean"},module:{type:"boolean"},optionalChaining:{type:"boolean"},templateLiteral:{type:"boolean"}};function ye(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,ye.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),ye.errors=a,0===i}function he(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var f=u===i;if(p=p||f,!p){const n=i;if(i==i)if(t&&"object"==typeof t&&!Array.isArray(t)){const n=i;for(const e in t)if("dry"!==e&&"keep"!==e){const t={params:{additionalProperty:e}};null===a?a=[t]:a.push(t),i++;break}if(n===i){if(void 0!==t.dry){const e=i;if("boolean"!=typeof t.dry){const e={params:{type:"boolean"}};null===a?a=[e]:a.push(e),i++}var c=e===i}else c=!0;if(c)if(void 0!==t.keep){let n=t.keep;const r=i,s=i;let o=!1;const l=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=l===i;if(o=o||m,!o){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=t===i,o=o||m,!o){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,o=o||m}}if(o)i=s,null!==a&&(s?a.length=s:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=r===i}else c=!0}}else{const e={params:{type:"object"}};null===a?a=[e]:a.push(e),i++}f=n===i,p=p||f}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,he.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),he.errors=a,0===i}function de(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,de.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),de.errors=a,0===i}function ge(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,ge.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),ge.errors=a,0===i}function be(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return be.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("jsonp"!==t&&"import-scripts"!==t&&"require"!==t&&"async-node"!==t&&"import"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,be.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return be.errors=o,0===a}function ve(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return ve.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("var"!==t&&"module"!==t&&"assign"!==t&&"assign-properties"!==t&&"this"!==t&&"window"!==t&&"self"!==t&&"global"!==t&&"commonjs"!==t&&"commonjs2"!==t&&"commonjs-module"!==t&&"commonjs-static"!==t&&"amd"!==t&&"amd-require"!==t&&"umd"!==t&&"umd2"!==t&&"jsonp"!==t&&"system"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ve.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return ve.errors=o,0===a}function De(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return De.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if("fetch-streaming"!==t&&"fetch"!==t&&"async-node"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if("string"!=typeof t){const e={params:{type:"string"}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,De.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return De.errors=o,0===a}function Pe(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1,u=null;const f=i,c=i;let m=!1;const y=i;if(i===y)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}else if(t.length<1){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}var h=y===i;if(m=m||h,!m){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}h=e===i,m=m||h}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(f===i&&(p=!0,u=0),!p){const e={params:{passingSchemas:u}};return null===a?a=[e]:a.push(e),i++,Pe.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Pe.errors=a,0===i}function Ae(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;u(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?u.errors:o.concat(u.errors),a=o.length);var c=p===a;if(l=l||c,!l){const i=a;f(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?f.errors:o.concat(f.errors),a=o.length),c=i===a,l=l||c}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,Ae.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Ae.errors=o,0===a}function xe(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let l=null,u=0;if(0===u){if(!t||"object"!=typeof t||Array.isArray(t))return xe.errors=[{params:{type:"object"}}],!1;{const s=u;for(const e in t)if(!n.call(ce,e))return xe.errors=[{params:{additionalProperty:e}}],!1;if(s===u){if(void 0!==t.assetModuleFilename){let n=t.assetModuleFilename;const r=u,s=u;let o=!1;const a=u;if(u===a)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var f=a===u;if(o=o||f,!o){const e=u;if(!(n instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}f=e===u,o=o||f}if(!o){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=s,null!==l&&(s?l.length=s:l=null);var y=r===u}else y=!0;if(y){if(void 0!==t.asyncChunks){const e=u;if("boolean"!=typeof t.asyncChunks)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.auxiliaryComment){const e=u,n=u;let s=!1,o=null;const i=u;if(p(t.auxiliaryComment,{instancePath:r+"/auxiliaryComment",parentData:t,parentDataProperty:"auxiliaryComment",rootData:a})||(l=null===l?p.errors:l.concat(p.errors),u=l.length),i===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=n,null!==l&&(n?l.length=n:l=null),y=e===u}else y=!0;if(y){if(void 0!==t.charset){const e=u;if("boolean"!=typeof t.charset)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.chunkFilename){const e=u;ye(t.chunkFilename,{instancePath:r+"/chunkFilename",parentData:t,parentDataProperty:"chunkFilename",rootData:a})||(l=null===l?ye.errors:l.concat(ye.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.chunkFormat){let e=t.chunkFormat;const n=u,r=u;let s=!1;const o=u;if("array-push"!==e&&"commonjs"!==e&&"module"!==e&&!1!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var h=o===u;if(s=s||h,!s){const t=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}h=t===u,s=s||h}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.chunkLoadTimeout){const e=u;if("number"!=typeof t.chunkLoadTimeout)return xe.errors=[{params:{type:"number"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.chunkLoading){const e=u;i(t.chunkLoading,{instancePath:r+"/chunkLoading",parentData:t,parentDataProperty:"chunkLoading",rootData:a})||(l=null===l?i.errors:l.concat(i.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.chunkLoadingGlobal){const e=u;if("string"!=typeof t.chunkLoadingGlobal)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.clean){const e=u;he(t.clean,{instancePath:r+"/clean",parentData:t,parentDataProperty:"clean",rootData:a})||(l=null===l?he.errors:l.concat(he.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.compareBeforeEmit){const e=u;if("boolean"!=typeof t.compareBeforeEmit)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.crossOriginLoading){let e=t.crossOriginLoading;const n=u;if(!1!==e&&"anonymous"!==e&&"use-credentials"!==e)return xe.errors=[{params:{}}],!1;y=n===u}else y=!0;if(y){if(void 0!==t.cssChunkFilename){const e=u;de(t.cssChunkFilename,{instancePath:r+"/cssChunkFilename",parentData:t,parentDataProperty:"cssChunkFilename",rootData:a})||(l=null===l?de.errors:l.concat(de.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.cssFilename){const e=u;ge(t.cssFilename,{instancePath:r+"/cssFilename",parentData:t,parentDataProperty:"cssFilename",rootData:a})||(l=null===l?ge.errors:l.concat(ge.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.devtoolFallbackModuleFilenameTemplate){let e=t.devtoolFallbackModuleFilenameTemplate;const n=u,r=u;let s=!1;const o=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var d=o===u;if(s=s||d,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}d=t===u,s=s||d}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.devtoolModuleFilenameTemplate){let e=t.devtoolModuleFilenameTemplate;const n=u,r=u;let s=!1;const o=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var g=o===u;if(s=s||g,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}g=t===u,s=s||g}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.devtoolNamespace){const e=u;if("string"!=typeof t.devtoolNamespace)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.enabledChunkLoadingTypes){const e=u;be(t.enabledChunkLoadingTypes,{instancePath:r+"/enabledChunkLoadingTypes",parentData:t,parentDataProperty:"enabledChunkLoadingTypes",rootData:a})||(l=null===l?be.errors:l.concat(be.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.enabledLibraryTypes){const e=u;ve(t.enabledLibraryTypes,{instancePath:r+"/enabledLibraryTypes",parentData:t,parentDataProperty:"enabledLibraryTypes",rootData:a})||(l=null===l?ve.errors:l.concat(ve.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.enabledWasmLoadingTypes){const e=u;De(t.enabledWasmLoadingTypes,{instancePath:r+"/enabledWasmLoadingTypes",parentData:t,parentDataProperty:"enabledWasmLoadingTypes",rootData:a})||(l=null===l?De.errors:l.concat(De.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.environment){let e=t.environment;const r=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return xe.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if(!n.call(me,t))return xe.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.arrowFunction){const t=u;if("boolean"!=typeof e.arrowFunction)return xe.errors=[{params:{type:"boolean"}}],!1;var b=t===u}else b=!0;if(b){if(void 0!==e.bigIntLiteral){const t=u;if("boolean"!=typeof e.bigIntLiteral)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.const){const t=u;if("boolean"!=typeof e.const)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.destructuring){const t=u;if("boolean"!=typeof e.destructuring)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.dynamicImport){const t=u;if("boolean"!=typeof e.dynamicImport)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.forOf){const t=u;if("boolean"!=typeof e.forOf)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.module){const t=u;if("boolean"!=typeof e.module)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b){if(void 0!==e.optionalChaining){const t=u;if("boolean"!=typeof e.optionalChaining)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0;if(b)if(void 0!==e.templateLiteral){const t=u;if("boolean"!=typeof e.templateLiteral)return xe.errors=[{params:{type:"boolean"}}],!1;b=t===u}else b=!0}}}}}}}}}}y=r===u}else y=!0;if(y){if(void 0!==t.filename){const e=u;Pe(t.filename,{instancePath:r+"/filename",parentData:t,parentDataProperty:"filename",rootData:a})||(l=null===l?Pe.errors:l.concat(Pe.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.globalObject){let e=t.globalObject;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hashDigest){const e=u;if("string"!=typeof t.hashDigest)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.hashDigestLength){let e=t.hashDigestLength;const n=u;if(u==u){if("number"!=typeof e)return xe.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return xe.errors=[{params:{comparison:">=",limit:1}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hashFunction){let e=t.hashFunction;const n=u,r=u;let s=!1;const o=u;if(u===o)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}var v=o===u;if(s=s||v,!s){const t=u;if(!(e instanceof Function)){const e={params:{}};null===l?l=[e]:l.push(e),u++}v=t===u,s=s||v}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.hashSalt){let e=t.hashSalt;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.hotUpdateChunkFilename){let n=t.hotUpdateChunkFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.hotUpdateGlobal){const e=u;if("string"!=typeof t.hotUpdateGlobal)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.hotUpdateMainFilename){let n=t.hotUpdateMainFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.iife){const e=u;if("boolean"!=typeof t.iife)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.importFunctionName){const e=u;if("string"!=typeof t.importFunctionName)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.importMetaName){const e=u;if("string"!=typeof t.importMetaName)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.library){const e=u;Ae(t.library,{instancePath:r+"/library",parentData:t,parentDataProperty:"library",rootData:a})||(l=null===l?Ae.errors:l.concat(Ae.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.libraryExport){let e=t.libraryExport;const n=u,r=u;let s=!1,o=null;const a=u,i=u;let p=!1;const f=u;if(u===f)if(Array.isArray(e)){const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u;if(u===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===l?l=[e]:l.push(e),u++}var D=f===u;if(p=p||D,!p){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}D=t===u,p=p||D}if(p)u=i,null!==l&&(i?l.length=i:l=null);else{const e={params:{}};null===l?l=[e]:l.push(e),u++}if(a===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.libraryTarget){let e=t.libraryTarget;const n=u,r=u;let s=!1,o=null;const a=u,i=u;let p=!1;const f=u;if("var"!==e&&"module"!==e&&"assign"!==e&&"assign-properties"!==e&&"this"!==e&&"window"!==e&&"self"!==e&&"global"!==e&&"commonjs"!==e&&"commonjs2"!==e&&"commonjs-module"!==e&&"commonjs-static"!==e&&"amd"!==e&&"amd-require"!==e&&"umd"!==e&&"umd2"!==e&&"jsonp"!==e&&"system"!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var P=f===u;if(p=p||P,!p){const t=u;if("string"!=typeof e){const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}P=t===u,p=p||P}if(p)u=i,null!==l&&(i?l.length=i:l=null);else{const e={params:{}};null===l?l=[e]:l.push(e),u++}if(a===u&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.module){const e=u;if("boolean"!=typeof t.module)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.path){let n=t.path;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.pathinfo){let e=t.pathinfo;const n=u,r=u;let s=!1;const o=u;if("verbose"!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var A=o===u;if(s=s||A,!s){const t=u;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===l?l=[e]:l.push(e),u++}A=t===u,s=s||A}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.publicPath){const e=u;c(t.publicPath,{instancePath:r+"/publicPath",parentData:t,parentDataProperty:"publicPath",rootData:a})||(l=null===l?c.errors:l.concat(c.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.scriptType){let e=t.scriptType;const n=u;if(!1!==e&&"text/javascript"!==e&&"module"!==e)return xe.errors=[{params:{}}],!1;y=n===u}else y=!0;if(y){if(void 0!==t.sourceMapFilename){let n=t.sourceMapFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.sourcePrefix){const e=u;if("string"!=typeof t.sourcePrefix)return xe.errors=[{params:{type:"string"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.strictModuleErrorHandling){const e=u;if("boolean"!=typeof t.strictModuleErrorHandling)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.strictModuleExceptionHandling){const e=u;if("boolean"!=typeof t.strictModuleExceptionHandling)return xe.errors=[{params:{type:"boolean"}}],!1;y=e===u}else y=!0;if(y){if(void 0!==t.trustedTypes){let e=t.trustedTypes;const n=u,r=u;let s=!1;const o=u;if(!0!==e){const e={params:{}};null===l?l=[e]:l.push(e),u++}var x=o===u;if(s=s||x,!s){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}if(x=t===u,s=s||x,!s){const t=u;if(u==u)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=u;for(const t in e)if("policyName"!==t){const e={params:{additionalProperty:t}};null===l?l=[e]:l.push(e),u++;break}if(t===u&&void 0!==e.policyName){let t=e.policyName;if(u==u)if("string"==typeof t){if(t.length<1){const e={params:{}};null===l?l=[e]:l.push(e),u++}}else{const e={params:{type:"string"}};null===l?l=[e]:l.push(e),u++}}}else{const e={params:{type:"object"}};null===l?l=[e]:l.push(e),u++}x=t===u,s=s||x}}if(!s){const e={params:{}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=r,null!==l&&(r?l.length=r:l=null),y=n===u}else y=!0;if(y){if(void 0!==t.umdNamedDefine){const e=u,n=u;let r=!1,s=null;const o=u;if("boolean"!=typeof t.umdNamedDefine){const e={params:{type:"boolean"}};null===l?l=[e]:l.push(e),u++}if(o===u&&(r=!0,s=0),!r){const e={params:{passingSchemas:s}};return null===l?l=[e]:l.push(e),u++,xe.errors=l,!1}u=n,null!==l&&(n?l.length=n:l=null),y=e===u}else y=!0;if(y){if(void 0!==t.uniqueName){let e=t.uniqueName;const n=u;if(u==u){if("string"!=typeof e)return xe.errors=[{params:{type:"string"}}],!1;if(e.length<1)return xe.errors=[{params:{}}],!1}y=n===u}else y=!0;if(y){if(void 0!==t.wasmLoading){const e=u;m(t.wasmLoading,{instancePath:r+"/wasmLoading",parentData:t,parentDataProperty:"wasmLoading",rootData:a})||(l=null===l?m.errors:l.concat(m.errors),u=l.length),y=e===u}else y=!0;if(y){if(void 0!==t.webassemblyModuleFilename){let n=t.webassemblyModuleFilename;const r=u;if(u==u){if("string"!=typeof n)return xe.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!1!==e.test(n))return xe.errors=[{params:{}}],!1}y=r===u}else y=!0;if(y){if(void 0!==t.workerChunkLoading){const e=u;i(t.workerChunkLoading,{instancePath:r+"/workerChunkLoading",parentData:t,parentDataProperty:"workerChunkLoading",rootData:a})||(l=null===l?i.errors:l.concat(i.errors),u=l.length),y=e===u}else y=!0;if(y)if(void 0!==t.workerWasmLoading){const e=u;m(t.workerWasmLoading,{instancePath:r+"/workerWasmLoading",parentData:t,parentDataProperty:"workerWasmLoading",rootData:a})||(l=null===l?m.errors:l.concat(m.errors),u=l.length),y=e===u}else y=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return xe.errors=l,0===u}function ke(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if(!1!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const t=a;if(a==a)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=a;for(const t in e)if("assetFilter"!==t&&"hints"!==t&&"maxAssetSize"!==t&&"maxEntrypointSize"!==t){const e={params:{additionalProperty:t}};null===o?o=[e]:o.push(e),a++;break}if(t===a){if(void 0!==e.assetFilter){const t=a;if(!(e.assetFilter instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}var f=t===a}else f=!0;if(f){if(void 0!==e.hints){let t=e.hints;const n=a;if(!1!==t&&"warning"!==t&&"error"!==t){const e={params:{}};null===o?o=[e]:o.push(e),a++}f=n===a}else f=!0;if(f){if(void 0!==e.maxAssetSize){const t=a;if("number"!=typeof e.maxAssetSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}f=t===a}else f=!0;if(f)if(void 0!==e.maxEntrypointSize){const t=a;if("number"!=typeof e.maxEntrypointSize){const e={params:{type:"number"}};null===o?o=[e]:o.push(e),a++}f=t===a}else f=!0}}}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}u=t===a,l=l||u}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ke.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ke.errors=o,0===a}function je(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;if(0===a){if(!Array.isArray(e))return je.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=a,s=a;let l=!1;const p=a;if(a==a)if(t&&"object"==typeof t&&!Array.isArray(t)){let e;if(void 0===t.apply&&(e="apply")){const t={params:{missingProperty:e}};null===o?o=[t]:o.push(t),a++}else if(void 0!==t.apply&&!(t.apply instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}}else{const e={params:{type:"object"}};null===o?o=[e]:o.push(e),a++}var i=p===a;if(l=l||i,!l){const e=a;if(!(t instanceof Function)){const e={params:{}};null===o?o=[e]:o.push(e),a++}i=e===a,l=l||i}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,je.errors=o,!1}if(a=s,null!==o&&(s?o.length=s:o=null),r!==a)break}}}return je.errors=o,0===a}function Se(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(W(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?W.errors:o.concat(W.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,Se.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Se.errors=o,0===a}function Ce(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1,p=null;const u=a;if(W(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?W.errors:o.concat(W.errors),a=o.length),u===a&&(l=!0,p=0),!l){const e={params:{passingSchemas:p}};return null===o?o=[e]:o.push(e),a++,Ce.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),Ce.errors=o,0===a}const Oe={all:{type:"boolean"},assets:{type:"boolean"},assetsSort:{type:"string"},assetsSpace:{type:"number"},builtAt:{type:"boolean"},cached:{type:"boolean"},cachedAssets:{type:"boolean"},cachedModules:{type:"boolean"},children:{type:"boolean"},chunkGroupAuxiliary:{type:"boolean"},chunkGroupChildren:{type:"boolean"},chunkGroupMaxAssets:{type:"number"},chunkGroups:{type:"boolean"},chunkModules:{type:"boolean"},chunkModulesSpace:{type:"number"},chunkOrigins:{type:"boolean"},chunkRelations:{type:"boolean"},chunks:{type:"boolean"},chunksSort:{type:"string"},colors:{anyOf:[{type:"boolean"},{type:"object",additionalProperties:!1,properties:{bold:{type:"string"},cyan:{type:"string"},green:{type:"string"},magenta:{type:"string"},red:{type:"string"},yellow:{type:"string"}}}]},context:{type:"string",absolutePath:!0},dependentModules:{type:"boolean"},depth:{type:"boolean"},entrypoints:{anyOf:[{enum:["auto"]},{type:"boolean"}]},env:{type:"boolean"},errorDetails:{anyOf:[{enum:["auto"]},{type:"boolean"}]},errorStack:{type:"boolean"},errors:{type:"boolean"},errorsCount:{type:"boolean"},exclude:{anyOf:[{type:"boolean"},{$ref:"#/definitions/ModuleFilterTypes"}]},excludeAssets:{oneOf:[{$ref:"#/definitions/AssetFilterTypes"}]},excludeModules:{anyOf:[{type:"boolean"},{$ref:"#/definitions/ModuleFilterTypes"}]},groupAssetsByChunk:{type:"boolean"},groupAssetsByEmitStatus:{type:"boolean"},groupAssetsByExtension:{type:"boolean"},groupAssetsByInfo:{type:"boolean"},groupAssetsByPath:{type:"boolean"},groupModulesByAttributes:{type:"boolean"},groupModulesByCacheStatus:{type:"boolean"},groupModulesByExtension:{type:"boolean"},groupModulesByLayer:{type:"boolean"},groupModulesByPath:{type:"boolean"},groupModulesByType:{type:"boolean"},groupReasonsByOrigin:{type:"boolean"},hash:{type:"boolean"},ids:{type:"boolean"},logging:{anyOf:[{enum:["none","error","warn","info","log","verbose"]},{type:"boolean"}]},loggingDebug:{anyOf:[{type:"boolean"},{$ref:"#/definitions/FilterTypes"}]},loggingTrace:{type:"boolean"},moduleAssets:{type:"boolean"},moduleTrace:{type:"boolean"},modules:{type:"boolean"},modulesSort:{type:"string"},modulesSpace:{type:"number"},nestedModules:{type:"boolean"},nestedModulesSpace:{type:"number"},optimizationBailout:{type:"boolean"},orphanModules:{type:"boolean"},outputPath:{type:"boolean"},performance:{type:"boolean"},preset:{anyOf:[{type:"boolean"},{type:"string"}]},providedExports:{type:"boolean"},publicPath:{type:"boolean"},reasons:{type:"boolean"},reasonsSpace:{type:"number"},relatedAssets:{type:"boolean"},runtime:{type:"boolean"},runtimeModules:{type:"boolean"},source:{type:"boolean"},timings:{type:"boolean"},usedExports:{type:"boolean"},version:{type:"boolean"},warnings:{type:"boolean"},warningsCount:{type:"boolean"},warningsFilter:{oneOf:[{$ref:"#/definitions/WarningFilterTypes"}]}};function Fe(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Fe.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Fe.errors=a,0===i}function Re(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Re.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Re.errors=a,0===i}function Ee(t,{instancePath:n="",parentData:r,parentDataProperty:s,rootData:o=t}={}){let a=null,i=0;const l=i;let p=!1;const u=i;if(i===u)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n;r++){let n=t[r];const s=i,o=i;let l=!1,p=null;const u=i,c=i;let m=!1;const y=i;if(!(n instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var f=y===i;if(m=m||f,!m){const t=i;if(i===t)if("string"==typeof n){if(n.includes("!")||!1!==e.test(n)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(f=t===i,m=m||f,!m){const e=i;if(!(n instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}f=e===i,m=m||f}}if(m)i=c,null!==a&&(c?a.length=c:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}if(u===i&&(l=!0,p=0),l)i=o,null!==a&&(o?a.length=o:a=null);else{const e={params:{passingSchemas:p}};null===a?a=[e]:a.push(e),i++}if(s!==i)break}}else{const e={params:{type:"array"}};null===a?a=[e]:a.push(e),i++}var c=u===i;if(p=p||c,!p){const n=i,r=i;let s=!1;const o=i;if(!(t instanceof RegExp)){const e={params:{}};null===a?a=[e]:a.push(e),i++}var m=o===i;if(s=s||m,!s){const n=i;if(i===n)if("string"==typeof t){if(t.includes("!")||!1!==e.test(t)){const e={params:{}};null===a?a=[e]:a.push(e),i++}}else{const e={params:{type:"string"}};null===a?a=[e]:a.push(e),i++}if(m=n===i,s=s||m,!s){const e=i;if(!(t instanceof Function)){const e={params:{}};null===a?a=[e]:a.push(e),i++}m=e===i,s=s||m}}if(s)i=r,null!==a&&(r?a.length=r:a=null);else{const e={params:{}};null===a?a=[e]:a.push(e),i++}c=n===i,p=p||c}if(!p){const e={params:{}};return null===a?a=[e]:a.push(e),i++,Ee.errors=a,!1}return i=l,null!==a&&(l?a.length=l:a=null),Ee.errors=a,0===i}function $e(t,{instancePath:r="",parentData:s,parentDataProperty:o,rootData:a=t}={}){let i=null,l=0;if(0===l){if(!t||"object"!=typeof t||Array.isArray(t))return $e.errors=[{params:{type:"object"}}],!1;{const s=l;for(const e in t)if(!n.call(Oe,e))return $e.errors=[{params:{additionalProperty:e}}],!1;if(s===l){if(void 0!==t.all){const e=l;if("boolean"!=typeof t.all)return $e.errors=[{params:{type:"boolean"}}],!1;var p=e===l}else p=!0;if(p){if(void 0!==t.assets){const e=l;if("boolean"!=typeof t.assets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.assetsSort){const e=l;if("string"!=typeof t.assetsSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.assetsSpace){const e=l;if("number"!=typeof t.assetsSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.builtAt){const e=l;if("boolean"!=typeof t.builtAt)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cached){const e=l;if("boolean"!=typeof t.cached)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cachedAssets){const e=l;if("boolean"!=typeof t.cachedAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.cachedModules){const e=l;if("boolean"!=typeof t.cachedModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.children){const e=l;if("boolean"!=typeof t.children)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupAuxiliary){const e=l;if("boolean"!=typeof t.chunkGroupAuxiliary)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupChildren){const e=l;if("boolean"!=typeof t.chunkGroupChildren)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroupMaxAssets){const e=l;if("number"!=typeof t.chunkGroupMaxAssets)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkGroups){const e=l;if("boolean"!=typeof t.chunkGroups)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkModules){const e=l;if("boolean"!=typeof t.chunkModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkModulesSpace){const e=l;if("number"!=typeof t.chunkModulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkOrigins){const e=l;if("boolean"!=typeof t.chunkOrigins)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunkRelations){const e=l;if("boolean"!=typeof t.chunkRelations)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunks){const e=l;if("boolean"!=typeof t.chunks)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.chunksSort){const e=l;if("string"!=typeof t.chunksSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.colors){let e=t.colors;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var u=o===l;if(s=s||u,!s){const t=l;if(l===t)if(e&&"object"==typeof e&&!Array.isArray(e)){const t=l;for(const t in e)if("bold"!==t&&"cyan"!==t&&"green"!==t&&"magenta"!==t&&"red"!==t&&"yellow"!==t){const e={params:{additionalProperty:t}};null===i?i=[e]:i.push(e),l++;break}if(t===l){if(void 0!==e.bold){const t=l;if("string"!=typeof e.bold){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}var f=t===l}else f=!0;if(f){if(void 0!==e.cyan){const t=l;if("string"!=typeof e.cyan){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.green){const t=l;if("string"!=typeof e.green){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.magenta){const t=l;if("string"!=typeof e.magenta){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f){if(void 0!==e.red){const t=l;if("string"!=typeof e.red){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0;if(f)if(void 0!==e.yellow){const t=l;if("string"!=typeof e.yellow){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}f=t===l}else f=!0}}}}}}else{const e={params:{type:"object"}};null===i?i=[e]:i.push(e),l++}u=t===l,s=s||u}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.context){let n=t.context;const r=l;if(l===r){if("string"!=typeof n)return $e.errors=[{params:{type:"string"}}],!1;if(n.includes("!")||!0!==e.test(n))return $e.errors=[{params:{}}],!1}p=r===l}else p=!0;if(p){if(void 0!==t.dependentModules){const e=l;if("boolean"!=typeof t.dependentModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.depth){const e=l;if("boolean"!=typeof t.depth)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.entrypoints){let e=t.entrypoints;const n=l,r=l;let s=!1;const o=l;if("auto"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var c=o===l;if(s=s||c,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}c=t===l,s=s||c}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.env){const e=l;if("boolean"!=typeof t.env)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errorDetails){let e=t.errorDetails;const n=l,r=l;let s=!1;const o=l;if("auto"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var m=o===l;if(s=s||m,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}m=t===l,s=s||m}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.errorStack){const e=l;if("boolean"!=typeof t.errorStack)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errors){const e=l;if("boolean"!=typeof t.errors)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.errorsCount){const e=l;if("boolean"!=typeof t.errorsCount)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.exclude){let e=t.exclude;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var y=u===l;if(o=o||y,!o){const n=l;Fe(e,{instancePath:r+"/exclude",parentData:t,parentDataProperty:"exclude",rootData:a})||(i=null===i?Fe.errors:i.concat(Fe.errors),l=i.length),y=n===l,o=o||y}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.excludeAssets){const e=l,n=l;let s=!1,o=null;const u=l;if(Re(t.excludeAssets,{instancePath:r+"/excludeAssets",parentData:t,parentDataProperty:"excludeAssets",rootData:a})||(i=null===i?Re.errors:i.concat(Re.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0;if(p){if(void 0!==t.excludeModules){let e=t.excludeModules;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var h=u===l;if(o=o||h,!o){const n=l;Fe(e,{instancePath:r+"/excludeModules",parentData:t,parentDataProperty:"excludeModules",rootData:a})||(i=null===i?Fe.errors:i.concat(Fe.errors),l=i.length),h=n===l,o=o||h}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.groupAssetsByChunk){const e=l;if("boolean"!=typeof t.groupAssetsByChunk)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByEmitStatus){const e=l;if("boolean"!=typeof t.groupAssetsByEmitStatus)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByExtension){const e=l;if("boolean"!=typeof t.groupAssetsByExtension)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByInfo){const e=l;if("boolean"!=typeof t.groupAssetsByInfo)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupAssetsByPath){const e=l;if("boolean"!=typeof t.groupAssetsByPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByAttributes){const e=l;if("boolean"!=typeof t.groupModulesByAttributes)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByCacheStatus){const e=l;if("boolean"!=typeof t.groupModulesByCacheStatus)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByExtension){const e=l;if("boolean"!=typeof t.groupModulesByExtension)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByLayer){const e=l;if("boolean"!=typeof t.groupModulesByLayer)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByPath){const e=l;if("boolean"!=typeof t.groupModulesByPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupModulesByType){const e=l;if("boolean"!=typeof t.groupModulesByType)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.groupReasonsByOrigin){const e=l;if("boolean"!=typeof t.groupReasonsByOrigin)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.hash){const e=l;if("boolean"!=typeof t.hash)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.ids){const e=l;if("boolean"!=typeof t.ids)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.logging){let e=t.logging;const n=l,r=l;let s=!1;const o=l;if("none"!==e&&"error"!==e&&"warn"!==e&&"info"!==e&&"log"!==e&&"verbose"!==e){const e={params:{}};null===i?i=[e]:i.push(e),l++}var d=o===l;if(s=s||d,!s){const t=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}d=t===l,s=s||d}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.loggingDebug){let e=t.loggingDebug;const n=l,s=l;let o=!1;const u=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var g=u===l;if(o=o||g,!o){const n=l;O(e,{instancePath:r+"/loggingDebug",parentData:t,parentDataProperty:"loggingDebug",rootData:a})||(i=null===i?O.errors:i.concat(O.errors),l=i.length),g=n===l,o=o||g}if(!o){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=s,null!==i&&(s?i.length=s:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.loggingTrace){const e=l;if("boolean"!=typeof t.loggingTrace)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.moduleAssets){const e=l;if("boolean"!=typeof t.moduleAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.moduleTrace){const e=l;if("boolean"!=typeof t.moduleTrace)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modules){const e=l;if("boolean"!=typeof t.modules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modulesSort){const e=l;if("string"!=typeof t.modulesSort)return $e.errors=[{params:{type:"string"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.modulesSpace){const e=l;if("number"!=typeof t.modulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.nestedModules){const e=l;if("boolean"!=typeof t.nestedModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.nestedModulesSpace){const e=l;if("number"!=typeof t.nestedModulesSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.optimizationBailout){const e=l;if("boolean"!=typeof t.optimizationBailout)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.orphanModules){const e=l;if("boolean"!=typeof t.orphanModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.outputPath){const e=l;if("boolean"!=typeof t.outputPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.performance){const e=l;if("boolean"!=typeof t.performance)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.preset){let e=t.preset;const n=l,r=l;let s=!1;const o=l;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===i?i=[e]:i.push(e),l++}var b=o===l;if(s=s||b,!s){const t=l;if("string"!=typeof e){const e={params:{type:"string"}};null===i?i=[e]:i.push(e),l++}b=t===l,s=s||b}if(!s){const e={params:{}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=r,null!==i&&(r?i.length=r:i=null),p=n===l}else p=!0;if(p){if(void 0!==t.providedExports){const e=l;if("boolean"!=typeof t.providedExports)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.publicPath){const e=l;if("boolean"!=typeof t.publicPath)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reasons){const e=l;if("boolean"!=typeof t.reasons)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.reasonsSpace){const e=l;if("number"!=typeof t.reasonsSpace)return $e.errors=[{params:{type:"number"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.relatedAssets){const e=l;if("boolean"!=typeof t.relatedAssets)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.runtime){const e=l;if("boolean"!=typeof t.runtime)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.runtimeModules){const e=l;if("boolean"!=typeof t.runtimeModules)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.source){const e=l;if("boolean"!=typeof t.source)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.timings){const e=l;if("boolean"!=typeof t.timings)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.usedExports){const e=l;if("boolean"!=typeof t.usedExports)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.version){const e=l;if("boolean"!=typeof t.version)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.warnings){const e=l;if("boolean"!=typeof t.warnings)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p){if(void 0!==t.warningsCount){const e=l;if("boolean"!=typeof t.warningsCount)return $e.errors=[{params:{type:"boolean"}}],!1;p=e===l}else p=!0;if(p)if(void 0!==t.warningsFilter){const e=l,n=l;let s=!1,o=null;const u=l;if(Ee(t.warningsFilter,{instancePath:r+"/warningsFilter",parentData:t,parentDataProperty:"warningsFilter",rootData:a})||(i=null===i?Ee.errors:i.concat(Ee.errors),l=i.length),u===l&&(s=!0,o=0),!s){const e={params:{passingSchemas:o}};return null===i?i=[e]:i.push(e),l++,$e.errors=i,!1}l=n,null!==i&&(n?i.length=n:i=null),p=e===l}else p=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return $e.errors=i,0===l}function ze(e,{instancePath:t="",parentData:n,parentDataProperty:r,rootData:s=e}={}){let o=null,a=0;const i=a;let l=!1;const p=a;if("none"!==e&&"summary"!==e&&"errors-only"!==e&&"errors-warnings"!==e&&"minimal"!==e&&"normal"!==e&&"detailed"!==e&&"verbose"!==e){const e={params:{}};null===o?o=[e]:o.push(e),a++}var u=p===a;if(l=l||u,!l){const i=a;if("boolean"!=typeof e){const e={params:{type:"boolean"}};null===o?o=[e]:o.push(e),a++}if(u=i===a,l=l||u,!l){const i=a;$e(e,{instancePath:t,parentData:n,parentDataProperty:r,rootData:s})||(o=null===o?$e.errors:o.concat($e.errors),a=o.length),u=i===a,l=l||u}}if(!l){const e={params:{}};return null===o?o=[e]:o.push(e),a++,ze.errors=o,!1}return a=i,null!==o&&(i?o.length=i:o=null),ze.errors=o,0===a}const Le=new RegExp("^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$","u");function we(r,{instancePath:s="",parentData:a,parentDataProperty:i,rootData:l=r}={}){let p=null,u=0;if(0===u){if(!r||"object"!=typeof r||Array.isArray(r))return we.errors=[{params:{type:"object"}}],!1;{const a=u;for(const e in r)if(!n.call(t,e))return we.errors=[{params:{additionalProperty:e}}],!1;if(a===u){if(void 0!==r.amd){let e=r.amd;const t=u,n=u;let s=!1;const o=u;if(!1!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}var f=o===u;if(s=s||f,!s){const t=u;if(!e||"object"!=typeof e||Array.isArray(e)){const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}f=t===u,s=s||f}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null);var c=t===u}else c=!0;if(c){if(void 0!==r.bail){const e=u;if("boolean"!=typeof r.bail)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.cache){const e=u;o(r.cache,{instancePath:s+"/cache",parentData:r,parentDataProperty:"cache",rootData:l})||(p=null===p?o.errors:p.concat(o.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.context){let t=r.context;const n=u;if(u==u){if("string"!=typeof t)return we.errors=[{params:{type:"string"}}],!1;if(t.includes("!")||!0!==e.test(t))return we.errors=[{params:{}}],!1}c=n===u}else c=!0;if(c){if(void 0!==r.dependencies){let e=r.dependencies;const t=u;if(u==u){if(!Array.isArray(e))return we.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){const t=u;if("string"!=typeof e[n])return we.errors=[{params:{type:"string"}}],!1;if(t!==u)break}}}c=t===u}else c=!0;if(c){if(void 0!==r.devServer){let e=r.devServer;const t=u;if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.devtool){let e=r.devtool;const t=u,n=u;let s=!1;const o=u;if(!1!==e&&"eval"!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}var m=o===u;if(s=s||m,!s){const t=u;if(u===t)if("string"==typeof e){if(!Le.test(e)){const e={params:{pattern:"^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$"}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}m=t===u,s=s||m}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null),c=t===u}else c=!0;if(c){if(void 0!==r.entry){const e=u;b(r.entry,{instancePath:s+"/entry",parentData:r,parentDataProperty:"entry",rootData:l})||(p=null===p?b.errors:p.concat(b.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.experiments){const e=u;k(r.experiments,{instancePath:s+"/experiments",parentData:r,parentDataProperty:"experiments",rootData:l})||(p=null===p?k.errors:p.concat(k.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.externals){const e=u;C(r.externals,{instancePath:s+"/externals",parentData:r,parentDataProperty:"externals",rootData:l})||(p=null===p?C.errors:p.concat(C.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.externalsPresets){let e=r.externalsPresets;const t=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("electron"!==t&&"electronMain"!==t&&"electronPreload"!==t&&"electronRenderer"!==t&&"node"!==t&&"nwjs"!==t&&"web"!==t&&"webAsync"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.electron){const t=u;if("boolean"!=typeof e.electron)return we.errors=[{params:{type:"boolean"}}],!1;var y=t===u}else y=!0;if(y){if(void 0!==e.electronMain){const t=u;if("boolean"!=typeof e.electronMain)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.electronPreload){const t=u;if("boolean"!=typeof e.electronPreload)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.electronRenderer){const t=u;if("boolean"!=typeof e.electronRenderer)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.node){const t=u;if("boolean"!=typeof e.node)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.nwjs){const t=u;if("boolean"!=typeof e.nwjs)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y){if(void 0!==e.web){const t=u;if("boolean"!=typeof e.web)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0;if(y)if(void 0!==e.webAsync){const t=u;if("boolean"!=typeof e.webAsync)return we.errors=[{params:{type:"boolean"}}],!1;y=t===u}else y=!0}}}}}}}}}c=t===u}else c=!0;if(c){if(void 0!==r.externalsType){let e=r.externalsType;const t=u;if("var"!==e&&"module"!==e&&"assign"!==e&&"this"!==e&&"window"!==e&&"self"!==e&&"global"!==e&&"commonjs"!==e&&"commonjs2"!==e&&"commonjs-module"!==e&&"commonjs-static"!==e&&"amd"!==e&&"amd-require"!==e&&"umd"!==e&&"umd2"!==e&&"jsonp"!==e&&"system"!==e&&"promise"!==e&&"import"!==e&&"script"!==e&&"node-commonjs"!==e)return we.errors=[{params:{}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.ignoreWarnings){let e=r.ignoreWarnings;const t=u;if(u==u){if(!Array.isArray(e))return we.errors=[{params:{type:"array"}}],!1;{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u,s=u;let o=!1;const a=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var h=a===u;if(o=o||h,!o){const e=u;if(u===e)if(t&&"object"==typeof t&&!Array.isArray(t)){const e=u;for(const e in t)if("file"!==e&&"message"!==e&&"module"!==e){const t={params:{additionalProperty:e}};null===p?p=[t]:p.push(t),u++;break}if(e===u){if(void 0!==t.file){const e=u;if(!(t.file instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var d=e===u}else d=!0;if(d){if(void 0!==t.message){const e=u;if(!(t.message instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0;if(d)if(void 0!==t.module){const e=u;if(!(t.module instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}d=e===u}else d=!0}}}else{const e={params:{type:"object"}};null===p?p=[e]:p.push(e),u++}if(h=e===u,o=o||h,!o){const e=u;if(!(t instanceof Function)){const e={params:{}};null===p?p=[e]:p.push(e),u++}h=e===u,o=o||h}}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=s,null!==p&&(s?p.length=s:p=null),r!==u)break}}}c=t===u}else c=!0;if(c){if(void 0!==r.infrastructureLogging){const e=u;F(r.infrastructureLogging,{instancePath:s+"/infrastructureLogging",parentData:r,parentDataProperty:"infrastructureLogging",rootData:l})||(p=null===p?F.errors:p.concat(F.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.loader){let e=r.loader;const t=u;if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.mode){let e=r.mode;const t=u;if("development"!==e&&"production"!==e&&"none"!==e)return we.errors=[{params:{}}],!1;c=t===u}else c=!0;if(c){if(void 0!==r.module){const e=u;oe(r.module,{instancePath:s+"/module",parentData:r,parentDataProperty:"module",rootData:l})||(p=null===p?oe.errors:p.concat(oe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.name){const e=u;if("string"!=typeof r.name)return we.errors=[{params:{type:"string"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.node){const e=u;ne(r.node,{instancePath:s+"/node",parentData:r,parentDataProperty:"node",rootData:l})||(p=null===p?ne.errors:p.concat(ne.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.optimization){const e=u;fe(r.optimization,{instancePath:s+"/optimization",parentData:r,parentDataProperty:"optimization",rootData:l})||(p=null===p?fe.errors:p.concat(fe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.output){const e=u;xe(r.output,{instancePath:s+"/output",parentData:r,parentDataProperty:"output",rootData:l})||(p=null===p?xe.errors:p.concat(xe.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.parallelism){let e=r.parallelism;const t=u;if(u==u){if("number"!=typeof e)return we.errors=[{params:{type:"number"}}],!1;if(e<1||isNaN(e))return we.errors=[{params:{comparison:">=",limit:1}}],!1}c=t===u}else c=!0;if(c){if(void 0!==r.performance){const e=u;ke(r.performance,{instancePath:s+"/performance",parentData:r,parentDataProperty:"performance",rootData:l})||(p=null===p?ke.errors:p.concat(ke.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.plugins){const e=u;je(r.plugins,{instancePath:s+"/plugins",parentData:r,parentDataProperty:"plugins",rootData:l})||(p=null===p?je.errors:p.concat(je.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.profile){const e=u;if("boolean"!=typeof r.profile)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c){if(void 0!==r.recordsInputPath){let t=r.recordsInputPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var g=a===u;if(o=o||g,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}g=n===u,o=o||g}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.recordsOutputPath){let t=r.recordsOutputPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var v=a===u;if(o=o||v,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}v=n===u,o=o||v}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.recordsPath){let t=r.recordsPath;const n=u,s=u;let o=!1;const a=u;if(!1!==t){const e={params:{}};null===p?p=[e]:p.push(e),u++}var D=a===u;if(o=o||D,!o){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}D=n===u,o=o||D}if(!o){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=s,null!==p&&(s?p.length=s:p=null),c=n===u}else c=!0;if(c){if(void 0!==r.resolve){const e=u;Se(r.resolve,{instancePath:s+"/resolve",parentData:r,parentDataProperty:"resolve",rootData:l})||(p=null===p?Se.errors:p.concat(Se.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.resolveLoader){const e=u;Ce(r.resolveLoader,{instancePath:s+"/resolveLoader",parentData:r,parentDataProperty:"resolveLoader",rootData:l})||(p=null===p?Ce.errors:p.concat(Ce.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.snapshot){let t=r.snapshot;const n=u;if(u==u){if(!t||"object"!=typeof t||Array.isArray(t))return we.errors=[{params:{type:"object"}}],!1;{const n=u;for(const e in t)if("buildDependencies"!==e&&"immutablePaths"!==e&&"managedPaths"!==e&&"module"!==e&&"resolve"!==e&&"resolveBuildDependencies"!==e)return we.errors=[{params:{additionalProperty:e}}],!1;if(n===u){if(void 0!==t.buildDependencies){let e=t.buildDependencies;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var P=t===u}else P=!0;if(P)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;P=t===u}else P=!0}}}var A=n===u}else A=!0;if(A){if(void 0!==t.immutablePaths){let n=t.immutablePaths;const r=u;if(u===r){if(!Array.isArray(n))return we.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var x=i===u;if(a=a||x,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}x=n===u,a=a||x}if(!a){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=o,null!==p&&(o?p.length=o:p=null),s!==u)break}}}A=r===u}else A=!0;if(A){if(void 0!==t.managedPaths){let n=t.managedPaths;const r=u;if(u===r){if(!Array.isArray(n))return we.errors=[{params:{type:"array"}}],!1;{const t=n.length;for(let r=0;r<t;r++){let t=n[r];const s=u,o=u;let a=!1;const i=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}var j=i===u;if(a=a||j,!a){const n=u;if(u===n)if("string"==typeof t){if(t.includes("!")||!0!==e.test(t)){const e={params:{}};null===p?p=[e]:p.push(e),u++}else if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}j=n===u,a=a||j}if(!a){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}if(u=o,null!==p&&(o?p.length=o:p=null),s!==u)break}}}A=r===u}else A=!0;if(A){if(void 0!==t.module){let e=t.module;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var S=t===u}else S=!0;if(S)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;S=t===u}else S=!0}}}A=n===u}else A=!0;if(A){if(void 0!==t.resolve){let e=t.resolve;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var O=t===u}else O=!0;if(O)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;O=t===u}else O=!0}}}A=n===u}else A=!0;if(A)if(void 0!==t.resolveBuildDependencies){let e=t.resolveBuildDependencies;const n=u;if(u===n){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("hash"!==t&&"timestamp"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.hash){const t=u;if("boolean"!=typeof e.hash)return we.errors=[{params:{type:"boolean"}}],!1;var R=t===u}else R=!0;if(R)if(void 0!==e.timestamp){const t=u;if("boolean"!=typeof e.timestamp)return we.errors=[{params:{type:"boolean"}}],!1;R=t===u}else R=!0}}}A=n===u}else A=!0}}}}}}}c=n===u}else c=!0;if(c){if(void 0!==r.stats){const e=u;ze(r.stats,{instancePath:s+"/stats",parentData:r,parentDataProperty:"stats",rootData:l})||(p=null===p?ze.errors:p.concat(ze.errors),u=p.length),c=e===u}else c=!0;if(c){if(void 0!==r.target){let e=r.target;const t=u,n=u;let s=!1;const o=u;if(u===o)if(Array.isArray(e))if(e.length<1){const e={params:{limit:1}};null===p?p=[e]:p.push(e),u++}else{const t=e.length;for(let n=0;n<t;n++){let t=e[n];const r=u;if(u===r)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var E=o===u;if(s=s||E,!s){const t=u;if(!1!==e){const e={params:{}};null===p?p=[e]:p.push(e),u++}if(E=t===u,s=s||E,!s){const t=u;if(u===t)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}E=t===u,s=s||E}}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=n,null!==p&&(n?p.length=n:p=null),c=t===u}else c=!0;if(c){if(void 0!==r.watch){const e=u;if("boolean"!=typeof r.watch)return we.errors=[{params:{type:"boolean"}}],!1;c=e===u}else c=!0;if(c)if(void 0!==r.watchOptions){let e=r.watchOptions;const t=u;if(u==u){if(!e||"object"!=typeof e||Array.isArray(e))return we.errors=[{params:{type:"object"}}],!1;{const t=u;for(const t in e)if("aggregateTimeout"!==t&&"followSymlinks"!==t&&"ignored"!==t&&"poll"!==t&&"stdin"!==t)return we.errors=[{params:{additionalProperty:t}}],!1;if(t===u){if(void 0!==e.aggregateTimeout){const t=u;if("number"!=typeof e.aggregateTimeout)return we.errors=[{params:{type:"number"}}],!1;var $=t===u}else $=!0;if($){if(void 0!==e.followSymlinks){const t=u;if("boolean"!=typeof e.followSymlinks)return we.errors=[{params:{type:"boolean"}}],!1;$=t===u}else $=!0;if($){if(void 0!==e.ignored){let t=e.ignored;const n=u,r=u;let s=!1;const o=u;if(u===o)if(Array.isArray(t)){const e=t.length;for(let n=0;n<e;n++){let e=t[n];const r=u;if(u===r)if("string"==typeof e){if(e.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}if(r!==u)break}}else{const e={params:{type:"array"}};null===p?p=[e]:p.push(e),u++}var z=o===u;if(s=s||z,!s){const e=u;if(!(t instanceof RegExp)){const e={params:{}};null===p?p=[e]:p.push(e),u++}if(z=e===u,s=s||z,!s){const e=u;if(u===e)if("string"==typeof t){if(t.length<1){const e={params:{}};null===p?p=[e]:p.push(e),u++}}else{const e={params:{type:"string"}};null===p?p=[e]:p.push(e),u++}z=e===u,s=s||z}}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),$=n===u}else $=!0;if($){if(void 0!==e.poll){let t=e.poll;const n=u,r=u;let s=!1;const o=u;if("number"!=typeof t){const e={params:{type:"number"}};null===p?p=[e]:p.push(e),u++}var L=o===u;if(s=s||L,!s){const e=u;if("boolean"!=typeof t){const e={params:{type:"boolean"}};null===p?p=[e]:p.push(e),u++}L=e===u,s=s||L}if(!s){const e={params:{}};return null===p?p=[e]:p.push(e),u++,we.errors=p,!1}u=r,null!==p&&(r?p.length=r:p=null),$=n===u}else $=!0;if($)if(void 0!==e.stdin){const t=u;if("boolean"!=typeof e.stdin)return we.errors=[{params:{type:"boolean"}}],!1;$=t===u}else $=!0}}}}}}c=t===u}else c=!0}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}return we.errors=p,0===u}
diff --git a/a.js b/b.js
@@ -7,8 +7,6 @@
A blob:782a076a4c79374e718dd13fb50d352cd475196d
	Author Tobias Koppers @sokra
*/

"use strict";

const { cachedSetProperty } = require("../util/cleverMerge");
const ContextElementDependency = require("./ContextElementDependency");
const ImportMetaContextDependency = require("./ImportMetaContextDependency");
const ImportMetaContextDependencyParserPlugin = require("./ImportMetaContextDependencyParserPlugin");
const RequireContextDependency = require("./RequireContextDependency");
const RequireContextDependencyParserPlugin = require("./RequireContextDependencyParserPlugin");

/** @typedef {import("../../declarations/WebpackOptions").ResolveOptions} ResolveOptions */
diff --git a/a.js b/b.js
@@ -36,14 +34,6 @@ apply(compiler) {
A blob:782a076a4c79374e718dd13fb50d352cd475196d
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireContextPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireContextDependency,
					new RequireContextDependency.Template()
				);
				compilation.dependencyFactories.set(
					ImportMetaContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportMetaContextDependency,
					new ImportMetaContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					ContextElementDependency,
					normalModuleFactory
diff --git a/a.js b/b.js
@@ -60,16 +50,6 @@ apply(compiler) {
A blob:782a076a4c79374e718dd13fb50d352cd475196d
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireContextPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireContextDependency,
					new RequireContextDependency.Template()
				);
				compilation.dependencyFactories.set(
					ImportMetaContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportMetaContextDependency,
					new ImportMetaContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					ContextElementDependency,
					normalModuleFactory
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireContext !== undefined &&
						!parserOptions.requireContext
					)
						return;

					new RequireContextDependencyParserPlugin().apply(parser);
				};

				const handlerImportMeta = (parser, parserOptions) => {
					new ImportMetaContextDependencyParserPlugin().apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireContextPlugin", handlerImportMeta);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("RequireContextPlugin", handlerImportMeta);
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireContextPlugin", handler);
				normalModuleFactory.hooks.parser
diff --git a/a.js b/b.js
@@ -1,4 +1,11 @@
A blob:a3f34d8d18a80148a53eabdec7df9f2dea91971a
it("should not bundle context requires with asyncMode === 'weak'", function() {
	const contextRequire = import.meta.webpackContext(".", {
		recursive: false,
		regExp: /two/,
		mode: "weak"
diff --git a/a.js b/b.js
@@ -10,13 +17,13 @@ expect(function() {
A blob:a3f34d8d18a80148a53eabdec7df9f2dea91971a
	const contextRequire = import.meta.webpackContext(".", {
		recursive: false,
		regExp: /two/,
		mode: "weak"
	});
	expect(function() {
		contextRequire("./two")
	}).toThrowError(/not available/);
});

it("should find module with asyncMode === 'weak' when required elsewhere", function() {
	const contextRequire = require.context(".", false, /.+/, "weak");
	expect(contextRequire("./three")).toBe(3);
	require("./three"); // in a real app would be served as a separate chunk
});

it("should find module with asyncMode === 'weak' when required elsewhere (recursive)", function() {
	const contextRequire = require.context(".", true, /.+/, "weak");
	expect(contextRequire("./dir/four")).toBe(4);
	require("./dir/four"); // in a real app would be served as a separate chunk
});

diff --git a/a.js b/b.js
@@ -46,6 +46,7 @@
A blob:be925f61044bd2adfb1d5e2c94e6dc4a6a5ecec8

const ZERO_BIG_INT = BigInt(0);

const compareModuleIterables = compareIterables(compareModulesByIdentifier);

/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */
/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */

/**
 * @typedef {Object} ChunkSizeOptions
 * @property {number=} chunkOverhead constant overhead for a chunk
diff --git a/a.js b/b.js
@@ -1180,8 +1181,6 @@ getChunkDependentHashModulesIterable(chunk) {
A blob:be925f61044bd2adfb1d5e2c94e6dc4a6a5ecec8

	/**
	 * @param {Chunk} chunk the chunk
	 * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)
	 */
	getChunkDependentHashModulesIterable(chunk) {
		const cgc = this._getChunkGraphChunk(chunk);
		return cgc.dependentHashModules;
	}

	/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */

	/**
	 * @param {Chunk} chunk the chunk
	 * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)
	 */
diff --git a/a.js b/b.js
@@ -43,6 +43,7 @@
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
	tryRunOrWebpackError
} = require("./HookWebpackError");
const MainTemplate = require("./MainTemplate");
const Module = require("./Module");
const ModuleDependencyError = require("./ModuleDependencyError");
const ModuleDependencyWarning = require("./ModuleDependencyWarning");
const ModuleGraph = require("./ModuleGraph");
const ModuleNotFoundError = require("./ModuleNotFoundError");
const ModuleProfile = require("./ModuleProfile");
const ModuleRestoreError = require("./ModuleRestoreError");
const ModuleStoreError = require("./ModuleStoreError");
diff --git a/a.js b/b.js
@@ -182,6 +183,7 @@
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
 * @property {function(number): string=} hashWithLength
 * @property {(Record<string, string>)=} contentHash
 * @property {(Record<string, (length: number) => string>)=} contentHashWithLength
 */

/**
 * @typedef {Object} ChunkHashContext
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 */
diff --git a/a.js b/b.js
@@ -3326,7 +3328,8 @@ _codeGenerationModule(
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
	 * @param {WebpackError[]} errors errors
	 * @param {CodeGenerationResults} results results
	 * @param {function(WebpackError=, boolean=): void} callback callback
	 */
	_codeGenerationModule(
		module,
		runtime,
		runtimes,
		hash,
		dependencyTemplates,
		chunkGraph,
		moduleGraph,
		runtimeTemplate,
		errors,
		results,
		callback
	) {
		let codeGenerated = false;
		const cache = new MultiItemCache(
			runtimes.map(runtime =>
				this._codeGenerationCache.getItemCache(
					`${module.identifier()}|${getRuntimeKey(runtime)}`,
					`${hash}|${dependencyTemplates.getHash()}`
				)
			)
		);
		cache.get((err, cachedResult) => {
			if (err) return callback(err);
			let result;
			if (!cachedResult) {
				try {
					codeGenerated = true;
					this.codeGeneratedModules.add(module);
					result = module.codeGeneration({
						chunkGraph,
						moduleGraph,
						dependencyTemplates,
						runtimeTemplate,
						runtime,
						codeGenerationResults: results
					});
				} catch (err) {
					errors.push(new CodeGenerationError(module, err));
					result = cachedResult = {
diff --git a/a.js b/b.js
@@ -3882,6 +3885,7 @@ createModuleHashes() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
diff --git a/a.js b/b.js
@@ -3892,7 +3896,7 @@ createModuleHashes() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
diff --git a/a.js b/b.js
@@ -3906,13 +3910,20 @@ createModuleHashes() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.substr(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
				}
				statModulesHashed++;
				const digest = this._createModuleHash(
					module,
					chunkGraph,
					runtime,
					hashFunction,
					runtimeTemplate,
					hashDigest,
					hashDigestLength
				);
				if (memCache) {
					memCache.set(`moduleHash-${getRuntimeKey(runtime)}`, digest);
				}
			}
		}
		this.logger.log(
			`${statModulesHashed} modules hashed, ${statModulesFromCache} from cache (${
				Math.round(
					(100 * (statModulesHashed + statModulesFromCache)) / this.modules.size
diff --git a/a.js b/b.js
@@ -3929,22 +3940,27 @@ _createModuleHash(
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
				) / 100
			} variants per module in average)`
		);
	}

	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength
	) {
		const moduleHash = createHash(hashFunction);
		module.updateHash(moduleHash, {
			chunkGraph,
			runtime,
			runtimeTemplate
		});
		const moduleHashDigest = /** @type {string} */ (
			moduleHash.digest(hashDigest)
		);
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

diff --git a/a.js b/b.js
@@ -4090,6 +4106,7 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
diff --git a/a.js b/b.js
@@ -4104,7 +4121,8 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
diff --git a/a.js b/b.js
@@ -4128,15 +4146,16 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
diff --git a/a.js b/b.js
@@ -4145,7 +4164,7 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
diff --git a/a.js b/b.js
@@ -4160,13 +4179,19 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
diff --git a/a.js b/b.js
@@ -4186,7 +4211,7 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
diff --git a/a.js b/b.js
@@ -4197,7 +4222,7 @@ createHash() {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
			moduleHashDigest.substr(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time("hashing: initialize hash");
		const chunkGraph = this.chunkGraph;
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd("hashing: initialize hash");
		if (this.children.length > 0) {
			this.logger.time("hashing: hash child compilations");
			for (const child of this.children) {
				hash.update(child.hash);
			}
			this.logger.timeEnd("hashing: hash child compilations");
		}
		if (this.warnings.length > 0) {
			this.logger.time("hashing: hash warnings");
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd("hashing: hash warnings");
		}
		if (this.errors.length > 0) {
			this.logger.time("hashing: hash errors");
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd("hashing: hash errors");
		}

		this.logger.time("hashing: sort chunks");
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map<Chunk, RuntimeChunkInfo>} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e => e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo = runtimeChunksMap.get(other);
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining > 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info = runtimeChunksMap.get(chunk);
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length > 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining > 0) {
			let circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c => c.chunk.name || c.chunk.id
				).join(", ")})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd("hashing: sort chunks");

		const fullHashChunks = new Set();
		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
		const codeGenerationJobs = [];
		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
		const codeGenerationJobsMap = new Map();

		const processChunk = chunk => {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time("hashing: hash runtime modules");
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate("hashing: hash runtime modules");
			this.logger.time("hashing: hash chunks");
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
			this.logger.timeAggregate("hashing: hash chunks");
		};
		otherChunks.forEach(processChunk);
		for (const chunk of runtimeChunks) processChunk(chunk);

		this.logger.timeAggregateEnd("hashing: hash runtime modules");
		this.logger.timeAggregateEnd("hashing: hash chunks");
		this.logger.time("hashing: hash digest");
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
		this.logger.timeEnd("hashing: hash digest");

		this.logger.time("hashing: process full hash modules");
		for (const chunk of fullHashChunks) {
			for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
				const moduleHash = createHash(hashFunction);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.substr(0, hashDigestLength)
				);
				codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
			}
			const chunkHash = createHash(hashFunction);
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest = /** @type {string} */ (
				chunkHash.digest(hashDigest)
			);
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd("hashing: process full hash modules");
		return codeGenerationJobs;
diff --git a/a.js b/b.js
@@ -4799,6 +4824,9 @@ executeModule(module, options, callback) {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
diff --git a/a.js b/b.js
@@ -4808,15 +4836,14 @@ executeModule(module, options, callback) {
A blob:4e8ff6b45edfd1388fb4286292ea09ffdd117e5a
	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			/**
			 * @param {Module} module the module
			 * @param {function(Module): void} push push more jobs
			 * @param {Callback} callback callback
			 * @returns {void}
			 */
			(module, push, callback) => {
				this.buildQueue.waitFor(module, err => {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err => {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err => {
				if (err) return callback(err);

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = "build time";
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk("build time chunk", this._backCompat);
				chunk.id = chunk.name;
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength
					);
				}

				const codeGenerationResults = new CodeGenerationResults(
					this.outputOptions.hashFunction
				);
				/** @type {WebpackError[]} */
				const errors = [];
				/**
				 * @param {Module} module the module
				 * @param {Callback} callback callback
				 * @returns {void}
diff --git a/a.js b/b.js
@@ -291,15 +291,15 @@ setUnknownExportsProvided(
A blob:cc0deb343e267440e36a520659805488dfde4df6
	 * @param {any=} targetKey use this as key for the target
	 * @param {ModuleGraphConnection=} targetModule set this module as target
	 * @param {number=} priority priority
	 * @returns {boolean} true, if this call changed something
	 */
	setUnknownExportsProvided(
		canMangle,
		excludeExports,
		targetKey,
		targetModule,
		priority
	) {
		let changed = false;
		if (excludeExports) {
			for (const name of excludeExports) {
				// Make sure these entries exist, so they can get different info
				this.getExportInfo(name);
			}
		}
		for (const exportInfo of this._exports.values()) {
			if (excludeExports && excludeExports.has(exportInfo.name)) continue;
			if (exportInfo.provided !== true && exportInfo.provided !== null) {
				exportInfo.provided = null;
				changed = true;
			}
			if (!canMangle && exportInfo.canMangleProvide !== false) {
				exportInfo.canMangleProvide = false;
				changed = true;
			}
			if (targetKey) {
				exportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);
			}
		}
diff --git a/a.js b/b.js
@@ -28,17 +28,25 @@
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
const ObjectMatcherRulePlugin = require("./rules/ObjectMatcherRulePlugin");
const RuleSetCompiler = require("./rules/RuleSetCompiler");
const UseEffectRulePlugin = require("./rules/UseEffectRulePlugin");
const LazySet = require("./util/LazySet");
const { getScheme } = require("./util/URLAbsoluteSpecifier");
const { cachedCleverMerge, cachedSetProperty } = require("./util/cleverMerge");
const { join } = require("./util/fs");
const { parseResource } = require("./util/identifier");

/** @typedef {import("../declarations/WebpackOptions").ModuleOptionsNormalized} ModuleOptions */
/** @typedef {import("./Generator")} Generator */
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import("./Parser")} Parser */
/** @typedef {import("./ResolverFactory")} ResolverFactory */
/** @typedef {import("./dependencies/ModuleDependency")} ModuleDependency */
/** @typedef {import("./util/fs").InputFileSystem} InputFileSystem */

/**
 * @typedef {Object} ResolveData
 * @property {ModuleFactoryCreateData["contextInfo"]} contextInfo
 * @property {ModuleFactoryCreateData["resolveOptions"]} resolveOptions
diff --git a/a.js b/b.js
@@ -48,7 +56,7 @@
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
 * @property {ModuleFactoryCreateData["contextInfo"]} contextInfo
 * @property {ModuleFactoryCreateData["resolveOptions"]} resolveOptions
 * @property {string} context
 * @property {string} request
 * @property {Record<string, any> | undefined} assertions
 * @property {ModuleDependency[]} dependencies
 * @property {string} dependencyType
 * @property {Object} createData
 * @property {LazySet<string>} fileDependencies
 * @property {LazySet<string>} missingDependencies
 * @property {LazySet<string>} contextDependencies
 * @property {boolean} cacheable allow to use the unsafe cache
diff --git a/a.js b/b.js
@@ -66,6 +74,11 @@
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
 * @property {string} query
 * @property {string} fragment
 * @property {string=} context
 */

/** @typedef {ResourceData & { data: Record<string, any> }} ResourceDataWithData */

const EMPTY_RESOLVE_OPTIONS = {};
const EMPTY_PARSER_OPTIONS = {};
const EMPTY_GENERATOR_OPTIONS = {};
const EMPTY_ELEMENTS = [];
diff --git a/a.js b/b.js
@@ -97,27 +110,6 @@ const stringifyLoadersAndResource = (loaders, resource) => {
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
		return data.loader + "??" + data.ident;
	}
	return data.loader + "?" + JSON.stringify(data.options);
};

const stringifyLoadersAndResource = (loaders, resource) => {
	let str = "";
	for (const loader of loaders) {
		str += loaderToIdent(loader) + "!";
	}
	return str + resource;
};

/**
 * @param {string} resultString resultString
 * @returns {{loader: string, options: string|undefined}} parsed loader request
 */
const identToLoaderRequest = resultString => {
	const idx = resultString.indexOf("?");
	if (idx >= 0) {
		const loader = resultString.substr(0, idx);
		const options = resultString.substr(idx + 1);
		return {
			loader,
			options
		};
	} else {
		return {
			loader: resultString,
			options: undefined
		};
	}
};

const needCalls = (times, callback) => {
	return err => {
		if (--times === 0) {
			return callback(err);
diff --git a/a.js b/b.js
@@ -212,7 +204,7 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
diff --git a/a.js b/b.js
@@ -222,15 +214,15 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
diff --git a/a.js b/b.js
@@ -264,6 +256,9 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
diff --git a/a.js b/b.js
@@ -311,7 +306,9 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
diff --git a/a.js b/b.js
@@ -351,7 +348,7 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {{loader: string, options: string|undefined}[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;
diff --git a/a.js b/b.js
@@ -382,7 +379,7 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {{loader: string, options: string|undefined}[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

diff --git a/a.js b/b.js
@@ -405,7 +402,13 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {{loader: string, options: string|undefined}[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

					scheme = getScheme(requestWithoutMatchResource);

					if (!scheme && !contextScheme) {
						const firstChar = requestWithoutMatchResource.charCodeAt(0);
						const secondChar = requestWithoutMatchResource.charCodeAt(1);
						noPreAutoLoaders = firstChar === 45 && secondChar === 33; // startsWith "-!"
						noAutoLoaders = noPreAutoLoaders || firstChar === 33; // startsWith "!"
						noPrePostAutoLoaders = firstChar === 33 && secondChar === 33; // startsWith "!!";
						const rawElements = requestWithoutMatchResource
							.slice(
								noPreAutoLoaders || noPrePostAutoLoaders
									? 2
									: noAutoLoaders
									? 1
									: 0
							)
							.split(/!+/);
						unresolvedResource = rawElements.pop();
						elements = rawElements.map(identToLoaderRequest);
						scheme = getScheme(unresolvedResource);
					} else {
						unresolvedResource = requestWithoutMatchResource;
						elements = EMPTY_ELEMENTS;
diff --git a/a.js b/b.js
@@ -434,7 +437,7 @@ constructor({
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {Object=} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			resolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveForScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {HookMap<AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>>} */
			resolveInScheme: new HookMap(
				() => new AsyncSeriesBailHook(["resourceData", "resolveData"])
			),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			factorize: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			beforeResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData], TODO>} */
			afterResolve: new AsyncSeriesBailHook(["resolveData"]),
			/** @type {AsyncSeriesBailHook<[ResolveData["createData"], ResolveData], TODO>} */
			createModule: new AsyncSeriesBailHook(["createData", "resolveData"]),
			/** @type {SyncWaterfallHook<[Module, ResolveData["createData"], ResolveData], TODO>} */
			module: new SyncWaterfallHook(["module", "createData", "resolveData"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: options.defaultRules
			},
			{
				rules: options.rules
			}
		]);
		this.context = context || "";
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map<string, WeakMap<Object, TODO>>} */
		this.parserCache = new Map();
		/** @type {Map<string, WeakMap<Object, Generator>>} */
		this.generatorCache = new Map();
		/** @type {Set<Module>} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);

		this.hooks.factorize.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(resolveData, callback) => {
				this.hooks.resolve.callAsync(resolveData, (err, result) => {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === "object")
						throw new Error(
							deprecationChangedHookMessage("resolve", this.hooks.resolve) +
								" Returning a Module object will result in this module used as result."
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) => {
						if (err) return callback(err);

						if (typeof result === "object")
							throw new Error(
								deprecationChangedHookMessage(
									"afterResolve",
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) => {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error("Empty dependency (no request)"));
									}

									createdModule = new NormalModule(createData);
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: "NormalModuleFactory",
				stage: 100
			},
			(data, callback) => {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver("loader");

				/** @type {ResourceData | undefined} */
				let matchResourceData = undefined;
				/** @type {string} */
				let unresolvedResource;
				/** @type {{loader: string, options: string|undefined}[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === ".", 47 === "/"
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 && matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}
						matchResourceData = {
							resource: matchResource,
							...cacheParseResource(matchResource)
						};
						requestWithoutMatchResource = request.substr(
							matchResourceMatch[0].length
						);
					}

					scheme = getScheme(requestWithoutMatchResource);

					if (!scheme && !contextScheme) {
						const firstChar = requestWithoutMatchResource.charCodeAt(0);
						const secondChar = requestWithoutMatchResource.charCodeAt(1);
						noPreAutoLoaders = firstChar === 45 && secondChar === 33; // startsWith "-!"
						noAutoLoaders = noPreAutoLoaders || firstChar === 33; // startsWith "!"
						noPrePostAutoLoaders = firstChar === 33 && secondChar === 33; // startsWith "!!";
						const rawElements = requestWithoutMatchResource
							.slice(
								noPreAutoLoaders || noPrePostAutoLoaders
									? 2
									: noAutoLoaders
									? 1
									: 0
							)
							.split(/!+/);
						unresolvedResource = rawElements.pop();
						elements = rawElements.map(identToLoaderRequest);
						scheme = getScheme(unresolvedResource);
					} else {
						unresolvedResource = requestWithoutMatchResource;
						elements = EMPTY_ELEMENTS;
					}
				} else {
					unresolvedResource = request;
					elements = EMPTY_ELEMENTS;
				}

				const resolveContext = {
					fileDependencies,
					missingDependencies,
					contextDependencies
				};

				/** @type {ResourceDataWithData} */
				let resourceData;

				let loaders;

				const continueCallback = needCalls(2, err => {
					if (err) return callback(err);

					// translate option idents
					try {
						for (const item of loaders) {
							if (typeof item.options === "string" && item.options[0] === "?") {
								const ident = item.options.substr(1);
								if (ident === "[[missing ident]]") {
									throw new Error(
										"No ident is provided by referenced loader. " +
											"When using a function for Rule.use in config you need to " +
diff --git a/a.js b/b.js
@@ -1017,12 +1020,14 @@ resolveRequestArray(
A blob:4cb2cb65d5d30830df73ffd2d35bc38b4a6c56c7
				callback(null, hints.filter(Boolean));
			}
		);
	}

	resolveRequestArray(
		contextInfo,
		context,
		array,
		resolver,
		resolveContext,
		callback
	) {
		if (array.length === 0) return callback(null, array);
		asyncLib.map(
			array,
			(item, callback) => {
				resolver.resolve(
					contextInfo,
					context,
					item.loader,
					resolveContext,
					(err, result) => {
						if (
							err &&
							/^[^/]*$/.test(item.loader) &&
							!/-loader$/.test(item.loader)
						) {
							return resolver.resolve(
								contextInfo,
								context,
								item.loader + "-loader",
								resolveContext,
								err2 => {
									if (!err2) {
										err.message =
											err.message +
											"\n" +
											"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" +
											`                 You need to specify '${item.loader}-loader' instead of '${item.loader}',\n` +
											"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed";
									}
									callback(err);
								}
							);
						}
						if (err) return callback(err);

						const parsedResult = identToLoaderRequest(result);
						const resolved = {
							loader: parsedResult.loader,
							options:
								item.options === undefined
									? parsedResult.options
									: item.options,
							ident: item.options === undefined ? undefined : item.ident
						};
						return callback(null, resolved);
diff --git a/a.js b/b.js
@@ -96,7 +96,7 @@ const createDefaultHandler = (profile, logger) => {
A blob:095e2a57bc42d28b576a6f0ff8a1d63e3b6e9806
);
const median3 = (a, b, c) => {
	return a + b + c - Math.max(a, b, c) - Math.min(a, b, c);
};

const createDefaultHandler = (profile, logger) => {
	/** @type {{ value: string, time: number }[]} */
	const lastStateInfo = [];

	const defaultHandler = (percentage, msg, ...args) => {
		if (profile) {
			if (percentage === 0) {
				lastStateInfo.length = 0;
			}
			const fullState = [msg, ...args];
			const state = fullState.map(s => s.replace(/\d+\/\d+ /g, ""));
			const now = Date.now();
			const len = Math.max(state.length, lastStateInfo.length);
			for (let i = len; i >= 0; i--) {
				const stateItem = i < state.length ? state[i] : undefined;
				const lastStateItem =
					i < lastStateInfo.length ? lastStateInfo[i] : undefined;
				if (lastStateItem) {
					if (stateItem !== lastStateItem.value) {
						const diff = now - lastStateItem.time;
						if (lastStateItem.value) {
							let reportState = lastStateItem.value;
							if (i > 0) {
								reportState = lastStateInfo[i - 1].value + " > " + reportState;
							}
							const stateMsg = `${" | ".repeat(i)}${diff} ms ${reportState}`;
							const d = diff;
							// This depends on timing so we ignore it for coverage
							/* istanbul ignore next */
							{
								if (d > 10000) {
									logger.error(stateMsg);
								} else if (d > 1000) {
									logger.warn(stateMsg);
								} else if (d > 10) {
									logger.info(stateMsg);
								} else if (d > 5) {
									logger.log(stateMsg);
								} else {
									logger.debug(stateMsg);
								}
							}
						}
						if (stateItem === undefined) {
							lastStateInfo.length = i;
						} else {
							lastStateItem.value = stateItem;
							lastStateItem.time = now;
							lastStateInfo.length = i + 1;
						}
					}
				} else {
					lastStateInfo[i] = {
						value: stateItem,
						time: now
					};
				}
			}
		}
		logger.status(`${Math.floor(percentage * 100)}%`, msg, ...args);
		if (percentage === 1 || (!msg && args.length === 0)) logger.status();
	};

	return defaultHandler;
};

/**
 * @callback ReportProgress
 * @param {number} p
 * @param {...string[]} [args]
 * @returns {void}
 */

/** @type {WeakMap<Compiler,ReportProgress>} */
diff --git a/a.js b/b.js
@@ -531,15 +531,14 @@ _applyOnCompiler(compiler, handler) {
A blob:095e2a57bc42d28b576a6f0ff8a1d63e3b6e9806
	/**
	 * @param {Compiler} compiler webpack compiler
	 * @param {HandlerFunction} handler function that executes for every progress step
	 * @returns {void}
	 */
	_applyOnCompiler(compiler, handler) {
		const showEntries = this.showEntries;
		const showModules = this.showModules;
		const showDependencies = this.showDependencies;
		const showActiveModules = this.showActiveModules;
		let lastActiveModule = "";
		let currentLoader = "";
		let lastModulesCount = 0;
		let lastDependenciesCount = 0;
		let lastEntriesCount = 0;
		let modulesCount = 0;
		let dependenciesCount = 0;
		let entriesCount = 1;
		let doneModules = 0;
		let doneDependencies = 0;
		let doneEntries = 0;
		const activeModules = new Set();
		let lastUpdate = 0;

		const updateThrottled = () => {
			if (lastUpdate + 500 < Date.now()) update();
		};

		const update = () => {
			/** @type {string[]} */
			const items = [];
			const percentByModules =
				doneModules /
				Math.max(lastModulesCount || this.modulesCount || 1, modulesCount);
			const percentByEntries =
				doneEntries /
				Math.max(lastEntriesCount || this.dependenciesCount || 1, entriesCount);
			const percentByDependencies =
				doneDependencies /
				Math.max(lastDependenciesCount || 1, dependenciesCount);
			let percentageFactor;

			switch (this.percentBy) {
				case "entries":
					percentageFactor = percentByEntries;
					break;
				case "dependencies":
					percentageFactor = percentByDependencies;
					break;
				case "modules":
					percentageFactor = percentByModules;
					break;
				default:
					percentageFactor = median3(
						percentByModules,
						percentByEntries,
						percentByDependencies
					);
			}

			const percentage = 0.1 + percentageFactor * 0.55;

			if (currentLoader) {
				items.push(
					`import loader ${contextify(
						compiler.context,
						currentLoader,
						compiler.root
					)}`
				);
			} else {
				const statItems = [];
				if (showEntries) {
					statItems.push(`${doneEntries}/${entriesCount} entries`);
				}
				if (showDependencies) {
					statItems.push(
						`${doneDependencies}/${dependenciesCount} dependencies`
					);
				}
				if (showModules) {
					statItems.push(`${doneModules}/${modulesCount} modules`);
				}
				if (showActiveModules) {
					statItems.push(`${activeModules.size} active`);
				}
				if (statItems.length > 0) {
					items.push(statItems.join(" "));
				}
				if (showActiveModules) {
					items.push(lastActiveModule);
				}
			}
			handler(percentage, "building", ...items);
			lastUpdate = Date.now();
		};

		const factorizeAdd = () => {
			dependenciesCount++;
			if (dependenciesCount < 50 || dependenciesCount % 100 === 0)
				updateThrottled();
		};

		const factorizeDone = () => {
			doneDependencies++;
			if (doneDependencies < 50 || doneDependencies % 100 === 0)
				updateThrottled();
		};

		const moduleAdd = () => {
			modulesCount++;
			if (modulesCount < 50 || modulesCount % 100 === 0) updateThrottled();
		};

		// only used when showActiveModules is set
		const moduleBuild = module => {
			const ident = module.identifier();
			if (ident) {
				activeModules.add(ident);
				lastActiveModule = ident;
				update();
			}
		};

		const entryAdd = (entry, options) => {
			entriesCount++;
			if (entriesCount < 5 || entriesCount % 10 === 0) updateThrottled();
		};

		const moduleDone = module => {
			doneModules++;
			if (showActiveModules) {
				const ident = module.identifier();
				if (ident) {
					activeModules.delete(ident);
					if (lastActiveModule === ident) {
						lastActiveModule = "";
						for (const m of activeModules) {
							lastActiveModule = m;
						}
						update();
						return;
					}
				}
			}
			if (doneModules < 50 || doneModules % 100 === 0) updateThrottled();
		};

		const entryDone = (entry, options) => {
			doneEntries++;
			update();
		};

		const cache = compiler
			.getCache("ProgressPlugin")
			.getItemCache("counts", null);

		let cacheGetPromise;

		compiler.hooks.beforeCompile.tap("ProgressPlugin", () => {
			if (!cacheGetPromise) {
				cacheGetPromise = cache.getPromise().then(
					data => {
						if (data) {
							lastModulesCount = lastModulesCount || data.modulesCount;
							lastDependenciesCount =
								lastDependenciesCount || data.dependenciesCount;
						}
						return data;
					},
					err => {
						// Ignore error
					}
				);
			}
		});

		compiler.hooks.afterCompile.tapPromise("ProgressPlugin", compilation => {
			if (compilation.compiler.isChild()) return Promise.resolve();
			return cacheGetPromise.then(async oldData => {
				if (
					!oldData ||
					oldData.modulesCount !== modulesCount ||
					oldData.dependenciesCount !== dependenciesCount
				) {
					await cache.storePromise({ modulesCount, dependenciesCount });
				}
			});
		});

		compiler.hooks.compilation.tap("ProgressPlugin", compilation => {
			if (compilation.compiler.isChild()) return;
			lastModulesCount = modulesCount;
			lastEntriesCount = entriesCount;
			lastDependenciesCount = dependenciesCount;
			modulesCount = dependenciesCount = entriesCount = 0;
			doneModules = doneDependencies = doneEntries = 0;

			compilation.factorizeQueue.hooks.added.tap(
				"ProgressPlugin",
				factorizeAdd
			);
			compilation.factorizeQueue.hooks.result.tap(
				"ProgressPlugin",
				factorizeDone
			);

			compilation.addModuleQueue.hooks.added.tap("ProgressPlugin", moduleAdd);
			compilation.processDependenciesQueue.hooks.result.tap(
				"ProgressPlugin",
				moduleDone
			);

			if (showActiveModules) {
				compilation.hooks.buildModule.tap("ProgressPlugin", moduleBuild);
			}

			compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd);
			compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone);
			compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);

			// avoid dynamic require if bundled with webpack
			// @ts-expect-error
			if (typeof __webpack_require__ !== "function") {
				const requiredLoaders = new Set();
				NormalModule.getCompilationHooks(compilation).beforeLoaders.tap(
					"ProgressPlugin",
					loaders => {
						for (const loader of loaders) {
							if (
								loader.type !== "module" &&
								!requiredLoaders.has(loader.loader)
							) {
								requiredLoaders.add(loader.loader);
								currentLoader = loader.loader;
								update();
								require(loader.loader);
							}
						}
						if (currentLoader) {
							currentLoader = "";
							update();
						}
					}
				);
			}

			const hooks = {
				finishModules: "finish module graph",
				seal: "plugins",
				optimizeDependencies: "dependencies optimization",
				afterOptimizeDependencies: "after dependencies optimization",
				beforeChunks: "chunk graph",
				afterChunks: "after chunk graph",
				optimize: "optimizing",
				optimizeModules: "module optimization",
				afterOptimizeModules: "after module optimization",
				optimizeChunks: "chunk optimization",
				afterOptimizeChunks: "after chunk optimization",
				optimizeTree: "module and chunk tree optimization",
				afterOptimizeTree: "after module and chunk tree optimization",
				optimizeChunkModules: "chunk modules optimization",
				afterOptimizeChunkModules: "after chunk modules optimization",
				reviveModules: "module reviving",
				beforeModuleIds: "before module ids",
				moduleIds: "module ids",
				optimizeModuleIds: "module id optimization",
				afterOptimizeModuleIds: "module id optimization",
				reviveChunks: "chunk reviving",
				beforeChunkIds: "before chunk ids",
				chunkIds: "chunk ids",
				optimizeChunkIds: "chunk id optimization",
				afterOptimizeChunkIds: "after chunk id optimization",
				recordModules: "record modules",
				recordChunks: "record chunks",
				beforeModuleHash: "module hashing",
				beforeCodeGeneration: "code generation",
				beforeRuntimeRequirements: "runtime requirements",
				beforeHash: "hashing",
				afterHash: "after hashing",
				recordHash: "record hash",
				beforeModuleAssets: "module assets processing",
				beforeChunkAssets: "chunk assets processing",
				processAssets: "asset processing",
				afterProcessAssets: "after asset optimization",
				record: "recording",
				afterSeal: "after seal"
			};
			const numberOfHooks = Object.keys(hooks).length;
			Object.keys(hooks).forEach((name, idx) => {
				const title = hooks[name];
				const percentage = (idx / numberOfHooks) * 0.25 + 0.7;
				compilation.hooks[name].intercept({
					name: "ProgressPlugin",
					call() {
						handler(percentage, "sealing", title);
					},
					done() {
						progressReporters.set(compiler, undefined);
						handler(percentage, "sealing", title);
					},
					result() {
						handler(percentage, "sealing", title);
					},
					error() {
						handler(percentage, "sealing", title);
					},
					tap(tap) {
						// p is percentage from 0 to 1
						// args is any number of messages in a hierarchical matter
						progressReporters.set(compilation.compiler, (p, ...args) => {
							handler(percentage, "sealing", title, tap.name, ...args);
						});
						handler(percentage, "sealing", title, tap.name);
					}
				});
			});
		});
		compiler.hooks.make.intercept({
			name: "ProgressPlugin",
			call() {
				handler(0.1, "building");
			},
			done() {
				handler(0.65, "building");
			}
		});
		const interceptHook = (hook, progress, category, name) => {
			hook.intercept({
				name: "ProgressPlugin",
				call() {
					handler(progress, category, name);
				},
				done() {
					progressReporters.set(compiler, undefined);
					handler(progress, category, name);
				},
				result() {
					handler(progress, category, name);
				},
				error() {
					handler(progress, category, name);
				},
				tap(tap) {
					progressReporters.set(compiler, (p, ...args) => {
						handler(progress, category, name, tap.name, ...args);
					});
					handler(progress, category, name, tap.name);
				}
			});
		};
		compiler.cache.hooks.endIdle.intercept({
			name: "ProgressPlugin",
			call() {
				handler(0, "");
			}
		});
		interceptHook(compiler.cache.hooks.endIdle, 0.01, "cache", "end idle");
		compiler.hooks.initialize.intercept({
			name: "ProgressPlugin",
			call() {
				handler(0, "");
			}
		});
		interceptHook(compiler.hooks.initialize, 0.01, "setup", "initialize");
		interceptHook(compiler.hooks.beforeRun, 0.02, "setup", "before run");
		interceptHook(compiler.hooks.run, 0.03, "setup", "run");
		interceptHook(compiler.hooks.watchRun, 0.03, "setup", "watch run");
		interceptHook(
			compiler.hooks.normalModuleFactory,
			0.04,
diff --git a/a.js b/b.js
@@ -905,7 +905,7 @@ const extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {
A blob:9849f51f8e77f15880efc336f42c8bf4fdbefd22
 */
const bySetSize = (a, b) => {
	return b.size + b.plus.size - a.size - a.plus.size;
};

const extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {
	let blockCache;
	let modules;

	const arrays = [];

	const queue = [module];
	while (queue.length > 0) {
		const block = queue.pop();
		const arr = [];
		arrays.push(arr);
		blockModulesMap.set(block, arr);
		for (const b of block.blocks) {
			queue.push(b);
		}
	}

	for (const connection of moduleGraph.getOutgoingConnections(module)) {
		const d = connection.dependency;
		// We skip connections without dependency
		if (!d) continue;
		const m = connection.module;
		// We skip connections without Module pointer
		if (!m) continue;
		// We skip weak connections
		if (connection.weak) continue;
		const state = connection.getActiveState(runtime);
		// We skip inactive connections
		if (state === false) continue;

		const block = moduleGraph.getParentBlock(d);
		let index = moduleGraph.getParentBlockIndex(d);

		// deprecated fallback
		if (index < 0) {
			index = block.dependencies.indexOf(d);
		}

		if (blockCache !== block) {
			modules = blockModulesMap.get((blockCache = block));
		}

		const i = index << 2;
		modules[i] = m;
		modules[i + 1] = state;
	}

	for (const modules of arrays) {
		if (modules.length === 0) continue;
		let indexMap;
		let length = 0;
		outer: for (let j = 0; j < modules.length; j += 2) {
			const m = modules[j];
			if (m === undefined) continue;
			const state = modules[j + 1];
			if (indexMap === undefined) {
				let i = 0;
				for (; i < length; i += 2) {
					if (modules[i] === m) {
						const merged = modules[i + 1];
						if (merged === true) continue outer;
						modules[i + 1] = ModuleGraphConnection.addConnectionStates(
							merged,
							state
						);
					}
				}
				modules[length] = m;
				length++;
				modules[length] = state;
				length++;
				if (length > 30) {
					// To avoid worse case performance, we will use an index map for
					// linear cost access, which allows to maintain O(n) complexity
					// while keeping allocations down to a minimum
					indexMap = new Map();
					for (let i = 0; i < length; i += 2) {
						indexMap.set(modules[i], i + 1);
					}
				}
			} else {
				const idx = indexMap.get(m);
				if (idx !== undefined) {
					const merged = modules[idx];
					if (merged === true) continue outer;
					modules[idx] = ModuleGraphConnection.addConnectionStates(
						merged,
						state
					);
				} else {
					modules[length] = m;
					length++;
					modules[length] = state;
					indexMap.set(m, length);
					length++;
				}
			}
		}
		modules.length = length;
	}
};

/**
 *
 * @param {Logger} logger a logger
 * @param {Compilation} compilation the compilation
 * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules
 * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules
 * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks
 * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks
 * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here
 */
const visitModules = (
	logger,
	compilation,
	inputEntrypointsAndModules,
	chunkGroupInfoMap,
	blockConnections,
	blocksWithNestedBlocks,
	allCreatedChunkGroups
) => {
	const { moduleGraph, chunkGraph, moduleMemCaches } = compilation;

	const blockModulesRuntimeMap = new Map();

	/** @type {RuntimeSpec | false} */
	let blockModulesMapRuntime = false;
	let blockModulesMap;

	/**
	 *
	 * @param {DependenciesBlock} block block
	 * @param {RuntimeSpec} runtime runtime
	 * @returns {(Module | ConnectionState)[]} block modules in flatten tuples
	 */
	const getBlockModules = (block, runtime) => {
		if (blockModulesMapRuntime !== runtime) {
			blockModulesMap = blockModulesRuntimeMap.get(runtime);
			if (blockModulesMap === undefined) {
				blockModulesMap = new Map();
				blockModulesRuntimeMap.set(runtime, blockModulesMap);
			}
		}
		let blockModules = blockModulesMap.get(block);
		if (blockModules !== undefined) return blockModules;
		const module = /** @type {Module} */ (block.getRootBlock());
		const memCache = moduleMemCaches && moduleMemCaches.get(module);
		if (memCache !== undefined) {
			const map = memCache.provide(
				"bundleChunkGraph.blockModules",
				runtime,
				() => {
					logger.time("visitModules: prepare");
					const map = new Map();
					extractBlockModules(module, moduleGraph, runtime, map);
					logger.timeAggregate("visitModules: prepare");
					return map;
				}
			);
			for (const [block, blockModules] of map)
				blockModulesMap.set(block, blockModules);
			return map.get(block);
		} else {
			logger.time("visitModules: prepare");
			extractBlockModules(module, moduleGraph, runtime, blockModulesMap);
			blockModules = blockModulesMap.get(block);
			logger.timeAggregate("visitModules: prepare");
			return blockModules;
		}
	};

	let statProcessedQueueItems = 0;
	let statProcessedBlocks = 0;
	let statConnectedChunkGroups = 0;
	let statProcessedChunkGroupsForMerging = 0;
	let statMergedAvailableModuleSets = 0;
	let statForkedAvailableModules = 0;
	let statForkedAvailableModulesCount = 0;
	let statForkedAvailableModulesCountPlus = 0;
	let statForkedMergedModulesCount = 0;
	let statForkedMergedModulesCountPlus = 0;
	let statForkedResultModulesCount = 0;
	let statChunkGroupInfoUpdated = 0;
	let statChildChunkGroupsReconnected = 0;

	let nextChunkGroupIndex = 0;
	let nextFreeModulePreOrderIndex = 0;
	let nextFreeModulePostOrderIndex = 0;

	/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */
	const blockChunkGroups = new Map();

	/** @type {Map<string, ChunkGroupInfo>} */
	const namedChunkGroups = new Map();

	/** @type {Map<string, ChunkGroupInfo>} */
	const namedAsyncEntrypoints = new Map();

	const ADD_AND_ENTER_ENTRY_MODULE = 0;
	const ADD_AND_ENTER_MODULE = 1;
	const ENTER_MODULE = 2;
	const PROCESS_BLOCK = 3;
	const PROCESS_ENTRY_BLOCK = 4;
	const LEAVE_MODULE = 5;

	/** @type {QueueItem[]} */
	let queue = [];

	/** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */
	const queueConnect = new Map();
	/** @type {Set<ChunkGroupInfo>} */
	const chunkGroupsForCombining = new Set();

	// Fill queue with entrypoint modules
	// Create ChunkGroupInfo for entrypoints
	for (const [chunkGroup, modules] of inputEntrypointsAndModules) {
		const runtime = getEntryRuntime(
			compilation,
			chunkGroup.name,
			chunkGroup.options
		);
		/** @type {ChunkGroupInfo} */
		const chunkGroupInfo = {
			chunkGroup,
			runtime,
			minAvailableModules: undefined,
			minAvailableModulesOwned: false,
			availableModulesToBeMerged: [],
			skippedItems: undefined,
			resultingAvailableModules: undefined,
			children: undefined,
			availableSources: undefined,
			availableChildren: undefined,
			preOrderIndex: 0,
			postOrderIndex: 0,
			chunkLoading:
				chunkGroup.options.chunkLoading !== undefined
					? chunkGroup.options.chunkLoading !== false
					: compilation.outputOptions.chunkLoading !== false,
			asyncChunks:
				chunkGroup.options.asyncChunks !== undefined
					? chunkGroup.options.asyncChunks
					: compilation.outputOptions.asyncChunks !== false
		};
		chunkGroup.index = nextChunkGroupIndex++;
		if (chunkGroup.getNumberOfParents() > 0) {
			// minAvailableModules for child entrypoints are unknown yet, set to undefined.
			// This means no module is added until other sets are merged into
			// this minAvailableModules (by the parent entrypoints)
			const skippedItems = new Set();
			for (const module of modules) {
				skippedItems.add(module);
			}
			chunkGroupInfo.skippedItems = skippedItems;
			chunkGroupsForCombining.add(chunkGroupInfo);
		} else {
			// The application may start here: We start with an empty list of available modules
			chunkGroupInfo.minAvailableModules = EMPTY_SET;
			const chunk = chunkGroup.getEntrypointChunk();
			for (const module of modules) {
				queue.push({
					action: ADD_AND_ENTER_MODULE,
					block: module,
					module,
					chunk,
					chunkGroup,
					chunkGroupInfo
				});
			}
		}
		chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);
		if (chunkGroup.name) {
			namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);
		}
	}
	// Fill availableSources with parent-child dependencies between entrypoints
	for (const chunkGroupInfo of chunkGroupsForCombining) {
		const { chunkGroup } = chunkGroupInfo;
		chunkGroupInfo.availableSources = new Set();
		for (const parent of chunkGroup.parentsIterable) {
			const parentChunkGroupInfo = chunkGroupInfoMap.get(parent);
			chunkGroupInfo.availableSources.add(parentChunkGroupInfo);
			if (parentChunkGroupInfo.availableChildren === undefined) {
				parentChunkGroupInfo.availableChildren = new Set();
			}
			parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);
		}
	}
	// pop() is used to read from the queue
	// so it need to be reversed to be iterated in
	// correct order
	queue.reverse();

	/** @type {Set<ChunkGroupInfo>} */
	const outdatedChunkGroupInfo = new Set();
	/** @type {Set<ChunkGroupInfo>} */
	const chunkGroupsForMerging = new Set();
	/** @type {QueueItem[]} */
	let queueDelayed = [];

	/** @type {[Module, ConnectionState][]} */
	const skipConnectionBuffer = [];
	/** @type {Module[]} */
	const skipBuffer = [];
	/** @type {QueueItem[]} */
	const queueBuffer = [];

	/** @type {Module} */
	let module;
	/** @type {Chunk} */
	let chunk;
	/** @type {ChunkGroup} */
	let chunkGroup;
	/** @type {DependenciesBlock} */
	let block;
	/** @type {ChunkGroupInfo} */
	let chunkGroupInfo;

	// For each async Block in graph
	/**
	 * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock
	 * @returns {void}
	 */
	const iteratorBlock = b => {
		// 1. We create a chunk group with single chunk in it for this Block
		// but only once (blockChunkGroups map)
		let cgi = blockChunkGroups.get(b);
		/** @type {ChunkGroup} */
		let c;
		/** @type {Entrypoint} */
		let entrypoint;
		const entryOptions = b.groupOptions && b.groupOptions.entryOptions;
		if (cgi === undefined) {
			const chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;
			if (entryOptions) {
				cgi = namedAsyncEntrypoints.get(chunkName);
				if (!cgi) {
					entrypoint = compilation.addAsyncEntrypoint(
						entryOptions,
						module,
						b.loc,
						b.request
					);
					entrypoint.index = nextChunkGroupIndex++;
					cgi = {
						chunkGroup: entrypoint,
						runtime: entrypoint.options.runtime || entrypoint.name,
						minAvailableModules: EMPTY_SET,
						minAvailableModulesOwned: false,
						availableModulesToBeMerged: [],
						skippedItems: undefined,
						resultingAvailableModules: undefined,
						children: undefined,
						availableSources: undefined,
						availableChildren: undefined,
						preOrderIndex: 0,
						postOrderIndex: 0,
						chunkLoading:
							entryOptions.chunkLoading !== undefined
								? entryOptions.chunkLoading !== false
								: chunkGroupInfo.chunkLoading,
						asyncChunks:
							entryOptions.asyncChunks !== undefined
								? entryOptions.asyncChunks
								: chunkGroupInfo.asyncChunks
					};
					chunkGroupInfoMap.set(entrypoint, cgi);

					chunkGraph.connectBlockAndChunkGroup(b, entrypoint);
					if (chunkName) {
						namedAsyncEntrypoints.set(chunkName, cgi);
					}
				} else {
					entrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);
					// TODO merge entryOptions
					entrypoint.addOrigin(module, b.loc, b.request);
					chunkGraph.connectBlockAndChunkGroup(b, entrypoint);
				}

				// 2. We enqueue the DependenciesBlock for traversal
				queueDelayed.push({
					action: PROCESS_ENTRY_BLOCK,
					block: b,
					module: module,
					chunk: entrypoint.chunks[0],
					chunkGroup: entrypoint,
					chunkGroupInfo: cgi
				});
			} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {
				// Just queue the block into the current chunk group
				queue.push({
					action: PROCESS_BLOCK,
					block: b,
					module: module,
					chunk,
					chunkGroup,
					chunkGroupInfo
				});
			} else {
				cgi = chunkName && namedChunkGroups.get(chunkName);
				if (!cgi) {
					c = compilation.addChunkInGroup(
						b.groupOptions || b.chunkName,
						module,
						b.loc,
						b.request
					);
					c.index = nextChunkGroupIndex++;
					cgi = {
						chunkGroup: c,
						runtime: chunkGroupInfo.runtime,
						minAvailableModules: undefined,
						minAvailableModulesOwned: undefined,
						availableModulesToBeMerged: [],
						skippedItems: undefined,
						resultingAvailableModules: undefined,
						children: undefined,
						availableSources: undefined,
						availableChildren: undefined,
						preOrderIndex: 0,
						postOrderIndex: 0,
						chunkLoading: chunkGroupInfo.chunkLoading,
						asyncChunks: chunkGroupInfo.asyncChunks
					};
					allCreatedChunkGroups.add(c);
					chunkGroupInfoMap.set(c, cgi);
					if (chunkName) {
						namedChunkGroups.set(chunkName, cgi);
					}
				} else {
					c = cgi.chunkGroup;
					if (c.isInitial()) {
						compilation.errors.push(
							new AsyncDependencyToInitialChunkError(chunkName, module, b.loc)
						);
						c = chunkGroup;
					}
					c.addOptions(b.groupOptions);
					c.addOrigin(module, b.loc, b.request);
				}
				blockConnections.set(b, []);
			}
			blockChunkGroups.set(b, cgi);
		} else if (entryOptions) {
			entrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);
		} else {
			c = cgi.chunkGroup;
		}

		if (c !== undefined) {
			// 2. We store the connection for the block
			// to connect it later if needed
			blockConnections.get(b).push({
				originChunkGroupInfo: chunkGroupInfo,
				chunkGroup: c
			});

			// 3. We enqueue the chunk group info creation/updating
			let connectList = queueConnect.get(chunkGroupInfo);
			if (connectList === undefined) {
				connectList = new Set();
				queueConnect.set(chunkGroupInfo, connectList);
			}
			connectList.add(cgi);

			// TODO check if this really need to be done for each traversal
			// or if it is enough when it's queued when created
			// 4. We enqueue the DependenciesBlock for traversal
			queueDelayed.push({
				action: PROCESS_BLOCK,
				block: b,
				module: module,
				chunk: c.chunks[0],
				chunkGroup: c,
				chunkGroupInfo: cgi
			});
		} else if (entrypoint !== undefined) {
			chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);
		}
	};

	/**
	 * @param {DependenciesBlock} block the block
	 * @returns {void}
	 */
	const processBlock = block => {
		statProcessedBlocks++;
		// get prepared block info
		const blockModules = getBlockModules(block, chunkGroupInfo.runtime);

		if (blockModules !== undefined) {
			const { minAvailableModules } = chunkGroupInfo;
			// Buffer items because order need to be reversed to get indices correct
			// Traverse all referenced modules
			for (let i = 0; i < blockModules.length; i += 2) {
				const refModule = /** @type {Module} */ (blockModules[i]);
				if (chunkGraph.isModuleInChunk(refModule, chunk)) {
					// skip early if already connected
					continue;
				}
				const activeState = /** @type {ConnectionState} */ (
					blockModules[i + 1]
				);
				if (activeState !== true) {
					skipConnectionBuffer.push([refModule, activeState]);
					if (activeState === false) continue;
				}
				if (
					activeState === true &&
					(minAvailableModules.has(refModule) ||
						minAvailableModules.plus.has(refModule))
				) {
					// already in parent chunks, skip it for now
					skipBuffer.push(refModule);
					continue;
				}
				// enqueue, then add and enter to be in the correct order
				// this is relevant with circular dependencies
				queueBuffer.push({
					action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,
					block: refModule,
					module: refModule,
					chunk,
					chunkGroup,
					chunkGroupInfo
				});
			}
			// Add buffered items in reverse order
			if (skipConnectionBuffer.length > 0) {
				let { skippedModuleConnections } = chunkGroupInfo;
				if (skippedModuleConnections === undefined) {
					chunkGroupInfo.skippedModuleConnections = skippedModuleConnections =
						new Set();
				}
				for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {
					skippedModuleConnections.add(skipConnectionBuffer[i]);
				}
				skipConnectionBuffer.length = 0;
			}
			if (skipBuffer.length > 0) {
				let { skippedItems } = chunkGroupInfo;
				if (skippedItems === undefined) {
					chunkGroupInfo.skippedItems = skippedItems = new Set();
				}
				for (let i = skipBuffer.length - 1; i >= 0; i--) {
					skippedItems.add(skipBuffer[i]);
				}
				skipBuffer.length = 0;
			}
			if (queueBuffer.length > 0) {
				for (let i = queueBuffer.length - 1; i >= 0; i--) {
					queue.push(queueBuffer[i]);
				}
				queueBuffer.length = 0;
			}
		}

		// Traverse all Blocks
		for (const b of block.blocks) {
			iteratorBlock(b);
		}

		if (block.blocks.length > 0 && module !== block) {
			blocksWithNestedBlocks.add(block);
		}
	};

	/**
	 * @param {DependenciesBlock} block the block
	 * @returns {void}
	 */
	const processEntryBlock = block => {
		statProcessedBlocks++;
		// get prepared block info
		const blockModules = getBlockModules(block, chunkGroupInfo.runtime);

		if (blockModules !== undefined) {
			// Traverse all referenced modules
			for (let i = 0; i < blockModules.length; i += 2) {
				const refModule = /** @type {Module} */ (blockModules[i]);
				const activeState = /** @type {ConnectionState} */ (
					blockModules[i + 1]
				);
				// enqueue, then add and enter to be in the correct order
				// this is relevant with circular dependencies
				queueBuffer.push({
					action:
						activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,
					block: refModule,
					module: refModule,
					chunk,
					chunkGroup,
					chunkGroupInfo
				});
			}
			// Add buffered items in reverse order
			if (queueBuffer.length > 0) {
				for (let i = queueBuffer.length - 1; i >= 0; i--) {
					queue.push(queueBuffer[i]);
				}
				queueBuffer.length = 0;
			}
		}

		// Traverse all Blocks
		for (const b of block.blocks) {
			iteratorBlock(b);
		}

		if (block.blocks.length > 0 && module !== block) {
			blocksWithNestedBlocks.add(block);
		}
	};

	const processQueue = () => {
		while (queue.length) {
			statProcessedQueueItems++;
			const queueItem = queue.pop();
			module = queueItem.module;
			block = queueItem.block;
			chunk = queueItem.chunk;
			chunkGroup = queueItem.chunkGroup;
			chunkGroupInfo = queueItem.chunkGroupInfo;

			switch (queueItem.action) {
				case ADD_AND_ENTER_ENTRY_MODULE:
					chunkGraph.connectChunkAndEntryModule(
						chunk,
						module,
						/** @type {Entrypoint} */ (chunkGroup)
					);
				// fallthrough
				case ADD_AND_ENTER_MODULE: {
					if (chunkGraph.isModuleInChunk(module, chunk)) {
						// already connected, skip it
						break;
					}
					// We connect Module and Chunk
					chunkGraph.connectChunkAndModule(chunk, module);
				}
				// fallthrough
				case ENTER_MODULE: {
					const index = chunkGroup.getModulePreOrderIndex(module);
					if (index === undefined) {
						chunkGroup.setModulePreOrderIndex(
							module,
							chunkGroupInfo.preOrderIndex++
						);
					}

					if (
						moduleGraph.setPreOrderIndexIfUnset(
							module,
							nextFreeModulePreOrderIndex
						)
					) {
						nextFreeModulePreOrderIndex++;
					}

					// reuse queueItem
					queueItem.action = LEAVE_MODULE;
					queue.push(queueItem);
				}
				// fallthrough
				case PROCESS_BLOCK: {
					processBlock(block);
					break;
				}
				case PROCESS_ENTRY_BLOCK: {
					processEntryBlock(block);
					break;
				}
				case LEAVE_MODULE: {
					const index = chunkGroup.getModulePostOrderIndex(module);
					if (index === undefined) {
						chunkGroup.setModulePostOrderIndex(
							module,
							chunkGroupInfo.postOrderIndex++
						);
					}

					if (
						moduleGraph.setPostOrderIndexIfUnset(
							module,
							nextFreeModulePostOrderIndex
						)
					) {
						nextFreeModulePostOrderIndex++;
					}
					break;
				}
			}
		}
	};

	const calculateResultingAvailableModules = chunkGroupInfo => {
		if (chunkGroupInfo.resultingAvailableModules)
			return chunkGroupInfo.resultingAvailableModules;

		const minAvailableModules = chunkGroupInfo.minAvailableModules;

		// Create a new Set of available modules at this point
		// We want to be as lazy as possible. There are multiple ways doing this:
		// Note that resultingAvailableModules is stored as "(a) + (b)" as it's a ModuleSetPlus
		// - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)
		// - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)
		// We choose one depending on the size of minAvailableModules vs minAvailableModules.plus

		let resultingAvailableModules;
		if (minAvailableModules.size > minAvailableModules.plus.size) {
			// resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)
			resultingAvailableModules =
				/** @type {Set<Module> & {plus: Set<Module>}} */ (new Set());
			for (const module of minAvailableModules.plus)
				minAvailableModules.add(module);
			minAvailableModules.plus = EMPTY_SET;
			resultingAvailableModules.plus = minAvailableModules;
			chunkGroupInfo.minAvailableModulesOwned = false;
		} else {
			// resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)
			resultingAvailableModules =
				/** @type {Set<Module> & {plus: Set<Module>}} */ (
					new Set(minAvailableModules)
				);
			resultingAvailableModules.plus = minAvailableModules.plus;
		}

		// add the modules from the chunk group to the set
		for (const chunk of chunkGroupInfo.chunkGroup.chunks) {
			for (const m of chunkGraph.getChunkModulesIterable(chunk)) {
				resultingAvailableModules.add(m);
			}
		}
		return (chunkGroupInfo.resultingAvailableModules =
			resultingAvailableModules);
	};

	const processConnectQueue = () => {
		// Figure out new parents for chunk groups
		// to get new available modules for these children
		for (const [chunkGroupInfo, targets] of queueConnect) {
			// 1. Add new targets to the list of children
			if (chunkGroupInfo.children === undefined) {
				chunkGroupInfo.children = targets;
			} else {
				for (const target of targets) {
					chunkGroupInfo.children.add(target);
				}
			}

			// 2. Calculate resulting available modules
			const resultingAvailableModules =
				calculateResultingAvailableModules(chunkGroupInfo);

			const runtime = chunkGroupInfo.runtime;

			// 3. Update chunk group info
			for (const target of targets) {
				target.availableModulesToBeMerged.push(resultingAvailableModules);
				chunkGroupsForMerging.add(target);
				const oldRuntime = target.runtime;
				const newRuntime = mergeRuntime(oldRuntime, runtime);
				if (oldRuntime !== newRuntime) {
					target.runtime = newRuntime;
					outdatedChunkGroupInfo.add(target);
				}
			}

			statConnectedChunkGroups += targets.size;
		}
		queueConnect.clear();
	};

	const processChunkGroupsForMerging = () => {
		statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;

		// Execute the merge
		for (const info of chunkGroupsForMerging) {
			const availableModulesToBeMerged = info.availableModulesToBeMerged;
			let cachedMinAvailableModules = info.minAvailableModules;

			statMergedAvailableModuleSets += availableModulesToBeMerged.length;

			// 1. Get minimal available modules
			// It doesn't make sense to traverse a chunk again with more available modules.
			// This step calculates the minimal available modules and skips traversal when
			// the list didn't shrink.
			if (availableModulesToBeMerged.length > 1) {
				availableModulesToBeMerged.sort(bySetSize);
			}
			let changed = false;
			merge: for (const availableModules of availableModulesToBeMerged) {
				if (cachedMinAvailableModules === undefined) {
					cachedMinAvailableModules = availableModules;
					info.minAvailableModules = cachedMinAvailableModules;
					info.minAvailableModulesOwned = false;
					changed = true;
				} else {
					if (info.minAvailableModulesOwned) {
						// We own it and can modify it
						if (cachedMinAvailableModules.plus === availableModules.plus) {
							for (const m of cachedMinAvailableModules) {
								if (!availableModules.has(m)) {
									cachedMinAvailableModules.delete(m);
									changed = true;
								}
							}
						} else {
							for (const m of cachedMinAvailableModules) {
								if (!availableModules.has(m) && !availableModules.plus.has(m)) {
									cachedMinAvailableModules.delete(m);
									changed = true;
								}
							}
							for (const m of cachedMinAvailableModules.plus) {
								if (!availableModules.has(m) && !availableModules.plus.has(m)) {
									// We can't remove modules from the plus part
									// so we need to merge plus into the normal part to allow modifying it
									const iterator =
										cachedMinAvailableModules.plus[Symbol.iterator]();
									// fast forward add all modules until m
									/** @type {IteratorResult<Module>} */
									let it;
									while (!(it = iterator.next()).done) {
										const module = it.value;
										if (module === m) break;
										cachedMinAvailableModules.add(module);
									}
									// check the remaining modules before adding
									while (!(it = iterator.next()).done) {
										const module = it.value;
										if (
											availableModules.has(module) ||
											availableModules.plus.has(m)
										) {
											cachedMinAvailableModules.add(module);
										}
									}
diff --git a/a.js b/b.js
@@ -715,7 +715,15 @@ A(module, "defaultRules", () => {
A blob:e1e9658c4d17dc5275ccd54706597f10a5238921
	F(module.parser, "javascript", () => ({}));
	applyJavascriptParserOptionsDefaults(module.parser.javascript, {
		futureDefaults
	});

	A(module, "defaultRules", () => {
		const esm = {
			type: "javascript/esm",
			resolve: {
				byDependency: {
					esm: {
						fullySpecified: true
					}
				}
			}
		};
		const commonjs = {
			type: "javascript/dynamic"
		};
		/** @type {RuleSetRules} */
		const rules = [
			{
				mimetype: "application/node",
				type: "javascript/auto"
			},
			{
				test: /\.json$/i,
				type: "json"
			},
			{
				mimetype: "application/json",
				type: "json"
			},
			{
				test: /\.mjs$/i,
				...esm
			},
			{
				test: /\.js$/i,
				descriptionData: {
					type: "module"
				},
				...esm
			},
			{
				test: /\.cjs$/i,
				...commonjs
			},
			{
				test: /\.js$/i,
				descriptionData: {
					type: "commonjs"
				},
				...commonjs
			},
			{
				mimetype: {
					or: ["text/javascript", "application/javascript"]
				},
				...esm
			}
		];
		if (asyncWebAssembly) {
			const wasm = {
				type: "webassembly/async",
				rules: [
					{
						descriptionData: {
							type: "module"
						},
						resolve: {
							fullySpecified: true
						}
					}
				]
			};
			rules.push({
				test: /\.wasm$/i,
				...wasm
			});
			rules.push({
				mimetype: "application/wasm",
				...wasm
			});
		} else if (syncWebAssembly) {
			const wasm = {
				type: "webassembly/sync",
				rules: [
					{
						descriptionData: {
							type: "module"
						},
						resolve: {
							fullySpecified: true
						}
					}
				]
			};
			rules.push({
				test: /\.wasm$/i,
				...wasm
			});
			rules.push({
				mimetype: "application/wasm",
				...wasm
			});
		}
		if (css) {
			const cssRule = {
				type: "css",
				resolve: {
					fullySpecified: true,
					preferRelative: true
				}
			};
			const cssModulesRule = {
				type: "css/module",
				resolve: {
					fullySpecified: true
				}
			};
			rules.push({
				test: /\.css$/i,
				oneOf: [
					{
						test: /\.module\.css$/i,
						...cssModulesRule
					},
					{
						...cssRule
					}
				]
			});
			rules.push({
				mimetype: "text/css+module",
				...cssModulesRule
			});
			rules.push({
				mimetype: "text/css",
				...cssRule
			});
		}
		rules.push(
			{
				dependency: "url",
				oneOf: [
					{
						scheme: /^data$/,
						type: "asset/inline"
					},
					{
						type: "asset/resource"
					}
				]
			},
			{
				assert: { type: "json" },
				type: "json"
			}
		);
		return rules;
	});
};

/**
 * @param {Output} output options
 * @param {Object} options options
 * @param {string} options.context context
 * @param {TargetProperties | false} options.targetProperties target properties
 * @param {boolean} options.isAffectedByBrowserslist is affected by browserslist
 * @param {boolean} options.outputModule is outputModule experiment enabled
 * @param {boolean} options.development is development mode
 * @param {Entry} options.entry entry option
 * @param {ModuleOptions} options.module module option
 * @param {boolean} options.futureDefaults is future defaults enabled
 * @returns {void}
 */
const applyOutputDefaults = (
	output,
	{
		context,
		targetProperties: tp,
		isAffectedByBrowserslist,
		outputModule,
		development,
		entry,
		module,
		futureDefaults
	}
) => {
	/**
	 * @param {Library=} library the library option
	 * @returns {string} a readable library name
	 */
	const getLibraryName = library => {
		const libraryName =
			typeof library === "object" &&
			library &&
			!Array.isArray(library) &&
			"type" in library
				? library.name
				: /** @type {LibraryName=} */ (library);
		if (Array.isArray(libraryName)) {
			return libraryName.join(".");
		} else if (typeof libraryName === "object") {
			return getLibraryName(libraryName.root);
		} else if (typeof libraryName === "string") {
			return libraryName;
		}
		return "";
	};

	F(output, "uniqueName", () => {
		const libraryName = getLibraryName(output.library);
		if (libraryName) return libraryName;
		const pkgPath = path.resolve(context, "package.json");
		try {
			const packageInfo = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
diff --git a/a.js b/b.js
@@ -907,6 +915,7 @@ D(
A blob:e1e9658c4d17dc5275ccd54706597f10a5238921
	);
	D(output, "chunkLoadTimeout", 120000);
	D(output, "hashFunction", futureDefaults ? "xxhash64" : "md4");
	D(output, "hashDigest", "hex");
	D(output, "hashDigestLength", futureDefaults ? 16 : 20);
	D(output, "strictModuleExceptionHandling", false);

	const optimistic = v => v || v === undefined;
	F(
		output.environment,
		"arrowFunction",
		() => tp && optimistic(tp.arrowFunction)
diff --git a/a.js b/b.js
@@ -920,8 +929,12 @@ F(
A blob:e1e9658c4d17dc5275ccd54706597f10a5238921
	F(
		output.environment,
		"destructuring",
		() => tp && optimistic(tp.destructuring)
	);
	F(output.environment, "forOf", () => tp && optimistic(tp.forOf));
	F(output.environment, "bigIntLiteral", () => tp && tp.bigIntLiteral);
	F(output.environment, "dynamicImport", () => tp && tp.dynamicImport);
	F(output.environment, "module", () => tp && tp.module);

	const { trustedTypes } = output;
	if (trustedTypes) {
		F(
diff --git a/a.js b/b.js
@@ -274,78 +274,71 @@ generate() {
A blob:136d2d154d7ebced562227c32f70886b0e594015
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { compilation, chunk, _runtimeRequirements } = this;
		const {
			chunkGraph,
			runtimeTemplate,
			outputOptions: {
				crossOriginLoading,
				uniqueName,
				chunkLoadTimeout: loadTimeout
			}
		} = compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const conditionMap = chunkGraph.getChunkConditionMap(
			chunk,
			(chunk, chunkGraph) =>
				!!chunkGraph.getChunkModulesIterableBySourceType(chunk, "css")
		);
		const hasCssMatcher = compileBooleanMatcher(conditionMap);

		const withLoading =
			_runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers) &&
			hasCssMatcher !== false;
		const withHmr = _runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const initialChunkIdsWithCss = new Set();
		const initialChunkIdsWithoutCss = new Set();
		for (const c of chunk.getAllInitialChunks()) {
			(chunkHasCss(c, chunkGraph)
				? initialChunkIdsWithCss
				: initialChunkIdsWithoutCss
			).add(c.id);
		}

		if (!withLoading && !withHmr && initialChunkIdsWithCss.size === 0) {
			return null;
		}

		const { createStylesheet } =
			CssLoadingRuntimeModule.getCompilationHooks(compilation);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_css`
			: undefined;

		const code = Template.asString([
			"link = document.createElement('link');",
			uniqueName
				? 'link.setAttribute("data-webpack", uniqueName + ":" + key);'
				: "",
			"link.setAttribute(loadingAttribute, 1);",
			'link.rel = "stylesheet";',
			"link.href = url;",
			crossOriginLoading
				? Template.asString([
						"if (link.src.indexOf(window.location.origin + '/') !== 0) {",
						Template.indent(
							`link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
						),
						"}"
				  ])
				: ""
		]);

		const cc = str => str.charCodeAt(0);

		return Template.asString([
			"// object to store loaded and loading chunks",
			"// undefined = chunk not loaded, null = chunk preloaded/prefetched",
			"// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded",
			`var installedChunks = ${
				stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""
			}{${Array.from(
				initialChunkIdsWithoutCss,
				id => `${JSON.stringify(id)}:0`
			).join(",")}};`,
			"",
			uniqueName
				? `var uniqueName = ${JSON.stringify(
						runtimeTemplate.outputOptions.uniqueName
				  )};`
				: "// data-webpack is not used as build has no uniqueName",
			`var loadCssChunkData = ${runtimeTemplate.basicFunction(
				"target, link, chunkId",
				[
					`var data, token = "", token2, exports = {}, exportsWithId = [], exportsWithDashes = [], ${
						withHmr ? "moduleIds = [], " : ""
					}i = 0, cc = 1;`,
					"try { if(!link) link = loadStylesheet(chunkId); data = link.sheet.cssRules; data = data[data.length - 1].style; } catch(e) { data = getComputedStyle(document.head); }",
					`data = data.getPropertyValue(${
						uniqueName
							? runtimeTemplate.concatenation(
									"--webpack-",
									{ expr: "uniqueName" },
									"-",
									{ expr: "chunkId" }
							  )
							: runtimeTemplate.concatenation("--webpack-", { expr: "chunkId" })
					});`,
					"if(!data) return [];",
					"for(; cc; i++) {",
					Template.indent([
						"cc = data.charCodeAt(i);",
						`if(cc == ${cc("(")}) { token2 = token; token = ""; }`,
						`else if(cc == ${cc(
							")"
						)}) { exports[token2.replace(/^_/, "")] = token.replace(/^_/, ""); token = ""; }`,
						`else if(cc == ${cc("/")} || cc == ${cc(
							"%"
						)}) { token = token.replace(/^_/, ""); exports[token] = token; exportsWithId.push(token); if(cc == ${cc(
							"%"
						)}) exportsWithDashes.push(token); token = ""; }`,
						`else if(!cc || cc == ${cc(
							","
						)}) { token = token.replace(/^_/, ""); exportsWithId.forEach(${runtimeTemplate.expressionFunction(
							`exports[x] = ${
								uniqueName
									? runtimeTemplate.concatenation(
											{ expr: "uniqueName" },
											"-",
											{ expr: "token" },
											"-",
											{ expr: "exports[x]" }
									  )
									: runtimeTemplate.concatenation({ expr: "token" }, "-", {
											expr: "exports[x]"
									  })
							}`,
							"x"
						)}); exportsWithDashes.forEach(${runtimeTemplate.expressionFunction(
							`exports[x] = "--" + exports[x]`,
							"x"
						)}); ${
							RuntimeGlobals.makeNamespaceObject
						}(exports); target[token] = (${runtimeTemplate.basicFunction(
							"exports, module",
							`module.exports = exports;`
						)}).bind(null, exports); ${
							withHmr ? "moduleIds.push(token); " : ""
						}token = ""; exports = {}; exportsWithId.length = 0; }`,
						`else if(cc == ${cc("\\")}) { token += data[++i] }`,
						`else { token += data[i]; }`
					]),
					"}",
					`${
						withHmr ? `if(target == ${RuntimeGlobals.moduleFactories}) ` : ""
					}installedChunks[chunkId] = 0;`,
					withHmr ? "return moduleIds;" : ""
				]
			)}`,
			'var loadingAttribute = "data-webpack-loading";',
			`var loadStylesheet = ${runtimeTemplate.basicFunction(
				"chunkId, url, done" + (withHmr ? ", hmr" : ""),
				[
					'var link, needAttach, key = "chunk-" + chunkId;',
					withHmr ? "if(!hmr) {" : "",
					'var links = document.getElementsByTagName("link");',
					"for(var i = 0; i < links.length; i++) {",
					Template.indent([
						"var l = links[i];",
						`if(l.rel == "stylesheet" && (${
							withHmr
								? 'l.href.startsWith(url) || l.getAttribute("href").startsWith(url)'
								: 'l.href == url || l.getAttribute("href") == url'
						}${
							uniqueName
								? ' || l.getAttribute("data-webpack") == uniqueName + ":" + key'
								: ""
						})) { link = l; break; }`
					]),
					"}",
					"if(!done) return link;",
					withHmr ? "}" : "",
					"if(!link) {",
					Template.indent([
						"needAttach = true;",
						createStylesheet.call(code, this.chunk)
					]),
					"}",
					`var onLinkComplete = ${runtimeTemplate.basicFunction(
						"prev, event",
						Template.asString([
							"link.onerror = link.onload = null;",
							"link.removeAttribute(loadingAttribute);",
							"clearTimeout(timeout);",
							'if(event && event.type != "load") link.parentNode.removeChild(link)',
							"done(event);",
							"if(prev) return prev(event);"
						])
					)};`,
					"if(link.getAttribute(loadingAttribute)) {",
					Template.indent([
						`var timeout = setTimeout(onLinkComplete.bind(null, undefined, { type: 'timeout', target: link }), ${loadTimeout});`,
						"link.onerror = onLinkComplete.bind(null, link.onerror);",
						"link.onload = onLinkComplete.bind(null, link.onload);"
					]),
					"} else onLinkComplete(undefined, { type: 'load', target: link });", // We assume any existing stylesheet is render blocking
					withHmr ? "hmr ? document.head.insertBefore(link, hmr) :" : "",
					"needAttach && document.head.appendChild(link);",
					"return link;"
				]
			)};`,
			initialChunkIdsWithCss.size > 2
				? `${JSON.stringify(
						Array.from(initialChunkIdsWithCss)
				  )}.forEach(loadCssChunkData.bind(null, ${
						RuntimeGlobals.moduleFactories
				  }, 0));`
				: initialChunkIdsWithCss.size > 0
				? `${Array.from(
						initialChunkIdsWithCss,
						id =>
							`loadCssChunkData(${
								RuntimeGlobals.moduleFactories
							}, 0, ${JSON.stringify(id)});`
				  ).join("")}`
				: "// no initial css",
			"",
			withLoading
				? Template.asString([
						`${fn}.css = ${runtimeTemplate.basicFunction(
							"chunkId, promises",
							hasCssMatcher !== false
								? [
										"// css chunk loading",
										`var installedChunkData = ${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`,
										'if(installedChunkData !== 0) { // 0 means "already installed".',
										Template.indent([
											"",
											'// a Promise means "currently loading".',
											"if(installedChunkData) {",
											Template.indent([
												"promises.push(installedChunkData[2]);"
											]),
											"} else {",
											Template.indent([
												hasCssMatcher === true
													? "if(true) { // all chunks have CSS"
													: `if(${hasCssMatcher("chunkId")}) {`,
												Template.indent([
													"// setup Promise in chunk cache",
													`var promise = new Promise(${runtimeTemplate.expressionFunction(
														`installedChunkData = installedChunks[chunkId] = [resolve, reject]`,
														"resolve, reject"
													)});`,
													"promises.push(installedChunkData[2] = promise);",
													"",
													"// start chunk loading",
													`var url = ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkCssFilename}(chunkId);`,
													"// create error before stack unwound to get useful stacktrace later",
													"var error = new Error();",
													`var loadingEnded = ${runtimeTemplate.basicFunction(
														"event",
														[
															`if(${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId)) {`,
															Template.indent([
																"installedChunkData = installedChunks[chunkId];",
																"if(installedChunkData !== 0) installedChunks[chunkId] = undefined;",
																"if(installedChunkData) {",
																Template.indent([
																	'if(event.type !== "load") {',
																	Template.indent([
																		"var errorType = event && event.type;",
																		"var realSrc = event && event.target && event.target.src;",
																		"error.message = 'Loading css chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';",
																		"error.name = 'ChunkLoadError';",
																		"error.type = errorType;",
																		"error.request = realSrc;",
																		"installedChunkData[1](error);"
																	]),
																	"} else {",
																	Template.indent([
																		`loadCssChunkData(${RuntimeGlobals.moduleFactories}, link, chunkId);`,
																		"installedChunkData[0]();"
																	]),
																	"}"
																]),
																"}"
															]),
															"}"
														]
													)};`,
													"var link = loadStylesheet(chunkId, url, loadingEnded);"
												]),
												"} else installedChunks[chunkId] = 0;"
											]),
											"}"
										]),
										"}"
								  ]
								: "installedChunks[chunkId] = 0;"
						)};`
				  ])
				: "// no chunk loading",
			"",
			withHmr
diff --git a/a.js b/b.js
@@ -343,7 +343,8 @@ interceptAllHooksFor(
A blob:6d6af9d39c4d2c2c5c339271437166e7299a33c1
			});
	});
};

const interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {
	interceptAllHooksFor(
		{
			hooks:
				require("../javascript/JavascriptModulesPlugin").getCompilationHooks(
					compilation
				)
		},
		tracer,
		"JavascriptModulesPlugin"
	);
};

const makeInterceptorFor = (instance, tracer) => hookName => ({
	register: ({ name, type, context, fn }) => {
		const newFn =
			// Don't tap our own hooks to ensure stream can close cleanly
			name === pluginName
				? fn
diff --git a/a.js b/b.js
@@ -354,9 +355,7 @@ const makeInterceptorFor = (instance, tracer) =>
A blob:6d6af9d39c4d2c2c5c339271437166e7299a33c1
		tracer,
		"JavascriptModulesPlugin"
	);
};

const makeInterceptorFor = (instance, tracer) => hookName => ({
	register: ({ name, type, context, fn }) => {
		const newFn =
			// Don't tap our own hooks to ensure stream can close cleanly
			name === pluginName
				? fn
				: makeNewProfiledTapFn(hookName, tracer, {
						name,
						type,
						fn
				  });
		return {
			name,
			type,
			context,
			fn: newFn
		};
	}
});
diff --git a/a.js b/b.js
@@ -53,12 +53,18 @@ getReferencedExports(moduleGraph, runtime) {
A blob:a2dd43c8b72876d53cdcda6f3a4a63ca9f19e734
	 * Returns list of exports referenced by this dependency
	 * @param {ModuleGraph} moduleGraph module graph
	 * @param {RuntimeSpec} runtime the runtime for which the module is analysed
	 * @returns {(string[] | ReferencedExport)[]} referenced exports
	 */
	getReferencedExports(moduleGraph, runtime) {
		return this.referencedExports
			? this.referencedExports.map(e => ({
					name: e,
					canMangle: false
			  }))
			: Dependency.EXPORTS_OBJECT_REFERENCED;
	}

	serialize(context) {
		context.write(this.referencedExports);
		super.serialize(context);
	}

	deserialize(context) {
		this.referencedExports = context.read();
		super.deserialize(context);
	}
}

diff --git a/a.js b/b.js
@@ -46,6 +46,12 @@ const getProperty = (moduleGraph, module, exportName, property, runtime) => {
A blob:5aa28e5d4e82e37010c1a4c6c0d224b0b2f9371f
 * @param {string | null} exportName name of the export if any
 * @param {string | null} property name of the requested property
 * @param {RuntimeSpec} runtime for which runtime
 * @returns {any} value of the property
 */
const getProperty = (moduleGraph, module, exportName, property, runtime) => {
	if (!exportName) {
		switch (property) {
			case "usedExports": {
				const usedExports = moduleGraph
					.getExportsInfo(module)
					.getUsedExports(runtime);
				if (
					typeof usedExports === "boolean" ||
					usedExports === undefined ||
					usedExports === null
				) {
					return usedExports;
				}
				return Array.from(usedExports).sort();
			}
		}
	}
	switch (property) {
		case "used":
			return (
				moduleGraph.getExportsInfo(module).getUsed(exportName, runtime) !==
				UsageState.Unused
diff --git a/a.js b/b.js
@@ -11,6 +11,7 @@
A blob:9a50d534270208db6178fd0f4d9e96e1dc74ad16

const util = require("util");
const memoize = require("./util/memoize");

/** @typedef {import("../declarations/WebpackOptions").Entry} Entry */
/** @typedef {import("../declarations/WebpackOptions").EntryNormalized} EntryNormalized */
/** @typedef {import("../declarations/WebpackOptions").EntryObject} EntryObject */
/** @typedef {import("../declarations/WebpackOptions").LibraryOptions} LibraryOptions */
/** @typedef {import("../declarations/WebpackOptions").ModuleOptions} ModuleOptions */
/** @typedef {import("../declarations/WebpackOptions").ResolveOptions} ResolveOptions */
/** @typedef {import("../declarations/WebpackOptions").RuleSetCondition} RuleSetCondition */
diff --git a/a.js b/b.js
@@ -26,11 +27,15 @@
A blob:9a50d534270208db6178fd0f4d9e96e1dc74ad16
/** @typedef {import("../declarations/WebpackOptions").StatsOptions} StatsOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} Configuration */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptionsNormalized */
/** @typedef {import("../declarations/WebpackOptions").WebpackPluginFunction} WebpackPluginFunction */
/** @typedef {import("../declarations/WebpackOptions").WebpackPluginInstance} WebpackPluginInstance */
/** @typedef {import("./Compilation").Asset} Asset */
/** @typedef {import("./Compilation").AssetInfo} AssetInfo */
/** @typedef {import("./MultiStats")} MultiStats */
/** @typedef {import("./Parser").ParserState} ParserState */
/** @typedef {import("./ResolverFactory").ResolvePluginInstance} ResolvePluginInstance */
/** @typedef {import("./ResolverFactory").Resolver} Resolver */
/** @typedef {import("./Watching")} Watching */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsAsset} StatsAsset */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsChunk} StatsChunk */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsChunkGroup} StatsChunkGroup */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsChunkOrigin} StatsChunkOrigin */
diff --git a/a.js b/b.js
@@ -103,6 +103,7 @@ const printGeneratedCodeForStack = (module, code) => {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	return chunkGraph.getChunkModulesIterableBySourceType(chunk, "javascript")
		? true
		: false;
};

const printGeneratedCodeForStack = (module, code) => {
	const lines = code.split("\n");
	const n = `${lines.length}`.length;
	return `\n\nGenerated code for ${module.identifier()}\n${lines
		.map((line, i, lines) => {
			const iStr = `${i + 1}`;
			return `${" ".repeat(n - iStr.length)}${iStr} | ${line}`;
		})
		.join("\n")}`;
};

/**
 * @typedef {Object} RenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {boolean} strictMode rendering in strict context
 */

/**
 * @typedef {Object} MainRenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {string} hash hash to be used for render call
 * @property {boolean} strictMode rendering in strict context
 */

/**
 * @typedef {Object} ChunkRenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {InitFragment<ChunkRenderContext>[]} chunkInitFragments init fragments for the chunk
 * @property {boolean} strictMode rendering in strict context
 */

/**
 * @typedef {Object} RenderBootstrapContext
 * @property {Chunk} chunk the chunk
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {string} hash hash to be used for render call
diff --git a/a.js b/b.js
@@ -332,6 +333,7 @@ apply(compiler) {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JavascriptModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
				normalModuleFactory.hooks.createParser
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("auto");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("script");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("module");
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				compilation.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const {
							hash,
							chunk,
							chunkGraph,
							moduleGraph,
							runtimeTemplate,
							dependencyTemplates,
							outputOptions,
							codeGenerationResults
						} = options;

						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;

						let render;
						const filenameTemplate =
							JavascriptModulesPlugin.getChunkFilenameTemplate(
								chunk,
								outputOptions
							);
						if (hotUpdateChunk) {
							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						} else if (chunk.hasRuntime()) {
							render = () =>
								this.renderMain(
									{
										hash,
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks,
									compilation
								);
						} else {
							if (!chunkHasJs(chunk, chunkGraph)) {
								return result;
							}

							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						}

						result.push({
							render,
							filenameTemplate,
							pathOptions: {
								hash,
								runtime: chunk.runtime,
								chunk,
								contentHashType: "javascript"
							},
							info: {
								javascriptModule: compilation.runtimeTemplate.isModule()
							},
							identifier: hotUpdateChunk
								? `hotupdatechunk${chunk.id}`
								: `chunk${chunk.id}`,
							hash: chunk.contentHash.javascript
						});

						return result;
					}
				);
				compilation.hooks.chunkHash.tap(
					"JavascriptModulesPlugin",
					(chunk, hash, context) => {
						hooks.chunkHash.call(chunk, hash, context);
						if (chunk.hasRuntime()) {
							this.updateHashWithBootstrap(
								hash,
								{
									hash: "0000",
									chunk,
									chunkGraph: context.chunkGraph,
									moduleGraph: context.moduleGraph,
									runtimeTemplate: context.runtimeTemplate
								},
diff --git a/a.js b/b.js
@@ -344,6 +346,7 @@ apply(compiler) {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JavascriptModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
				normalModuleFactory.hooks.createParser
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("auto");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("script");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("module");
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				compilation.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const {
							hash,
							chunk,
							chunkGraph,
							moduleGraph,
							runtimeTemplate,
							dependencyTemplates,
							outputOptions,
							codeGenerationResults
						} = options;

						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;

						let render;
						const filenameTemplate =
							JavascriptModulesPlugin.getChunkFilenameTemplate(
								chunk,
								outputOptions
							);
						if (hotUpdateChunk) {
							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						} else if (chunk.hasRuntime()) {
							render = () =>
								this.renderMain(
									{
										hash,
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks,
									compilation
								);
						} else {
							if (!chunkHasJs(chunk, chunkGraph)) {
								return result;
							}

							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						}

						result.push({
							render,
							filenameTemplate,
							pathOptions: {
								hash,
								runtime: chunk.runtime,
								chunk,
								contentHashType: "javascript"
							},
							info: {
								javascriptModule: compilation.runtimeTemplate.isModule()
							},
							identifier: hotUpdateChunk
								? `hotupdatechunk${chunk.id}`
								: `chunk${chunk.id}`,
							hash: chunk.contentHash.javascript
						});

						return result;
					}
				);
				compilation.hooks.chunkHash.tap(
					"JavascriptModulesPlugin",
					(chunk, hash, context) => {
						hooks.chunkHash.call(chunk, hash, context);
						if (chunk.hasRuntime()) {
							this.updateHashWithBootstrap(
								hash,
								{
									hash: "0000",
									chunk,
									chunkGraph: context.chunkGraph,
									moduleGraph: context.moduleGraph,
									runtimeTemplate: context.runtimeTemplate
								},
								hooks
							);
						}
					}
				);
				compilation.hooks.contentHash.tap("JavascriptModulesPlugin", chunk => {
					const {
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
diff --git a/a.js b/b.js
@@ -361,6 +364,7 @@ apply(compiler) {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JavascriptModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
				normalModuleFactory.hooks.createParser
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("auto");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("script");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("module");
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				compilation.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const {
							hash,
							chunk,
							chunkGraph,
							moduleGraph,
							runtimeTemplate,
							dependencyTemplates,
							outputOptions,
							codeGenerationResults
						} = options;

						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;

						let render;
						const filenameTemplate =
							JavascriptModulesPlugin.getChunkFilenameTemplate(
								chunk,
								outputOptions
							);
						if (hotUpdateChunk) {
							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						} else if (chunk.hasRuntime()) {
							render = () =>
								this.renderMain(
									{
										hash,
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks,
									compilation
								);
						} else {
							if (!chunkHasJs(chunk, chunkGraph)) {
								return result;
							}

							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						}

						result.push({
							render,
							filenameTemplate,
							pathOptions: {
								hash,
								runtime: chunk.runtime,
								chunk,
								contentHashType: "javascript"
							},
							info: {
								javascriptModule: compilation.runtimeTemplate.isModule()
							},
							identifier: hotUpdateChunk
								? `hotupdatechunk${chunk.id}`
								: `chunk${chunk.id}`,
							hash: chunk.contentHash.javascript
						});

						return result;
					}
				);
				compilation.hooks.chunkHash.tap(
					"JavascriptModulesPlugin",
					(chunk, hash, context) => {
						hooks.chunkHash.call(chunk, hash, context);
						if (chunk.hasRuntime()) {
							this.updateHashWithBootstrap(
								hash,
								{
									hash: "0000",
									chunk,
									chunkGraph: context.chunkGraph,
									moduleGraph: context.moduleGraph,
									runtimeTemplate: context.runtimeTemplate
								},
								hooks
							);
						}
					}
				);
				compilation.hooks.contentHash.tap("JavascriptModulesPlugin", chunk => {
					const {
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						}
					} = compilation;
					const hash = createHash(hashFunction);
					if (hashSalt) hash.update(hashSalt);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: "0000",
								chunk,
								chunkGraph: compilation.chunkGraph,
								moduleGraph: compilation.moduleGraph,
								runtimeTemplate: compilation.runtimeTemplate
							},
diff --git a/a.js b/b.js
@@ -373,6 +377,7 @@ apply(compiler) {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JavascriptModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
				normalModuleFactory.hooks.createParser
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("auto");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("script");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", options => {
						return new JavascriptParser("module");
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				compilation.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const {
							hash,
							chunk,
							chunkGraph,
							moduleGraph,
							runtimeTemplate,
							dependencyTemplates,
							outputOptions,
							codeGenerationResults
						} = options;

						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;

						let render;
						const filenameTemplate =
							JavascriptModulesPlugin.getChunkFilenameTemplate(
								chunk,
								outputOptions
							);
						if (hotUpdateChunk) {
							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						} else if (chunk.hasRuntime()) {
							render = () =>
								this.renderMain(
									{
										hash,
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks,
									compilation
								);
						} else {
							if (!chunkHasJs(chunk, chunkGraph)) {
								return result;
							}

							render = () =>
								this.renderChunk(
									{
										chunk,
										dependencyTemplates,
										runtimeTemplate,
										moduleGraph,
										chunkGraph,
										codeGenerationResults,
										strictMode: runtimeTemplate.isModule()
									},
									hooks
								);
						}

						result.push({
							render,
							filenameTemplate,
							pathOptions: {
								hash,
								runtime: chunk.runtime,
								chunk,
								contentHashType: "javascript"
							},
							info: {
								javascriptModule: compilation.runtimeTemplate.isModule()
							},
							identifier: hotUpdateChunk
								? `hotupdatechunk${chunk.id}`
								: `chunk${chunk.id}`,
							hash: chunk.contentHash.javascript
						});

						return result;
					}
				);
				compilation.hooks.chunkHash.tap(
					"JavascriptModulesPlugin",
					(chunk, hash, context) => {
						hooks.chunkHash.call(chunk, hash, context);
						if (chunk.hasRuntime()) {
							this.updateHashWithBootstrap(
								hash,
								{
									hash: "0000",
									chunk,
									chunkGraph: context.chunkGraph,
									moduleGraph: context.moduleGraph,
									runtimeTemplate: context.runtimeTemplate
								},
								hooks
							);
						}
					}
				);
				compilation.hooks.contentHash.tap("JavascriptModulesPlugin", chunk => {
					const {
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						}
					} = compilation;
					const hash = createHash(hashFunction);
					if (hashSalt) hash.update(hashSalt);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: "0000",
								chunk,
								chunkGraph: compilation.chunkGraph,
								moduleGraph: compilation.moduleGraph,
								runtimeTemplate: compilation.runtimeTemplate
							},
							hooks
						);
					} else {
						hash.update(`${chunk.id} `);
						hash.update(chunk.ids ? chunk.ids.join(",") : "");
					}
					hooks.chunkHash.call(chunk, hash, {
						chunkGraph,
						moduleGraph,
						runtimeTemplate
					});
					const modules = chunkGraph.getChunkModulesIterableBySourceType(
diff --git a/a.js b/b.js
@@ -978,7 +983,13 @@ updateHashWithBootstrap(hash, renderContext, hooks) {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	/**
	 * @param {Hash} hash the hash to be updated
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 */
	updateHashWithBootstrap(hash, renderContext, hooks) {
		const bootstrap = this.renderBootstrap(renderContext, hooks);
		for (const key of Object.keys(bootstrap)) {
			hash.update(key);
			if (Array.isArray(bootstrap[key])) {
				for (const line of bootstrap[key]) {
					hash.update(line);
				}
			} else {
				hash.update(JSON.stringify(bootstrap[key]));
			}
		}
	}

	/**
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @returns {{ header: string[], beforeStartup: string[], startup: string[], afterStartup: string[], allowInlineStartup: boolean }} the generated source of the bootstrap code
	 */
	renderBootstrap(renderContext, hooks) {
		const { chunkGraph, moduleGraph, chunk, runtimeTemplate } = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);

		const requireFunction = runtimeRequirements.has(RuntimeGlobals.require);
diff --git a/a.js b/b.js
@@ -1102,8 +1113,18 @@ renderBootstrap(renderContext, hooks) {
A blob:28ee536d2c19b39da045ce426a6bb61f5ef18ef5
	/**
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @returns {{ header: string[], beforeStartup: string[], startup: string[], afterStartup: string[], allowInlineStartup: boolean }} the generated source of the bootstrap code
	 */
	renderBootstrap(renderContext, hooks) {
		const { chunkGraph, moduleGraph, chunk, runtimeTemplate } = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);

		const requireFunction = runtimeRequirements.has(RuntimeGlobals.require);
		const moduleCache = runtimeRequirements.has(RuntimeGlobals.moduleCache);
		const moduleFactories = runtimeRequirements.has(
			RuntimeGlobals.moduleFactories
		);
		const moduleUsed = runtimeRequirements.has(RuntimeGlobals.module);
		const requireScopeUsed = runtimeRequirements.has(
			RuntimeGlobals.requireScope
		);
		const interceptModuleExecution = runtimeRequirements.has(
			RuntimeGlobals.interceptModuleExecution
		);

		const useRequire =
			requireFunction || interceptModuleExecution || moduleUsed;

		const result = {
			header: [],
			beforeStartup: [],
			startup: [],
			afterStartup: [],
			allowInlineStartup: true
		};

		let { header: buf, startup, beforeStartup, afterStartup } = result;

		if (result.allowInlineStartup && moduleFactories) {
			startup.push(
				"// module factories are used so entry inlining is disabled"
			);
			result.allowInlineStartup = false;
		}
		if (result.allowInlineStartup && moduleCache) {
			startup.push("// module cache are used so entry inlining is disabled");
			result.allowInlineStartup = false;
		}
		if (result.allowInlineStartup && interceptModuleExecution) {
			startup.push(
				"// module execution is intercepted so entry inlining is disabled"
			);
			result.allowInlineStartup = false;
		}

		if (useRequire || moduleCache) {
			buf.push("// The module cache");
			buf.push("var __webpack_module_cache__ = {};");
			buf.push("");
		}

		if (useRequire) {
			buf.push("// The require function");
			buf.push(`function __webpack_require__(moduleId) {`);
			buf.push(Template.indent(this.renderRequire(renderContext, hooks)));
			buf.push("}");
			buf.push("");
		} else if (runtimeRequirements.has(RuntimeGlobals.requireScope)) {
			buf.push("// The require scope");
			buf.push("var __webpack_require__ = {};");
			buf.push("");
		}

		if (
			moduleFactories ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly)
		) {
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(`${RuntimeGlobals.moduleFactories} = __webpack_modules__;`);
			buf.push("");
		}

		if (moduleCache) {
			buf.push("// expose the module cache");
			buf.push(`${RuntimeGlobals.moduleCache} = __webpack_module_cache__;`);
			buf.push("");
		}

		if (interceptModuleExecution) {
			buf.push("// expose the module execution interceptor");
			buf.push(`${RuntimeGlobals.interceptModuleExecution} = [];`);
			buf.push("");
		}

		if (!runtimeRequirements.has(RuntimeGlobals.startupNoDefault)) {
			if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
				/** @type {string[]} */
				const buf2 = [];
				const runtimeRequirements =
					chunkGraph.getTreeRuntimeRequirements(chunk);
				buf2.push("// Load entry module and return exports");
				let i = chunkGraph.getNumberOfEntryModules(chunk);
				for (const [
					entryModule,
					entrypoint
				] of chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)) {
					const chunks = entrypoint.chunks.filter(c => c !== chunk);
					if (result.allowInlineStartup && chunks.length > 0) {
						buf2.push(
							"// This entry module depends on other loaded chunks and execution need to be delayed"
						);
						result.allowInlineStartup = false;
					}
					if (
						result.allowInlineStartup &&
						someInIterable(
							moduleGraph.getIncomingConnectionsByOriginModule(entryModule),
							([originModule, connections]) =>
								originModule &&
								connections.some(c => c.isTargetActive(chunk.runtime)) &&
								someInIterable(
									chunkGraph.getModuleRuntimes(originModule),
									runtime =>
										intersectRuntime(runtime, chunk.runtime) !== undefined
								)
						)
					) {
						buf2.push(
							"// This entry module is referenced by other modules so it can't be inlined"
						);
						result.allowInlineStartup = false;
					}
					if (
						result.allowInlineStartup &&
						(!entryModule.buildInfo ||
							!entryModule.buildInfo.topLevelDeclarations)
					) {
						buf2.push(
diff --git a/a.js b/b.js
@@ -416,7 +416,6 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
diff --git a/a.js b/b.js
@@ -437,7 +436,6 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}
diff --git a/a.js b/b.js
@@ -486,10 +484,10 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
diff --git a/a.js b/b.js
@@ -545,9 +543,7 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
diff --git a/a.js b/b.js
@@ -600,9 +596,7 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
diff --git a/a.js b/b.js
@@ -635,9 +629,7 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
diff --git a/a.js b/b.js
@@ -816,7 +808,7 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
diff --git a/a.js b/b.js
@@ -915,7 +907,6 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
diff --git a/a.js b/b.js
@@ -1054,7 +1045,6 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(
								info.name,
								info.rootInfo,
								info.getMembers,
								info.getMembersOptionals
							)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
diff --git a/a.js b/b.js
@@ -1321,7 +1311,6 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(
								info.name,
								info.rootInfo,
								info.getMembers,
								info.getMembersOptionals
							)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
diff --git a/a.js b/b.js
@@ -1395,7 +1384,7 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(
								info.name,
								info.rootInfo,
								info.getMembers,
								info.getMembersOptionals
							)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
						res.setOptions([consequent]);
					}
					if (alternate.isConditional()) {
						res.addOptions(alternate.options);
					} else {
						res.addOptions([alternate]);
					}
				} else {
					res = this.evaluateExpression(
						conditionValue ? expr.consequent : expr.alternate
					);
					if (condition.couldHaveSideEffects()) res.setSideEffects();
				}
				res.setRange(expr.range);
				return res;
			});
		this.hooks.evaluate
			.for("ArrayExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ArrayExpressionNode} */ (_expr);

				const items = expr.elements.map(element => {
					return (
						element !== null &&
						element.type !== "SpreadElement" &&
						this.evaluateExpression(element)
					);
				});
				if (!items.every(Boolean)) return;
				return new BasicEvaluatedExpression()
					.setItems(items)
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ChainExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ChainExpressionNode} */ (_expr);
				/** @type {ExpressionNode[]} */
				const optionalExpressionsStack = [];
				/** @type {ExpressionNode|SuperNode} */
				let next = expr.expression;

				while (
					next.type === "MemberExpression" ||
					next.type === "CallExpression"
				) {
					if (next.type === "MemberExpression") {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.object)
							);
						}
						next = next.object;
					} else {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.callee)
							);
						}
						next = next.callee;
					}
				}

				while (optionalExpressionsStack.length > 0) {
					const expression = optionalExpressionsStack.pop();
					const evaluated = this.evaluateExpression(expression);

					if (evaluated && evaluated.asNullish()) {
						return evaluated.setRange(_expr.range);
					}
				}
				return this.evaluateExpression(expr.expression);
diff --git a/a.js b/b.js
@@ -1405,7 +1394,7 @@ _initializeEvaluating() {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
		this.prevStatement = undefined;
		this.currentTagData = undefined;
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("JavascriptParser", _expr => {
			const expr = /** @type {LiteralNode} */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {NewExpressionNode} */ (_expr);
			const callee = expr.callee;
			if (
				callee.type !== "Identifier" ||
				callee.name !== "RegExp" ||
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp, flags;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return new BasicEvaluatedExpression()
					.setRegExp(new RegExp(""))
					.setRange(expr.range);
			}

			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(expr.range);
		});
		this.hooks.evaluate
			.for("LogicalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {LogicalExpressionNode} */ (_expr);

				const left = this.evaluateExpression(expr.left);
				if (!left) return;
				let returnRight = false;
				/** @type {boolean|undefined} */
				let allowedRight;
				if (expr.operator === "&&") {
					const leftAsBool = left.asBool();
					if (leftAsBool === false) return left.setRange(expr.range);
					returnRight = leftAsBool === true;
					allowedRight = false;
				} else if (expr.operator === "||") {
					const leftAsBool = left.asBool();
					if (leftAsBool === true) return left.setRange(expr.range);
					returnRight = leftAsBool === false;
					allowedRight = true;
				} else if (expr.operator === "??") {
					const leftAsNullish = left.asNullish();
					if (leftAsNullish === false) return left.setRange(expr.range);
					if (leftAsNullish !== true) return;
					returnRight = true;
				} else return;
				const right = this.evaluateExpression(expr.right);
				if (!right) return;
				if (returnRight) {
					if (left.couldHaveSideEffects()) right.setSideEffects();
					return right.setRange(expr.range);
				}

				const asBool = right.asBool();

				if (allowedRight === true && asBool === true) {
					return new BasicEvaluatedExpression()
						.setRange(expr.range)
						.setTruthy();
				} else if (allowedRight === false && asBool === false) {
					return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();
				}
			});

		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(expr.range);
			}
		};

		this.hooks.evaluate
			.for("BinaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {BinaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const left = this.evaluateExpression(expr.left);
					if (!left || !left.isCompileTimeValue()) return;

					const right = this.evaluateExpression(expr.right);
					if (!right || !right.isCompileTimeValue()) return;

					const result = fn(
						left.asCompileTimeValue(),
						right.asCompileTimeValue()
					);
					return valueAsExpression(
						result,
						expr,
						left.couldHaveSideEffects() || right.couldHaveSideEffects()
					);
				};

				const isAlwaysDifferent = (a, b) =>
					(a === true && b === false) || (a === false && b === true);

				const handleTemplateStringCompare = (left, right, res, eql) => {
					const getPrefix = parts => {
						let value = "";
						for (const p of parts) {
							const v = p.asString();
							if (v !== undefined) value += v;
							else break;
						}
						return value;
					};
					const getSuffix = parts => {
						let value = "";
						for (let i = parts.length - 1; i >= 0; i--) {
							const v = parts[i].asString();
							if (v !== undefined) value = v + value;
							else break;
						}
						return value;
					};
					const leftPrefix = getPrefix(left.parts);
					const rightPrefix = getPrefix(right.parts);
					const leftSuffix = getSuffix(left.parts);
					const rightSuffix = getSuffix(right.parts);
					const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
					const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
					if (
						leftPrefix.slice(0, lenPrefix) !==
							rightPrefix.slice(0, lenPrefix) ||
						leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleStrictEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									(left.asCompileTimeValue() === right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}

					const leftPrimitive = left.isPrimitiveType();
					const rightPrimitive = right.isPrimitiveType();

					if (
						// Primitive !== Object or
						// compile-time object types are never equal to something at runtime
						(leftPrimitive === false &&
							(leftConst || rightPrimitive === true)) ||
						(rightPrimitive === false &&
							(rightConst || leftPrimitive === true)) ||
						// Different nullish or boolish status also means not equal
						isAlwaysDifferent(left.asBool(), right.asBool()) ||
						isAlwaysDifferent(left.asNullish(), right.asNullish())
					) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
				};

				const handleAbstractEqualityComparison = eql => {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					res.setRange(expr.range);

					const leftConst = left.isCompileTimeValue();
					const rightConst = right.isCompileTimeValue();

					if (leftConst && rightConst) {
						return res
							.setBoolean(
								eql ===
									// eslint-disable-next-line eqeqeq
									(left.asCompileTimeValue() == right.asCompileTimeValue())
							)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}

					if (left.isArray() && right.isArray()) {
						return res
							.setBoolean(!eql)
							.setSideEffects(
								left.couldHaveSideEffects() || right.couldHaveSideEffects()
							);
					}
					if (left.isTemplateString() && right.isTemplateString()) {
						return handleTemplateStringCompare(left, right, res, eql);
					}
				};

				if (expr.operator === "+") {
					const left = this.evaluateExpression(expr.left);
					if (!left) return;
					const right = this.evaluateExpression(expr.right);
					if (!right) return;
					const res = new BasicEvaluatedExpression();
					if (left.isString()) {
						if (right.isString()) {
							res.setString(left.string + right.string);
						} else if (right.isNumber()) {
							res.setString(left.string + right.number);
						} else if (
							right.isWrapped() &&
							right.prefix &&
							right.prefix.isString()
						) {
							// "left" + ("prefix" + inner + "postfix")
							// => ("leftPrefix" + inner + "postfix")
							res.setWrapped(
								new BasicEvaluatedExpression()
									.setString(left.string + right.prefix.string)
									.setRange(joinRanges(left.range, right.prefix.range)),
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// "left" + ([null] + inner + "postfix")
							// => ("left" + inner + "postfix")
							res.setWrapped(
								left,
								right.postfix,
								right.wrappedInnerExpressions
							);
						} else {
							// "left" + expr
							// => ("left" + expr + "")
							res.setWrapped(left, null, [right]);
						}
					} else if (left.isNumber()) {
						if (right.isString()) {
							res.setString(left.number + right.string);
						} else if (right.isNumber()) {
							res.setNumber(left.number + right.number);
						} else {
							return;
						}
					} else if (left.isBigInt()) {
						if (right.isBigInt()) {
							res.setBigInt(left.bigint + right.bigint);
						}
					} else if (left.isWrapped()) {
						if (left.postfix && left.postfix.isString() && right.isString()) {
							// ("prefix" + inner + "postfix") + "right"
							// => ("prefix" + inner + "postfixRight")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.string)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (
							left.postfix &&
							left.postfix.isString() &&
							right.isNumber()
						) {
							// ("prefix" + inner + "postfix") + 123
							// => ("prefix" + inner + "postfix123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(left.postfix.string + right.number)
									.setRange(joinRanges(left.postfix.range, right.range)),
								left.wrappedInnerExpressions
							);
						} else if (right.isString()) {
							// ("prefix" + inner + [null]) + "right"
							// => ("prefix" + inner + "right")
							res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
						} else if (right.isNumber()) {
							// ("prefix" + inner + [null]) + 123
							// => ("prefix" + inner + "123")
							res.setWrapped(
								left.prefix,
								new BasicEvaluatedExpression()
									.setString(right.number + "")
									.setRange(right.range),
								left.wrappedInnerExpressions
							);
						} else if (right.isWrapped()) {
							// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
							// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
							res.setWrapped(
								left.prefix,
								right.postfix,
								left.wrappedInnerExpressions &&
									right.wrappedInnerExpressions &&
									left.wrappedInnerExpressions
										.concat(left.postfix ? [left.postfix] : [])
										.concat(right.prefix ? [right.prefix] : [])
										.concat(right.wrappedInnerExpressions)
							);
						} else {
							// ("prefix" + inner + postfix) + expr
							// => ("prefix" + inner + postfix + expr + [null])
							res.setWrapped(
								left.prefix,
								null,
								left.wrappedInnerExpressions &&
									left.wrappedInnerExpressions.concat(
										left.postfix ? [left.postfix, right] : [right]
									)
							);
						}
					} else {
						if (right.isString()) {
							// left + "right"
							// => ([null] + left + "right")
							res.setWrapped(null, right, [left]);
						} else if (right.isWrapped()) {
							// left + (prefix + inner + "postfix")
							// => ([null] + left + prefix + inner + "postfix")
							res.setWrapped(
								null,
								right.postfix,
								right.wrappedInnerExpressions &&
									(right.prefix ? [left, right.prefix] : [left]).concat(
										right.wrappedInnerExpressions
									)
							);
						} else {
							return;
						}
					}
					if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
						res.setSideEffects();
					res.setRange(expr.range);
					return res;
				} else if (expr.operator === "-") {
					return handleConstOperation((l, r) => l - r);
				} else if (expr.operator === "*") {
					return handleConstOperation((l, r) => l * r);
				} else if (expr.operator === "/") {
					return handleConstOperation((l, r) => l / r);
				} else if (expr.operator === "**") {
					return handleConstOperation((l, r) => l ** r);
				} else if (expr.operator === "===") {
					return handleStrictEqualityComparison(true);
				} else if (expr.operator === "==") {
					return handleAbstractEqualityComparison(true);
				} else if (expr.operator === "!==") {
					return handleStrictEqualityComparison(false);
				} else if (expr.operator === "!=") {
					return handleAbstractEqualityComparison(false);
				} else if (expr.operator === "&") {
					return handleConstOperation((l, r) => l & r);
				} else if (expr.operator === "|") {
					return handleConstOperation((l, r) => l | r);
				} else if (expr.operator === "^") {
					return handleConstOperation((l, r) => l ^ r);
				} else if (expr.operator === ">>>") {
					return handleConstOperation((l, r) => l >>> r);
				} else if (expr.operator === ">>") {
					return handleConstOperation((l, r) => l >> r);
				} else if (expr.operator === "<<") {
					return handleConstOperation((l, r) => l << r);
				} else if (expr.operator === "<") {
					return handleConstOperation((l, r) => l < r);
				} else if (expr.operator === ">") {
					return handleConstOperation((l, r) => l > r);
				} else if (expr.operator === "<=") {
					return handleConstOperation((l, r) => l <= r);
				} else if (expr.operator === ">=") {
					return handleConstOperation((l, r) => l >= r);
				}
			});
		this.hooks.evaluate
			.for("UnaryExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {UnaryExpressionNode} */ (_expr);

				const handleConstOperation = fn => {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument || !argument.isCompileTimeValue()) return;
					const result = fn(argument.asCompileTimeValue());
					return valueAsExpression(
						result,
						expr,
						argument.couldHaveSideEffects()
					);
				};

				if (expr.operator === "typeof") {
					switch (expr.argument.type) {
						case "Identifier": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								expr.argument.name,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MetaProperty": {
							const res = this.callHooksForName(
								this.hooks.evaluateTypeof,
								getRootName(expr.argument),
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "MemberExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "ChainExpression": {
							const res = this.callHooksForExpression(
								this.hooks.evaluateTypeof,
								expr.argument.expression,
								expr
							);
							if (res !== undefined) return res;
							break;
						}
						case "FunctionExpression": {
							return new BasicEvaluatedExpression()
								.setString("function")
								.setRange(expr.range);
						}
					}
					const arg = this.evaluateExpression(expr.argument);
					if (arg.isUnknown()) return;
					if (arg.isString()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setRange(expr.range);
					}
					if (arg.isWrapped()) {
						return new BasicEvaluatedExpression()
							.setString("string")
							.setSideEffects()
							.setRange(expr.range);
					}
					if (arg.isUndefined()) {
						return new BasicEvaluatedExpression()
							.setString("undefined")
							.setRange(expr.range);
					}
					if (arg.isNumber()) {
						return new BasicEvaluatedExpression()
							.setString("number")
							.setRange(expr.range);
					}
					if (arg.isBigInt()) {
						return new BasicEvaluatedExpression()
							.setString("bigint")
							.setRange(expr.range);
					}
					if (arg.isBoolean()) {
						return new BasicEvaluatedExpression()
							.setString("boolean")
							.setRange(expr.range);
					}
					if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setRange(expr.range);
					}
					if (arg.isArray()) {
						return new BasicEvaluatedExpression()
							.setString("object")
							.setSideEffects(arg.couldHaveSideEffects())
							.setRange(expr.range);
					}
				} else if (expr.operator === "!") {
					const argument = this.evaluateExpression(expr.argument);
					if (!argument) return;
					const bool = argument.asBool();
					if (typeof bool !== "boolean") return;
					return new BasicEvaluatedExpression()
						.setBoolean(!bool)
						.setSideEffects(argument.couldHaveSideEffects())
						.setRange(expr.range);
				} else if (expr.operator === "~") {
					return handleConstOperation(v => ~v);
				} else if (expr.operator === "+") {
					return handleConstOperation(v => +v);
				} else if (expr.operator === "-") {
					return handleConstOperation(v => -v);
				}
			});
		this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("JavascriptParser", expr => {
			if (/** @type {IdentifierNode} */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(expr.range);
			}
		});
		/**
		 * @param {string} exprType expression type name
		 * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {ExpressionNode | undefined} */
			let cachedExpression = undefined;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo = undefined;
			this.hooks.evaluate.for(exprType).tap("JavascriptParser", expr => {
				const expression = /** @type {MemberExpressionNode} */ (expr);

				const info = getInfo(expr);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: "JavascriptParser", stage: 100 }, expr => {
					const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(
								info.name,
								info.rootInfo,
								info.getMembers,
								info.getMembersOptionals
							)
							.setRange(expr.range);
					}
				});
			this.hooks.finish.tap("JavascriptParser", () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(
				/** @type {IdentifierNode} */ (expr).name
			);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => []
				};
			}
		});
		this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", expr => {
			const metaProperty = /** @type {MetaPropertyNode} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				getRootName(expr),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpressionNode} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", _expr => {
			const expr = /** @type {CallExpressionNode} */ (_expr);
			if (
				expr.callee.type !== "MemberExpression" ||
				expr.callee.property.type !==
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				return;
			}

			// type Super also possible here
			const param = this.evaluateExpression(
				/** @type {ExpressionNode} */ (expr.callee.object)
			);
			if (!param) return;
			const property =
				expr.callee.property.type === "Literal"
					? `${expr.callee.property.value}`
					: expr.callee.property.name;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== undefined) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = arg1Eval.string;

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = param.string.indexOf(arg1Value, arg2Eval.number);
				} else {
					result = param.string.indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				const arg2Value = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1Value, arg2Value))
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		["substr", "substring", "slice"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("JavascriptParser", (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(expr.range);
				});
		});

		/**
		 * @param {"cooked" | "raw"} kind kind of values to get
		 * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate
			.for("TemplateLiteral")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TemplateLiteralNode} */ (_node);

				const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
				if (parts.length === 1) {
					return parts[0].setRange(node.range);
				}
				return new BasicEvaluatedExpression()
					.setTemplateString(quasis, parts, "cooked")
					.setRange(node.range);
			});
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap("JavascriptParser", _node => {
				const node = /** @type {TaggedTemplateExpressionNode} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts } = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(node.range);
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								param.couldHaveSideEffects()
						)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("JavascriptParser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ConditionalExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ConditionalExpressionNode} */ (_expr);

				const condition = this.evaluateExpression(expr.test);
				const conditionValue = condition.asBool();
				let res;
				if (conditionValue === undefined) {
					const consequent = this.evaluateExpression(expr.consequent);
					const alternate = this.evaluateExpression(expr.alternate);
					if (!consequent || !alternate) return;
					res = new BasicEvaluatedExpression();
					if (consequent.isConditional()) {
						res.setOptions(consequent.options);
					} else {
						res.setOptions([consequent]);
					}
					if (alternate.isConditional()) {
						res.addOptions(alternate.options);
					} else {
						res.addOptions([alternate]);
					}
				} else {
					res = this.evaluateExpression(
						conditionValue ? expr.consequent : expr.alternate
					);
					if (condition.couldHaveSideEffects()) res.setSideEffects();
				}
				res.setRange(expr.range);
				return res;
			});
		this.hooks.evaluate
			.for("ArrayExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ArrayExpressionNode} */ (_expr);

				const items = expr.elements.map(element => {
					return (
						element !== null &&
						element.type !== "SpreadElement" &&
						this.evaluateExpression(element)
					);
				});
				if (!items.every(Boolean)) return;
				return new BasicEvaluatedExpression()
					.setItems(items)
					.setRange(expr.range);
			});
		this.hooks.evaluate
			.for("ChainExpression")
			.tap("JavascriptParser", _expr => {
				const expr = /** @type {ChainExpressionNode} */ (_expr);
				/** @type {ExpressionNode[]} */
				const optionalExpressionsStack = [];
				/** @type {ExpressionNode|SuperNode} */
				let next = expr.expression;

				while (
					next.type === "MemberExpression" ||
					next.type === "CallExpression"
				) {
					if (next.type === "MemberExpression") {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.object)
							);
						}
						next = next.object;
					} else {
						if (next.optional) {
							// SuperNode can not be optional
							optionalExpressionsStack.push(
								/** @type {ExpressionNode} */ (next.callee)
							);
						}
						next = next.callee;
					}
				}

				while (optionalExpressionsStack.length > 0) {
					const expression = optionalExpressionsStack.pop();
					const evaluated = this.evaluateExpression(expression);

					if (evaluated && evaluated.asNullish()) {
						return evaluated.setRange(_expr.range);
					}
				}
				return this.evaluateExpression(expr.expression);
			});
	}

	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result && result.isIdentifier()) {
			return result.identifier;
		}
	}

diff --git a/a.js b/b.js
@@ -3187,17 +3176,15 @@ enterAssignmentPattern(pattern, onIdent) {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f

	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	}

	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	}

	/**
	 * @param {ExpressionNode} expression expression node
	 * @returns {BasicEvaluatedExpression | undefined} evaluation result
	 */
	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result !== undefined) {
					if (result) {
						result.setExpression(expression);
					}
					return result;
				}
			}
		} catch (e) {
diff --git a/a.js b/b.js
@@ -3368,6 +3355,10 @@ parse(source, state) {
A blob:56591d5013c7ee0cfbe46cf46049fe464ade257f
	/**
	 * @param {string | Buffer | PreparsedAst} source the source to parse
	 * @param {ParserState} state the parser state
	 * @returns {ParserState} the parser state
	 */
	parse(source, state) {
		let ast;
		let comments;
		const semicolons = new Set();
		if (source === null) {
			throw new Error("source must not be null");
		}
		if (Buffer.isBuffer(source)) {
			source = source.toString("utf-8");
		}
		if (typeof source === "object") {
			ast = /** @type {ProgramNode} */ (source);
			comments = source.comments;
		} else {
			comments = [];
			ast = JavascriptParser._parse(source, {
				sourceType: this.sourceType,
				onComment: comments,
				onInsertedSemicolon: pos => semicolons.add(pos)
			});
		}

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		const oldSemicolons = this.semicolons;
		const oldStatementPath = this.statementPath;
		const oldPrevStatement = this.prevStatement;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			isStrict: false,
			isAsmJs: false,
			definitions: new StackedMap()
		};
		/** @type {ParserState} */
		this.state = state;
		this.comments = comments;
		this.semicolons = semicolons;
		this.statementPath = [];
		this.prevStatement = undefined;
		if (this.hooks.program.call(ast, comments) === undefined) {
			this.detectMode(ast.body);
			this.preWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.blockPreWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.walkStatements(ast.body);
		}
		this.hooks.finish.call(ast, comments);
		this.scope = oldScope;
		/** @type {ParserState} */
		this.state = oldState;
		this.comments = oldComments;
		this.semicolons = oldSemicolons;
		this.statementPath = oldStatementPath;
		this.prevStatement = oldPrevStatement;
		return state;
	}

	evaluate(source) {
		const ast = JavascriptParser._parse("(" + source + ")", {
			sourceType: this.sourceType,
			locations: false
diff --git a/a.js b/b.js
@@ -14,6 +14,7 @@
A blob:1bda47fae4126fedd1790ced2876a34edbda66d4
const { isSubset } = require("../util/SetHelpers");
const { getAllChunks } = require("./ChunkHelpers");

/** @typedef {import("../util/Hash")} Hash */
/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../ChunkGraph")} ChunkGraph */
/** @typedef {import("../ChunkGroup")} ChunkGroup */
/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */
/** @typedef {(string|number)[]} EntryItem */

diff --git a/a.js b/b.js
@@ -23,7 +24,7 @@
A blob:1bda47fae4126fedd1790ced2876a34edbda66d4
/** @typedef {(string|number)[]} EntryItem */

const EXPORT_PREFIX = "var __webpack_exports__ = ";

/**
 * @param {ChunkGraph} chunkGraph chunkGraph
 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
 * @param {import("../ChunkGraph").EntryModuleWithChunkGroup[]} entries entries
 * @param {Chunk} chunk chunk
 * @param {boolean} passive true: passive startup with on chunks loaded
 * @returns {string} runtime code
 */
diff --git a/a.js b/b.js
@@ -101,7 +102,7 @@
A blob:1bda47fae4126fedd1790ced2876a34edbda66d4
	runtime.push("");
	return Template.asString(runtime);
};

/**
 * @param {Hash} hash the hash to update
 * @param {ChunkGraph} chunkGraph chunkGraph
 * @param {import("../ChunkGraph").EntryModuleWithChunkGroup[]} entries entries
 * @param {Chunk} chunk chunk
 * @returns {void}
 */
exports.updateHashForEntryStartup = (hash, chunkGraph, entries, chunk) => {
diff --git a/a.js b/b.js
@@ -222,9 +222,15 @@ render(source, { chunk }, { options, compilation }) {
A blob:f9e3d82d3872d2481a1ebd245c35e4a10d1698e4
	 * @param {Source} source source
	 * @param {RenderContext} renderContext render context
	 * @param {LibraryContext<T>} libraryContext context
	 * @returns {Source} source with library export
	 */
	render(source, { chunk }, { options, compilation }) {
		const fullNameResolved = this._getResolvedFullName(
			options,
			chunk,
			compilation
		);
		if (this.declare) {
			const base = fullNameResolved[0];
			if (!isNameValid(base)) {
				throw new Error(
					`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(
						base
					)}) or use a different library type (e. g. 'type: "global"', which assign a property on the global scope instead of declaring a variable). ${
						AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE
					}`
				);
			}
			source = new ConcatSource(`${this.declare} ${base};\n`, source);
		}
		return source;
	}

	/**
	 * @param {Module} module the exporting entry module
	 * @param {RenderContext} renderContext render context
	 * @param {LibraryContext<T>} libraryContext context
	 * @returns {string | undefined} bailout reason
	 */
	embedInRuntimeBailout(module, { chunk }, { options, compilation }) {
		const topLevelDeclarations =
			module.buildInfo && module.buildInfo.topLevelDeclarations;
		if (!topLevelDeclarations)
			return "it doesn't tell about top level declarations.";
		const fullNameResolved = this._getResolvedFullName(
			options,
diff --git a/a.js b/b.js
@@ -54,6 +54,7 @@
A blob:5c4a1f4bfd985bf7634ab5e8f4e473454ca12b55
	"timers",
	"timers/promises",
	"tls",
	"trace_events",
	"tty",
	"url",
	"util",
	"v8",
	"vm",
	"wasi",
	"worker_threads",
diff --git a/a.js b/b.js
@@ -822,10 +822,6 @@ build(options, compilation, resolver, fs, callback) {
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {function(WebpackError=): void} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		const { rootModule } = this;
		this.buildInfo = {
			strict: true,
			cacheable: true,
			moduleArgument: rootModule.buildInfo.moduleArgument,
			exportsArgument: rootModule.buildInfo.exportsArgument,
			fileDependencies: new LazySet(),
			contextDependencies: new LazySet(),
			missingDependencies: new LazySet(),
			topLevelDeclarations: new Set(),
			assets: undefined
		};
		this.buildMeta = rootModule.buildMeta;
		this.clearDependenciesAndBlocks();
		this.clearWarningsAndErrors();

		for (const m of this._modules) {
			// populate cacheable
			if (!m.buildInfo.cacheable) {
				this.buildInfo.cacheable = false;
			}

			// populate dependencies
			for (const d of m.dependencies.filter(
				dep =>
					!(dep instanceof HarmonyImportDependency) ||
					!this._modules.has(compilation.moduleGraph.getModule(dep))
			)) {
				this.dependencies.push(d);
			}
			// populate blocks
			for (const d of m.blocks) {
				this.blocks.push(d);
			}

			// populate warnings
			const warnings = m.getWarnings();
			if (warnings !== undefined) {
				for (const warning of warnings) {
					this.addWarning(warning);
				}
			}

			// populate errors
			const errors = m.getErrors();
			if (errors !== undefined) {
				for (const error of errors) {
					this.addError(error);
				}
			}

			// populate topLevelDeclarations
			if (m.buildInfo.topLevelDeclarations) {
				const topLevelDeclarations = this.buildInfo.topLevelDeclarations;
				if (topLevelDeclarations !== undefined) {
					for (const decl of m.buildInfo.topLevelDeclarations) {
						// reserved names will always be renamed
						if (RESERVED_NAMES.has(decl)) continue;
						// TODO actually this is incorrect since with renaming there could be more
						// We should do the renaming during build
						topLevelDeclarations.add(decl);
					}
				}
			} else {
diff --git a/a.js b/b.js
@@ -1113,6 +1109,8 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
diff --git a/a.js b/b.js
@@ -1257,6 +1255,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
diff --git a/a.js b/b.js
@@ -1283,6 +1282,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
diff --git a/a.js b/b.js
@@ -1300,6 +1300,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
						namespaceObjectName = info.internalNames.get(
							info.namespaceExportSymbol
						);
					} else {
						namespaceObjectName = this.findNewName(
							"namespaceObject",
							allUsedNames,
							namespaceObjectUsedNames,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(namespaceObjectName);
					}
					info.namespaceObjectName = namespaceObjectName;
					break;
				}
				case "external": {
					const externalName = this.findNewName(
diff --git a/a.js b/b.js
@@ -1311,6 +1312,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
						namespaceObjectName = info.internalNames.get(
							info.namespaceExportSymbol
						);
					} else {
						namespaceObjectName = this.findNewName(
							"namespaceObject",
							allUsedNames,
							namespaceObjectUsedNames,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(namespaceObjectName);
					}
					info.namespaceObjectName = namespaceObjectName;
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						namespaceObjectUsedNames,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					break;
				}
			}
			if (info.module.buildMeta.exportsType !== "namespace") {
diff --git a/a.js b/b.js
@@ -1323,6 +1325,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
						namespaceObjectName = info.internalNames.get(
							info.namespaceExportSymbol
						);
					} else {
						namespaceObjectName = this.findNewName(
							"namespaceObject",
							allUsedNames,
							namespaceObjectUsedNames,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(namespaceObjectName);
					}
					info.namespaceObjectName = namespaceObjectName;
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						namespaceObjectUsedNames,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					break;
				}
			}
			if (info.module.buildMeta.exportsType !== "namespace") {
				const externalNameInterop = this.findNewName(
					"namespaceObject",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObjectName = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "default" &&
				info.module.buildMeta.defaultObject !== "redirect"
diff --git a/a.js b/b.js
@@ -1336,6 +1339,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
						namespaceObjectName = info.internalNames.get(
							info.namespaceExportSymbol
						);
					} else {
						namespaceObjectName = this.findNewName(
							"namespaceObject",
							allUsedNames,
							namespaceObjectUsedNames,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(namespaceObjectName);
					}
					info.namespaceObjectName = namespaceObjectName;
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						namespaceObjectUsedNames,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					break;
				}
			}
			if (info.module.buildMeta.exportsType !== "namespace") {
				const externalNameInterop = this.findNewName(
					"namespaceObject",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObjectName = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "default" &&
				info.module.buildMeta.defaultObject !== "redirect"
			) {
				const externalNameInterop = this.findNewName(
					"namespaceObject2",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObject2Name = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "dynamic" ||
				!info.module.buildMeta.exportsType
diff --git a/a.js b/b.js
@@ -1349,6 +1353,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
						namespaceObjectName = info.internalNames.get(
							info.namespaceExportSymbol
						);
					} else {
						namespaceObjectName = this.findNewName(
							"namespaceObject",
							allUsedNames,
							namespaceObjectUsedNames,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(namespaceObjectName);
					}
					info.namespaceObjectName = namespaceObjectName;
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						namespaceObjectUsedNames,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					break;
				}
			}
			if (info.module.buildMeta.exportsType !== "namespace") {
				const externalNameInterop = this.findNewName(
					"namespaceObject",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObjectName = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "default" &&
				info.module.buildMeta.defaultObject !== "redirect"
			) {
				const externalNameInterop = this.findNewName(
					"namespaceObject2",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObject2Name = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "dynamic" ||
				!info.module.buildMeta.exportsType
			) {
				const externalNameInterop = this.findNewName(
					"default",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopDefaultAccessName = externalNameInterop;
			}
		}

		// Find and replace references to modules
diff --git a/a.js b/b.js
@@ -1618,6 +1623,7 @@ codeGeneration({
A blob:4692b28e9888d9a749dbba3084a8b8ed4351be97

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime: generationRuntime,
		codeGenerationResults
	}) {
		/** @type {Set<string>} */
		const runtimeRequirements = new Set();
		const runtime = intersectRuntime(generationRuntime, this._runtime);

		const requestShortener = runtimeTemplate.requestShortener;
		// Meta info for each module
		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
			moduleGraph,
			runtime
		);

		// Set with modules that need a generated namespace object
		/** @type {Set<ConcatenatedModuleInfo>} */
		const neededNamespaceObjects = new Set();

		// Generate source code and analyse scopes
		// Prepare a ReplaceSource for the final source
		for (const info of moduleToInfoMap.values()) {
			this._analyseModule(
				moduleToInfoMap,
				info,
				dependencyTemplates,
				runtimeTemplate,
				moduleGraph,
				chunkGraph,
				runtime,
				codeGenerationResults
			);
		}

		// List of all used names to avoid conflicts
		const allUsedNames = new Set(RESERVED_NAMES);

		// List of additional names in scope for module references
		/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */
		const usedNamesInScopeInfo = new Map();
		/**
		 * @param {string} module module identifier
		 * @param {string} id export id
		 * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info
		 */
		const getUsedNamesInScopeInfo = (module, id) => {
			const key = `${module}-${id}`;
			let info = usedNamesInScopeInfo.get(key);
			if (info === undefined) {
				info = {
					usedNames: new Set(),
					alreadyCheckedScopes: new Set()
				};
				usedNamesInScopeInfo.set(key, info);
			}
			return info;
		};

		// Set of already checked scopes
		const ignoredScopes = new Set();

		// get all global names
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				// ignore symbols from moduleScope
				if (info.moduleScope) {
					ignoredScopes.add(info.moduleScope);
				}

				// The super class expression in class scopes behaves weird
				// We get ranges of all super class expressions to make
				// renaming to work correctly
				const superClassCache = new WeakMap();
				const getSuperClassExpressions = scope => {
					const cacheEntry = superClassCache.get(scope);
					if (cacheEntry !== undefined) return cacheEntry;
					const superClassExpressions = [];
					for (const childScope of scope.childScopes) {
						if (childScope.type !== "class") continue;
						const block = childScope.block;
						if (
							(block.type === "ClassDeclaration" ||
								block.type === "ClassExpression") &&
							block.superClass
						) {
							superClassExpressions.push({
								range: block.superClass.range,
								variables: childScope.variables
							});
						}
					}
					superClassCache.set(scope, superClassExpressions);
					return superClassExpressions;
				};

				// add global symbols
				if (info.globalScope) {
					for (const reference of info.globalScope.through) {
						const name = reference.identifier.name;
						if (ConcatenationScope.isModuleReference(name)) {
							const match = ConcatenationScope.matchModuleReference(name);
							if (!match) continue;
							const referencedInfo = modulesWithInfo[match.index];
							if (referencedInfo.type === "reference")
								throw new Error("Module reference can't point to a reference");
							const binding = getFinalBinding(
								moduleGraph,
								referencedInfo,
								match.ids,
								moduleToInfoMap,
								runtime,
								requestShortener,
								runtimeTemplate,
								neededNamespaceObjects,
								false,
								info.module.buildMeta.strictHarmonyModule,
								true
							);
							if (!binding.ids) continue;
							const { usedNames, alreadyCheckedScopes } =
								getUsedNamesInScopeInfo(
									binding.info.module.identifier(),
									"name" in binding ? binding.name : ""
								);
							for (const expr of getSuperClassExpressions(reference.from)) {
								if (
									expr.range[0] <= reference.identifier.range[0] &&
									expr.range[1] >= reference.identifier.range[1]
								) {
									for (const variable of expr.variables) {
										usedNames.add(variable.name);
									}
								}
							}
							addScopeSymbols(
								reference.from,
								usedNames,
								alreadyCheckedScopes,
								ignoredScopes
							);
						} else {
							allUsedNames.add(name);
						}
					}
				}
			}
		}

		// generate names for symbols
		for (const info of moduleToInfoMap.values()) {
			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
				info.module.identifier(),
				""
			);
			switch (info.type) {
				case "concatenated": {
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
							info.module.identifier(),
							name
						);
						if (allUsedNames.has(name) || usedNames.has(name)) {
							const references = getAllReferences(variable);
							for (const ref of references) {
								addScopeSymbols(
									ref.from,
									usedNames,
									alreadyCheckedScopes,
									ignoredScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								usedNames,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (path && path.length > 1) {
									const maybeProperty =
										path[1].type === "AssignmentPattern" &&
										path[1].left === path[0]
											? path[2]
											: path[1];
									if (
										maybeProperty.type === "Property" &&
										maybeProperty.shorthand
									) {
										source.insert(r[1], `: ${newName}`);
										continue;
									}
								}
								source.replace(r[0], r[1] - 1, newName);
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					let namespaceObjectName;
					if (info.namespaceExportSymbol) {
						namespaceObjectName = info.internalNames.get(
							info.namespaceExportSymbol
						);
					} else {
						namespaceObjectName = this.findNewName(
							"namespaceObject",
							allUsedNames,
							namespaceObjectUsedNames,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(namespaceObjectName);
					}
					info.namespaceObjectName = namespaceObjectName;
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						namespaceObjectUsedNames,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					break;
				}
			}
			if (info.module.buildMeta.exportsType !== "namespace") {
				const externalNameInterop = this.findNewName(
					"namespaceObject",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObjectName = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "default" &&
				info.module.buildMeta.defaultObject !== "redirect"
			) {
				const externalNameInterop = this.findNewName(
					"namespaceObject2",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopNamespaceObject2Name = externalNameInterop;
			}
			if (
				info.module.buildMeta.exportsType === "dynamic" ||
				!info.module.buildMeta.exportsType
			) {
				const externalNameInterop = this.findNewName(
					"default",
					allUsedNames,
					namespaceObjectUsedNames,
					info.module.readableIdentifier(requestShortener)
				);
				allUsedNames.add(externalNameInterop);
				info.interopDefaultAccessName = externalNameInterop;
			}
		}

		// Find and replace references to modules
		for (const info of moduleToInfoMap.values()) {
			if (info.type === "concatenated") {
				for (const reference of info.globalScope.through) {
					const name = reference.identifier.name;
					const match = ConcatenationScope.matchModuleReference(name);
					if (match) {
						const referencedInfo = modulesWithInfo[match.index];
						if (referencedInfo.type === "reference")
							throw new Error("Module reference can't point to a reference");
						const finalName = getFinalName(
							moduleGraph,
							referencedInfo,
							match.ids,
							moduleToInfoMap,
							runtime,
							requestShortener,
							runtimeTemplate,
							neededNamespaceObjects,
							match.call,
							!match.directImport,
							info.module.buildMeta.strictHarmonyModule,
							match.asiSafe
						);
						const r = reference.identifier.range;
						const source = info.source;
						// range is extended by 2 chars to cover the appended "._"
						source.replace(r[0], r[1] + 1, finalName);
					}
				}
			}
		}

		// Map with all root exposed used exports
		/** @type {Map<string, function(RequestShortener): string>} */
		const exportsMap = new Map();

		// Set with all root exposed unused exports
		/** @type {Set<string>} */
		const unusedExports = new Set();

		const rootInfo = /** @type {ConcatenatedModuleInfo} */ (
			moduleToInfoMap.get(this.rootModule)
		);
		const strictHarmonyModule = rootInfo.module.buildMeta.strictHarmonyModule;
		const exportsInfo = moduleGraph.getExportsInfo(rootInfo.module);
		for (const exportInfo of exportsInfo.orderedExports) {
			const name = exportInfo.name;
			if (exportInfo.provided === false) continue;
			const used = exportInfo.getUsedName(undefined, runtime);
			if (!used) {
				unusedExports.add(name);
				continue;
			}
			exportsMap.set(used, requestShortener => {
				try {
					const finalName = getFinalName(
						moduleGraph,
						rootInfo,
						[name],
						moduleToInfoMap,
						runtime,
						requestShortener,
						runtimeTemplate,
						neededNamespaceObjects,
						false,
						false,
						strictHarmonyModule,
						true
					);
					return `/* ${
						exportInfo.isReexport() ? "reexport" : "binding"
					} */ ${finalName}`;
				} catch (e) {
					e.message += `\nwhile generating the root export '${name}' (used name: '${used}')`;
					throw e;
				}
			});
		}

		const result = new ConcatSource();

		// add harmony compatibility flag (must be first because of possible circular dependencies)
		if (
			moduleGraph.getExportsInfo(this).otherExportsInfo.getUsed(runtime) !==
			UsageState.Unused
		) {
			result.add(`// ESM COMPAT FLAG\n`);
			result.add(
				runtimeTemplate.defineEsModuleFlagStatement({
					exportsArgument: this.exportsArgument,
					runtimeRequirements
				})
			);
		}

		// define exports
		if (exportsMap.size > 0) {
			runtimeRequirements.add(RuntimeGlobals.exports);
			runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
			const definitions = [];
			for (const [key, value] of exportsMap) {
				definitions.push(
					`\n  ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(
						value(requestShortener)
					)}`
				);
			}
			result.add(`\n// EXPORTS\n`);
			result.add(
				`${RuntimeGlobals.definePropertyGetters}(${
					this.exportsArgument
				}, {${definitions.join(",")}\n});\n`
			);
		}

		// list unused exports
		if (unusedExports.size > 0) {
			result.add(
				`\n// UNUSED EXPORTS: ${joinIterableWithComma(unusedExports)}\n`
			);
		}

		// generate namespace objects
		const namespaceObjectSources = new Map();
		for (const info of neededNamespaceObjects) {
			if (info.namespaceExportSymbol) continue;
			const nsObj = [];
			const exportsInfo = moduleGraph.getExportsInfo(info.module);
			for (const exportInfo of exportsInfo.orderedExports) {
				if (exportInfo.provided === false) continue;
				const usedName = exportInfo.getUsedName(undefined, runtime);
				if (usedName) {
					const finalName = getFinalName(
						moduleGraph,
						info,
						[exportInfo.name],
						moduleToInfoMap,
						runtime,
						requestShortener,
						runtimeTemplate,
						neededNamespaceObjects,
						false,
						undefined,
						info.module.buildMeta.strictHarmonyModule,
						true
					);
					nsObj.push(
						`\n  ${JSON.stringify(
							usedName
						)}: ${runtimeTemplate.returningFunction(finalName)}`
					);
				}
			}
			const name = info.namespaceObjectName;
			const defineGetters =
				nsObj.length > 0
					? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(
							","
					  )}\n});\n`
					: "";
			if (nsObj.length > 0)
				runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
			namespaceObjectSources.set(
				info,
				`
// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}
var ${name} = {};
${RuntimeGlobals.makeNamespaceObject}(${name});
${defineGetters}`
			);
			runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);
		}

		// define required namespace objects (must be before evaluation modules)
		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				const source = namespaceObjectSources.get(info);
				if (!source) continue;
				result.add(source);
			}
		}

		const chunkInitFragments = [];

		// evaluate modules in order
		for (const rawInfo of modulesWithInfo) {
			let name;
			let isConditional = false;
			const info = rawInfo.type === "reference" ? rawInfo.target : rawInfo;
			switch (info.type) {
				case "concatenated": {
					result.add(
						`\n;// CONCATENATED MODULE: ${info.module.readableIdentifier(
							requestShortener
						)}\n`
					);
					result.add(info.source);
					if (info.chunkInitFragments) {
						for (const f of info.chunkInitFragments) chunkInitFragments.push(f);
					}
					if (info.runtimeRequirements) {
						for (const r of info.runtimeRequirements) {
							runtimeRequirements.add(r);
						}
					}
					name = info.namespaceObjectName;
					break;
				}
				case "external": {
					result.add(
						`\n// EXTERNAL MODULE: ${info.module.readableIdentifier(
							requestShortener
						)}\n`
					);
					runtimeRequirements.add(RuntimeGlobals.require);
					const { runtimeCondition } =
						/** @type {ExternalModuleInfo | ReferenceToModuleInfo} */ (rawInfo);
					const condition = runtimeTemplate.runtimeConditionExpression({
						chunkGraph,
						runtimeCondition,
						runtime,
						runtimeRequirements
					});
					if (condition !== "true") {
						isConditional = true;
						result.add(`if (${condition}) {\n`);
					}
					result.add(
						`var ${info.name} = __webpack_require__(${JSON.stringify(
							chunkGraph.getModuleId(info.module)
						)});`
					);
					name = info.name;
					break;
				}
				default:
					// @ts-expect-error never is expected here
					throw new Error(`Unsupported concatenation entry type ${info.type}`);
			}
			if (info.interopNamespaceObjectUsed) {
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				result.add(
					`\nvar ${info.interopNamespaceObjectName} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name}, 2);`
				);
			}
			if (info.interopNamespaceObject2Used) {
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				result.add(
					`\nvar ${info.interopNamespaceObject2Name} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name});`
				);
			}
			if (info.interopDefaultAccessUsed) {
				runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);
				result.add(
					`\nvar ${info.interopDefaultAccessName} = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${name});`
				);
			}
			if (isConditional) {
				result.add("\n}");
			}
		}

		const data = new Map();
		if (chunkInitFragments.length > 0)
			data.set("chunkInitFragments", chunkInitFragments);

		/** @type {CodeGenerationResult} */
		const resultEntry = {
			sources: new Map([["javascript", new CachedSource(result)]]),
diff --git a/a.js b/b.js
@@ -5,6 +5,7 @@
A blob:e2c3aa9c27fa511c991c40d9a95e41914a547dc8
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { extname, basename } = require("path");
const { URL } = require("url");
const { createGunzip, createBrotliDecompress, createInflate } = require("zlib");
const NormalModule = require("../NormalModule");
diff --git a/a.js b/b.js
@@ -19,6 +20,44 @@
A blob:e2c3aa9c27fa511c991c40d9a95e41914a547dc8
const memoize = require("../util/memoize");

/** @typedef {import("../../declarations/plugins/schemes/HttpUriPlugin").HttpUriPluginOptions} HttpUriPluginOptions */
/** @typedef {import("../Compiler")} Compiler */

const getHttp = memoize(() => require("http"));
const getHttps = memoize(() => require("https"));

/** @type {(() => void)[] | undefined} */
let inProgressWrite = undefined;

diff --git a/a.js b/b.js
@@ -274,6 +313,7 @@ constructor(options) {
A blob:e2c3aa9c27fa511c991c40d9a95e41914a547dc8

class HttpUriPlugin {
	/**
	 * @param {HttpUriPluginOptions} options options
	 */
	constructor(options) {
		validate(options);
		this._lockfileLocation = options.lockfileLocation;
		this._cacheLocation = options.cacheLocation;
		this._upgrade = options.upgrade;
		this._frozen = options.frozen;
		this._allowedUris = options.allowedUris;
	}

	/**
	 * Apply the plugin
diff --git a/a.js b/b.js
@@ -282,15 +322,16 @@ constructor(options) {
A blob:e2c3aa9c27fa511c991c40d9a95e41914a547dc8

class HttpUriPlugin {
	/**
	 * @param {HttpUriPluginOptions} options options
	 */
	constructor(options) {
		validate(options);
		this._lockfileLocation = options.lockfileLocation;
		this._cacheLocation = options.cacheLocation;
		this._upgrade = options.upgrade;
		this._frozen = options.frozen;
		this._allowedUris = options.allowedUris;
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const schemes = [
			{
				scheme: "http",
				fetch: (url, options, callback) => getHttp().get(url, options, callback)
			},
			{
				scheme: "https",
				fetch: (url, options, callback) =>
					getHttps().get(url, options, callback)
			}
		];
		let lockfileCache;
		compiler.hooks.compilation.tap(
diff --git a/a.js b/b.js
@@ -509,7 +550,7 @@ apply(compiler) {
A blob:e2c3aa9c27fa511c991c40d9a95e41914a547dc8
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const schemes = [
			{
				scheme: "http",
				fetch: (url, options, callback) => getHttp().get(url, options, callback)
			},
			{
				scheme: "https",
				fetch: (url, options, callback) =>
					getHttps().get(url, options, callback)
			}
		];
		let lockfileCache;
		compiler.hooks.compilation.tap(
			"HttpUriPlugin",
			(compilation, { normalModuleFactory }) => {
				const intermediateFs = compiler.intermediateFileSystem;
				const fs = compilation.inputFileSystem;
				const cache = compilation.getCache("webpack.HttpUriPlugin");
				const logger = compilation.getLogger("webpack.HttpUriPlugin");
				const lockfileLocation =
					this._lockfileLocation ||
					join(
						intermediateFs,
						compiler.context,
						compiler.name
							? `${toSafePath(compiler.name)}.webpack.lock`
							: "webpack.lock"
					);
				const cacheLocation =
					this._cacheLocation !== undefined
						? this._cacheLocation
						: lockfileLocation + ".data";
				const upgrade = this._upgrade || false;
				const frozen = this._frozen || false;
				const hashFunction = "sha512";
				const hashDigest = "hex";
				const hashDigestLength = 20;
				const allowedUris = this._allowedUris;

				let warnedAboutEol = false;

				const cacheKeyCache = new Map();
				/**
				 * @param {string} url the url
				 * @returns {string} the key
				 */
				const getCacheKey = url => {
					const cachedResult = cacheKeyCache.get(url);
					if (cachedResult !== undefined) return cachedResult;
					const result = _getCacheKey(url);
					cacheKeyCache.set(url, result);
					return result;
				};

				/**
				 * @param {string} url the url
				 * @returns {string} the key
				 */
				const _getCacheKey = url => {
					const parsedUrl = new URL(url);
					const folder = toSafePath(parsedUrl.origin);
					const name = toSafePath(parsedUrl.pathname);
					const query = toSafePath(parsedUrl.search);
					let ext = extname(name);
					if (ext.length > 20) ext = "";
					const basename = ext ? name.slice(0, -ext.length) : name;
					const hash = createHash(hashFunction);
					hash.update(url);
					const digest = hash.digest(hashDigest).slice(0, hashDigestLength);
					return `${folder.slice(-50)}/${`${basename}${
						query ? `_${query}` : ""
					}`.slice(0, 150)}_${digest}${ext}`;
				};

				const getLockfile = cachedWithoutKey(
					/**
					 * @param {function((Error | null)=, Lockfile=): void} callback callback
					 * @returns {void}
					 */
					callback => {
						const readLockfile = () => {
							intermediateFs.readFile(lockfileLocation, (err, buffer) => {
								if (err && err.code !== "ENOENT") {
									compilation.missingDependencies.add(lockfileLocation);
									return callback(err);
								}
								compilation.fileDependencies.add(lockfileLocation);
								compilation.fileSystemInfo.createSnapshot(
									compiler.fsStartTime,
									buffer ? [lockfileLocation] : [],
									[],
									buffer ? [] : [lockfileLocation],
									{ timestamp: true },
									(err, snapshot) => {
										if (err) return callback(err);
										const lockfile = buffer
											? Lockfile.parse(buffer.toString("utf-8"))
											: new Lockfile();
										lockfileCache = {
											lockfile,
											snapshot
										};
										callback(null, lockfile);
									}
								);
							});
						};
						if (lockfileCache) {
							compilation.fileSystemInfo.checkSnapshotValid(
								lockfileCache.snapshot,
								(err, valid) => {
									if (err) return callback(err);
									if (!valid) return readLockfile();
									callback(null, lockfileCache.lockfile);
								}
							);
						} else {
							readLockfile();
						}
					}
				);

				/** @type {Map<string, LockfileEntry | "ignore" | "no-cache"> | undefined} */
				let lockfileUpdates = undefined;
				const storeLockEntry = (lockfile, url, entry) => {
					const oldEntry = lockfile.entries.get(url);
					if (lockfileUpdates === undefined) lockfileUpdates = new Map();
					lockfileUpdates.set(url, entry);
					lockfile.entries.set(url, entry);
					if (!oldEntry) {
						logger.log(`${url} added to lockfile`);
					} else if (typeof oldEntry === "string") {
						if (typeof entry === "string") {
							logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);
						} else {
							logger.log(
								`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`
							);
						}
					} else if (typeof entry === "string") {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`
						);
					} else if (oldEntry.resolved !== entry.resolved) {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`
						);
					} else if (oldEntry.integrity !== entry.integrity) {
						logger.log(`${url} updated in lockfile: content changed`);
					} else if (oldEntry.contentType !== entry.contentType) {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`
						);
					} else {
						logger.log(`${url} updated in lockfile`);
					}
				};

				const storeResult = (lockfile, url, result, callback) => {
					if (result.storeLock) {
						storeLockEntry(lockfile, url, result.entry);
						if (!cacheLocation || !result.content)
							return callback(null, result);
						const key = getCacheKey(result.entry.resolved);
						const filePath = join(intermediateFs, cacheLocation, key);
						mkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {
							if (err) return callback(err);
							intermediateFs.writeFile(filePath, result.content, err => {
								if (err) return callback(err);
								callback(null, result);
							});
						});
					} else {
						storeLockEntry(lockfile, url, "no-cache");
						callback(null, result);
					}
				};

				for (const { scheme, fetch } of schemes) {
					/**
					 *
					 * @param {string} url URL
					 * @param {string} integrity integrity
					 * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback
					 */
					const resolveContent = (url, integrity, callback) => {
						const handleResult = (err, result) => {
							if (err) return callback(err);
							if ("location" in result) {
								return resolveContent(
									result.location,
									integrity,
									(err, innerResult) => {
										if (err) return callback(err);
										callback(null, {
											entry: innerResult.entry,
											content: innerResult.content,
											storeLock: innerResult.storeLock && result.storeLock
										});
									}
								);
							} else {
								if (
									!result.fresh &&
									integrity &&
									result.entry.integrity !== integrity &&
									!verifyIntegrity(result.content, integrity)
								) {
									return fetchContent.force(url, handleResult);
								}
								return callback(null, {
									entry: result.entry,
									content: result.content,
									storeLock: result.storeLock
								});
							}
						};
						fetchContent(url, handleResult);
					};

					/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */
					/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */
					/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */
					/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */

					/**
					 * @param {string} url URL
					 * @param {FetchResult} cachedResult result from cache
					 * @param {function((Error | null)=, FetchResult=): void} callback callback
					 * @returns {void}
					 */
					const fetchContentRaw = (url, cachedResult, callback) => {
diff --git a/a.js b/b.js
@@ -603,9 +644,30 @@ apply(compiler) {
A blob:e2c3aa9c27fa511c991c40d9a95e41914a547dc8
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const schemes = [
			{
				scheme: "http",
				fetch: (url, options, callback) => getHttp().get(url, options, callback)
			},
			{
				scheme: "https",
				fetch: (url, options, callback) =>
					getHttps().get(url, options, callback)
			}
		];
		let lockfileCache;
		compiler.hooks.compilation.tap(
			"HttpUriPlugin",
			(compilation, { normalModuleFactory }) => {
				const intermediateFs = compiler.intermediateFileSystem;
				const fs = compilation.inputFileSystem;
				const cache = compilation.getCache("webpack.HttpUriPlugin");
				const logger = compilation.getLogger("webpack.HttpUriPlugin");
				const lockfileLocation =
					this._lockfileLocation ||
					join(
						intermediateFs,
						compiler.context,
						compiler.name
							? `${toSafePath(compiler.name)}.webpack.lock`
							: "webpack.lock"
					);
				const cacheLocation =
					this._cacheLocation !== undefined
						? this._cacheLocation
						: lockfileLocation + ".data";
				const upgrade = this._upgrade || false;
				const frozen = this._frozen || false;
				const hashFunction = "sha512";
				const hashDigest = "hex";
				const hashDigestLength = 20;
				const allowedUris = this._allowedUris;

				let warnedAboutEol = false;

				const cacheKeyCache = new Map();
				/**
				 * @param {string} url the url
				 * @returns {string} the key
				 */
				const getCacheKey = url => {
					const cachedResult = cacheKeyCache.get(url);
					if (cachedResult !== undefined) return cachedResult;
					const result = _getCacheKey(url);
					cacheKeyCache.set(url, result);
					return result;
				};

				/**
				 * @param {string} url the url
				 * @returns {string} the key
				 */
				const _getCacheKey = url => {
					const parsedUrl = new URL(url);
					const folder = toSafePath(parsedUrl.origin);
					const name = toSafePath(parsedUrl.pathname);
					const query = toSafePath(parsedUrl.search);
					let ext = extname(name);
					if (ext.length > 20) ext = "";
					const basename = ext ? name.slice(0, -ext.length) : name;
					const hash = createHash(hashFunction);
					hash.update(url);
					const digest = hash.digest(hashDigest).slice(0, hashDigestLength);
					return `${folder.slice(-50)}/${`${basename}${
						query ? `_${query}` : ""
					}`.slice(0, 150)}_${digest}${ext}`;
				};

				const getLockfile = cachedWithoutKey(
					/**
					 * @param {function((Error | null)=, Lockfile=): void} callback callback
					 * @returns {void}
					 */
					callback => {
						const readLockfile = () => {
							intermediateFs.readFile(lockfileLocation, (err, buffer) => {
								if (err && err.code !== "ENOENT") {
									compilation.missingDependencies.add(lockfileLocation);
									return callback(err);
								}
								compilation.fileDependencies.add(lockfileLocation);
								compilation.fileSystemInfo.createSnapshot(
									compiler.fsStartTime,
									buffer ? [lockfileLocation] : [],
									[],
									buffer ? [] : [lockfileLocation],
									{ timestamp: true },
									(err, snapshot) => {
										if (err) return callback(err);
										const lockfile = buffer
											? Lockfile.parse(buffer.toString("utf-8"))
											: new Lockfile();
										lockfileCache = {
											lockfile,
											snapshot
										};
										callback(null, lockfile);
									}
								);
							});
						};
						if (lockfileCache) {
							compilation.fileSystemInfo.checkSnapshotValid(
								lockfileCache.snapshot,
								(err, valid) => {
									if (err) return callback(err);
									if (!valid) return readLockfile();
									callback(null, lockfileCache.lockfile);
								}
							);
						} else {
							readLockfile();
						}
					}
				);

				/** @type {Map<string, LockfileEntry | "ignore" | "no-cache"> | undefined} */
				let lockfileUpdates = undefined;
				const storeLockEntry = (lockfile, url, entry) => {
					const oldEntry = lockfile.entries.get(url);
					if (lockfileUpdates === undefined) lockfileUpdates = new Map();
					lockfileUpdates.set(url, entry);
					lockfile.entries.set(url, entry);
					if (!oldEntry) {
						logger.log(`${url} added to lockfile`);
					} else if (typeof oldEntry === "string") {
						if (typeof entry === "string") {
							logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);
						} else {
							logger.log(
								`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`
							);
						}
					} else if (typeof entry === "string") {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`
						);
					} else if (oldEntry.resolved !== entry.resolved) {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`
						);
					} else if (oldEntry.integrity !== entry.integrity) {
						logger.log(`${url} updated in lockfile: content changed`);
					} else if (oldEntry.contentType !== entry.contentType) {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`
						);
					} else {
						logger.log(`${url} updated in lockfile`);
					}
				};

				const storeResult = (lockfile, url, result, callback) => {
					if (result.storeLock) {
						storeLockEntry(lockfile, url, result.entry);
						if (!cacheLocation || !result.content)
							return callback(null, result);
						const key = getCacheKey(result.entry.resolved);
						const filePath = join(intermediateFs, cacheLocation, key);
						mkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {
							if (err) return callback(err);
							intermediateFs.writeFile(filePath, result.content, err => {
								if (err) return callback(err);
								callback(null, result);
							});
						});
					} else {
						storeLockEntry(lockfile, url, "no-cache");
						callback(null, result);
					}
				};

				for (const { scheme, fetch } of schemes) {
					/**
					 *
					 * @param {string} url URL
					 * @param {string} integrity integrity
					 * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback
					 */
					const resolveContent = (url, integrity, callback) => {
						const handleResult = (err, result) => {
							if (err) return callback(err);
							if ("location" in result) {
								return resolveContent(
									result.location,
									integrity,
									(err, innerResult) => {
										if (err) return callback(err);
										callback(null, {
											entry: innerResult.entry,
											content: innerResult.content,
											storeLock: innerResult.storeLock && result.storeLock
										});
									}
								);
							} else {
								if (
									!result.fresh &&
									integrity &&
									result.entry.integrity !== integrity &&
									!verifyIntegrity(result.content, integrity)
								) {
									return fetchContent.force(url, handleResult);
								}
								return callback(null, {
									entry: result.entry,
									content: result.content,
									storeLock: result.storeLock
								});
							}
						};
						fetchContent(url, handleResult);
					};

					/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */
					/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */
					/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */
					/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */

					/**
					 * @param {string} url URL
					 * @param {FetchResult} cachedResult result from cache
					 * @param {function((Error | null)=, FetchResult=): void} callback callback
					 * @returns {void}
					 */
					const fetchContentRaw = (url, cachedResult, callback) => {
						const requestTime = Date.now();
						fetch(
							new URL(url),
							{
								headers: {
									"accept-encoding": "gzip, deflate, br",
									"user-agent": "webpack",
									"if-none-match": cachedResult
										? cachedResult.etag || null
										: null
								}
							},
							res => {
								const etag = res.headers["etag"];
								const location = res.headers["location"];
								const cacheControl = res.headers["cache-control"];
								const { storeLock, storeCache, validUntil } = parseCacheControl(
									cacheControl,
									requestTime
								);
								/**
								 * @param {Partial<Pick<FetchResultMeta, "fresh">> & (Pick<RedirectFetchResult, "location"> | Pick<ContentFetchResult, "content" | "entry">)} partialResult result
								 * @returns {void}
								 */
								const finishWith = partialResult => {
									if ("location" in partialResult) {
										logger.debug(
											`GET ${url} [${res.statusCode}] -> ${partialResult.location}`
										);
									} else {
										logger.debug(
											`GET ${url} [${res.statusCode}] ${Math.ceil(
												partialResult.content.length / 1024
											)} kB${!storeLock ? " no-cache" : ""}`
										);
									}
									const result = {
										...partialResult,
										fresh: true,
										storeLock,
										storeCache,
										validUntil,
										etag
									};
									if (!storeCache) {
										logger.log(
											`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`
										);
										return callback(null, result);
									}
									cache.store(
										url,
										null,
										{
											...result,
											fresh: false
										},
										err => {
											if (err) {
												logger.warn(
													`${url} can't be stored in cache: ${err.message}`
												);
												logger.debug(err.stack);
											}
											callback(null, result);
										}
									);
								};
								if (res.statusCode === 304) {
									if (
										cachedResult.validUntil < validUntil ||
										cachedResult.storeLock !== storeLock ||
										cachedResult.storeCache !== storeCache ||
										cachedResult.etag !== etag
									) {
										return finishWith(cachedResult);
									} else {
										logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);
										return callback(null, {
											...cachedResult,
											fresh: true
										});
									}
								}
								if (
									location &&
									res.statusCode >= 301 &&
									res.statusCode <= 308
								) {
									return finishWith({
										location: new URL(location, url).href
									});
								}
								const contentType = res.headers["content-type"] || "";
								const bufferArr = [];

diff --git a/a.js b/b.js
@@ -40,6 +40,8 @@
A blob:fb14a2708ae5e28b7d67c808dff167edf1ff6653
Buffer -> n bytes
Section -> Buffer

*/

// "wpc" + 1 in little-endian
const VERSION = 0x01637077;

/**
 * @param {Buffer[]} buffers buffers
 * @param {string | Hash} hashFunction hash function to use
diff --git a/a.js b/b.js
@@ -87,7 +89,7 @@ const hashForName = (buffers, hashFunction) => {
A blob:fb14a2708ae5e28b7d67c808dff167edf1ff6653
/**
 * @param {Buffer[]} buffers buffers
 * @param {string | Hash} hashFunction hash function to use
 * @returns {string} hash
 */
const hashForName = (buffers, hashFunction) => {
	const hash = createHash(hashFunction);
	for (const buf of buffers) hash.update(buf);
	return /** @type {string} */ (hash.digest("hex"));
};

const COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;
const DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;

const writeUInt64LE = Buffer.prototype.writeBigUInt64LE
	? (buf, value, offset) => {
			buf.writeBigUInt64LE(BigInt(value), offset);
	  }
	: (buf, value, offset) => {
			const low = value % 0x100000000;
			const high = (value - low) / 0x100000000;
			buf.writeUInt32LE(low, offset);
			buf.writeUInt32LE(high, offset + 4);
	  };

const readUInt64LE = Buffer.prototype.readBigUInt64LE
	? (buf, offset) => {
			return Number(buf.readBigUInt64LE(offset));
	  }
	: (buf, offset) => {
			const low = buf.readUInt32LE(offset);
			const high = buf.readUInt32LE(offset + 4);
			return high * 0x100000000 + low;
	  };

/**
 * @typedef {Object} SerializeResult
 * @property {string | false} name
 * @property {number} size
 * @property {Promise=} backgroundJob
 */

/**
 * @param {FileMiddleware} middleware this
 * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized
 * @param {string | boolean} name file base name
 * @param {function(string | false, Buffer[]): Promise<void>} writeFile writes a file
 * @param {string | Hash} hashFunction hash function to use
 * @returns {Promise<SerializeResult>} resulting file pointer and promise
 */
const serialize = async (
diff --git a/a.js b/b.js
@@ -212,9 +214,9 @@ const hashForName = (buffers, hashFunction) => {
A blob:fb14a2708ae5e28b7d67c808dff167edf1ff6653
/**
 * @param {Buffer[]} buffers buffers
 * @param {string | Hash} hashFunction hash function to use
 * @returns {string} hash
 */
const hashForName = (buffers, hashFunction) => {
	const hash = createHash(hashFunction);
	for (const buf of buffers) hash.update(buf);
	return /** @type {string} */ (hash.digest("hex"));
};

const COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;
const DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;

const writeUInt64LE = Buffer.prototype.writeBigUInt64LE
	? (buf, value, offset) => {
			buf.writeBigUInt64LE(BigInt(value), offset);
	  }
	: (buf, value, offset) => {
			const low = value % 0x100000000;
			const high = (value - low) / 0x100000000;
			buf.writeUInt32LE(low, offset);
			buf.writeUInt32LE(high, offset + 4);
	  };

const readUInt64LE = Buffer.prototype.readBigUInt64LE
	? (buf, offset) => {
			return Number(buf.readBigUInt64LE(offset));
	  }
	: (buf, offset) => {
			const low = buf.readUInt32LE(offset);
			const high = buf.readUInt32LE(offset + 4);
			return high * 0x100000000 + low;
	  };

/**
 * @typedef {Object} SerializeResult
 * @property {string | false} name
 * @property {number} size
 * @property {Promise=} backgroundJob
 */

/**
 * @param {FileMiddleware} middleware this
 * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized
 * @param {string | boolean} name file base name
 * @param {function(string | false, Buffer[]): Promise<void>} writeFile writes a file
 * @param {string | Hash} hashFunction hash function to use
 * @returns {Promise<SerializeResult>} resulting file pointer and promise
 */
const serialize = async (
	middleware,
	data,
	name,
	writeFile,
	hashFunction = "md4"
) => {
	/** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */
	const processedData = [];
	/** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */
	const resultToLazy = new WeakMap();
	/** @type {Buffer[]} */
	let lastBuffers = undefined;
	for (const item of await data) {
		if (typeof item === "function") {
			if (!SerializerMiddleware.isLazy(item))
				throw new Error("Unexpected function");
			if (!SerializerMiddleware.isLazy(item, middleware)) {
				throw new Error(
					"Unexpected lazy value with non-this target (can't pass through lazy values)"
				);
			}
			lastBuffers = undefined;
			const serializedInfo = SerializerMiddleware.getLazySerializedValue(item);
			if (serializedInfo) {
				if (typeof serializedInfo === "function") {
					throw new Error(
						"Unexpected lazy value with non-this target (can't pass through lazy values)"
					);
				} else {
					processedData.push(serializedInfo);
				}
			} else {
				const content = item();
				if (content) {
					const options = SerializerMiddleware.getLazyOptions(item);
					processedData.push(
						serialize(
							middleware,
							content,
							(options && options.name) || true,
							writeFile,
							hashFunction
						).then(result => {
							/** @type {any} */ (item).options.size = result.size;
							resultToLazy.set(result, item);
							return result;
						})
					);
				} else {
					throw new Error(
						"Unexpected falsy value returned by lazy value function"
					);
				}
			}
		} else if (item) {
			if (lastBuffers) {
				lastBuffers.push(item);
			} else {
				lastBuffers = [item];
				processedData.push(lastBuffers);
			}
		} else {
			throw new Error("Unexpected falsy value in items array");
		}
	}
	/** @type {Promise<any>[]} */
	const backgroundJobs = [];
	const resolvedData = (
		await Promise.all(
			/** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */ (
				processedData
			)
		)
	).map(item => {
		if (Array.isArray(item) || Buffer.isBuffer(item)) return item;

		backgroundJobs.push(item.backgroundJob);
		// create pointer buffer from size and name
		const name = /** @type {string} */ (item.name);
		const nameBuffer = Buffer.from(name);
		const buf = Buffer.allocUnsafe(8 + nameBuffer.length);
		writeUInt64LE(buf, item.size, 0);
		nameBuffer.copy(buf, 8, 0);
		const lazy = resultToLazy.get(item);
		SerializerMiddleware.setLazySerializedValue(lazy, buf);
		return buf;
	});
	const lengths = [];
	for (const item of resolvedData) {
		if (Array.isArray(item)) {
			let l = 0;
			for (const b of item) l += b.length;
			while (l > 0x7fffffff) {
				lengths.push(0x7fffffff);
				l -= 0x7fffffff;
			}
			lengths.push(l);
		} else if (item) {
			lengths.push(-item.length);
		} else {
			throw new Error("Unexpected falsy value in resolved data " + item);
		}
	}
	const header = Buffer.allocUnsafe(8 + lengths.length * 4);
	header.writeUInt32LE(VERSION, 0);
	header.writeUInt32LE(lengths.length, 4);
	for (let i = 0; i < lengths.length; i++) {
		header.writeInt32LE(lengths[i], 8 + i * 4);
	}
	const buf = [header];
	for (const item of resolvedData) {
		if (Array.isArray(item)) {
			for (const b of item) buf.push(b);
		} else if (item) {
			buf.push(item);
		}
	}
	if (name === true) {
		name = hashForName(buf, hashFunction);
	}
	backgroundJobs.push(writeFile(name, buf));
	let size = 0;
	for (const b of buf) size += b.length;
	return {
		size,
		name,
		backgroundJob:
diff --git a/a.js b/b.js
@@ -422,7 +424,7 @@ serialize(data, context) {
A blob:fb14a2708ae5e28b7d67c808dff167edf1ff6653
	/**
	 * @param {DeserializedType} data data
	 * @param {Object} context context object
	 * @returns {SerializedType|Promise<SerializedType>} serialized data
	 */
	serialize(data, context) {
		const { filename, extension = "" } = context;
		return new Promise((resolve, reject) => {
			mkdirp(this.fs, dirname(this.fs, filename), err => {
				if (err) return reject(err);

				// It's important that we don't touch existing files during serialization
				// because serialize may read existing files (when deserializing)
				const allWrittenFiles = new Set();
				const writeFile = async (name, content) => {
					const file = name
						? join(this.fs, filename, `../${name}${extension}`)
						: filename;
					await new Promise((resolve, reject) => {
diff --git a/a.js b/b.js
@@ -441,10 +443,7 @@ serialize(data, context) {
A blob:fb14a2708ae5e28b7d67c808dff167edf1ff6653
	/**
	 * @param {DeserializedType} data data
	 * @param {Object} context context object
	 * @returns {SerializedType|Promise<SerializedType>} serialized data
	 */
	serialize(data, context) {
		const { filename, extension = "" } = context;
		return new Promise((resolve, reject) => {
			mkdirp(this.fs, dirname(this.fs, filename), err => {
				if (err) return reject(err);

				// It's important that we don't touch existing files during serialization
				// because serialize may read existing files (when deserializing)
				const allWrittenFiles = new Set();
				const writeFile = async (name, content) => {
					const file = name
						? join(this.fs, filename, `../${name}${extension}`)
						: filename;
					await new Promise((resolve, reject) => {
						let stream = this.fs.createWriteStream(file + "_");
						let compression;
						if (file.endsWith(".gz")) {
							compression = createGzip({
								chunkSize: COMPRESSION_CHUNK_SIZE,
								level: zConstants.Z_BEST_SPEED
							});
						} else if (file.endsWith(".br")) {
							compression = createBrotliCompress({
								chunkSize: COMPRESSION_CHUNK_SIZE,
								params: {
									[zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,
									[zConstants.BROTLI_PARAM_QUALITY]: 2,
									[zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,
									[zConstants.BROTLI_PARAM_SIZE_HINT]: content.reduce(
										(size, b) => size + b.length,
										0
									)
								}
							});
						}
						if (compression) {
diff --git a/a.js b/b.js
@@ -456,8 +455,44 @@ serialize(data, context) {
A blob:fb14a2708ae5e28b7d67c808dff167edf1ff6653
	/**
	 * @param {DeserializedType} data data
	 * @param {Object} context context object
	 * @returns {SerializedType|Promise<SerializedType>} serialized data
	 */
	serialize(data, context) {
		const { filename, extension = "" } = context;
		return new Promise((resolve, reject) => {
			mkdirp(this.fs, dirname(this.fs, filename), err => {
				if (err) return reject(err);

				// It's important that we don't touch existing files during serialization
				// because serialize may read existing files (when deserializing)
				const allWrittenFiles = new Set();
				const writeFile = async (name, content) => {
					const file = name
						? join(this.fs, filename, `../${name}${extension}`)
						: filename;
					await new Promise((resolve, reject) => {
						let stream = this.fs.createWriteStream(file + "_");
						let compression;
						if (file.endsWith(".gz")) {
							compression = createGzip({
								chunkSize: COMPRESSION_CHUNK_SIZE,
								level: zConstants.Z_BEST_SPEED
							});
						} else if (file.endsWith(".br")) {
							compression = createBrotliCompress({
								chunkSize: COMPRESSION_CHUNK_SIZE,
								params: {
									[zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,
									[zConstants.BROTLI_PARAM_QUALITY]: 2,
									[zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,
									[zConstants.BROTLI_PARAM_SIZE_HINT]: content.reduce(
										(size, b) => size + b.length,
										0
									)
								}
							});
						}
						if (compression) {
							pipeline(compression, stream, reject);
							stream = compression;
							stream.on("finish", () => resolve());
						} else {
							stream.on("error", err => reject(err));
							stream.on("finish", () => resolve());
						}
						for (const b of content) stream.write(b);
						stream.end();
					});
					if (name) allWrittenFiles.add(file);
				};

diff --git a/a.js b/b.js
@@ -18,7 +18,7 @@ const toSimpleString = str => {
A blob:49d5d6fa6977f3f8f107c419e33c0270a0198f06

const quoteMeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

const toSimpleString = str => {
	if (`${+str}` === str) {
		return str;
	}
	return JSON.stringify(str);
};

/**
 * @param {Record<string|number, boolean>} map value map
 * @returns {true|false|function(string): string} true/false, when unconditionally true/false, or a template function to determine the value at runtime
 */
const compileBooleanMatcher = map => {
	const positiveItems = Object.keys(map).filter(i => map[i]);
	const negativeItems = Object.keys(map).filter(i => !map[i]);
diff --git a/a.js b/b.js
@@ -498,7 +498,7 @@ module.exports = ({ maxSize, minSize, items, getSize, getKey }) => {
A blob:1b2a0899cbaf3f9d8707326bd9bb9d0f2984deb4
/**
 * @template T
 * @param {Options<T>} options options object
 * @returns {GroupedItems<T>[]} grouped items
 */
module.exports = ({ maxSize, minSize, items, getSize, getKey }) => {
	/** @type {Group<T>[]} */
	const result = [];

	const nodes = Array.from(
		items,
		item => new Node(item, getKey(item), getSize(item))
	);

	/** @type {Node<T>[]} */
	const initialNodes = [];

	// lexically ordering of keys
	nodes.sort((a, b) => {
		if (a.key < b.key) return -1;
		if (a.key > b.key) return 1;
		return 0;
	});

	// return nodes bigger than maxSize directly as group
	// But make sure that minSize is not violated
	for (const node of nodes) {
		if (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {
			result.push(new Group([node], []));
		} else {
			initialNodes.push(node);
		}
	}

	if (initialNodes.length > 0) {
		const initialGroup = new Group(initialNodes, getSimilarities(initialNodes));

		const removeProblematicNodes = (group, consideredSize = group.size) => {
			const problemTypes = getTooSmallTypes(consideredSize, minSize);
			if (problemTypes.size > 0) {
				// We hit an edge case where the working set is already smaller than minSize
				// We merge problematic nodes with the smallest result node to keep minSize intact
				const problemNodes = group.popNodes(
					n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0
				);
				if (problemNodes === undefined) return false;
				// Only merge it with result nodes that have the problematic size type
				const possibleResultGroups = result.filter(
					n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0
				);
				if (possibleResultGroups.length > 0) {
					const bestGroup = possibleResultGroups.reduce((min, group) => {
						const minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);
						const groupMatches = getNumberOfMatchingSizeTypes(
							group,
							problemTypes
						);
						if (minMatches !== groupMatches)
							return minMatches < groupMatches ? group : min;
						if (
							selectiveSizeSum(min.size, problemTypes) >
							selectiveSizeSum(group.size, problemTypes)
						)
							return group;
						return min;
					});
					for (const node of problemNodes) bestGroup.nodes.push(node);
					bestGroup.nodes.sort((a, b) => {
						if (a.key < b.key) return -1;
						if (a.key > b.key) return 1;
						return 0;
					});
				} else {
					// There are no other nodes with the same size types
					// We create a new group and have to accept that it's smaller than minSize
					result.push(new Group(problemNodes, null));
				}
				return true;
			} else {
				return false;
			}
		};

		if (initialGroup.nodes.length > 0) {
			const queue = [initialGroup];

			while (queue.length) {
				const group = queue.pop();
				// only groups bigger than maxSize need to be splitted
				if (!isTooBig(group.size, maxSize)) {
					result.push(group);
					continue;
				}
				// If the group is already too small
				// we try to work only with the unproblematic nodes
				if (removeProblematicNodes(group)) {
					// This changed something, so we try this group again
					queue.push(group);
					continue;
				}

				// find unsplittable area from left and right
				// going minSize from left and right
				// at least one node need to be included otherwise we get stuck
				let left = 1;
				let leftSize = Object.create(null);
				addSizeTo(leftSize, group.nodes[0].size);
				while (left < group.nodes.length && isTooSmall(leftSize, minSize)) {
					addSizeTo(leftSize, group.nodes[left].size);
					left++;
				}
				let right = group.nodes.length - 2;
				let rightSize = Object.create(null);
				addSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);
				while (right >= 0 && isTooSmall(rightSize, minSize)) {
					addSizeTo(rightSize, group.nodes[right].size);
					right--;
				}

				//      left v   v right
				// [ O O O ] O O O [ O O O ]
				// ^^^^^^^^^ leftSize
				//       rightSize ^^^^^^^^^
				// leftSize > minSize
				// rightSize > minSize

				// Perfect split: [ O O O ] [ O O O ]
				//                right === left - 1

				if (left - 1 > right) {
					// We try to remove some problematic nodes to "fix" that
					let prevSize;
					if (right < group.nodes.length - left) {
						subtractSizeFrom(rightSize, group.nodes[right + 1].size);
						prevSize = rightSize;
					} else {
						subtractSizeFrom(leftSize, group.nodes[left - 1].size);
						prevSize = leftSize;
					}
					if (removeProblematicNodes(group, prevSize)) {
						// This changed something, so we try this group again
						queue.push(group);
						continue;
					}
					// can't split group while holding minSize
					// because minSize is preferred of maxSize we return
					// the problematic nodes as result here even while it's too big
					// To avoid this make sure maxSize > minSize * 3
					result.push(group);
					continue;
				}
				if (left <= right) {
					// when there is a area between left and right
					// we look for best split point
					// we split at the minimum similarity
					// here key space is separated the most
					// But we also need to make sure to not create too small groups
					let best = -1;
					let bestSimilarity = Infinity;
					let pos = left;
					let rightSize = sumSize(group.nodes.slice(pos));

					//       pos v   v right
					// [ O O O ] O O O [ O O O ]
					// ^^^^^^^^^ leftSize
					// rightSize ^^^^^^^^^^^^^^^

					while (pos <= right + 1) {
						const similarity = group.similarities[pos - 1];
						if (
							similarity < bestSimilarity &&
							!isTooSmall(leftSize, minSize) &&
							!isTooSmall(rightSize, minSize)
						) {
							best = pos;
							bestSimilarity = similarity;
						}
						addSizeTo(leftSize, group.nodes[pos].size);
						subtractSizeFrom(rightSize, group.nodes[pos].size);
						pos++;
					}
					if (best < 0) {
						// This can't happen
						// but if that assumption is wrong
						// fallback to a big group
						result.push(group);
						continue;
					}
					left = best;
					right = best - 1;
				}

				// create two new groups for left and right area
				// and queue them up
				const rightNodes = [group.nodes[right + 1]];
				/** @type {number[]} */
				const rightSimilarities = [];
				for (let i = right + 2; i < group.nodes.length; i++) {
					rightSimilarities.push(group.similarities[i - 1]);
					rightNodes.push(group.nodes[i]);
				}
				queue.push(new Group(rightNodes, rightSimilarities));

				const leftNodes = [group.nodes[0]];
				/** @type {number[]} */
				const leftSimilarities = [];
				for (let i = 1; i < left; i++) {
					leftSimilarities.push(group.similarities[i - 1]);
					leftNodes.push(group.nodes[i]);
				}
				queue.push(new Group(leftNodes, leftSimilarities));
			}
		}
	}

	// lexically ordering
	result.sort((a, b) => {
		if (a.nodes[0].key < b.nodes[0].key) return -1;
		if (a.nodes[0].key > b.nodes[0].key) return 1;
		return 0;
	});

	// give every group a name
	const usedNames = new Set();
	for (let i = 0; i < result.length; i++) {
		const group = result[i];
		if (group.nodes.length === 1) {
			group.key = group.nodes[0].key;
		} else {
			const first = group.nodes[0];
			const last = group.nodes[group.nodes.length - 1];
			const name = getName(first.key, last.key, usedNames);
			group.key = name;
		}
	}

	// return the results
	return result.map(group => {
		/** @type {GroupedItems} */
		return {
			key: group.key,
			items: group.nodes.map(node => node.item),
			size: group.size
diff --git a/a.js b/b.js
@@ -81,7 +81,49 @@ const requestToAbsolute = (context, relativePath) => {
A blob:e6a0800581efcac6c500abc32c78639a7e2f6ebc
/**
 * @param {string} context context for relative path
 * @param {string} relativePath path
 * @returns {string} absolute path
 */
const requestToAbsolute = (context, relativePath) => {
	if (relativePath.startsWith("./") || relativePath.startsWith("../"))
		return path.join(context, relativePath);
	return relativePath;
};

const makeCacheable = fn => {
	/** @type {WeakMap<object, Map<string, Map<string, string>>>} */
	const cache = new WeakMap();

	/**
diff --git a/a.js b/b.js
@@ -215,7 +257,7 @@ const _makePathsRelative = (context, identifier) => {
A blob:e6a0800581efcac6c500abc32c78639a7e2f6ebc
 *
 * @param {string} context context for relative path
 * @param {string} identifier identifier for path
 * @returns {string} a converted relative path
 */
const _makePathsRelative = (context, identifier) => {
	return identifier
		.split(SEGMENTS_SPLIT_REGEXP)
		.map(str => absoluteToRequest(context, str))
		.join("");
};

exports.makePathsRelative = makeCacheable(_makePathsRelative);

/**
 *
 * @param {string} context context for relative path
diff --git a/a.js b/b.js
@@ -230,7 +272,7 @@ const _makePathsAbsolute = (context, identifier) => {
A blob:e6a0800581efcac6c500abc32c78639a7e2f6ebc
 *
 * @param {string} context context for relative path
 * @param {string} identifier identifier for path
 * @returns {string} a converted relative path
 */
const _makePathsAbsolute = (context, identifier) => {
	return identifier
		.split(SEGMENTS_SPLIT_REGEXP)
		.map(str => requestToAbsolute(context, str))
		.join("");
};

exports.makePathsAbsolute = makeCacheable(_makePathsAbsolute);

/**
 * @param {string} context absolute context path
 * @param {string} request any request string may containing absolute paths, query string, etc.
diff --git a/a.js b/b.js
@@ -244,7 +286,7 @@ const _contextify = (context, request) => {
A blob:e6a0800581efcac6c500abc32c78639a7e2f6ebc
/**
 * @param {string} context absolute context path
 * @param {string} request any request string may containing absolute paths, query string, etc.
 * @returns {string} a new request string avoiding absolute paths when possible
 */
const _contextify = (context, request) => {
	return request
		.split("!")
		.map(r => absoluteToRequest(context, r))
		.join("!");
};

const contextify = makeCacheable(_contextify);
exports.contextify = contextify;

/**
 * @param {string} context absolute context path
diff --git a/a.js b/b.js
@@ -259,13 +301,15 @@ const _absolutify = (context, request) => {
A blob:e6a0800581efcac6c500abc32c78639a7e2f6ebc
/**
 * @param {string} context absolute context path
 * @param {string} request any request string
 * @returns {string} a new request string using absolute paths when possible
 */
const _absolutify = (context, request) => {
	return request
		.split("!")
		.map(r => requestToAbsolute(context, r))
		.join("!");
};

const absolutify = makeCacheable(_absolutify);
exports.absolutify = absolutify;

const PATH_QUERY_FRAGMENT_REGEXP =
	/^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;

/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */

/**
 * @param {string} str the path with query and fragment
 * @returns {ParsedResource} parsed parts
diff --git a/a.js b/b.js
@@ -280,47 +324,24 @@ const _parseResource = str => {
A blob:e6a0800581efcac6c500abc32c78639a7e2f6ebc

/**
 * @param {string} str the path with query and fragment
 * @returns {ParsedResource} parsed parts
 */
const _parseResource = str => {
	const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
	return {
		resource: str,
		path: match[1].replace(/\0(.)/g, "$1"),
		query: match[2] ? match[2].replace(/\0(.)/g, "$1") : "",
		fragment: match[3] || ""
	};
};
exports.parseResource = (realFn => {
	/** @type {WeakMap<object, Map<string, ParsedResource>>} */
	const cache = new WeakMap();

	const getCache = associatedObjectForCache => {
		const entry = cache.get(associatedObjectForCache);
		if (entry !== undefined) return entry;
		/** @type {Map<string, ParsedResource>} */
		const map = new Map();
		cache.set(associatedObjectForCache, map);
		return map;
	};

	/**
	 * @param {string} str the path with query and fragment
	 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
	 * @returns {ParsedResource} parsed parts
	 */
	const fn = (str, associatedObjectForCache) => {
		if (!associatedObjectForCache) return realFn(str);
		const cache = getCache(associatedObjectForCache);
		const entry = cache.get(str);
		if (entry !== undefined) return entry;
		const result = realFn(str);
		cache.set(str, result);
		return result;
	};

	fn.bindCache = associatedObjectForCache => {
		const cache = getCache(associatedObjectForCache);
		return str => {
			const entry = cache.get(str);
			if (entry !== undefined) return entry;
			const result = realFn(str);
			cache.set(str, result);
			return result;
		};
	};

	return fn;
})(_parseResource);

/**
 * @param {string} filename the filename which should be undone
 * @param {string} outputPath the output path that is restored (only relevant when filename contains "..")
diff --git a/a.js b/b.js
@@ -17,6 +17,7 @@
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
const FakeDocument = require("./helpers/FakeDocument");
const CurrentScript = require("./helpers/CurrentScript");

const prepareOptions = require("./helpers/prepareOptions");
const { parseResource } = require("../lib/util/identifier");
const captureStdio = require("./helpers/captureStdio");
const asModule = require("./helpers/asModule");

const casesPath = path.join(__dirname, "configCases");
const categories = fs.readdirSync(casesPath).map(cat => {
	return {
diff --git a/a.js b/b.js
@@ -29,6 +30,25 @@
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
		tests: fs
			.readdirSync(path.join(casesPath, cat))
			.filter(folder => !folder.startsWith("_"))
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
diff --git a/a.js b/b.js
@@ -54,6 +74,7 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
diff --git a/a.js b/b.js
@@ -97,6 +118,10 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
diff --git a/a.js b/b.js
@@ -168,6 +193,7 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
diff --git a/a.js b/b.js
@@ -180,6 +206,26 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
diff --git a/a.js b/b.js
@@ -187,6 +233,7 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
							it(`${testName} should pre-compile to fill disk cache (2nd)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, (err, stats) => {
									deprecationTracker();
									if (err) return handleFatalError(err, done);
diff --git a/a.js b/b.js
@@ -228,6 +275,26 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
							it(`${testName} should pre-compile to fill disk cache (2nd)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, (err, stats) => {
									deprecationTracker();
									if (err) return handleFatalError(err, done);
									const { modules, children, errorsCount } = stats.toJson({
										all: false,
										modules: true,
										errorsCount: true
									});
									if (errorsCount === 0) {
										const infrastructureLogging = stderr.toString();
										if (infrastructureLogging) {
											return done(
												new Error(
													"Errors/Warnings during build:\n" +
														infrastructureLogging
												)
											);
										}
										const allModules = children
											? children.reduce(
													(all, { modules }) => all.concat(modules),
													modules || []
											  )
											: modules;
										if (
											allModules.some(
												m => m.type !== "cached modules" && !m.cached
											)
										) {
											return done(
												new Error(
													`Some modules were not cached:\n${stats.toString({
														all: false,
														modules: true,
														modulesSpace: 100
													})}`
												)
											);
										}
									}
									done();
								});
							}, 40000);
						}
diff --git a/a.js b/b.js
@@ -235,6 +302,7 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
							it(`${testName} should pre-compile to fill disk cache (2nd)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, (err, stats) => {
									deprecationTracker();
									if (err) return handleFatalError(err, done);
									const { modules, children, errorsCount } = stats.toJson({
										all: false,
										modules: true,
										errorsCount: true
									});
									if (errorsCount === 0) {
										const infrastructureLogging = stderr.toString();
										if (infrastructureLogging) {
											return done(
												new Error(
													"Errors/Warnings during build:\n" +
														infrastructureLogging
												)
											);
										}
										const allModules = children
											? children.reduce(
													(all, { modules }) => all.concat(modules),
													modules || []
											  )
											: modules;
										if (
											allModules.some(
												m => m.type !== "cached modules" && !m.cached
											)
										) {
											return done(
												new Error(
													`Some modules were not cached:\n${stats.toString({
														all: false,
														modules: true,
														modulesSpace: 100
													})}`
												)
											);
										}
									}
									done();
								});
							}, 40000);
						}
						it(`${testName} should compile`, done => {
							rimraf.sync(outputDirectory);
							fs.mkdirSync(outputDirectory, { recursive: true });
							const deprecationTracker = deprecationTracking.start();
							const onCompiled = (err, stats) => {
								const deprecations = deprecationTracker();
								if (err) return handleFatalError(err, done);
diff --git a/a.js b/b.js
@@ -298,6 +366,26 @@ describe(config.name, () => {
A blob:54732b0588a9b09d8f785e3cde6a4bb2fec1c471
			.sort()
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		jest.setTimeout(20000);

		for (const category of categories) {
			// eslint-disable-next-line no-loop-func
			describe(category.name, () => {
				for (const testName of category.tests) {
					// eslint-disable-next-line no-loop-func
					describe(testName, function () {
						const testDirectory = path.join(casesPath, category.name, testName);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)()) {
							describe.skip(testName, () => {
								it("filtered", () => {});
							});
							return;
						}
						const outBaseDir = path.join(__dirname, "js");
						const testSubPath = path.join(config.name, category.name, testName);
						const outputDirectory = path.join(outBaseDir, testSubPath);
						const cacheDirectory = path.join(outBaseDir, ".cache", testSubPath);
						let options, optionsArr, testConfig;
						beforeAll(() => {
							options = prepareOptions(
								require(path.join(testDirectory, "webpack.config.js")),
								{ testPath: outputDirectory }
							);
							optionsArr = [].concat(options);
							optionsArr.forEach((options, idx) => {
								if (!options.context) options.context = testDirectory;
								if (!options.mode) options.mode = "production";
								if (!options.optimization) options.optimization = {};
								if (options.optimization.minimize === undefined)
									options.optimization.minimize = false;
								if (options.optimization.minimizer === undefined) {
									options.optimization.minimizer = [
										new (require("terser-webpack-plugin"))({
											parallel: false
										})
									];
								}
								if (!options.entry) options.entry = "./index.js";
								if (!options.target) options.target = "async-node";
								if (!options.output) options.output = {};
								if (!options.output.path) options.output.path = outputDirectory;
								if (typeof options.output.pathinfo === "undefined")
									options.output.pathinfo = true;
								if (!options.output.filename)
									options.output.filename =
										"bundle" +
										idx +
										(options.experiments && options.experiments.outputModule
											? ".mjs"
											: ".js");
								if (config.cache) {
									options.cache = {
										cacheDirectory,
										name: `config-${idx}`,
										...config.cache
									};
								}
								if (!options.snapshot) options.snapshot = {};
								if (!options.snapshot.managedPaths) {
									options.snapshot.managedPaths = [
										path.resolve(__dirname, "../node_modules")
									];
								}
							});
							testConfig = {
								findBundle: function (i, options) {
									const ext = path.extname(
										parseResource(options.output.filename).path
									);
									if (
										fs.existsSync(
											path.join(options.output.path, "bundle" + i + ext)
										)
									) {
										return "./bundle" + i + ext;
									}
								},
								timeout: 30000
							};
							try {
								// try to load a test file
								testConfig = Object.assign(
									testConfig,
									require(path.join(testDirectory, "test.config.js"))
								);
							} catch (e) {
								// ignored
							}
							if (testConfig.timeout) setDefaultTimeout(testConfig.timeout);
						});
						afterAll(() => {
							// cleanup
							options = undefined;
							optionsArr = undefined;
							testConfig = undefined;
						});
						beforeAll(() => {
							rimraf.sync(cacheDirectory);
						});
						const handleFatalError = (err, done) => {
							const fakeStats = {
								errors: [
									{
										message: err.message,
										stack: err.stack
									}
								]
							};
							if (
								checkArrayExpectation(
									testDirectory,
									fakeStats,
									"error",
									"Error",
									done
								)
							) {
								return;
							}
							// Wait for uncaught errors to occur
							setTimeout(done, 200);
							return;
						};
						if (config.cache) {
							it(`${testName} should pre-compile to fill disk cache (1st)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, err => {
									deprecationTracker();
									const infrastructureLogging = stderr.toString();
									if (infrastructureLogging) {
										return done(
											new Error(
												"Errors/Warnings during build:\n" +
													infrastructureLogging
											)
										);
									}
									if (err) return handleFatalError(err, done);
									done();
								});
							}, 60000);
							it(`${testName} should pre-compile to fill disk cache (2nd)`, done => {
								rimraf.sync(outputDirectory);
								fs.mkdirSync(outputDirectory, { recursive: true });
								const deprecationTracker = deprecationTracking.start();
								require("..")(options, (err, stats) => {
									deprecationTracker();
									if (err) return handleFatalError(err, done);
									const { modules, children, errorsCount } = stats.toJson({
										all: false,
										modules: true,
										errorsCount: true
									});
									if (errorsCount === 0) {
										const infrastructureLogging = stderr.toString();
										if (infrastructureLogging) {
											return done(
												new Error(
													"Errors/Warnings during build:\n" +
														infrastructureLogging
												)
											);
										}
										const allModules = children
											? children.reduce(
													(all, { modules }) => all.concat(modules),
													modules || []
											  )
											: modules;
										if (
											allModules.some(
												m => m.type !== "cached modules" && !m.cached
											)
										) {
											return done(
												new Error(
													`Some modules were not cached:\n${stats.toString({
														all: false,
														modules: true,
														modulesSpace: 100
													})}`
												)
											);
										}
									}
									done();
								});
							}, 40000);
						}
						it(`${testName} should compile`, done => {
							rimraf.sync(outputDirectory);
							fs.mkdirSync(outputDirectory, { recursive: true });
							const deprecationTracker = deprecationTracking.start();
							const onCompiled = (err, stats) => {
								const deprecations = deprecationTracker();
								if (err) return handleFatalError(err, done);
								const statOptions = {
									preset: "verbose",
									colors: false
								};
								fs.mkdirSync(outputDirectory, { recursive: true });
								fs.writeFileSync(
									path.join(outputDirectory, "stats.txt"),
									stats.toString(statOptions),
									"utf-8"
								);
								const jsonStats = stats.toJson({
									errorDetails: true
								});
								fs.writeFileSync(
									path.join(outputDirectory, "stats.json"),
									JSON.stringify(jsonStats, null, 2),
									"utf-8"
								);
								if (
									checkArrayExpectation(
										testDirectory,
										jsonStats,
										"error",
										"Error",
										done
									)
								) {
									return;
								}
								if (
									checkArrayExpectation(
										testDirectory,
										jsonStats,
										"warning",
										"Warning",
										done
									)
								) {
									return;
								}
								const infrastructureLogging = stderr.toString();
								if (infrastructureLogging) {
									return done(
										new Error(
											"Errors/Warnings during build:\n" + infrastructureLogging
										)
									);
								}
								if (
									checkArrayExpectation(
										testDirectory,
										{ deprecations },
										"deprecation",
										"Deprecation",
										done
									)
								) {
									return;
								}

								let filesCount = 0;

								if (testConfig.noTests) return process.nextTick(done);
diff --git a/a.js b/b.js
@@ -13,64 +13,64 @@ const quoteMeta = str => {
A blob:39da9a2ba0964ee45a4ac2b0f5fa90a78a50c3a6
/**
 * Escapes regular expression metacharacters
 * @param {string} str String to quote
 * @returns {string} Escaped string
 */
const quoteMeta = str => {
	return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

describe("Defaults", () => {
	const cwd = process.cwd();
	const cwdRegExp = new RegExp(
		`${quoteMeta(cwd)}((?:\\\\)?(?:[a-zA-Z.\\-_]+\\\\)*)`,
		"g"
	);
	const escapedCwd = JSON.stringify(cwd).slice(1, -1);
	const escapedCwdRegExp = new RegExp(
		`${quoteMeta(escapedCwd)}((?:\\\\\\\\)?(?:[a-zA-Z.\\-_]+\\\\\\\\)*)`,
		"g"
	);
	const normalize = str => {
		if (cwd.startsWith("/")) {
			str = str.replace(new RegExp(quoteMeta(cwd), "g"), "<cwd>");
		} else {
			str = str.replace(cwdRegExp, (m, g) => `<cwd>${g.replace(/\\/g, "/")}`);
			str = str.replace(
				escapedCwdRegExp,
				(m, g) => `<cwd>${g.replace(/\\\\/g, "/")}`
			);
		}
		str = str.replace(/@@ -\d+,\d+ \+\d+,\d+ @@/g, "@@ ... @@");
		return str;
	};

	class Diff {
		constructor(value) {
			this.value = value;
		}
	}

	expect.addSnapshotSerializer({
		test(value) {
			return value instanceof Diff;
		},
		print(received) {
			return normalize(received.value);
		}
	});

	expect.addSnapshotSerializer({
		test(value) {
			return typeof value === "string";
		},
		print(received) {
			return JSON.stringify(normalize(received));
		}
	});

	const getDefaultConfig = config => {
		const { applyWebpackOptionsDefaults, getNormalizedWebpackOptions } =
			require("..").config;
		config = getNormalizedWebpackOptions(config);
		applyWebpackOptionsDefaults(config);
		process.chdir(cwd);
		return config;
	};

	const baseConfig = getDefaultConfig({ mode: "none" });

	it("should have the correct base config", () => {
		expect(baseConfig).toMatchInlineSnapshot(`
diff --git a/a.js b/b.js
@@ -882,6 +882,12 @@ test("output module", { experiments: { outputModule: true } }, e =>
A blob:39da9a2ba0964ee45a4ac2b0f5fa90a78a50c3a6
		+           },
		+         ],
		+         "type": "webassembly/sync",
	`)
	);
	test("output module", { experiments: { outputModule: true } }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received

		@@ ... @@
		-     "outputModule": false,
		+     "outputModule": true,
		@@ ... @@
		-   "externalsType": "var",
		+   "externalsType": "module",
		@@ ... @@
		-     "chunkFilename": "[name].js",
		+     "chunkFilename": "[name].mjs",
		@@ ... @@
		-     "filename": "[name].js",
		+     "filename": "[name].mjs",
		@@ ... @@
		-     "hotUpdateChunkFilename": "[id].[fullhash].hot-update.js",
diff --git a/a.js b/b.js
@@ -1054,6 +1060,197 @@ test("library", { output: { library: ["myLib", "awesome"] } }, e =>
A blob:39da9a2ba0964ee45a4ac2b0f5fa90a78a50c3a6
		@@ ... @@
		-     "filename": "[name].js",
		+     "filename": [Function filename],
	`)
	);
	test("library", { output: { library: ["myLib", "awesome"] } }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received

		@@ ... @@
		-     "chunkLoadingGlobal": "webpackChunkwebpack",
		+     "chunkLoadingGlobal": "webpackChunkmyLib_awesome",
		@@ ... @@
		-     "devtoolNamespace": "webpack",
		+     "devtoolNamespace": "myLib.awesome",
		@@ ... @@
		-     "enabledLibraryTypes": Array [],
		+     "enabledLibraryTypes": Array [
		+       "var",
		+     ],
		@@ ... @@
		-     "hotUpdateGlobal": "webpackHotUpdatewebpack",
		+     "hotUpdateGlobal": "webpackHotUpdatemyLib_awesome",
		@@ ... @@
		-     "library": undefined,
		+     "library": Object {
		+       "auxiliaryComment": undefined,
		+       "export": undefined,
		+       "name": Array [
		+         "myLib",
		+         "awesome",
		+       ],
		+       "type": "var",
		+       "umdNamedDefine": undefined,
		+     },
		@@ ... @@
		-     "uniqueName": "webpack",
		+     "uniqueName": "myLib.awesome",
	`)
	);
	test("target node", { target: "node" }, e =>
		e.toMatchInlineSnapshot(`
		- Expected
		+ Received
diff --git a/a.js b/b.js
@@ -2012,3 +2209,27 @@ test(
A blob:39da9a2ba0964ee45a4ac2b0f5fa90a78a50c3a6
			@@ ... @@
			+       "async-node",
		`)
	);

	test(
		"experiments.futureDefaults",
		{
			experiments: {
				futureDefaults: true
			}
		},
		e =>
			e.toMatchInlineSnapshot(`
			- Expected
			+ Received

			@@ ... @@
			-     "asyncWebAssembly": false,
			-     "backCompat": true,
			+     "asyncWebAssembly": true,
			+     "backCompat": false,
			@@ ... @@
			-     "cacheUnaffected": false,
			-     "css": undefined,
			-     "futureDefaults": false,
			+     "cacheUnaffected": true,
			+     "css": Object {
			+       "exportsOnly": false,
			+     },
			+     "futureDefaults": true,
			@@ ... @@
			-     "topLevelAwait": false,
			+     "topLevelAwait": true,
			@@ ... @@
			+       },
			+       Object {
			+         "rules": Array [
			+           Object {
			+             "descriptionData": Object {
			+               "type": "module",
			+             },
			+             "resolve": Object {
			+               "fullySpecified": true,
			+             },
			+           },
			+         ],
			+         "test": /\\.wasm$/i,
			+         "type": "webassembly/async",
			+       },
			+       Object {
			+         "mimetype": "application/wasm",
			+         "rules": Array [
			+           Object {
			+             "descriptionData": Object {
			+               "type": "module",
			+             },
			+             "resolve": Object {
			+               "fullySpecified": true,
			+             },
			+           },
			+         ],
			+         "type": "webassembly/async",
			+       },
			+       Object {
			+         "oneOf": Array [
			+           Object {
			+             "resolve": Object {
			+               "fullySpecified": true,
			+             },
			+             "test": /\\.module\\.css$/i,
			+             "type": "css/module",
			+           },
			+           Object {
			+             "resolve": Object {
			+               "fullySpecified": true,
			+               "preferRelative": true,
			+             },
			+             "type": "css",
			+           },
			+         ],
			+         "test": /\\.css$/i,
			+       },
			+       Object {
			+         "mimetype": "text/css+module",
			+         "resolve": Object {
			+           "fullySpecified": true,
			+         },
			+         "type": "css/module",
			+       },
			+       Object {
			+         "mimetype": "text/css",
			+         "resolve": Object {
			+           "fullySpecified": true,
			+           "preferRelative": true,
			+         },
			+         "type": "css",
			@@ ... @@
			+         "exportsPresence": "error",
			@@ ... @@
			-     "__dirname": "mock",
			-     "__filename": "mock",
			-     "global": true,
			+     "__dirname": "warn-mock",
			+     "__filename": "warn-mock",
			+     "global": "warn",
			@@ ... @@
			+         "css",
			@@ ... @@
			-     "hashDigestLength": 20,
			-     "hashFunction": "md4",
			+     "hashDigestLength": 16,
			+     "hashFunction": "xxhash64",
			@@ ... @@
			-       "<cwd>/node_modules/",
			+       /^(.+?[\\\\/]node_modules[\\\\/])/,
		`)
	);
});

diff --git a/a.js b/b.js
@@ -13,6 +13,7 @@ it("should handle output path with folder creation", done => {
A blob:f28b3c1d1660d868f49d35b0700eb6d52fda55e6
const rimraf = require("rimraf");

describe("Profiling Plugin", function () {
	jest.setTimeout(120000);

	it("should handle output path with folder creation", done => {
		const webpack = require("../");
		const outputPath = path.join(__dirname, "js/profilingPath");
		const finalPath = path.join(outputPath, "events.json");
		rimraf(outputPath, () => {
			const startTime = process.hrtime();
			const compiler = webpack({
				context: __dirname,
diff --git a/a.js b/b.js
@@ -24,7 +25,27 @@ it("should handle output path with folder creation", done => {
A blob:f28b3c1d1660d868f49d35b0700eb6d52fda55e6
const rimraf = require("rimraf");

describe("Profiling Plugin", function () {
	jest.setTimeout(120000);

	it("should handle output path with folder creation", done => {
		const webpack = require("../");
		const outputPath = path.join(__dirname, "js/profilingPath");
		const finalPath = path.join(outputPath, "events.json");
		rimraf(outputPath, () => {
			const startTime = process.hrtime();
			const compiler = webpack({
				context: __dirname,
				entry: "./fixtures/a.js",
				output: {
					path: path.join(__dirname, "js/profilingOut")
				},
				plugins: [
					new webpack.debug.ProfilingPlugin({
						outputPath: finalPath
					})
				],
				experiments: {
					backCompat: false
				}
diff --git a/a.js b/b.js
@@ -11,6 +11,7 @@
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
const { pathToFileURL, URL } = require("url");
const rimraf = require("rimraf");
const checkArrayExpectation = require("./checkArrayExpectation");
const createLazyTestEnv = require("./helpers/createLazyTestEnv");
const deprecationTracking = require("./helpers/deprecationTracking");
const captureStdio = require("./helpers/captureStdio");
const asModule = require("./helpers/asModule");

const casesPath = path.join(__dirname, "cases");
let categories = fs.readdirSync(casesPath);
categories = categories.map(cat => {
diff --git a/a.js b/b.js
@@ -23,6 +24,25 @@
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
		name: cat,
		tests: fs
			.readdirSync(path.join(casesPath, cat))
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
diff --git a/a.js b/b.js
@@ -49,6 +69,8 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
diff --git a/a.js b/b.js
@@ -187,6 +209,10 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								}
							};
							const cleanups = [];
							afterAll(() => {
diff --git a/a.js b/b.js
@@ -207,12 +233,31 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.timeout || 60000
diff --git a/a.js b/b.js
@@ -226,12 +271,31 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
diff --git a/a.js b/b.js
@@ -241,6 +305,7 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
								);
							}
							it(
								testName + " should compile",
								done => {
									const webpack = require("..");
									const compiler = webpack(options);
									const run = () => {
										const deprecationTracker = deprecationTracking.start();
diff --git a/a.js b/b.js
@@ -248,6 +313,24 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
								);
							}
							it(
								testName + " should compile",
								done => {
									const webpack = require("..");
									const compiler = webpack(options);
									const run = () => {
										const deprecationTracker = deprecationTracking.start();
										compiler.run((err, stats) => {
											const deprecations = deprecationTracker();
											if (err) return done(err);
											compiler.close(err => {
												if (err) return done(err);
												const statOptions = {
													preset: "verbose",
diff --git a/a.js b/b.js
@@ -344,7 +427,7 @@ describe(config.name, () => {
A blob:63c3f6bbdbcf8020ee44d50f40944e6ce861b3d8
			.filter(folder => folder.indexOf("_") < 0)
	};
});

const describeCases = config => {
	describe(config.name, () => {
		let stderr;
		beforeEach(() => {
			stderr = captureStdio(process.stderr, true);
		});
		afterEach(() => {
			stderr.restore();
		});
		categories.forEach(category => {
			describe(category.name, function () {
				jest.setTimeout(20000);

				category.tests
					.filter(test => {
						const testDirectory = path.join(casesPath, category.name, test);
						const filterPath = path.join(testDirectory, "test.filter.js");
						if (fs.existsSync(filterPath) && !require(filterPath)(config)) {
							describe.skip(test, () => {
								it("filtered", () => {});
							});
							return false;
						}
						return true;
					})
					.forEach(testName => {
						describe(testName, () => {
							const testDirectory = path.join(
								casesPath,
								category.name,
								testName
							);
							const outputDirectory = path.join(
								__dirname,
								"js",
								config.name,
								category.name,
								testName
							);
							const cacheDirectory = path.join(
								__dirname,
								"js/.cache",
								config.name,
								category.name,
								testName
							);
							let testConfig = {};
							const testConfigPath = path.join(testDirectory, "test.config.js");
							if (fs.existsSync(testConfigPath)) {
								testConfig = require(testConfigPath);
							}
							const TerserPlugin = require("terser-webpack-plugin");
							const terserForTesting = new TerserPlugin({
								parallel: false
							});
							let options = {
								context: casesPath,
								entry: "./" + category.name + "/" + testName + "/",
								target: config.target || "async-node",
								devtool: config.devtool,
								mode: config.mode || "none",
								optimization: config.mode
									? {
											emitOnErrors: true,
											minimizer: [terserForTesting],
											...config.optimization
									  }
									: {
											removeAvailableModules: true,
											removeEmptyChunks: true,
											mergeDuplicateChunks: true,
											flagIncludedChunks: true,
											sideEffects: true,
											providedExports: true,
											usedExports: true,
											mangleExports: true,
											emitOnErrors: true,
											concatenateModules: false,
											moduleIds: "size",
											chunkIds: "size",
											minimizer: [terserForTesting],
											...config.optimization
									  },
								performance: {
									hints: false
								},
								node: {
									__dirname: "mock",
									__filename: "mock"
								},
								cache: config.cache && {
									cacheDirectory,
									...config.cache
								},
								output: {
									pathinfo: "verbose",
									path: outputDirectory,
									filename: config.module ? "bundle.mjs" : "bundle.js"
								},
								resolve: {
									modules: ["web_modules", "node_modules"],
									mainFields: [
										"webpack",
										"browser",
										"web",
										"browserify",
										["jam", "main"],
										"main"
									],
									aliasFields: ["browser"],
									extensions: [".webpack.js", ".web.js", ".js", ".json"]
								},
								resolveLoader: {
									modules: [
										"web_loaders",
										"web_modules",
										"node_loaders",
										"node_modules"
									],
									mainFields: ["webpackLoader", "webLoader", "loader", "main"],
									extensions: [
										".webpack-loader.js",
										".web-loader.js",
										".loader.js",
										".js"
									]
								},
								module: {
									rules: [
										{
											test: /\.coffee$/,
											loader: "coffee-loader"
										},
										{
											test: /\.pug/,
											loader: "pug-loader"
										},
										{
											test: /\.wat$/i,
											loader: "wast-loader",
											type: "webassembly/async"
										}
									]
								},
								plugins: (config.plugins || []).concat(function () {
									this.hooks.compilation.tap("TestCasesTest", compilation => {
										[
											"optimize",
											"optimizeModules",
											"optimizeChunks",
											"afterOptimizeTree",
											"afterOptimizeAssets"
										].forEach(hook => {
											compilation.hooks[hook].tap("TestCasesTest", () =>
												compilation.checkConstraints()
											);
										});
									});
								}),
								experiments: {
									asyncWebAssembly: true,
									topLevelAwait: true,
									backCompat: false,
									...(config.module ? { outputModule: true } : {})
								}
							};
							const cleanups = [];
							afterAll(() => {
								options = undefined;
								testConfig = undefined;
								for (const fn of cleanups) fn();
							});
							beforeAll(done => {
								rimraf(cacheDirectory, done);
							});
							if (config.cache) {
								it(
									`${testName} should pre-compile to fill disk cache (1st)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache1"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.timeout || 60000
								);
								it(
									`${testName} should pre-compile to fill disk cache (2nd)`,
									done => {
										const oldPath = options.output.path;
										options.output.path = path.join(
											options.output.path,
											"cache2"
										);
										const deprecationTracker = deprecationTracking.start();
										const webpack = require("..");
										webpack(options, err => {
											deprecationTracker();
											options.output.path = oldPath;
											if (err) return done(err);
											done();
										});
									},
									testConfig.cachedTimeout || testConfig.timeout || 10000
								);
							}
							it(
								testName + " should compile",
								done => {
									const webpack = require("..");
									const compiler = webpack(options);
									const run = () => {
										const deprecationTracker = deprecationTracking.start();
										compiler.run((err, stats) => {
											const deprecations = deprecationTracker();
											if (err) return done(err);
											compiler.close(err => {
												if (err) return done(err);
												const statOptions = {
													preset: "verbose",
													colors: false,
													modules: true,
													reasonsSpace: 1000
												};
												fs.mkdirSync(outputDirectory, { recursive: true });
												fs.writeFileSync(
													path.join(outputDirectory, "stats.txt"),
													stats.toString(statOptions),
													"utf-8"
												);
												const jsonStats = stats.toJson({
													errorDetails: true,
													modules: false,
													assets: false,
													chunks: false
												});
												if (
													checkArrayExpectation(
														testDirectory,
														jsonStats,
														"error",
														"Error",
														done
													)
												) {
													return;
												}
												if (
													checkArrayExpectation(
														testDirectory,
														jsonStats,
														"warning",
														"Warning",
														done
													)
												) {
													return;
												}
												const infrastructureLogging = stderr.toString();
												if (infrastructureLogging) {
													done(
														new Error(
															"Errors/Warnings during build:\n" +
																infrastructureLogging
														)
													);
												}

												expect(deprecations).toEqual(config.deprecations || []);

												Promise.resolve().then(done);
											});
										});
									};
									if (config.cache) {
										// pre-compile to fill memory cache
										const deprecationTracker = deprecationTracking.start();
										compiler.run(err => {
											deprecationTracker();
											if (err) return done(err);
											run();
										});
									} else {
										run();
									}
								},
								testConfig.cachedTimeout ||
									testConfig.timeout ||
									(config.cache ? 20000 : 60000)
							);

							it(
								testName + " should load the compiled tests",
								done => {
									const esmContext = vm.createContext({
										it: _it,
										expect,
										process,
										global,
										URL,
										Buffer,
										setTimeout,
										setImmediate,
										nsObj: function (m) {
											Object.defineProperty(m, Symbol.toStringTag, {
												value: "Module"
											});
											return m;
										}
									});
									cleanups.push(() => (esmContext.it = undefined));
									function _require(module, esmMode) {
										if (module.substr(0, 2) === "./") {
											const p = path.join(outputDirectory, module);
											const content = fs.readFileSync(p, "utf-8");
											if (p.endsWith(".mjs")) {
												let esm;
diff --git a/a.js b/b.js
@@ -89,4 +89,34 @@ describe("getUndoPath", () => {
A blob:9d7fc327ee8ca7ff8fc424cd88709198a2810cd7
				});
			});
		});
	});

	describe("getUndoPath", () => {
		const cases = [
			["file.js", ""],
			["file.js", "./", true],
			["dir/file.js", "../"],
			["dir/file.js", "../", true],
			["./file.js", ""],
			[".dir/file.js", "../"],
			["./dir/file.js", "../"],
			["./dir/././file.js", "../"],
			["./dir/../file.js", ""],
			["./dir/../file.js", "./", true],
			["../file.js", "d/"],
			["../file.js", "./d/", true],
			["../dir/file.js", "../d/"],
			[".././../dir/file.js", "../c/d/"],
			["./.././../dir/file.js", "../c/d/"],
			["../dir/../file.js", "d/"],
			["../dir/../file.js", "./d/", true]
		];
		for (const [filename, expected, enforceRelative] of cases) {
			it(`should handle ${filename} correctly${
				enforceRelative ? " (enforced relative path)" : ""
			}`, () => {
				for (const outputPath of [
					"/a/b/c/d",
					"C:\\a\\b\\c\\d",
					"/a/b/c/d/",
					"C:\\a\\b\\c\\d\\"
				]) {
					expect(
						identifierUtil.getUndoPath(filename, outputPath, enforceRelative)
					).toBe(expected);
				}
			});
		}
	});
});

diff --git a/a.js b/b.js
@@ -80,10 +80,9 @@ _generateBaseUri(chunk, rootOutputDir) {
A blob:dd2476c7b254958451457e31a8d8f480bf13c94e
	 * @private
	 * @param {Chunk} chunk chunk
	 * @param {string} rootOutputDir root output directory
	 * @returns {string} generated code
	 */
	_generateBaseUri(chunk, rootOutputDir) {
		const options = chunk.getEntryOptions();
		if (options && options.baseUri) {
			return `${RuntimeGlobals.baseURI} = ${JSON.stringify(options.baseUri)};`;
		}
		const {
			compilation: {
				outputOptions: { importMetaName }
			}
		} = this;
		return `${RuntimeGlobals.baseURI} = new URL(${JSON.stringify(
			rootOutputDir
		)}, ${importMetaName}.url);`;
	}

	/**
	 * @returns {string} runtime code
	 */
	generate() {
		const { compilation, chunk } = this;
		const {
			runtimeTemplate,
			chunkGraph,
			outputOptions: { importFunctionName }
		} = compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI);
diff --git a/a.js b/b.js
@@ -21,7 +21,7 @@ get category() {
A blob:546155145318c0163bb2396924f10ca9468e395b
		super(options);

		this.range = range;
	}

	get category() {
		return "esm";
	}

	get type() {
		return "import.meta.webpackContext";
	}
}

makeSerializable(
diff --git a/a.js b/b.js
@@ -5,6 +5,7 @@
A blob:aa0fc0b8a6a5c0c7d7251cf9ce59141d040af98a
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/

"use strict";

const {
	evaluateToIdentifier
} = require("../javascript/JavascriptParserHelpers");
const ImportMetaContextDependency = require("./ImportMetaContextDependency");
diff --git a/a.js b/b.js
@@ -13,48 +14,24 @@
A blob:aa0fc0b8a6a5c0c7d7251cf9ce59141d040af98a
	evaluateToIdentifier
} = require("../javascript/JavascriptParserHelpers");
const ImportMetaContextDependency = require("./ImportMetaContextDependency");

/** @typedef {import("estree").Expression} ExpressionNode */
/** @typedef {import("estree").ObjectExpression} ObjectExpressionNode */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */

/**
 * @param {JavascriptParser} parser parser
 * @param {ObjectExpressionNode} optionsNode node
 * @returns {{mode: string, recursive: boolean, regExp: RegExp}} options
 */
function getOptions(parser, optionsNode) {
	let regExp = /^\.\/.*$/;
	let recursive = true;
	let mode = "sync";
	if (optionsNode) {
		for (const prop of optionsNode.properties) {
			if (prop.type !== "Property" || prop.key.type !== "Identifier") return;
			switch (prop.key.name) {
				case "regExp": {
					const regExpExpr = parser.evaluateExpression(
						/** @type {ExpressionNode} */ (prop.value)
					);
					if (!regExpExpr.isRegExp()) return;
					regExp = regExpExpr.regExp;
					break;
				}
				case "mode": {
					const modeExpr = parser.evaluateExpression(
						/** @type {ExpressionNode} */ (prop.value)
					);
					if (!modeExpr.isString()) return;
					mode = modeExpr.string;
					break;
				}
				case "recursive": {
					const recursiveExpr = parser.evaluateExpression(
						/** @type {ExpressionNode} */ (prop.value)
					);
					if (!recursiveExpr.isBoolean()) return;
					recursive = recursiveExpr.bool;
				}
			}
		}
	}

	return { recursive, regExp, mode };
}

module.exports = class ImportMetaContextDependencyParserPlugin {
	apply(parser) {
diff --git a/a.js b/b.js
@@ -78,13 +55,190 @@ apply(parser) {
A blob:aa0fc0b8a6a5c0c7d7251cf9ce59141d040af98a

	return { recursive, regExp, mode };
}

module.exports = class ImportMetaContextDependencyParserPlugin {
	apply(parser) {
		parser.hooks.evaluateIdentifier
			.for("import.meta.webpackContext")
			.tap("HotModuleReplacementPlugin", expr => {
				return evaluateToIdentifier(
					"import.meta.webpackContext",
					"import.meta",
					() => ["webpackContext"],
					true
				)(expr);
			});
		parser.hooks.call
			.for("import.meta.webpackContext")
			.tap("ImportMetaContextDependencyParserPlugin", expr => {
				if (expr.arguments.length < 1 || expr.arguments.length > 2) return;
				const [directoryNode, optionsNode] = expr.arguments;
				if (optionsNode && optionsNode.type !== "ObjectExpression") return;
				const requestExpr = parser.evaluateExpression(directoryNode);
				if (!requestExpr.isString()) return;
				const request = requestExpr.string;
				const options = getOptions(parser, optionsNode);
				if (!options) return;

				const dep = new ImportMetaContextDependency(
					{
						request,
						...options,
						category: "esm"
					},
					expr.range
				);
diff --git a/a.js b/b.js
@@ -7,8 +7,6 @@
A blob:6b7d1403e00843563e481364c4423016fb0b936b
	Author Tobias Koppers @sokra
*/

"use strict";

const { cachedSetProperty } = require("../util/cleverMerge");
const ContextElementDependency = require("./ContextElementDependency");
const ImportMetaContextDependency = require("./ImportMetaContextDependency");
const ImportMetaContextDependencyParserPlugin = require("./ImportMetaContextDependencyParserPlugin");
const RequireContextDependency = require("./RequireContextDependency");
const RequireContextDependencyParserPlugin = require("./RequireContextDependencyParserPlugin");

/** @typedef {import("../../declarations/WebpackOptions").ResolveOptions} ResolveOptions */
diff --git a/a.js b/b.js
@@ -36,14 +34,6 @@ apply(compiler) {
A blob:6b7d1403e00843563e481364c4423016fb0b936b
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireContextPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireContextDependency,
					new RequireContextDependency.Template()
				);
				compilation.dependencyFactories.set(
					ImportMetaContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportMetaContextDependency,
					new ImportMetaContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					ContextElementDependency,
					normalModuleFactory
diff --git a/a.js b/b.js
@@ -60,22 +50,6 @@ apply(compiler) {
A blob:6b7d1403e00843563e481364c4423016fb0b936b
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireContextPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireContextDependency,
					new RequireContextDependency.Template()
				);
				compilation.dependencyFactories.set(
					ImportMetaContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportMetaContextDependency,
					new ImportMetaContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					ContextElementDependency,
					normalModuleFactory
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireContext !== undefined &&
						!parserOptions.requireContext
					)
						return;

					new RequireContextDependencyParserPlugin().apply(parser);
				};

				const handlerImportMeta = (parser, parserOptions) => {
					if (
						parserOptions.requireContext !== undefined &&
						!parserOptions.requireContext
					)
						return;

					new ImportMetaContextDependencyParserPlugin().apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireContextPlugin", handlerImportMeta);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("RequireContextPlugin", handlerImportMeta);
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireContextPlugin", handler);
				normalModuleFactory.hooks.parser
diff --git a/a.js b/b.js
@@ -1,9 +1,11 @@
A blob:5ea896d645a98edd973e60ae90824b64bcf5de5a
it("import.meta.webpackContext without arguments should work", function() {
	const contextRequire = import.meta.webpackContext("./dir");
	expect(contextRequire("./four")).toBe(4);
});

it("should not bundle context requires with asyncMode === 'weak'", function() {
	const contextRequire = import.meta.webpackContext(".", {
		recursive: false,
		regExp: /two/,
		mode: "weak"
diff --git a/a.js b/b.js
@@ -15,13 +17,13 @@ expect(function() {
A blob:5ea896d645a98edd973e60ae90824b64bcf5de5a
	const contextRequire = import.meta.webpackContext(".", {
		recursive: false,
		regExp: /two/,
		mode: "weak"
	});
	expect(function() {
		contextRequire("./two")
	}).toThrowError(/not available/);
});

it("should find module with asyncMode === 'weak' when required elsewhere", function() {
	const contextRequire = require.context(".", false, /.+/, "weak");
	expect(contextRequire("./three")).toBe(3);
	require("./three"); // in a real app would be served as a separate chunk
});

it("should find module with asyncMode === 'weak' when required elsewhere (recursive)", function() {
	const contextRequire = require.context(".", true, /.+/, "weak");
	expect(contextRequire("./dir/four")).toBe(4);
	require("./dir/four"); // in a real app would be served as a separate chunk
});

diff --git a/a.js b/b.js
@@ -5,6 +5,7 @@
A blob:6c94a30a3ebbd66b01a04e0f64281d22acad7202
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { extname, basename } = require("path");
const { URL } = require("url");
const { createGunzip, createBrotliDecompress, createInflate } = require("zlib");
const NormalModule = require("../NormalModule");
diff --git a/a.js b/b.js
@@ -19,13 +20,15 @@
A blob:6c94a30a3ebbd66b01a04e0f64281d22acad7202
const memoize = require("../util/memoize");

/** @typedef {import("../../declarations/plugins/schemes/HttpUriPlugin").HttpUriPluginOptions} HttpUriPluginOptions */
/** @typedef {import("../Compiler")} Compiler */

const getHttp = memoize(() => require("http"));
const getHttps = memoize(() => require("https"));
const proxyFetch = request => (url, options, callback) =>
	new Promise(resolve => {
		const key = "http_proxy";
		const proxyUrl = process.env[key] || process.env[key.toUpperCase()];
		if (!proxyUrl) return resolve();

		const { hostname: host, port } = new URL(proxyUrl);

		getHttp()
			.request({
				host, // IP address of proxy server
diff --git a/a.js b/b.js
@@ -37,16 +40,24 @@ const proxyFetch = request =>
A blob:6c94a30a3ebbd66b01a04e0f64281d22acad7202
/** @typedef {import("../../declarations/plugins/schemes/HttpUriPlugin").HttpUriPluginOptions} HttpUriPluginOptions */
/** @typedef {import("../Compiler")} Compiler */

const getHttp = memoize(() => require("http"));
const getHttps = memoize(() => require("https"));
const proxyFetch = request => (url, options, callback) =>
	new Promise(resolve => {
		const key = "http_proxy";
		const proxyUrl = process.env[key] || process.env[key.toUpperCase()];
		if (!proxyUrl) return resolve();

		const { hostname: host, port } = new URL(proxyUrl);

		getHttp()
			.request({
				host, // IP address of proxy server
				port, // port of proxy server
				method: "CONNECT",
				path: url.host
			})
			.on("connect", (res, socket) => {
				if (res.statusCode === 200) {
					// connected to proxy server
					resolve(socket);
				}
			})
			.on("error", err => {
				console.error("Failed to connect to the proxy:", err);
			})
			.end();
	}).then(socket =>
		request.get(url, { ...options, ...(socket && { socket }) }, callback)
	);

/** @type {(() => void)[] | undefined} */
let inProgressWrite = undefined;

diff --git a/a.js b/b.js
@@ -302,6 +313,7 @@ constructor(options) {
A blob:6c94a30a3ebbd66b01a04e0f64281d22acad7202

class HttpUriPlugin {
	/**
	 * @param {HttpUriPluginOptions} options options
	 */
	constructor(options) {
		validate(options);
		this._lockfileLocation = options.lockfileLocation;
		this._cacheLocation = options.cacheLocation;
		this._upgrade = options.upgrade;
		this._frozen = options.frozen;
		this._allowedUris = options.allowedUris;
	}

	/**
	 * Apply the plugin
diff --git a/a.js b/b.js
@@ -310,14 +322,16 @@ constructor(options) {
A blob:6c94a30a3ebbd66b01a04e0f64281d22acad7202

class HttpUriPlugin {
	/**
	 * @param {HttpUriPluginOptions} options options
	 */
	constructor(options) {
		validate(options);
		this._lockfileLocation = options.lockfileLocation;
		this._cacheLocation = options.cacheLocation;
		this._upgrade = options.upgrade;
		this._frozen = options.frozen;
		this._allowedUris = options.allowedUris;
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const schemes = [
			{
				scheme: "http",
				fetch: proxyFetch(getHttp())
			},
			{
				scheme: "https",
				fetch: proxyFetch(getHttps())
			}
		];
		let lockfileCache;
		compiler.hooks.compilation.tap(
diff --git a/a.js b/b.js
@@ -700,13 +714,11 @@ apply(compiler) {
A blob:6c94a30a3ebbd66b01a04e0f64281d22acad7202
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const schemes = [
			{
				scheme: "http",
				fetch: proxyFetch(getHttp())
			},
			{
				scheme: "https",
				fetch: proxyFetch(getHttps())
			}
		];
		let lockfileCache;
		compiler.hooks.compilation.tap(
			"HttpUriPlugin",
			(compilation, { normalModuleFactory }) => {
				const intermediateFs = compiler.intermediateFileSystem;
				const fs = compilation.inputFileSystem;
				const cache = compilation.getCache("webpack.HttpUriPlugin");
				const logger = compilation.getLogger("webpack.HttpUriPlugin");
				const lockfileLocation =
					this._lockfileLocation ||
					join(
						intermediateFs,
						compiler.context,
						compiler.name
							? `${toSafePath(compiler.name)}.webpack.lock`
							: "webpack.lock"
					);
				const cacheLocation =
					this._cacheLocation !== undefined
						? this._cacheLocation
						: lockfileLocation + ".data";
				const upgrade = this._upgrade || false;
				const frozen = this._frozen || false;
				const hashFunction = "sha512";
				const hashDigest = "hex";
				const hashDigestLength = 20;
				const allowedUris = this._allowedUris;

				let warnedAboutEol = false;

				const cacheKeyCache = new Map();
				/**
				 * @param {string} url the url
				 * @returns {string} the key
				 */
				const getCacheKey = url => {
					const cachedResult = cacheKeyCache.get(url);
					if (cachedResult !== undefined) return cachedResult;
					const result = _getCacheKey(url);
					cacheKeyCache.set(url, result);
					return result;
				};

				/**
				 * @param {string} url the url
				 * @returns {string} the key
				 */
				const _getCacheKey = url => {
					const parsedUrl = new URL(url);
					const folder = toSafePath(parsedUrl.origin);
					const name = toSafePath(parsedUrl.pathname);
					const query = toSafePath(parsedUrl.search);
					let ext = extname(name);
					if (ext.length > 20) ext = "";
					const basename = ext ? name.slice(0, -ext.length) : name;
					const hash = createHash(hashFunction);
					hash.update(url);
					const digest = hash.digest(hashDigest).slice(0, hashDigestLength);
					return `${folder.slice(-50)}/${`${basename}${
						query ? `_${query}` : ""
					}`.slice(0, 150)}_${digest}${ext}`;
				};

				const getLockfile = cachedWithoutKey(
					/**
					 * @param {function((Error | null)=, Lockfile=): void} callback callback
					 * @returns {void}
					 */
					callback => {
						const readLockfile = () => {
							intermediateFs.readFile(lockfileLocation, (err, buffer) => {
								if (err && err.code !== "ENOENT") {
									compilation.missingDependencies.add(lockfileLocation);
									return callback(err);
								}
								compilation.fileDependencies.add(lockfileLocation);
								compilation.fileSystemInfo.createSnapshot(
									compiler.fsStartTime,
									buffer ? [lockfileLocation] : [],
									[],
									buffer ? [] : [lockfileLocation],
									{ timestamp: true },
									(err, snapshot) => {
										if (err) return callback(err);
										const lockfile = buffer
											? Lockfile.parse(buffer.toString("utf-8"))
											: new Lockfile();
										lockfileCache = {
											lockfile,
											snapshot
										};
										callback(null, lockfile);
									}
								);
							});
						};
						if (lockfileCache) {
							compilation.fileSystemInfo.checkSnapshotValid(
								lockfileCache.snapshot,
								(err, valid) => {
									if (err) return callback(err);
									if (!valid) return readLockfile();
									callback(null, lockfileCache.lockfile);
								}
							);
						} else {
							readLockfile();
						}
					}
				);

				/** @type {Map<string, LockfileEntry | "ignore" | "no-cache"> | undefined} */
				let lockfileUpdates = undefined;
				const storeLockEntry = (lockfile, url, entry) => {
					const oldEntry = lockfile.entries.get(url);
					if (lockfileUpdates === undefined) lockfileUpdates = new Map();
					lockfileUpdates.set(url, entry);
					lockfile.entries.set(url, entry);
					if (!oldEntry) {
						logger.log(`${url} added to lockfile`);
					} else if (typeof oldEntry === "string") {
						if (typeof entry === "string") {
							logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);
						} else {
							logger.log(
								`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`
							);
						}
					} else if (typeof entry === "string") {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`
						);
					} else if (oldEntry.resolved !== entry.resolved) {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`
						);
					} else if (oldEntry.integrity !== entry.integrity) {
						logger.log(`${url} updated in lockfile: content changed`);
					} else if (oldEntry.contentType !== entry.contentType) {
						logger.log(
							`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`
						);
					} else {
						logger.log(`${url} updated in lockfile`);
					}
				};

				const storeResult = (lockfile, url, result, callback) => {
					if (result.storeLock) {
						storeLockEntry(lockfile, url, result.entry);
						if (!cacheLocation || !result.content)
							return callback(null, result);
						const key = getCacheKey(result.entry.resolved);
						const filePath = join(intermediateFs, cacheLocation, key);
						mkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {
							if (err) return callback(err);
							intermediateFs.writeFile(filePath, result.content, err => {
								if (err) return callback(err);
								callback(null, result);
							});
						});
					} else {
						storeLockEntry(lockfile, url, "no-cache");
						callback(null, result);
					}
				};

				for (const { scheme, fetch } of schemes) {
					/**
					 *
					 * @param {string} url URL
					 * @param {string} integrity integrity
					 * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback
					 */
					const resolveContent = (url, integrity, callback) => {
						const handleResult = (err, result) => {
							if (err) return callback(err);
							if ("location" in result) {
								return resolveContent(
									result.location,
									integrity,
									(err, innerResult) => {
										if (err) return callback(err);
										callback(null, {
											entry: innerResult.entry,
											content: innerResult.content,
											storeLock: innerResult.storeLock && result.storeLock
										});
									}
								);
							} else {
								if (
									!result.fresh &&
									integrity &&
									result.entry.integrity !== integrity &&
									!verifyIntegrity(result.content, integrity)
								) {
									return fetchContent.force(url, handleResult);
								}
								return callback(null, {
									entry: result.entry,
									content: result.content,
									storeLock: result.storeLock
								});
							}
						};
						fetchContent(url, handleResult);
					};

					/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */
					/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */
					/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */
					/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */

					/**
					 * @param {string} url URL
					 * @param {FetchResult | RedirectFetchResult} cachedResult result from cache
					 * @param {function((Error | null)=, FetchResult=): void} callback callback
					 * @returns {void}
					 */
					const fetchContentRaw = (url, cachedResult, callback) => {
						const requestTime = Date.now();
						fetch(
							new URL(url),
							{
								headers: {
									"accept-encoding": "gzip, deflate, br",
									"user-agent": "webpack",
									"if-none-match": cachedResult
										? cachedResult.etag || null
										: null
								}
							},
							res => {
								const etag = res.headers["etag"];
								const location = res.headers["location"];
								const cacheControl = res.headers["cache-control"];
								const { storeLock, storeCache, validUntil } = parseCacheControl(
									cacheControl,
									requestTime
								);
								/**
								 * @param {Partial<Pick<FetchResultMeta, "fresh">> & (Pick<RedirectFetchResult, "location"> | Pick<ContentFetchResult, "content" | "entry">)} partialResult result
								 * @returns {void}
								 */
								const finishWith = partialResult => {
									if ("location" in partialResult) {
										logger.debug(
											`GET ${url} [${res.statusCode}] -> ${partialResult.location}`
										);
									} else {
										logger.debug(
											`GET ${url} [${res.statusCode}] ${Math.ceil(
												partialResult.content.length / 1024
											)} kB${!storeLock ? " no-cache" : ""}`
										);
									}
									const result = {
										...partialResult,
										fresh: true,
										storeLock,
										storeCache,
										validUntil,
										etag
									};
									if (!storeCache) {
										logger.log(
											`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`
										);
										return callback(null, result);
									}
									cache.store(
										url,
										null,
										{
											...result,
											fresh: false
										},
										err => {
											if (err) {
												logger.warn(
													`${url} can't be stored in cache: ${err.message}`
												);
												logger.debug(err.stack);
											}
											callback(null, result);
										}
									);
								};
								if (res.statusCode === 304) {
									if (
										cachedResult.validUntil < validUntil ||
										cachedResult.storeLock !== storeLock ||
										cachedResult.storeCache !== storeCache ||
										cachedResult.etag !== etag
									) {
										return finishWith(cachedResult);
									} else {
										logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);
										return callback(null, {
											...cachedResult,
											fresh: true
										});
									}
								}
								if (
									location &&
									res.statusCode >= 301 &&
									res.statusCode <= 308
								) {
									const result = {
										location: new URL(location, url).href
									};
									if (
										!cachedResult ||
										!("location" in cachedResult) ||
										cachedResult.location !== result.location ||
										cachedResult.validUntil < validUntil ||
										cachedResult.storeLock !== storeLock ||
										cachedResult.storeCache !== storeCache ||
										cachedResult.etag !== etag
									) {
										return finishWith(result);
									} else {
										logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);
										return callback(null, {
											...result,
											fresh: true,
											storeLock,
											storeCache,
											validUntil,
											etag
										});
									}
								}
								const contentType = res.headers["content-type"] || "";
								const bufferArr = [];

								const contentEncoding = res.headers["content-encoding"];
								let stream = res;
								if (contentEncoding === "gzip") {
									stream = stream.pipe(createGunzip());
								} else if (contentEncoding === "br") {
									stream = stream.pipe(createBrotliDecompress());
								} else if (contentEncoding === "deflate") {
									stream = stream.pipe(createInflate());
								}

								stream.on("data", chunk => {
									bufferArr.push(chunk);
								});

								stream.on("end", () => {
									if (!res.complete) {
										logger.log(`GET ${url} [${res.statusCode}] (terminated)`);
										return callback(new Error(`${url} request was terminated`));
									}

									const content = Buffer.concat(bufferArr);

									if (res.statusCode !== 200) {
										logger.log(`GET ${url} [${res.statusCode}]`);
										return callback(
											new Error(
												`${url} request status code = ${
													res.statusCode
												}\n${content.toString("utf-8")}`
											)
										);
									}

									const integrity = computeIntegrity(content);
									const entry = { resolved: url, integrity, contentType };

									finishWith({
										entry,
										content
									});
								});
							}
						).then(request =>
							request.on("error", err => {
								logger.log(`GET ${url} (error)`);
								err.message += `\nwhile fetching ${url}`;
								callback(err);
							})
						);
					};

					const fetchContent = cachedWithKey(
						/**
diff --git a/a.js b/b.js
@@ -19,7 +19,11 @@
A blob:3b0bcced4136867388ac05413c91e54264c60ce2
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder,
	compareModulesById
} = require("./util/comparators");
const { contextify, parseResource } = require("./util/identifier");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptions */
diff --git a/a.js b/b.js
@@ -317,13 +321,11 @@ libIdent(options) {
A blob:3b0bcced4136867388ac05413c91e54264c60ce2

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let identifier;

		if (this.context) {
			identifier = contextify(
				options.context,
				this.context,
				options.associatedObjectForCache
			);
		} else if (typeof this.options.resource === "string") {
			identifier = contextify(
				options.context,
				this.options.resource,
				options.associatedObjectForCache
			);
		} else if (this.options.resource === false) {
			identifier = "false";
		} else {
			const arr = [];
			for (const res of this.options.resource) {
				arr.push(
					contextify(options.context, res, options.associatedObjectForCache)
				);
			}
			identifier = arr.join(" ");
		}

		if (this.layer) identifier = `(${this.layer})/${identifier}`;
		if (this.options.mode) {
diff --git a/a.js b/b.js
@@ -1068,9 +1070,21 @@ getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
A blob:3b0bcced4136867388ac05413c91e54264c60ce2
	/**
	 * @param {string} asyncMode module mode
	 * @param {CodeGenerationContext} context context info
	 * @returns {string} the source code
	 */
	getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
		const id = chunkGraph.getModuleId(this);
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(block, block.dependencies, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getWeakSyncSource(this.dependencies, id, chunkGraph);
			}
		}
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

diff --git a/a.js b/b.js
@@ -1080,11 +1094,14 @@ getSource(sourceString) {
A blob:3b0bcced4136867388ac05413c91e54264c60ce2
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration(context) {
		const { chunkGraph } = context;
		const sources = new Map();
		sources.set(
			"javascript",
			this.getSource(this.getSourceString(this.options.mode, context))
		);
		const set = new Set();
		const allDeps = /** @type {ContextElementDependency[]} */ (
			this.dependencies.concat(this.blocks.map(b => b.dependencies[0]))
diff --git a/a.js b/b.js
@@ -180,7 +180,7 @@ processAsyncTree(
A blob:3b50a1c200852700a01f0f7ddda6061a97204758
		filename,
		parent: undefined
	}));
	/** @type {Assets} */
	const keptAssets = new Map();
	processAsyncTree(
		jobs,
		10,
		({ type, filename, parent }, push, callback) => {
			const handleError = err => {
				if (err.code === "ENOENT") {
					log(`${filename} was removed during cleaning by something else`);
					handleParent();
					return callback();
				}
				return callback(err);
			};
			const handleParent = () => {
				if (parent && --parent.remaining === 0) push(parent.job);
			};
			const path = join(fs, outputPath, filename);
			switch (type) {
				case "check":
					if (isKept(filename)) {
						keptAssets.set(filename, Date.now());
						// do not decrement parent entry as we don't want to delete the parent
						log(`${filename} will be kept`);
						return process.nextTick(callback);
					}
diff --git a/a.js b/b.js
@@ -365,7 +365,7 @@ apply(compiler) {
A blob:3b50a1c200852700a01f0f7ddda6061a97204758
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const { dry, keep } = this.options;

		const keepFn =
			typeof keep === "function"
				? keep
				: typeof keep === "string"
				? path => path.startsWith(keep)
				: typeof keep === "object" && keep.test
				? path => keep.test(path)
				: () => false;

		// We assume that no external modification happens while the compiler is active
		// So we can store the old assets and only diff to them to avoid fs access on
		// incremental builds
		/** @type {undefined|Assets} */
		let oldAssets;

		compiler.hooks.emit.tapAsync(
			{
				name: "CleanPlugin",
				stage: 100
			},
			(compilation, callback) => {
				const hooks = CleanPlugin.getCompilationHooks(compilation);
				const logger = compilation.getLogger("webpack.CleanPlugin");
				const fs = compiler.outputFileSystem;

				if (!fs.readdir) {
					return callback(
						new Error(
							"CleanPlugin: Output filesystem doesn't support listing directories (readdir)"
						)
					);
				}

				/** @type {Assets} */
				const currentAssets = new Map();
				const now = Date.now();
				for (const asset of Object.keys(compilation.assets)) {
					if (/^[A-Za-z]:\\|^\/|^\\\\/.test(asset)) continue;
					let normalizedAsset;
					let newNormalizedAsset = asset.replace(/\\/g, "/");
					do {
						normalizedAsset = newNormalizedAsset;
						newNormalizedAsset = normalizedAsset.replace(
							/(^|\/)(?!\.\.)[^/]+\/\.\.\//g,
							"$1"
						);
					} while (newNormalizedAsset !== normalizedAsset);
					if (normalizedAsset.startsWith("../")) continue;
					const assetInfo = compilation.assetsInfo.get(asset);
					if (assetInfo && assetInfo.hotModuleReplacement) {
						currentAssets.set(normalizedAsset, now + _10sec);
					} else {
						currentAssets.set(normalizedAsset, now);
					}
				}

				const outputPath = compilation.getPath(compiler.outputPath, {});
diff --git a/a.js b/b.js
@@ -394,13 +394,13 @@ apply(compiler) {
A blob:3b50a1c200852700a01f0f7ddda6061a97204758
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const { dry, keep } = this.options;

		const keepFn =
			typeof keep === "function"
				? keep
				: typeof keep === "string"
				? path => path.startsWith(keep)
				: typeof keep === "object" && keep.test
				? path => keep.test(path)
				: () => false;

		// We assume that no external modification happens while the compiler is active
		// So we can store the old assets and only diff to them to avoid fs access on
		// incremental builds
		/** @type {undefined|Assets} */
		let oldAssets;

		compiler.hooks.emit.tapAsync(
			{
				name: "CleanPlugin",
				stage: 100
			},
			(compilation, callback) => {
				const hooks = CleanPlugin.getCompilationHooks(compilation);
				const logger = compilation.getLogger("webpack.CleanPlugin");
				const fs = compiler.outputFileSystem;

				if (!fs.readdir) {
					return callback(
						new Error(
							"CleanPlugin: Output filesystem doesn't support listing directories (readdir)"
						)
					);
				}

				/** @type {Assets} */
				const currentAssets = new Map();
				const now = Date.now();
				for (const asset of Object.keys(compilation.assets)) {
					if (/^[A-Za-z]:\\|^\/|^\\\\/.test(asset)) continue;
					let normalizedAsset;
					let newNormalizedAsset = asset.replace(/\\/g, "/");
					do {
						normalizedAsset = newNormalizedAsset;
						newNormalizedAsset = normalizedAsset.replace(
							/(^|\/)(?!\.\.)[^/]+\/\.\.\//g,
							"$1"
						);
					} while (newNormalizedAsset !== normalizedAsset);
					if (normalizedAsset.startsWith("../")) continue;
					const assetInfo = compilation.assetsInfo.get(asset);
					if (assetInfo && assetInfo.hotModuleReplacement) {
						currentAssets.set(normalizedAsset, now + _10sec);
					} else {
						currentAssets.set(normalizedAsset, now);
					}
				}

				const outputPath = compilation.getPath(compiler.outputPath, {});

				const isKept = path => {
					const result = hooks.keep.call(path);
					if (result !== undefined) return result;
					return keepFn(path);
				};

				/**
				 * @param {Error=} err err
				 * @param {Set<string>=} diff diff
				 */
				const diffCallback = (err, diff) => {
					if (err) {
						oldAssets = undefined;
						callback(err);
						return;
					}
					applyDiff(
						fs,
						outputPath,
						dry,
						logger,
						diff,
						isKept,
						(err, notDeletedAssets) => {
							if (err) {
								oldAssets = undefined;
							} else {
								if (oldAssets) mergeAssets(currentAssets, oldAssets);
								oldAssets = currentAssets;
								if (notDeletedAssets) mergeAssets(oldAssets, notDeletedAssets);
							}
							callback(err);
						}
					);
diff --git a/a.js b/b.js
@@ -19,7 +19,11 @@
A blob:100eda5188b46efebcd9d0d6bb0e8113facbeb9b
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder,
	compareModulesById
} = require("./util/comparators");
const { contextify, parseResource } = require("./util/identifier");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source} Source */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized} WebpackOptions */
diff --git a/a.js b/b.js
@@ -317,13 +321,11 @@ libIdent(options) {
A blob:100eda5188b46efebcd9d0d6bb0e8113facbeb9b

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let identifier;

		if (this.context) {
			identifier = contextify(
				options.context,
				this.context,
				options.associatedObjectForCache
			);
		} else if (typeof this.options.resource === "string") {
			identifier = contextify(
				options.context,
				this.options.resource,
				options.associatedObjectForCache
			);
		} else if (this.options.resource === false) {
			identifier = "false";
		} else {
			const arr = [];
			for (const res of this.options.resource) {
				arr.push(
					contextify(options.context, res, options.associatedObjectForCache)
				);
			}
			identifier = arr.join(" ");
		}

		if (this.layer) identifier = `(${this.layer})/${identifier}`;
		if (this.options.mode) {
diff --git a/a.js b/b.js
@@ -374,8 +376,9 @@ needBuild({ fileSystemInfo }, callback) {
A blob:100eda5188b46efebcd9d0d6bb0e8113facbeb9b
	/**
	 * @param {NeedBuildContext} context context info
	 * @param {function((WebpackError | null)=, boolean=): void} callback callback function, returns true, if the module needs a rebuild
	 * @returns {void}
	 */
	needBuild({ fileSystemInfo }, callback) {
		// build if enforced
		if (this._forceBuild) return callback(null, true);

		// always build when we have no snapshot
		if (!this.buildInfo.snapshot) return callback(null, true);

		fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {
			callback(err, !valid);
		});
diff --git a/a.js b/b.js
@@ -490,7 +493,7 @@ build(options, compilation, resolver, fs, callback) {
A blob:100eda5188b46efebcd9d0d6bb0e8113facbeb9b
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {function(WebpackError=): void} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		/** @type {BuildMeta} */
		this.buildMeta = {
			exportsType: "default",
			defaultObject: "redirect-warn"
		};
		this.buildInfo = {
			snapshot: undefined
		};
		this.dependencies.length = 0;
		this.blocks.length = 0;
		const startTime = Date.now();
		this.resolveDependencies(fs, this.options, (err, dependencies) => {
			if (err) {
				return callback(
					makeWebpackError(err, "ContextModule.resolveDependencies")
				);
			}

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			}

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}
			dependencies.sort(
				concatComparators(
					compareSelect(a => a.loc, compareLocations),
					keepOriginalOrder(this.dependencies)
				)
			);

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy-once") {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock({
						...this.options.groupOptions,
						name: this.options.chunkName
					});
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy") {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						}
						chunkName = chunkName.replace(/\[index\]/g, `${index++}`);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						{
							...this.options.groupOptions,
							name: chunkName
						},
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new WebpackError(`Unsupported mode "${this.options.mode}" in context`)
				);
				return;
			}
			if (!this.context || !this.options.resource) return callback();

			compilation.fileSystemInfo.createSnapshot(
				startTime,
				null,
diff --git a/a.js b/b.js
@@ -1067,9 +1070,21 @@ getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
A blob:100eda5188b46efebcd9d0d6bb0e8113facbeb9b
	/**
	 * @param {string} asyncMode module mode
	 * @param {CodeGenerationContext} context context info
	 * @returns {string} the source code
	 */
	getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
		const id = chunkGraph.getModuleId(this);
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(block, block.dependencies, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === "weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getWeakSyncSource(this.dependencies, id, chunkGraph);
			}
		}
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

diff --git a/a.js b/b.js
@@ -1079,11 +1094,14 @@ getSource(sourceString) {
A blob:100eda5188b46efebcd9d0d6bb0e8113facbeb9b
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	getSource(sourceString) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration(context) {
		const { chunkGraph } = context;
		const sources = new Map();
		sources.set(
			"javascript",
			this.getSource(this.getSourceString(this.options.mode, context))
		);
		const set = new Set();
		const allDeps = /** @type {ContextElementDependency[]} */ (
			this.dependencies.concat(this.blocks.map(b => b.dependencies[0]))
diff --git a/a.js b/b.js
@@ -5,7 +5,7 @@
A blob:b56d33a42590b79fc7ec283ad1d5fe82a217ee6d
const path = require("path");

/** @type {import("../../../../").Configuration} */
module.exports = {
	resolve: {
		modules: [path.resolve(__dirname, "a"), path.resolve(__dirname, "b")],
		alias: {
			[path.resolve(__dirname, "a/foo")]: false
		}
	}
};

diff --git a/a.js b/b.js
@@ -1,7 +1,7 @@
A blob:0679d569bd538e7dc2ae16cbba525dded49b6893
const id = () => Math.random();

it("should compile", () => {
	expect(/* webpackMode: "lazy" */ import(`foo/${id()}`)).rejects.toBeTruthy();
	expect(/* webpackMode: "lazy" */ import(`foo/${id()}`)).rejects.toBeTruthy();
	expect(/* webpackMode: "lazy" */ import(`foo/${id()}`)).rejects.toBeTruthy();
});

