diff --git a/a.js b/b.js
@@ -738,17 +738,16 @@ function byteLength(string, encoding) {
A blob:57d6cddbaa2e6bdd846a667897588dea18daeb42
        return encodingOps.base64url;
      break;
  }
}

function byteLength(string, encoding) {
  if (typeof string !== 'string') {
    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {
      return string.byteLength;
    }

    throw new ERR_INVALID_ARG_TYPE(
      'string', ['string', 'Buffer', 'ArrayBuffer'], string
    );
  }

  const len = string.length;
  const mustMatch = (arguments.length > 2 && arguments[2] === true);
  if (!mustMatch && len === 0)
    return 0;

  if (!encoding)
    return (mustMatch ? -1 : byteLengthUtf8(string));

  const ops = getEncodingOps(encoding);
  if (ops === undefined)
    return (mustMatch ? -1 : byteLengthUtf8(string));
  return ops.byteLength(string);
}

Buffer.byteLength = byteLength;

diff --git a/a.js b/b.js
@@ -23,8 +23,6 @@
A blob:33cbb3268440a10e168027beaea041d18da301d9
      message: 'The "string" argument must be of type string or an instance ' +
               'of Buffer or ArrayBuffer.' +
               common.invalidArgTypeHelper(args[0])
    }
  );
});

assert.strictEqual(Buffer.byteLength('', undefined, true), -1);

assert(ArrayBuffer.isView(new Buffer(10)));
assert(ArrayBuffer.isView(new SlowBuffer(10)));
assert(ArrayBuffer.isView(Buffer.alloc(10)));
assert(ArrayBuffer.isView(Buffer.allocUnsafe(10)));
diff --git a/a.js b/b.js
@@ -27,6 +27,7 @@
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544

const {
  ArrayPrototypeMap,
  ObjectCreate,
  ObjectDefineProperties,
  ObjectDefineProperty,
  ReflectApply,
} = primordials;

const cares = internalBinding('cares_wrap');
const { toASCII } = require('internal/idna');
diff --git a/a.js b/b.js
@@ -63,6 +64,15 @@
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544

const {
  GetAddrInfoReqWrap,
  GetNameInfoReqWrap,
  QueryReqWrap,
} = cares;

const dnsException = errors.dnsException;

let promises = null; // Lazy loaded

diff --git a/a.js b/b.js
@@ -72,6 +82,7 @@ function onlookup(err, addresses) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544

const dnsException = errors.dnsException;

let promises = null; // Lazy loaded

function onlookup(err, addresses) {
  if (err) {
    return this.callback(dnsException(err, 'getaddrinfo', this.hostname));
  }
  this.callback(null, addresses[0], this.family || isIP(addresses[0]));
}


function onlookupall(err, addresses) {
diff --git a/a.js b/b.js
@@ -90,6 +101,7 @@ function onlookupall(err, addresses) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544
  }
  this.callback(null, addresses[0], this.family || isIP(addresses[0]));
}


function onlookupall(err, addresses) {
  if (err) {
    return this.callback(dnsException(err, 'getaddrinfo', this.hostname));
  }

  const family = this.family;
  for (let i = 0; i < addresses.length; i++) {
    const addr = addresses[i];
    addresses[i] = {
      address: addr,
      family: family || isIP(addr)
    };
  }

  this.callback(null, addresses);
}


// Easy DNS A/AAAA look up
diff --git a/a.js b/b.js
@@ -176,6 +188,13 @@ function lookup(hostname, options, callback) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544
}


// Easy DNS A/AAAA look up
// lookup(hostname, [options,] callback)
function lookup(hostname, options, callback) {
  let hints = 0;
  let family = -1;
  let all = false;
  let verbatim = getDefaultVerbatim();

  // Parse arguments
  if (hostname) {
    validateString(hostname, 'hostname');
  }

  if (typeof options === 'function') {
    callback = options;
    family = 0;
  } else {
    validateFunction(callback, 'callback');

    if (options !== null && typeof options === 'object') {
      if (options.hints != null && typeof options.hints !== 'number') {
        emitTypeCoercionDeprecationWarning();
      }
      hints = options.hints >>> 0;
      if (options.family != null && typeof options.family !== 'number') {
        emitTypeCoercionDeprecationWarning();
      }
      family = options.family >>> 0;
      if (options.all != null && typeof options.all !== 'boolean') {
        emitTypeCoercionDeprecationWarning();
      }
      all = options.all === true;
      if (typeof options.verbatim === 'boolean') {
        verbatim = options.verbatim === true;
      } else if (options.verbatim != null) {
        emitTypeCoercionDeprecationWarning();
      }

      validateHints(hints);
    } else {
      if (options != null && typeof options !== 'number') {
        emitTypeCoercionDeprecationWarning();
      }
      family = options >>> 0;
    }
  }

  validateOneOf(family, 'family', [0, 4, 6]);

  if (!hostname) {
    emitInvalidHostnameWarning(hostname);
    if (all) {
      process.nextTick(callback, null, []);
    } else {
      process.nextTick(callback, null, null, family === 6 ? 6 : 4);
    }
    return {};
  }

  const matchedFamily = isIP(hostname);
  if (matchedFamily) {
    if (all) {
      process.nextTick(
        callback, null, [{ address: hostname, family: matchedFamily }]);
    } else {
      process.nextTick(callback, null, hostname, matchedFamily);
    }
    return {};
  }

  const req = new GetAddrInfoReqWrap();
  req.callback = callback;
  req.family = family;
  req.hostname = hostname;
  req.oncomplete = all ? onlookupall : onlookup;

  const err = cares.getaddrinfo(
    req, toASCII(hostname), family, hints, verbatim
  );
  if (err) {
    process.nextTick(callback, dnsException(err, 'getaddrinfo', hostname));
    return {};
  }
  return req;
}

ObjectDefineProperty(lookup, customPromisifyArgs,
diff --git a/a.js b/b.js
@@ -188,6 +207,7 @@ function onlookupservice(err, hostname, service) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544

ObjectDefineProperty(lookup, customPromisifyArgs,
                     { value: ['address', 'family'], enumerable: false });


function onlookupservice(err, hostname, service) {
  if (err)
    return this.callback(dnsException(err, 'getnameinfo', this.hostname));

  this.callback(null, hostname, service);
}


function lookupService(address, port, callback) {
diff --git a/a.js b/b.js
@@ -212,6 +232,14 @@ function lookupService(address, port, callback) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544

  this.callback(null, hostname, service);
}


function lookupService(address, port, callback) {
  if (arguments.length !== 3)
    throw new ERR_MISSING_ARGS('address', 'port', 'callback');

  if (isIP(address) === 0)
    throw new ERR_INVALID_ARG_VALUE('address', address);

  validatePort(port);

  validateFunction(callback, 'callback');

  port = +port;

  const req = new GetNameInfoReqWrap();
  req.callback = callback;
  req.hostname = address;
  req.port = port;
  req.oncomplete = onlookupservice;

  const err = cares.getnameinfo(req, address, port);
  if (err) throw dnsException(err, 'getnameinfo', address);
  return req;
}

ObjectDefineProperty(lookupService, customPromisifyArgs,
diff --git a/a.js b/b.js
@@ -226,8 +254,10 @@ function onresolve(err, result, ttls) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544

ObjectDefineProperty(lookupService, customPromisifyArgs,
                     { value: ['hostname', 'service'], enumerable: false });


function onresolve(err, result, ttls) {
  if (ttls && this.ttl)
    result = ArrayPrototypeMap(
      result, (address, index) => ({ address, ttl: ttls[index] }));

  if (err)
    this.callback(dnsException(err, this.bindingName, this.hostname));
  else
    this.callback(null, result);
}

function resolver(bindingName) {
  function query(name, /* options, */ callback) {
diff --git a/a.js b/b.js
@@ -249,6 +279,14 @@ function resolver(bindingName) {
A blob:d795e8e09045c4c14186d0a3be7a1733ed758544
    this.callback(dnsException(err, this.bindingName, this.hostname));
  else
    this.callback(null, result);
}

function resolver(bindingName) {
  function query(name, /* options, */ callback) {
    let options;
    if (arguments.length > 2) {
      options = callback;
      callback = arguments[2];
    }

    validateString(name, 'name');
    validateFunction(callback, 'callback');

    const req = new QueryReqWrap();
    req.bindingName = bindingName;
    req.callback = callback;
    req.hostname = name;
    req.oncomplete = onresolve;
    req.ttl = !!(options && options.ttl);
    const err = this._handle[bindingName](req, toASCII(name));
    if (err) throw dnsException(err, bindingName, name);
    return req;
  }
  ObjectDefineProperty(query, 'name', { value: bindingName });
  return query;
diff --git a/a.js b/b.js
@@ -5,6 +5,7 @@
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162
'use strict';
const {
  ArrayPrototypeMap,
  ObjectCreate,
  ObjectDefineProperty,
  Promise,
  ReflectApply,
} = primordials;

const {
  bindDefaultResolver,
diff --git a/a.js b/b.js
@@ -38,6 +39,15 @@
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162
} = codes;
const {
  validatePort,
  validateString,
  validateOneOf,
} = require('internal/validators');

function onlookup(err, addresses) {
  if (err) {
    this.reject(dnsException(err, 'getaddrinfo', this.hostname));
    return;
diff --git a/a.js b/b.js
@@ -46,6 +56,7 @@ function onlookup(err, addresses) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162
  validatePort,
  validateString,
  validateOneOf,
} = require('internal/validators');

function onlookup(err, addresses) {
  if (err) {
    this.reject(dnsException(err, 'getaddrinfo', this.hostname));
    return;
  }

  const family = this.family || isIP(addresses[0]);
  this.resolve({ address: addresses[0], family });
}

function onlookupall(err, addresses) {
  if (err) {
diff --git a/a.js b/b.js
@@ -66,6 +77,7 @@ function onlookupall(err, addresses) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162

  const family = this.family || isIP(addresses[0]);
  this.resolve({ address: addresses[0], family });
}

function onlookupall(err, addresses) {
  if (err) {
    this.reject(dnsException(err, 'getaddrinfo', this.hostname));
    return;
  }

  const family = this.family;

  for (var i = 0; i < addresses.length; i++) {
    const address = addresses[i];

    addresses[i] = {
      address,
      family: family || isIP(addresses[i])
    };
  }

  this.resolve(addresses);
}

function createLookupPromise(family, hostname, all, hints, verbatim) {
  return new Promise((resolve, reject) => {
diff --git a/a.js b/b.js
@@ -96,6 +108,14 @@ function createLookupPromise(family, hostname, all, hints, verbatim) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162
  }

  this.resolve(addresses);
}

function createLookupPromise(family, hostname, all, hints, verbatim) {
  return new Promise((resolve, reject) => {
    if (!hostname) {
      emitInvalidHostnameWarning(hostname);
      resolve(all ? [] : { address: null, family: family === 6 ? 6 : 4 });
      return;
    }

    const matchedFamily = isIP(hostname);

    if (matchedFamily !== 0) {
      const result = { address: hostname, family: matchedFamily };
      resolve(all ? [result] : result);
      return;
    }

    const req = new GetAddrInfoReqWrap();

    req.family = family;
    req.hostname = hostname;
    req.oncomplete = all ? onlookupall : onlookup;
    req.resolve = resolve;
    req.reject = reject;

    const err = getaddrinfo(req, toASCII(hostname), family, hints, verbatim);

    if (err) {
      reject(dnsException(err, 'getaddrinfo', hostname));
    }
  });
}

diff --git a/a.js b/b.js
@@ -151,6 +171,7 @@ function onlookupservice(err, hostname, service) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162

  return createLookupPromise(family, hostname, all, hints, verbatim);
}


function onlookupservice(err, hostname, service) {
  if (err) {
    this.reject(dnsException(err, 'getnameinfo', this.host));
    return;
  }

  this.resolve({ hostname, service });
}

function createLookupServicePromise(hostname, port) {
  return new Promise((resolve, reject) => {
diff --git a/a.js b/b.js
@@ -167,6 +188,15 @@ function createLookupServicePromise(hostname, port) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162
  }

  this.resolve({ hostname, service });
}

function createLookupServicePromise(hostname, port) {
  return new Promise((resolve, reject) => {
    const req = new GetNameInfoReqWrap();

    req.hostname = hostname;
    req.port = port;
    req.oncomplete = onlookupservice;
    req.resolve = resolve;
    req.reject = reject;

    const err = getnameinfo(req, hostname, port);

    if (err)
      reject(dnsException(err, 'getnameinfo', hostname));
  });
}

function lookupService(address, port) {
diff --git a/a.js b/b.js
@@ -194,6 +224,7 @@ function onresolve(err, result, ttls) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162

  return createLookupServicePromise(address, +port);
}


function onresolve(err, result, ttls) {
  if (err) {
    this.reject(dnsException(err, this.bindingName, this.hostname));
    return;
  }

  if (ttls && this.ttl)
    result = ArrayPrototypeMap(
      result, (address, index) => ({ address, ttl: ttls[index] }));

  this.resolve(result);
}

function createResolverPromise(resolver, bindingName, hostname, ttl) {
  return new Promise((resolve, reject) => {
diff --git a/a.js b/b.js
@@ -211,6 +242,16 @@ function createResolverPromise(resolver, bindingName, hostname, ttl) {
A blob:fcff215896ae8f99d2cf0f737e49b5def7205162
      result, (address, index) => ({ address, ttl: ttls[index] }));

  this.resolve(result);
}

function createResolverPromise(resolver, bindingName, hostname, ttl) {
  return new Promise((resolve, reject) => {
    const req = new QueryReqWrap();

    req.bindingName = bindingName;
    req.hostname = hostname;
    req.oncomplete = onresolve;
    req.resolve = resolve;
    req.reject = reject;
    req.ttl = ttl;

    const err = resolver._handle[bindingName](req, toASCII(hostname));

    if (err)
      reject(dnsException(err, bindingName, hostname));
  });
}

function resolver(bindingName) {
diff --git a/a.js b/b.js
@@ -24,6 +24,8 @@
A blob:ca9e68a96258ab869ab7cf84c1fadc3a308f78b3
} = primordials;

const {
  constants: {
    NODE_PERFORMANCE_ENTRY_TYPE_GC,
    NODE_PERFORMANCE_ENTRY_TYPE_HTTP2,
    NODE_PERFORMANCE_ENTRY_TYPE_HTTP,
  },
  installGarbageCollectionTracking,
  observerCounts,
  removeGarbageCollectionTracking,
diff --git a/a.js b/b.js
@@ -75,12 +77,14 @@
A blob:ca9e68a96258ab869ab7cf84c1fadc3a308f78b3

const kTypeSingle = 0;
const kTypeMultiple = 1;

let gcTrackingInstalled = false;

const kSupportedEntryTypes = ObjectFreeze([
  'function',
  'gc',
  'http',
  'http2',
  'mark',
  'measure',
]);

// Performance timeline entry Buffers
let markEntryBuffer = [];
diff --git a/a.js b/b.js
@@ -114,6 +118,8 @@ function getObserverType(type) {
A blob:ca9e68a96258ab869ab7cf84c1fadc3a308f78b3
    for (const pending of pendings)
      pending[kDispatch]();
  });
}

function getObserverType(type) {
  switch (type) {
    case 'gc': return NODE_PERFORMANCE_ENTRY_TYPE_GC;
    case 'http2': return NODE_PERFORMANCE_ENTRY_TYPE_HTTP2;
    case 'http': return NODE_PERFORMANCE_ENTRY_TYPE_HTTP;
  }
}

function maybeDecrementObserverCounts(entryTypes) {
diff --git a/a.js b/b.js
@@ -440,6 +446,32 @@ function hasObserver(type) {
A blob:ca9e68a96258ab869ab7cf84c1fadc3a308f78b3
  enqueue(entry);
}

setupObservers(observerCallback);

function hasObserver(type) {
  const observerType = getObserverType(type);
  return observerCounts[observerType] > 0;
}

module.exports = {
  PerformanceObserver,
  PerformanceObserverEntryList,
  enqueue,
diff --git a/a.js b/b.js
@@ -447,4 +479,6 @@ function hasObserver(type) {
A blob:ca9e68a96258ab869ab7cf84c1fadc3a308f78b3
  enqueue(entry);
}

setupObservers(observerCallback);

function hasObserver(type) {
  const observerType = getObserverType(type);
  return observerCounts[observerType] > 0;
}

module.exports = {
  PerformanceObserver,
  PerformanceObserverEntryList,
  enqueue,
  hasObserver,
  clearEntriesFromBuffer,
  filterBufferMapByNameAndType,
};

diff --git a/a.js b/b.js
@@ -130,6 +130,12 @@
A blob:53ecbd9a1f5f4d8829c0f06caa90ed065e2794e7
const DEFAULT_IPV4_ADDR = '0.0.0.0';
const DEFAULT_IPV6_ADDR = '::';

const isWindows = process.platform === 'win32';

const noop = () => {};

function getFlags(ipv6Only) {
  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;
}

diff --git a/a.js b/b.js
@@ -952,6 +958,8 @@ debug('binding to localAddress: %s and localPort: %d (addressType: %d)',
A blob:53ecbd9a1f5f4d8829c0f06caa90ed065e2794e7
      err = self._handle.bind(localAddress, localPort);
    } else { // addressType === 6
      localAddress = localAddress || DEFAULT_IPV6_ADDR;
      err = self._handle.bind6(localAddress, localPort, flags);
    }
    debug('binding to localAddress: %s and localPort: %d (addressType: %d)',
          localAddress, localPort, addressType);

    err = checkBindError(err, localPort, self._handle);
    if (err) {
      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);
      self.destroy(ex);
      return;
    }
  }

  if (addressType === 6 || addressType === 4) {
    const req = new TCPConnectWrap();
    req.oncomplete = afterConnect;
    req.address = address;
    req.port = port;
    req.localAddress = localAddress;
    req.localPort = localPort;

    if (addressType === 4)
      err = self._handle.connect(req, address, port);
    else
      err = self._handle.connect6(req, address, port);
  } else {
    const req = new PipeConnectWrap();
    req.address = address;
    req.oncomplete = afterConnect;

    err = self._handle.connect(req, address, afterConnect);
  }

  if (err) {
    const sockname = self._getsockname();
    let details;

    if (sockname) {
      details = sockname.address + ':' + sockname.port;
    }

    const ex = exceptionWithHostPort(err, 'connect', address, port, details);
    self.destroy(ex);
  }
}


diff --git a/a.js b/b.js
@@ -1177,7 +1185,7 @@ function afterConnect(status, handle, req, readable, writable) {
A blob:53ecbd9a1f5f4d8829c0f06caa90ed065e2794e7

  return this;
};


function afterConnect(status, handle, req, readable, writable) {
  const self = handle[owner_symbol];

  // Callback may come after call to destroy
  if (self.destroyed) {
    return;
  }

  debug('afterConnect');

  assert(self.connecting);
  self.connecting = false;
  self._sockname = null;

  if (status === 0) {
    if (self.readable && !readable) {
      self.push(null);
      self.read();
    }
    if (self.writable && !writable) {
      self.end();
    }
    self._unrefTimer();

    if (self[kSetNoDelay] && self._handle.setNoDelay) {
      self._handle.setNoDelay(true);
    }

    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {
      self._handle.setKeepAlive(true, self[kSetKeepAliveInitialDelay]);
    }

    self.emit('connect');
    self.emit('ready');

    // Start the first read, or get an immediate EOF.
    // this doesn't actually consume any bytes, because len=0.
    if (readable && !self.isPaused())
      self.read(0);

  } else {
    self.connecting = false;
    let details;
    if (req.localAddress && req.localPort) {
diff --git a/a.js b/b.js
@@ -31,6 +31,7 @@
A blob:16b832527f7c64e90952d0e59b23de0f964f6d86
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_PROPERTY_VALUE,
  ERR_INVALID_RETURN_VALUE,
  ERR_UNKNOWN_MODULE_FORMAT
} = require('internal/errors').codes;
const { pathToFileURL, isURLInstance, URL } = require('internal/url');
const {
  isAnyArrayBuffer,
  isArrayBufferView,
} = require('internal/util/types');
diff --git a/a.js b/b.js
@@ -53,6 +54,13 @@
A blob:16b832527f7c64e90952d0e59b23de0f964f6d86
const { translators } = require(
  'internal/modules/esm/translators');
const { getOptionValue } = require('internal/options');
const {
  fetchModule,
} = require('internal/modules/esm/fetch_module');

/**
 * An ESMLoader instance is used as the main entry point for loading ES modules.
 * Currently, this is a singleton -- there is only one used for loading
 * the main module and everything in its dependency graph.
diff --git a/a.js b/b.js
@@ -107,6 +115,22 @@
A blob:16b832527f7c64e90952d0e59b23de0f964f6d86
  moduleMap = new ModuleMap();

  /**
   * Methods which translate input code or other information into ES modules
   */
  translators = translators;

  static pluckHooks({
    globalPreload,
    resolve,
    load,
diff --git a/a.js b/b.js
@@ -364,7 +364,6 @@ function resolveDirectoryEntry(search) {
A blob:53085f327469b38cd5eebf17c79b514d71fa7cab

/**
 * @param {URL} search
 * @returns {URL | undefined}
 */
function resolveDirectoryEntry(search) {
  const dirPath = fileURLToPath(search);
  const pkgJsonPath = resolve(dirPath, 'package.json');
  if (fileExists(pkgJsonPath)) {
    const pkgJson = packageJsonReader.read(pkgJsonPath);
    if (pkgJson.containsKeys) {
      const { main } = JSONParse(pkgJson.string);
      if (main != null) {
        const mainUrl = pathToFileURL(resolve(dirPath, main));
        return resolveExtensionsWithTryExactName(mainUrl);
      }
    }
  }
  return resolveExtensions(new URL('index', search));
}

const encodedSepRegEx = /%2F|%5C/i;
let experimentalSpecifierResolutionWarned = false;
/**
 * @param {URL} resolved
 * @param {string | URL | undefined} base
 * @param {boolean} preserveSymlinks
diff --git a/a.js b/b.js
@@ -379,13 +378,6 @@ function finalizeResolution(resolved, base, preserveSymlinks) {
A blob:53085f327469b38cd5eebf17c79b514d71fa7cab
 * @param {URL} resolved
 * @param {string | URL | undefined} base
 * @param {boolean} preserveSymlinks
 * @returns {URL | undefined}
 */
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname, 'must not include encoded "/" or "\\" characters',
      fileURLToPath(base));

  let path = fileURLToPath(resolved);
  if (getOptionValue('--experimental-specifier-resolution') === 'node') {
    if (!experimentalSpecifierResolutionWarned) {
      process.emitWarning(
        'The Node.js specifier resolution flag is experimental. It could change or be removed at any time.',
        'ExperimentalWarning');
      experimentalSpecifierResolutionWarned = true;
    }

    let file = resolveExtensionsWithTryExactName(resolved);

    // Directory
    if (file === undefined) {
diff --git a/a.js b/b.js
@@ -55,9 +55,6 @@ async function initializeLoader() {
A blob:73385a85b4e106fcea43326b0d77f2d00ef6c95e

/**
 * Causes side-effects: user-defined loader hooks are added to esmLoader.
 * @returns {void}
 */
async function initializeLoader() {
  const { getOptionValue } = require('internal/options');
  // customLoaders CURRENTLY can be only 1 (a string)
  // Once chaining is implemented, it will be string[]
  const customLoaders = getOptionValue('--experimental-loader');

  if (!customLoaders.length) return;

  const { emitExperimentalWarning } = require('internal/util');
  emitExperimentalWarning('--experimental-loader');

  let cwd;
  try {
    cwd = process.cwd() + '/';
  } catch {
diff --git a/a.js b/b.js
@@ -12,10 +12,10 @@
A blob:ac15b841df9c3a13be5a8955ea2872fb6f29d246
const tmpdir = require('../common/tmpdir');
tmpdir.refresh();
const tmpDir = tmpdir.path;
const longPath = path.join(...[tmpDir].concat(Array(30).fill('1234567890')));
fs.mkdirSync(longPath, { recursive: true });

// Test if we can have symlinks to files and folders with long filenames
const targetDirtectory = path.join(longPath, 'target-directory');
fs.mkdirSync(targetDirtectory);
const pathDirectory = path.join(tmpDir, 'new-directory');
fs.symlink(targetDirtectory, pathDirectory, 'dir', common.mustSucceed(() => {
  assert(fs.existsSync(pathDirectory));
}));

const targetFile = path.join(longPath, 'target-file');
diff --git a/a.js b/b.js
@@ -53,9 +53,9 @@
A blob:58906a25df42b939513eda51610feefc35be4a35
}

for (let i = 0; i < validDelays.length; i++) {
  s.setTimeout(validDelays[i], () => {});
}

for (let i = 0; i < invalidCallbacks.length; i++) {
  [0, 1].forEach((mesc) =>
    assert.throws(
      () => s.setTimeout(mesc, invalidCallbacks[i]),
      {
        code: 'ERR_INVALID_ARG_TYPE',
        name: 'TypeError',
      }
diff --git a/a.js b/b.js
@@ -11,7 +11,7 @@
A blob:ee64c6e68ab7ab6f5219c6931c5a84d6b406be12
// An uncaught exception inside a queueMicrotask callback should not lead
// to multiple after() calls for it.

let µtaskId;
const events = [];

async_hooks.createHook({
  init(id, type, triggerId, resoure) {
    if (type === 'Microtask') {
      µtaskId = id;
      events.push('init');
    }
diff --git a/a.js b/b.js
@@ -155,10 +155,10 @@ pipeline(
A blob:07ef2f9ccf7c3c1cbc4ab11499cee9059fc8f8ec
  }));
}

{
  // https://github.com/nodejs/node/issues/40497
  pipeline(
    ['abc\ndef\nghi'],
    Duplex.from(async function * (source) {
      let rest = '';
      for await (const chunk of source) {
        const lines = (rest + chunk.toString()).split('\n');
        rest = lines.pop();
        for (const line of lines) {
          yield line;
        }
      }
      yield rest;
    }),
    async function * (source) { // eslint-disable-line require-yield
      let ret = '';
      for await (const x of source) {
        ret += x;
      }
      assert.strictEqual(ret, 'abcdefghi');
    },
    common.mustCall(() => {}),
  );
}

// Ensure that isDuplexNodeStream was called
{
  const duplex = new Duplex();
  assert.strictEqual(Duplex.from(duplex), duplex);
}

// Ensure that Duplex.from works for blobs
{
  const blob = new Blob(['blob']);
  const expecteByteLength = blob.size;
  const duplex = Duplex.from(blob);
  duplex.on('data', common.mustCall((arrayBuffer) => {
    assert.strictEqual(arrayBuffer.byteLength, expecteByteLength);
  }));
}

// Ensure that given a promise rejection it emits an error
diff --git a/a.js b/b.js
@@ -68,7 +68,7 @@ _write(chunk, encoding, callback) {
A blob:3fb9796251c16dae9763caf6af5c4722a28b4633
  constructor(fn, options) {
    super(options);
    this.fn = fn;
  }

  _write(chunk, encoding, callback) {
    this.fn(Buffer.isBuffer(chunk), typeof chunk, encoding);
    callback();
  }
}

(function defaultCondingIsUtf8() {
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(enc, 'utf8');
  }, { decodeStrings: false });
  m.write('foo');
  m.end();
}());

(function changeDefaultEncodingToAscii() {
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(enc, 'ascii');
  }, { decodeStrings: false });
  m.setDefaultEncoding('ascii');
  m.write('bar');
  m.end();
}());

// Change default encoding to invalid value.
assert.throws(() => {
  const m = new MyWritable(
    (isBuffer, type, enc) => {},
    { decodeStrings: false });
  m.setDefaultEncoding({});
  m.write('bar');
  m.end();
}, {
  name: 'TypeError',
  code: 'ERR_UNKNOWN_ENCODING',
  message: 'Unknown encoding: {}'
});

(function checkVairableCaseEncoding() {
  const m = new MyWritable(function(isBuffer, type, enc) {
    assert.strictEqual(enc, 'ascii');
  }, { decodeStrings: false });
  m.setDefaultEncoding('AsCii');
diff --git a/a.js b/b.js
@@ -16,6 +16,15 @@
A blob:e0e3fd88544fff8906392369522757e3c23a235c

tmpdir.refresh();

let count = 0;
const nextDirPath = (name = 'rm') =>
  path.join(tmpdir.path, `${name}-${count++}`);

function makeNonEmptyDirectory(depth, files, folders, dirname, createSymLinks) {
  fs.mkdirSync(dirname, { recursive: true });
  fs.writeFileSync(path.join(dirname, 'text.txt'), 'hello', 'utf8');

diff --git a/a.js b/b.js
@@ -130,6 +139,16 @@ function removeAsync(dir) {
A blob:e0e3fd88544fff8906392369522757e3c23a235c
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rm(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rm');

    // Removal should fail without the recursive option set to true.
    fs.rm(dir, { recursive: false }, common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rm');

      // Recursive removal should succeed.
      fs.rm(dir, { recursive: true }, common.mustSucceed(() => {

        // Attempted removal should fail now because the directory is gone.
        fs.rm(dir, common.mustCall((err) => {
          assert.strictEqual(err.syscall, 'stat');
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Same test using URL instead of a path
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(pathToFileURL(dir));

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);

  // Should fail if target does not exist
  fs.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-async-file.txt');
  fs.writeFileSync(filePath, '');
  fs.rm(filePath, { recursive: true }, common.mustCall((err) => {
    try {
      assert.strictEqual(err, null);
      assert.strictEqual(fs.existsSync(filePath), false);
    } finally {
      fs.rmSync(filePath, { force: true });
    }
  }));
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
diff --git a/a.js b/b.js
@@ -179,6 +198,15 @@ function removeAsync(dir) {
A blob:e0e3fd88544fff8906392369522757e3c23a235c
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rm(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rm');

    // Removal should fail without the recursive option set to true.
    fs.rm(dir, { recursive: false }, common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rm');

      // Recursive removal should succeed.
      fs.rm(dir, { recursive: true }, common.mustSucceed(() => {

        // Attempted removal should fail now because the directory is gone.
        fs.rm(dir, common.mustCall((err) => {
          assert.strictEqual(err.syscall, 'stat');
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Same test using URL instead of a path
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(pathToFileURL(dir));

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);

  // Should fail if target does not exist
  fs.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-async-file.txt');
  fs.writeFileSync(filePath, '');
  fs.rm(filePath, { recursive: true }, common.mustCall((err) => {
    try {
      assert.strictEqual(err, null);
      assert.strictEqual(fs.existsSync(filePath), false);
    } finally {
      fs.rmSync(filePath, { force: true });
    }
  }));
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  assert.throws(() => {
    fs.rmSync(dir);
  }, { syscall: 'rm' });
  assert.throws(() => {
    fs.rmSync(dir, { recursive: false });
  }, { syscall: 'rm' });

  // Should fail if target does not exist
  assert.throws(() => {
    fs.rmSync(path.join(tmpdir.path, 'noexist.txt'), { recursive: true });
  }, {
    code: 'ENOENT',
    name: 'Error',
    message: /^ENOENT: no such file or directory, stat/
  });

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    fs.rmSync(filePath, { recursive: true });
  } finally {
    fs.rmSync(filePath, { force: true });
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    fs.rmSync(fileURL, { recursive: true });
  } finally {
    fs.rmSync(fileURL, { force: true });
  }

  // Recursive removal should succeed.
  fs.rmSync(dir, { recursive: true });

  // Attempted removal should fail now because the directory is gone.
  assert.throws(() => fs.rmSync(dir), { syscall: 'stat' });
}

// Test the Promises based version.
(async () => {
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
diff --git a/a.js b/b.js
@@ -230,6 +258,17 @@ function removeAsync(dir) {
A blob:e0e3fd88544fff8906392369522757e3c23a235c
      createSymLinks
    );
  }
}

function removeAsync(dir) {
  // Removal should fail without the recursive option.
  fs.rm(dir, common.mustCall((err) => {
    assert.strictEqual(err.syscall, 'rm');

    // Removal should fail without the recursive option set to true.
    fs.rm(dir, { recursive: false }, common.mustCall((err) => {
      assert.strictEqual(err.syscall, 'rm');

      // Recursive removal should succeed.
      fs.rm(dir, { recursive: true }, common.mustSucceed(() => {

        // Attempted removal should fail now because the directory is gone.
        fs.rm(dir, common.mustCall((err) => {
          assert.strictEqual(err.syscall, 'stat');
        }));
      }));
    }));
  }));
}

// Test the asynchronous version
{
  // Create a 4-level folder hierarchy including symlinks
  let dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
  removeAsync(dir);

  // Create a 2-level folder hierarchy without symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(dir);

  // Same test using URL instead of a path
  dir = nextDirPath();
  makeNonEmptyDirectory(2, 10, 2, dir, false);
  removeAsync(pathToFileURL(dir));

  // Create a flat folder including symlinks
  dir = nextDirPath();
  makeNonEmptyDirectory(1, 10, 2, dir, true);
  removeAsync(dir);

  // Should fail if target does not exist
  fs.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true },
    common.mustCall((err) => {
      assert.strictEqual(err.code, 'ENOENT');
    })
  );

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-async-file.txt');
  fs.writeFileSync(filePath, '');
  fs.rm(filePath, { recursive: true }, common.mustCall((err) => {
    try {
      assert.strictEqual(err, null);
      assert.strictEqual(fs.existsSync(filePath), false);
    } finally {
      fs.rmSync(filePath, { force: true });
    }
  }));
}

// Test the synchronous version.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  assert.throws(() => {
    fs.rmSync(dir);
  }, { syscall: 'rm' });
  assert.throws(() => {
    fs.rmSync(dir, { recursive: false });
  }, { syscall: 'rm' });

  // Should fail if target does not exist
  assert.throws(() => {
    fs.rmSync(path.join(tmpdir.path, 'noexist.txt'), { recursive: true });
  }, {
    code: 'ENOENT',
    name: 'Error',
    message: /^ENOENT: no such file or directory, stat/
  });

  // Should delete a file
  const filePath = path.join(tmpdir.path, 'rm-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    fs.rmSync(filePath, { recursive: true });
  } finally {
    fs.rmSync(filePath, { force: true });
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    fs.rmSync(fileURL, { recursive: true });
  } finally {
    fs.rmSync(fileURL, { force: true });
  }

  // Recursive removal should succeed.
  fs.rmSync(dir, { recursive: true });

  // Attempted removal should fail now because the directory is gone.
  assert.throws(() => fs.rmSync(dir), { syscall: 'stat' });
}

// Test the Promises based version.
(async () => {
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);

  // Removal should fail without the recursive option set to true.
  await assert.rejects(fs.promises.rm(dir), { syscall: 'rm' });
  await assert.rejects(fs.promises.rm(dir, { recursive: false }), {
    syscall: 'rm'
  });

  // Recursive removal should succeed.
  await fs.promises.rm(dir, { recursive: true });

  // Attempted removal should fail now because the directory is gone.
  await assert.rejects(fs.promises.rm(dir), { syscall: 'stat' });

  // Should fail if target does not exist
  await assert.rejects(fs.promises.rm(
    path.join(tmpdir.path, 'noexist.txt'),
    { recursive: true }
  ), {
    code: 'ENOENT',
    name: 'Error',
    message: /^ENOENT: no such file or directory, stat/
  });

  // Should not fail if target does not exist and force option is true
  await fs.promises.rm(path.join(tmpdir.path, 'noexist.txt'), { force: true });

  // Should delete file
  const filePath = path.join(tmpdir.path, 'rm-promises-file.txt');
  fs.writeFileSync(filePath, '');

  try {
    await fs.promises.rm(filePath, { recursive: true });
  } finally {
    fs.rmSync(filePath, { force: true });
  }

  // Should accept URL
  const fileURL = pathToFileURL(path.join(tmpdir.path, 'rm-promises-file.txt'));
  fs.writeFileSync(fileURL, '');

  try {
    await fs.promises.rm(fileURL, { recursive: true });
  } finally {
    fs.rmSync(fileURL, { force: true });
  }
})().then(common.mustCall());

// Test input validation.
{
  const dir = nextDirPath();
  makeNonEmptyDirectory(4, 10, 2, dir, true);
diff --git a/a.js b/b.js
@@ -87,6 +87,7 @@ create(context) {
A blob:ae6d71b80c99e3460f6ac61eefa21b57d7934514
        messages: {
            unexpected: "eval can be harmful."
        }
    },

    create(context) {
        const allowIndirect = Boolean(
            context.options[0] &&
            context.options[0].allowIndirect
        );
        const sourceCode = context.getSourceCode();
        let funcInfo = null;

        /**
         * Pushs a variable scope (Program or Function) information to the stack.
         *
         * This is used in order to check whether or not `this` binding is a
         * reference to the global object.
         * @param {ASTNode} node A node of the scope. This is one of Program,
         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
         * @returns {void}
         */
        function enterVarScope(node) {
            const strict = context.getScope().isStrict;

            funcInfo = {
                upper: funcInfo,
                node,
                strict,
                defaultThis: false,
                initialized: strict
            };
        }
diff --git a/a.js b/b.js
@@ -222,12 +223,14 @@ create(context) {
A blob:ae6d71b80c99e3460f6ac61eefa21b57d7934514
        messages: {
            unexpected: "eval can be harmful."
        }
    },

    create(context) {
        const allowIndirect = Boolean(
            context.options[0] &&
            context.options[0].allowIndirect
        );
        const sourceCode = context.getSourceCode();
        let funcInfo = null;

        /**
         * Pushs a variable scope (Program or Function) information to the stack.
         *
         * This is used in order to check whether or not `this` binding is a
         * reference to the global object.
         * @param {ASTNode} node A node of the scope. This is one of Program,
         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
         * @returns {void}
         */
        function enterVarScope(node) {
            const strict = context.getScope().isStrict;

            funcInfo = {
                upper: funcInfo,
                node,
                strict,
                defaultThis: false,
                initialized: strict
            };
        }

        /**
         * Pops a variable scope from the stack.
         * @returns {void}
         */
        function exitVarScope() {
            funcInfo = funcInfo.upper;
        }

        /**
         * Reports a given node.
         *
         * `node` is `Identifier` or `MemberExpression`.
         * The parent of `node` might be `CallExpression`.
         *
         * The location of the report is always `eval` `Identifier` (or possibly
         * `Literal`). The type of the report is `CallExpression` if the parent is
         * `CallExpression`. Otherwise, it's the given node type.
         * @param {ASTNode} node A node to report.
         * @returns {void}
         */
        function report(node) {
            const parent = node.parent;
            const locationNode = node.type === "MemberExpression"
                ? node.property
                : node;

            const reportNode = parent.type === "CallExpression" && parent.callee === node
                ? parent
                : node;

            context.report({
                node: reportNode,
                loc: locationNode.loc,
                messageId: "unexpected"
            });
        }

        /**
         * Reports accesses of `eval` via the global object.
         * @param {eslint-scope.Scope} globalScope The global scope.
         * @returns {void}
         */
        function reportAccessingEvalViaGlobalObject(globalScope) {
            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
                const name = candidatesOfGlobalObject[i];
                const variable = astUtils.getVariableByName(globalScope, name);

                if (!variable) {
                    continue;
                }

                const references = variable.references;

                for (let j = 0; j < references.length; ++j) {
                    const identifier = references[j].identifier;
                    let node = identifier.parent;

                    // To detect code like `window.window.eval`.
                    while (isMember(node, name)) {
                        node = node.parent;
                    }

                    // Reports.
                    if (isMember(node, "eval")) {
                        report(node);
                    }
                }
            }
        }

        /**
         * Reports all accesses of `eval` (excludes direct calls to eval).
         * @param {eslint-scope.Scope} globalScope The global scope.
         * @returns {void}
         */
        function reportAccessingEval(globalScope) {
            const variable = astUtils.getVariableByName(globalScope, "eval");

            if (!variable) {
                return;
            }

            const references = variable.references;

            for (let i = 0; i < references.length; ++i) {
                const reference = references[i];
                const id = reference.identifier;

                if (id.name === "eval" && !astUtils.isCallee(id)) {

                    // Is accessing to eval (excludes direct calls to eval)
                    report(id);
                }
            }
        }

        if (allowIndirect) {

            // Checks only direct calls to eval. It's simple!
            return {
                "CallExpression:exit"(node) {
                    const callee = node.callee;

                    /*
                     * Optional call (`eval?.("code")`) is not direct eval.
                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation
                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation
                     */
                    if (!node.optional && astUtils.isSpecificId(callee, "eval")) {
                        report(callee);
                    }
                }
            };
        }

        return {
            "CallExpression:exit"(node) {
                const callee = node.callee;

                if (astUtils.isSpecificId(callee, "eval")) {
                    report(callee);
                }
            },

            Program(node) {
                const scope = context.getScope(),
                    features = context.parserOptions.ecmaFeatures || {},
                    strict =
                        scope.isStrict ||
                        node.sourceType === "module" ||
                        (features.globalReturn && scope.childScopes[0].isStrict);

                funcInfo = {
                    upper: null,
                    node,
                    strict,
                    defaultThis: true,
                    initialized: true
                };
            },
diff --git a/a.js b/b.js
@@ -269,7 +272,8 @@ create(context) {
A blob:ae6d71b80c99e3460f6ac61eefa21b57d7934514
        messages: {
            unexpected: "eval can be harmful."
        }
    },

    create(context) {
        const allowIndirect = Boolean(
            context.options[0] &&
            context.options[0].allowIndirect
        );
        const sourceCode = context.getSourceCode();
        let funcInfo = null;

        /**
         * Pushs a variable scope (Program or Function) information to the stack.
         *
         * This is used in order to check whether or not `this` binding is a
         * reference to the global object.
         * @param {ASTNode} node A node of the scope. This is one of Program,
         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
         * @returns {void}
         */
        function enterVarScope(node) {
            const strict = context.getScope().isStrict;

            funcInfo = {
                upper: funcInfo,
                node,
                strict,
                defaultThis: false,
                initialized: strict
            };
        }

        /**
         * Pops a variable scope from the stack.
         * @returns {void}
         */
        function exitVarScope() {
            funcInfo = funcInfo.upper;
        }

        /**
         * Reports a given node.
         *
         * `node` is `Identifier` or `MemberExpression`.
         * The parent of `node` might be `CallExpression`.
         *
         * The location of the report is always `eval` `Identifier` (or possibly
         * `Literal`). The type of the report is `CallExpression` if the parent is
         * `CallExpression`. Otherwise, it's the given node type.
         * @param {ASTNode} node A node to report.
         * @returns {void}
         */
        function report(node) {
            const parent = node.parent;
            const locationNode = node.type === "MemberExpression"
                ? node.property
                : node;

            const reportNode = parent.type === "CallExpression" && parent.callee === node
                ? parent
                : node;

            context.report({
                node: reportNode,
                loc: locationNode.loc,
                messageId: "unexpected"
            });
        }

        /**
         * Reports accesses of `eval` via the global object.
         * @param {eslint-scope.Scope} globalScope The global scope.
         * @returns {void}
         */
        function reportAccessingEvalViaGlobalObject(globalScope) {
            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
                const name = candidatesOfGlobalObject[i];
                const variable = astUtils.getVariableByName(globalScope, name);

                if (!variable) {
                    continue;
                }

                const references = variable.references;

                for (let j = 0; j < references.length; ++j) {
                    const identifier = references[j].identifier;
                    let node = identifier.parent;

                    // To detect code like `window.window.eval`.
                    while (isMember(node, name)) {
                        node = node.parent;
                    }

                    // Reports.
                    if (isMember(node, "eval")) {
                        report(node);
                    }
                }
            }
        }

        /**
         * Reports all accesses of `eval` (excludes direct calls to eval).
         * @param {eslint-scope.Scope} globalScope The global scope.
         * @returns {void}
         */
        function reportAccessingEval(globalScope) {
            const variable = astUtils.getVariableByName(globalScope, "eval");

            if (!variable) {
                return;
            }

            const references = variable.references;

            for (let i = 0; i < references.length; ++i) {
                const reference = references[i];
                const id = reference.identifier;

                if (id.name === "eval" && !astUtils.isCallee(id)) {

                    // Is accessing to eval (excludes direct calls to eval)
                    report(id);
                }
            }
        }

        if (allowIndirect) {

            // Checks only direct calls to eval. It's simple!
            return {
                "CallExpression:exit"(node) {
                    const callee = node.callee;

                    /*
                     * Optional call (`eval?.("code")`) is not direct eval.
                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation
                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation
                     */
                    if (!node.optional && astUtils.isSpecificId(callee, "eval")) {
                        report(callee);
                    }
                }
            };
        }

        return {
            "CallExpression:exit"(node) {
                const callee = node.callee;

                if (astUtils.isSpecificId(callee, "eval")) {
                    report(callee);
                }
            },

            Program(node) {
                const scope = context.getScope(),
                    features = context.parserOptions.ecmaFeatures || {},
                    strict =
                        scope.isStrict ||
                        node.sourceType === "module" ||
                        (features.globalReturn && scope.childScopes[0].isStrict);

                funcInfo = {
                    upper: null,
                    node,
                    strict,
                    defaultThis: true,
                    initialized: true
                };
            },

            "Program:exit"() {
                const globalScope = context.getScope();

                exitVarScope();
                reportAccessingEval(globalScope);
                reportAccessingEvalViaGlobalObject(globalScope);
            },

            FunctionDeclaration: enterVarScope,
            "FunctionDeclaration:exit": exitVarScope,
            FunctionExpression: enterVarScope,
            "FunctionExpression:exit": exitVarScope,
            ArrowFunctionExpression: enterVarScope,
            "ArrowFunctionExpression:exit": exitVarScope,
            "PropertyDefinition > *.value": enterVarScope,
            "PropertyDefinition > *.value:exit": exitVarScope,
            StaticBlock: enterVarScope,
            "StaticBlock:exit": exitVarScope,

            ThisExpression(node) {
                if (!isMember(node.parent, "eval")) {
                    return;
                }

                /*
                 * `this.eval` is found.
                 * Checks whether or not the value of `this` is the global object.
                 */
                if (!funcInfo.initialized) {
                    funcInfo.initialized = true;
                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(
                        funcInfo.node,
                        sourceCode
                    );
                }

                if (!funcInfo.strict && funcInfo.defaultThis) {

                    // `this.eval` is possible built-in `eval`.
                    report(node.parent);
                }
diff --git a/a.js b/b.js
@@ -1,5 +1,5 @@
A blob:64e4d964a8444bdfb4e0745bb45b61cc1778dd26
/**
 * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.
 * @author Toru Nagashima
 */

"use strict";
diff --git a/a.js b/b.js
@@ -36,7 +36,7 @@ function isCodePathWithLexicalThis(codePath, node) {
A blob:64e4d964a8444bdfb4e0745bb45b61cc1778dd26
 * That is, if `this` within the code path refers to `this` of surrounding code path.
 * @param {CodePath} codePath Code path.
 * @param {ASTNode} node Node that started the code path.
 * @returns {boolean} `true` if it is a code path with lexical `this` binding.
 */
function isCodePathWithLexicalThis(codePath, node) {
    return codePath.origin === "function" && node.type === "ArrowFunctionExpression";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "disallow `this` keywords outside of classes or class-like objects",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-invalid-this"
        },

diff --git a/a.js b/b.js
@@ -98,11 +98,11 @@         stack.getCurrent = function() {
A blob:64e4d964a8444bdfb4e0745bb45b61cc1778dd26
         * The return value has a flag that whether or not `this` keyword is valid.
         * The flag is initialized when got at the first time.
         * @returns {{valid: boolean}}
         *   an object which has a flag that whether or not `this` keyword is valid.
         */
        stack.getCurrent = function() {
            const current = this[this.length - 1];

            if (!current.init) {
                current.init = true;
                current.valid = !astUtils.isDefaultThisBinding(
                    current.node,
                    sourceCode,
                    { capIsConstructor }
                );
            }
            return current;
        };

        return {

            onCodePathStart(codePath, node) {
                if (isCodePathWithLexicalThis(codePath, node)) {
                    return;
                }

                if (codePath.origin === "program") {
                    const scope = context.getScope();
                    const features = context.parserOptions.ecmaFeatures || {};

                    stack.push({
                        init: true,
                        node,
                        valid: !(
                            scope.isStrict ||
                            node.sourceType === "module" ||
                            (features.globalReturn && scope.childScopes[0].isStrict)
                        )
                    });
diff --git a/a.js b/b.js
@@ -450,8 +450,7 @@ function verifyForAlways(context, prevNode, nextNode, paddingLines) {
A blob:fe5d304dd5b6130a09d28a0336f70c8e22ba2bfb
 * @param {Array<Token[]>} paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns {void}
 * @private
 */
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
    if (paddingLines.length > 0) {
        return;
    }

    context.report({
        node: nextNode,
        messageId: "expectedBlankLine",
        fix(fixer) {
            const sourceCode = context.getSourceCode();
            let prevToken = getActualLastToken(sourceCode, prevNode);
            const nextToken = sourceCode.getFirstTokenBetween(
                prevToken,
                nextNode,
                {
                    includeComments: true,

                    /**
                     * Skip the trailing comments of the previous node.
                     * This inserts a blank line after the last trailing comment.
                     *
                     * For example:
                     *
                     *     foo(); // trailing comment.
                     *     // comment.
                     *     bar();
                     *
                     * Get fixed to:
                     *
                     *     foo(); // trailing comment.
                     *
                     *     // comment.
                     *     bar();
                     * @param {Token} token The token to check.
                     * @returns {boolean} `true` if the token is not a trailing comment.
                     * @private
                     */
                    filter(token) {
                        if (astUtils.isTokenOnSameLine(prevToken, token)) {
                            prevToken = token;
                            return false;
                        }
                        return true;
                    }
                }
            ) || nextNode;
            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)
                ? "\n\n"
                : "\n";

            return fixer.insertTextAfter(prevToken, insertText);
        }
    });
}

/**
 * Types of blank lines.
 * `any`, `never`, and `always` are defined.
 * Those have `verify` method to check and report statements.
 * @private
 */
const PaddingTypes = {
    any: { verify: verifyForAny },
    never: { verify: verifyForNever },
    always: { verify: verifyForAlways }
};

/**
 * Types of statements.
 * Those have `test` method to check it matches to the given statement.
 * @private
 */
const StatementTypes = {
    "*": { test: () => true },
    "block-like": {
        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
    },
    "cjs-export": {
        test: (node, sourceCode) =>
            node.type === "ExpressionStatement" &&
            node.expression.type === "AssignmentExpression" &&
            CJS_EXPORT.test(sourceCode.getText(node.expression.left))
    },
    "cjs-import": {
        test: (node, sourceCode) =>
            node.type === "VariableDeclaration" &&
            node.declarations.length > 0 &&
            Boolean(node.declarations[0].init) &&
            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
    },
    directive: {
        test: isDirectivePrologue
    },
    expression: {
        test: (node, sourceCode) =>
            node.type === "ExpressionStatement" &&
            !isDirectivePrologue(node, sourceCode)
    },
    iife: {
        test: isIIFEStatement
    },
    "multiline-block-like": {
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            isBlockLikeStatement(sourceCode, node)
    },
    "multiline-expression": {
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            node.type === "ExpressionStatement" &&
            !isDirectivePrologue(node, sourceCode)
    },

    "multiline-const": newMultilineKeywordTester("const"),
    "multiline-let": newMultilineKeywordTester("let"),
    "multiline-var": newMultilineKeywordTester("var"),
    "singleline-const": newSinglelineKeywordTester("const"),
    "singleline-let": newSinglelineKeywordTester("let"),
    "singleline-var": newSinglelineKeywordTester("var"),

    block: newNodeTypeTester("BlockStatement"),
    empty: newNodeTypeTester("EmptyStatement"),
    function: newNodeTypeTester("FunctionDeclaration"),

    break: newKeywordTester("break"),
    case: newKeywordTester("case"),
    class: newKeywordTester("class"),
    const: newKeywordTester("const"),
    continue: newKeywordTester("continue"),
    debugger: newKeywordTester("debugger"),
    default: newKeywordTester("default"),
    do: newKeywordTester("do"),
    export: newKeywordTester("export"),
    for: newKeywordTester("for"),
    if: newKeywordTester("if"),
    import: newKeywordTester("import"),
    let: newKeywordTester("let"),
    return: newKeywordTester("return"),
    switch: newKeywordTester("switch"),
    throw: newKeywordTester("throw"),
    try: newKeywordTester("try"),
    var: newKeywordTester("var"),
    while: newKeywordTester("while"),
    with: newKeywordTester("with")
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "require or disallow padding lines between statements",
            recommended: false,
            url: "https://eslint.org/docs/rules/padding-line-between-statements"
        },

        fixable: "whitespace",

        schema: {
            definitions: {
                paddingType: {
                    enum: Object.keys(PaddingTypes)
                },
                statementType: {
                    anyOf: [
                        { enum: Object.keys(StatementTypes) },
                        {
                            type: "array",
                            items: { enum: Object.keys(StatementTypes) },
                            minItems: 1,
                            uniqueItems: true,
                            additionalItems: false
                        }
                    ]
                }
            },
diff --git a/a.js b/b.js
@@ -466,8 +465,7 @@ function verifyForAlways(context, prevNode, nextNode, paddingLines) {
A blob:fe5d304dd5b6130a09d28a0336f70c8e22ba2bfb
 * @param {Array<Token[]>} paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns {void}
 * @private
 */
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
    if (paddingLines.length > 0) {
        return;
    }

    context.report({
        node: nextNode,
        messageId: "expectedBlankLine",
        fix(fixer) {
            const sourceCode = context.getSourceCode();
            let prevToken = getActualLastToken(sourceCode, prevNode);
            const nextToken = sourceCode.getFirstTokenBetween(
                prevToken,
                nextNode,
                {
                    includeComments: true,

                    /**
                     * Skip the trailing comments of the previous node.
                     * This inserts a blank line after the last trailing comment.
                     *
                     * For example:
                     *
                     *     foo(); // trailing comment.
                     *     // comment.
                     *     bar();
                     *
                     * Get fixed to:
                     *
                     *     foo(); // trailing comment.
                     *
                     *     // comment.
                     *     bar();
                     * @param {Token} token The token to check.
                     * @returns {boolean} `true` if the token is not a trailing comment.
                     * @private
                     */
                    filter(token) {
                        if (astUtils.isTokenOnSameLine(prevToken, token)) {
                            prevToken = token;
                            return false;
                        }
                        return true;
                    }
                }
            ) || nextNode;
            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)
                ? "\n\n"
                : "\n";

            return fixer.insertTextAfter(prevToken, insertText);
        }
    });
}

/**
 * Types of blank lines.
 * `any`, `never`, and `always` are defined.
 * Those have `verify` method to check and report statements.
 * @private
 */
const PaddingTypes = {
    any: { verify: verifyForAny },
    never: { verify: verifyForNever },
    always: { verify: verifyForAlways }
};

/**
 * Types of statements.
 * Those have `test` method to check it matches to the given statement.
 * @private
 */
const StatementTypes = {
    "*": { test: () => true },
    "block-like": {
        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
    },
    "cjs-export": {
        test: (node, sourceCode) =>
            node.type === "ExpressionStatement" &&
            node.expression.type === "AssignmentExpression" &&
            CJS_EXPORT.test(sourceCode.getText(node.expression.left))
    },
    "cjs-import": {
        test: (node, sourceCode) =>
            node.type === "VariableDeclaration" &&
            node.declarations.length > 0 &&
            Boolean(node.declarations[0].init) &&
            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
    },
    directive: {
        test: isDirectivePrologue
    },
    expression: {
        test: (node, sourceCode) =>
            node.type === "ExpressionStatement" &&
            !isDirectivePrologue(node, sourceCode)
    },
    iife: {
        test: isIIFEStatement
    },
    "multiline-block-like": {
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            isBlockLikeStatement(sourceCode, node)
    },
    "multiline-expression": {
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            node.type === "ExpressionStatement" &&
            !isDirectivePrologue(node, sourceCode)
    },

    "multiline-const": newMultilineKeywordTester("const"),
    "multiline-let": newMultilineKeywordTester("let"),
    "multiline-var": newMultilineKeywordTester("var"),
    "singleline-const": newSinglelineKeywordTester("const"),
    "singleline-let": newSinglelineKeywordTester("let"),
    "singleline-var": newSinglelineKeywordTester("var"),

    block: newNodeTypeTester("BlockStatement"),
    empty: newNodeTypeTester("EmptyStatement"),
    function: newNodeTypeTester("FunctionDeclaration"),

    break: newKeywordTester("break"),
    case: newKeywordTester("case"),
    class: newKeywordTester("class"),
    const: newKeywordTester("const"),
    continue: newKeywordTester("continue"),
    debugger: newKeywordTester("debugger"),
    default: newKeywordTester("default"),
    do: newKeywordTester("do"),
    export: newKeywordTester("export"),
    for: newKeywordTester("for"),
    if: newKeywordTester("if"),
    import: newKeywordTester("import"),
    let: newKeywordTester("let"),
    return: newKeywordTester("return"),
    switch: newKeywordTester("switch"),
    throw: newKeywordTester("throw"),
    try: newKeywordTester("try"),
    var: newKeywordTester("var"),
    while: newKeywordTester("while"),
    with: newKeywordTester("with")
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "require or disallow padding lines between statements",
            recommended: false,
            url: "https://eslint.org/docs/rules/padding-line-between-statements"
        },

        fixable: "whitespace",

        schema: {
            definitions: {
                paddingType: {
                    enum: Object.keys(PaddingTypes)
                },
                statementType: {
                    anyOf: [
                        { enum: Object.keys(StatementTypes) },
                        {
                            type: "array",
                            items: { enum: Object.keys(StatementTypes) },
                            minItems: 1,
                            uniqueItems: true,
                            additionalItems: false
                        }
                    ]
                }
            },
            type: "array",
            items: {
                type: "object",
                properties: {
                    blankLine: { $ref: "#/definitions/paddingType" },
                    prev: { $ref: "#/definitions/statementType" },
                    next: { $ref: "#/definitions/statementType" }
                },
                additionalProperties: false,
                required: ["blankLine", "prev", "next"]
            },
            additionalItems: false
        },

        messages: {
            unexpectedBlankLine: "Unexpected blank line before this statement.",
diff --git a/a.js b/b.js
@@ -247,7 +247,7 @@   _template = function () {
A blob:f25de7340e4befbe56ef9d07ec2c7cb9eec094a6
}

function _template() {
  const data = require("@babel/template");

  _template = function () {
    return data;
  };

  return data;
}

var _config = require("./config");

var _transform = require("./transform");

var _transformFile = require("./transform-file");

var _transformAst = require("./transform-ast");

var _parse = require("./parse");

const version = "7.17.5";
exports.version = version;
const DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
exports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;

diff --git a/a.js b/b.js
@@ -171,38 +171,43 @@ function ExportDeclaration(node) {
A blob:7a3cc26757cc511b59d703085f42d6904d10ac3a
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    const specifiers = node.specifiers.slice(0);
    let hasSpecial = false;

    for (;;) {
      const first = specifiers[0];

      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);

        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length || !specifiers.length && !hasSpecial) {
      this.token("{");

      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }

      this.token("}");
    }

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
      this.printAssertions(node);
    }

    this.semicolon();
  }
}

function ImportDeclaration(node) {
  this.word("import");
  this.space();

  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  const specifiers = node.specifiers.slice(0);

  if (specifiers != null && specifiers.length) {
    for (;;) {
      const first = specifiers[0];

      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift(), node);

        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }

    this.space();
    this.word("from");
    this.space();
  }
diff --git a/a.js b/b.js
@@ -174,7 +174,7 @@ function resolveTargets(queries, env) {
A blob:c1865996afd788f39cb048f915c2c13ca8fc78d4
  delete input.esmodules;
  delete input.browsers;
  return input;
}

function resolveTargets(queries, env) {
  const resolved = _browserslist(queries, {
    mobileToDesktop: true,
    env
  });

  return getLowestVersions(resolved);
}

function getTargets(inputTargets = {}, options = {}) {
  var _browsers;

  let {
    browsers,
    esmodules
diff --git a/a.js b/b.js
@@ -209,7 +209,7 @@ function getTargets(inputTargets = {}, options = {}) {
A blob:c1865996afd788f39cb048f915c2c13ca8fc78d4
  });

  return getLowestVersions(resolved);
}

function getTargets(inputTargets = {}, options = {}) {
  var _browsers;

  let {
    browsers,
    esmodules
  } = inputTargets;
  const {
    configPath = "."
  } = options;
  validateBrowsers(browsers);
  const input = generateTargets(inputTargets);
  let targets = validateTargetNames(input);
  const shouldParseBrowsers = !!browsers;
  const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
  const shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

  if (!browsers && shouldSearchForConfig) {
    browsers = _browserslist.loadConfig({
      config: options.configFile,
      path: configPath,
      env: options.browserslistEnv
    });

    if (browsers == null) {
      {
        browsers = [];
      }
    }
  }

  if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
    browsers = Object.keys(ESM_SUPPORT).map(browser => `${browser} >= ${ESM_SUPPORT[browser]}`).join(", ");
    esmodules = false;
  }

  if (browsers) {
    const queryBrowsers = resolveTargets(browsers, options.browserslistEnv);

    if (esmodules === "intersect") {
      for (const browser of Object.keys(queryBrowsers)) {
diff --git a/a.js b/b.js
@@ -369,7 +369,9 @@ function buildExportInitializationStatements(programPath, metadata, constantReex
A blob:b9688eb6078d13ad67794d0e66a0c215a667f2d5
    name: name.name,
    statement: variableDeclaration("var", [variableDeclarator(name, valueToNode(exportedVars))])
  };
}

function buildExportInitializationStatements(programPath, metadata, constantReexports = false, noIncompleteNsImportDetection = false) {
  const initStatements = [];

  for (const [localName, data] of metadata.local) {
    if (data.kind === "import") {} else if (data.kind === "hoisted") {
      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);
    } else if (!noIncompleteNsImportDetection) {
      for (const exportName of data.names) {
        initStatements.push([exportName, null]);
      }
    }
  }

  for (const data of metadata.source.values()) {
    if (!constantReexports) {
      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);
      const reexports = [...data.reexports.keys()];

      for (let i = 0; i < reexportsStatements.length; i++) {
        initStatements.push([reexports[i], reexportsStatements[i]]);
      }
    }

    if (!noIncompleteNsImportDetection) {
      for (const exportName of data.reexportNamespace) {
        initStatements.push([exportName, null]);
      }
    }
  }

  initStatements.sort(([a], [b]) => {
    if (a < b) return -1;
    if (b < a) return 1;
    return 0;
  });
  const results = [];

  if (noIncompleteNsImportDetection) {
    for (const [, initStatement] of initStatements) {
      results.push(initStatement);
    }
  } else {
    const chunkSize = 100;

    for (let i = 0, uninitializedExportNames = []; i < initStatements.length; i += chunkSize) {
      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
        const [exportName, initStatement] = initStatements[i + j];

        if (initStatement !== null) {
diff --git a/a.js b/b.js
@@ -90,7 +90,7 @@ function rewriteLiveReferences(programPath, metadata) {
A blob:8173fd57f24011175fa6970c64238ffd4aff5ce1

    }
  } while (path = path.parentPath);
}

function rewriteLiveReferences(programPath, metadata) {
  const imported = new Map();
  const exported = new Map();

  const requeueInParent = path => {
    programPath.requeue(path);
  };

  for (const [source, data] of metadata.source) {
    for (const [localName, importName] of data.imports) {
      imported.set(localName, [source, importName, null]);
    }

    for (const localName of data.importsNamespace) {
      imported.set(localName, [source, null, localName]);
    }
  }

  for (const [local, data] of metadata.local) {
    let exportMeta = exported.get(local);

    if (!exportMeta) {
      exportMeta = [];
      exported.set(local, exportMeta);
    }

    exportMeta.push(...data.names);
  }

  const rewriteBindingInitVisitorState = {
    metadata,
    requeueInParent,
    scope: programPath.scope,
    exported
  };
  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));
  const rewriteReferencesVisitorState = {
    seen: new WeakSet(),
    metadata,
    requeueInParent,
diff --git a/a.js b/b.js
@@ -230,6 +230,47 @@ ReferencedIdentifier(path) {
A blob:8173fd57f24011175fa6970c64238ffd4aff5ce1
    })()
  `;
};

const rewriteReferencesVisitor = {
  ReferencedIdentifier(path) {
    const {
      seen,
      buildImportReference,
      scope,
      imported,
      requeueInParent
    } = this;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    const localName = path.node.name;
    const importData = imported.get(localName);

    if (importData) {
      if (isInType(path)) {
        throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
      }

      const localBinding = path.scope.getBinding(localName);
      const rootBinding = scope.getBinding(localName);
      if (rootBinding !== localBinding) return;
      const ref = buildImportReference(importData, path.node);
      ref.loc = path.node.loc;

      if ((path.parentPath.isCallExpression({
        callee: path.node
      }) || path.parentPath.isOptionalCallExpression({
        callee: path.node
      }) || path.parentPath.isTaggedTemplateExpression({
        tag: path.node
      })) && isMemberExpression(ref)) {
        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));
      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
        const {
          object,
          property
        } = ref;
        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
      } else {
        path.replaceWith(ref);
      }

      requeueInParent(path);
      path.skip();
    }
  },

  AssignmentExpression: {
    exit(path) {
      const {
        scope,
diff --git a/a.js b/b.js
@@ -19,11 +19,12 @@
A blob:69bacda62d33f4861fab594fe0a471fef80f626b
  identifier,
  logicalExpression,
  numericLiteral,
  sequenceExpression,
  unaryExpression
} = _t;

function simplifyAccess(path, bindingNames) {
  path.traverse(simpleAssignmentVisitor, {
    scope: path.scope,
    bindingNames,
    seen: new WeakSet()
  });
}

const simpleAssignmentVisitor = {
diff --git a/a.js b/b.js
@@ -32,8 +33,14 @@ function simplifyAccess(path, bindingNames) {
A blob:69bacda62d33f4861fab594fe0a471fef80f626b
  numericLiteral,
  sequenceExpression,
  unaryExpression
} = _t;

function simplifyAccess(path, bindingNames) {
  path.traverse(simpleAssignmentVisitor, {
    scope: path.scope,
    bindingNames,
    seen: new WeakSet()
  });
}

const simpleAssignmentVisitor = {
  UpdateExpression: {
    exit(path) {
      const {
        scope,
        bindingNames
      } = this;
      const arg = path.get("argument");
      if (!arg.isIdentifier()) return;
      const localName = arg.node.name;
      if (!bindingNames.has(localName)) return;
diff --git a/a.js b/b.js
@@ -15,7 +15,7 @@ function helper(minVersion, source) {
A blob:9ef543e009a0b0b3965658b580451ec132b989ca
});
exports.default = void 0;

var _template = require("@babel/template");

function helper(minVersion, source) {
  return Object.freeze({
    minVersion,
    ast: () => _template.default.program.ast(source)
  });
}

var _default = Object.freeze({
  applyDecs: helper("7.17.0", 'function createMetadataMethodsForProperty(metadataMap,kind,property){return{getMetadata:function(key){if("symbol"!=typeof key)throw new TypeError("Metadata keys must be symbols, received: "+key);var metadataForKey=metadataMap[key];if(void 0!==metadataForKey)if(1===kind){var pub=metadataForKey.public;if(void 0!==pub)return pub[property]}else if(2===kind){var priv=metadataForKey.private;if(void 0!==priv)return priv.get(property)}else if(Object.hasOwnProperty.call(metadataForKey,"constructor"))return metadataForKey.constructor},setMetadata:function(key,value){if("symbol"!=typeof key)throw new TypeError("Metadata keys must be symbols, received: "+key);var metadataForKey=metadataMap[key];if(void 0===metadataForKey&&(metadataForKey=metadataMap[key]={}),1===kind){var pub=metadataForKey.public;void 0===pub&&(pub=metadataForKey.public={}),pub[property]=value}else if(2===kind){var priv=metadataForKey.priv;void 0===priv&&(priv=metadataForKey.private=new Map),priv.set(property,value)}else metadataForKey.constructor=value}}}function convertMetadataMapToFinal(obj,metadataMap){var parentMetadataMap=obj[Symbol.metadata||Symbol.for("Symbol.metadata")],metadataKeys=Object.getOwnPropertySymbols(metadataMap);if(0!==metadataKeys.length){for(var i=0;i<metadataKeys.length;i++){var key=metadataKeys[i],metaForKey=metadataMap[key],parentMetaForKey=parentMetadataMap?parentMetadataMap[key]:null,pub=metaForKey.public,parentPub=parentMetaForKey?parentMetaForKey.public:null;pub&&parentPub&&Object.setPrototypeOf(pub,parentPub);var priv=metaForKey.private;if(priv){var privArr=Array.from(priv.values()),parentPriv=parentMetaForKey?parentMetaForKey.private:null;parentPriv&&(privArr=privArr.concat(parentPriv)),metaForKey.private=privArr}parentMetaForKey&&Object.setPrototypeOf(metaForKey,parentMetaForKey)}parentMetadataMap&&Object.setPrototypeOf(metadataMap,parentMetadataMap),obj[Symbol.metadata||Symbol.for("Symbol.metadata")]=metadataMap}}function createAddInitializerMethod(initializers){return function(initializer){assertValidInitializer(initializer),initializers.push(initializer)}}function memberDecCtx(base,name,desc,metadataMap,initializers,kind,isStatic,isPrivate){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var metadataKind,metadataName,ctx={kind:kindStr,name:isPrivate?"#"+name:name,isStatic:isStatic,isPrivate:isPrivate};if(0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers)),isPrivate){metadataKind=2,metadataName=Symbol(name);var access={};0===kind?(access.get=desc.get,access.set=desc.set):2===kind?access.get=function(){return desc.value}:(1!==kind&&3!==kind||(access.get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(access.set=function(v){desc.set.call(this,v)})),ctx.access=access}else metadataKind=1,metadataName=name;return Object.assign(ctx,createMetadataMethodsForProperty(metadataMap,metadataKind,metadataName))}function assertValidInitializer(initializer){if("function"!=typeof initializer)throw new Error("initializers must be functions")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new Error("accessor decorators must return an object with get, set, or initializer properties or void 0")}else if("function"!==type)throw 0===kind?new Error("field decorators must return a initializer function or void 0"):new Error("method decorators must return a function or void 0")}function applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers){var desc,initializer,value,decs=decInfo[0];isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set);var newValue,get,set,ctx=memberDecCtx(base,name,desc,metadataMap,initializers,kind,isStatic,isPrivate);if("function"==typeof decs)void 0!==(newValue=decs(value,ctx))&&(assertValidReturnValue(kind,newValue),0===kind?initializer=newValue:1===kind?(initializer=newValue.initializer,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=(0,decs[i])(value,ctx)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=newValue.initializer,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===initializer?initializer=newInit:"function"==typeof initializer?initializer=[initializer,newInit]:initializer.push(newInit))}if(0===kind||1===kind){if(void 0===initializer)initializer=function(instance,init){return init};else if("function"!=typeof initializer){var ownInitializers=initializer;initializer=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=initializer;initializer=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(initializer)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function applyMemberDecs(ret,Class,protoMetadataMap,staticMetadataMap,decInfos){for(var protoInitializers=[],staticInitializers=[],existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,metadataMap,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,metadataMap=staticMetadataMap,kind-=5,initializers=staticInitializers):(base=Class.prototype,metadataMap=protoMetadataMap,initializers=protoInitializers),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers)}}protoInitializers.length>0&&pushInitializers(ret,protoInitializers),staticInitializers.length>0&&pushInitializers(ret,staticInitializers)}function pushInitializers(ret,initializers){initializers.length>0?(initializers=initializers.slice(),ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance,instance);return instance}))):ret.push((function(instance){return instance}))}function applyClassDecs(ret,targetClass,metadataMap,classDecs){for(var initializers=[],newClass=targetClass,name=targetClass.name,ctx=Object.assign({kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers)},createMetadataMethodsForProperty(metadataMap,0,name)),i=classDecs.length-1;i>=0;i--)newClass=classDecs[i](newClass,ctx)||newClass;ret.push(newClass),initializers.length>0?ret.push((function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass,newClass)})):ret.push((function(){}))}export default function applyDecs(targetClass,memberDecs,classDecs){var ret=[],staticMetadataMap={};if(memberDecs){var protoMetadataMap={};applyMemberDecs(ret,targetClass,protoMetadataMap,staticMetadataMap,memberDecs),convertMetadataMapToFinal(targetClass.prototype,protoMetadataMap)}return classDecs&&applyClassDecs(ret,targetClass,staticMetadataMap,classDecs),convertMetadataMapToFinal(targetClass,staticMetadataMap),ret}'),
  asyncIterator: helper("7.15.9", 'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'),
  jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'),
  objectSpread2: helper("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'),
  typeof: helper("7.0.0-beta.0", 'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'),
diff --git a/a.js b/b.js
@@ -5,13 +5,11 @@
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyDecs;

function createMetadataMethodsForProperty(metadataMap, kind, property) {
  return {
    getMetadata: function (key) {
      if (typeof key !== "symbol") {
        throw new TypeError("Metadata keys must be symbols, received: " + key);
      }

      var metadataForKey = metadataMap[key];
      if (metadataForKey === void 0) return void 0;

      if (kind === 1) {
diff --git a/a.js b/b.js
@@ -32,10 +30,8 @@ getMetadata: function (key) {
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
});
exports.default = applyDecs;

function createMetadataMethodsForProperty(metadataMap, kind, property) {
  return {
    getMetadata: function (key) {
      if (typeof key !== "symbol") {
        throw new TypeError("Metadata keys must be symbols, received: " + key);
      }

      var metadataForKey = metadataMap[key];
      if (metadataForKey === void 0) return void 0;

      if (kind === 1) {
        var pub = metadataForKey.public;

        if (pub !== void 0) {
          return pub[property];
        }
      } else if (kind === 2) {
        var priv = metadataForKey.private;

        if (priv !== void 0) {
          return priv.get(property);
        }
      } else if (Object.hasOwnProperty.call(metadataForKey, "constructor")) {
        return metadataForKey.constructor;
      }
    },
    setMetadata: function (key, value) {
      if (typeof key !== "symbol") {
        throw new TypeError("Metadata keys must be symbols, received: " + key);
      }

      var metadataForKey = metadataMap[key];

      if (metadataForKey === void 0) {
        metadataForKey = metadataMap[key] = {};
diff --git a/a.js b/b.js
@@ -106,14 +102,15 @@ function convertMetadataMapToFinal(obj, metadataMap) {
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      }
    }
  };
}

function convertMetadataMapToFinal(obj, metadataMap) {
  var parentMetadataMap = obj[Symbol.metadata || Symbol.for("Symbol.metadata")];
  var metadataKeys = Object.getOwnPropertySymbols(metadataMap);
  if (metadataKeys.length === 0) return;

  for (var i = 0; i < metadataKeys.length; i++) {
    var key = metadataKeys[i];
    var metaForKey = metadataMap[key];
    var parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null;
    var pub = metaForKey.public;
    var parentPub = parentMetaForKey ? parentMetaForKey.public : null;

    if (pub && parentPub) {
      Object.setPrototypeOf(pub, parentPub);
    }

    var priv = metaForKey.private;

    if (priv) {
      var privArr = Array.from(priv.values());
      var parentPriv = parentMetaForKey ? parentMetaForKey.private : null;

      if (parentPriv) {
        privArr = privArr.concat(parentPriv);
      }

      metaForKey.private = privArr;
    }

    if (parentMetaForKey) {
      Object.setPrototypeOf(metaForKey, parentMetaForKey);
    }
  }

  if (parentMetadataMap) {
    Object.setPrototypeOf(metadataMap, parentMetadataMap);
  }

  obj[Symbol.metadata || Symbol.for("Symbol.metadata")] = metadataMap;
}

function createAddInitializerMethod(initializers) {
  return function addInitializer(initializer) {
    assertValidInitializer(initializer);
    initializers.push(initializer);
  };
}

function memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate) {
  var kindStr;

  switch (kind) {
    case 1:
diff --git a/a.js b/b.js
@@ -143,9 +140,12 @@ function memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStati
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
    assertValidInitializer(initializer);
    initializers.push(initializer);
  };
}

function memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate) {
  var kindStr;

  switch (kind) {
    case 1:
      kindStr = "accessor";
      break;

    case 2:
      kindStr = "method";
      break;

    case 3:
      kindStr = "getter";
      break;

    case 4:
      kindStr = "setter";
      break;

    default:
      kindStr = "field";
  }

  var ctx = {
    kind: kindStr,
    name: isPrivate ? "#" + name : name,
    isStatic: isStatic,
    isPrivate: isPrivate
  };

  if (kind !== 0) {
    ctx.addInitializer = createAddInitializerMethod(initializers);
  }

  var metadataKind, metadataName;

diff --git a/a.js b/b.js
@@ -182,12 +182,28 @@         access.set = function (v) {
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
          return desc.get.call(this);
        };
      }

      if (kind === 1 || kind === 4) {
        access.set = function (v) {
          desc.set.call(this, v);
        };
      }
    }

    ctx.access = access;
  } else {
    metadataKind = 1;
    metadataName = name;
  }

  return Object.assign(ctx, createMetadataMethodsForProperty(metadataMap, metadataKind, metadataName));
}

function assertValidInitializer(initializer) {
  if (typeof initializer !== "function") {
    throw new Error("initializers must be functions");
  }
}

function assertValidReturnValue(kind, value) {
diff --git a/a.js b/b.js
@@ -196,15 +212,47 @@ function assertValidReturnValue(kind, value) {
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
  if (typeof initializer !== "function") {
    throw new Error("initializers must be functions");
  }
}

function assertValidReturnValue(kind, value) {
  var type = typeof value;

  if (kind === 1) {
    if (type !== "object" || value === null) {
      throw new Error("accessor decorators must return an object with get, set, or initializer properties or void 0");
    }
  } else if (type !== "function") {
    if (kind === 0) {
      throw new Error("field decorators must return a initializer function or void 0");
    } else {
      throw new Error("method decorators must return a function or void 0");
    }
  }
}

function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
  var decs = decInfo[0];
diff --git a/a.js b/b.js
@@ -247,11 +295,10 @@ function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, met
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      throw new Error("method decorators must return a function or void 0");
    }
  }
}

function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
  var decs = decInfo[0];
  var desc, initializer, value;

  if (isPrivate) {
    if (kind === 0 || kind === 1) {
      desc = {
        get: decInfo[3],
        set: decInfo[4]
      };
    } else if (kind === 3) {
      desc = {
        get: decInfo[3]
      };
    } else if (kind === 4) {
      desc = {
        set: decInfo[3]
      };
    } else {
      desc = {
        value: decInfo[3]
      };
    }
  } else if (kind !== 0) {
    desc = Object.getOwnPropertyDescriptor(base, name);
  }

  if (kind === 1) {
    value = {
      get: desc.get,
      set: desc.set
    };
  } else if (kind === 2) {
    value = desc.value;
  } else if (kind === 3) {
    value = desc.get;
  } else if (kind === 4) {
    value = desc.set;
  }

  var ctx = memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate);
  var newValue, get, set;

  if (typeof decs === "function") {
    newValue = decs(value, ctx);

    if (newValue !== void 0) {
      assertValidReturnValue(kind, newValue);

diff --git a/a.js b/b.js
@@ -259,7 +306,7 @@ function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, met
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      throw new Error("method decorators must return a function or void 0");
    }
  }
}

function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
  var decs = decInfo[0];
  var desc, initializer, value;

  if (isPrivate) {
    if (kind === 0 || kind === 1) {
      desc = {
        get: decInfo[3],
        set: decInfo[4]
      };
    } else if (kind === 3) {
      desc = {
        get: decInfo[3]
      };
    } else if (kind === 4) {
      desc = {
        set: decInfo[3]
      };
    } else {
      desc = {
        value: decInfo[3]
      };
    }
  } else if (kind !== 0) {
    desc = Object.getOwnPropertyDescriptor(base, name);
  }

  if (kind === 1) {
    value = {
      get: desc.get,
      set: desc.set
    };
  } else if (kind === 2) {
    value = desc.value;
  } else if (kind === 3) {
    value = desc.get;
  } else if (kind === 4) {
    value = desc.set;
  }

  var ctx = memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate);
  var newValue, get, set;

  if (typeof decs === "function") {
    newValue = decs(value, ctx);

    if (newValue !== void 0) {
      assertValidReturnValue(kind, newValue);

      if (kind === 0) {
        initializer = newValue;
      } else if (kind === 1) {
        initializer = newValue.initializer;
        get = newValue.get || value.get;
        set = newValue.set || value.set;
        value = {
          get: get,
diff --git a/a.js b/b.js
@@ -273,7 +320,7 @@ function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, met
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      throw new Error("method decorators must return a function or void 0");
    }
  }
}

function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
  var decs = decInfo[0];
  var desc, initializer, value;

  if (isPrivate) {
    if (kind === 0 || kind === 1) {
      desc = {
        get: decInfo[3],
        set: decInfo[4]
      };
    } else if (kind === 3) {
      desc = {
        get: decInfo[3]
      };
    } else if (kind === 4) {
      desc = {
        set: decInfo[3]
      };
    } else {
      desc = {
        value: decInfo[3]
      };
    }
  } else if (kind !== 0) {
    desc = Object.getOwnPropertyDescriptor(base, name);
  }

  if (kind === 1) {
    value = {
      get: desc.get,
      set: desc.set
    };
  } else if (kind === 2) {
    value = desc.value;
  } else if (kind === 3) {
    value = desc.get;
  } else if (kind === 4) {
    value = desc.set;
  }

  var ctx = memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate);
  var newValue, get, set;

  if (typeof decs === "function") {
    newValue = decs(value, ctx);

    if (newValue !== void 0) {
      assertValidReturnValue(kind, newValue);

      if (kind === 0) {
        initializer = newValue;
      } else if (kind === 1) {
        initializer = newValue.initializer;
        get = newValue.get || value.get;
        set = newValue.set || value.set;
        value = {
          get: get,
          set: set
        };
      } else {
        value = newValue;
      }
    }
  } else {
    for (var i = decs.length - 1; i >= 0; i--) {
      var dec = decs[i];
      newValue = dec(value, ctx);

      if (newValue !== void 0) {
        assertValidReturnValue(kind, newValue);
        var newInit;
diff --git a/a.js b/b.js
@@ -282,7 +329,7 @@ function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, met
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      throw new Error("method decorators must return a function or void 0");
    }
  }
}

function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
  var decs = decInfo[0];
  var desc, initializer, value;

  if (isPrivate) {
    if (kind === 0 || kind === 1) {
      desc = {
        get: decInfo[3],
        set: decInfo[4]
      };
    } else if (kind === 3) {
      desc = {
        get: decInfo[3]
      };
    } else if (kind === 4) {
      desc = {
        set: decInfo[3]
      };
    } else {
      desc = {
        value: decInfo[3]
      };
    }
  } else if (kind !== 0) {
    desc = Object.getOwnPropertyDescriptor(base, name);
  }

  if (kind === 1) {
    value = {
      get: desc.get,
      set: desc.set
    };
  } else if (kind === 2) {
    value = desc.value;
  } else if (kind === 3) {
    value = desc.get;
  } else if (kind === 4) {
    value = desc.set;
  }

  var ctx = memberDecCtx(base, name, desc, metadataMap, initializers, kind, isStatic, isPrivate);
  var newValue, get, set;

  if (typeof decs === "function") {
    newValue = decs(value, ctx);

    if (newValue !== void 0) {
      assertValidReturnValue(kind, newValue);

      if (kind === 0) {
        initializer = newValue;
      } else if (kind === 1) {
        initializer = newValue.initializer;
        get = newValue.get || value.get;
        set = newValue.set || value.set;
        value = {
          get: get,
          set: set
        };
      } else {
        value = newValue;
      }
    }
  } else {
    for (var i = decs.length - 1; i >= 0; i--) {
      var dec = decs[i];
      newValue = dec(value, ctx);

      if (newValue !== void 0) {
        assertValidReturnValue(kind, newValue);
        var newInit;

        if (kind === 0) {
          newInit = newValue;
        } else if (kind === 1) {
          newInit = newValue.initializer;
          get = newValue.get || value.get;
          set = newValue.set || value.set;
          value = {
            get: get,
diff --git a/a.js b/b.js
@@ -368,8 +415,8 @@       initializer = function (instance, init) {
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
        return value;
      };
    } else {
      var originalInitializer = initializer;

      initializer = function (instance, init) {
        return originalInitializer.call(instance, init);
      };
    }

    ret.push(initializer);
  }

  if (kind !== 0) {
    if (kind === 1) {
      desc.get = value.get;
      desc.set = value.set;
    } else if (kind === 2) {
      desc.value = value;
    } else if (kind === 3) {
      desc.get = value;
    } else if (kind === 4) {
      desc.set = value;
    }

    if (isPrivate) {
      if (kind === 1) {
        ret.push(function (instance, args) {
          return value.get.call(instance, args);
        });
        ret.push(function (instance, args) {
          return value.set.call(instance, args);
        });
      } else if (kind === 2) {
        ret.push(value);
      } else {
        ret.push(function (instance, args) {
          return value.call(instance, args);
        });
      }
    } else {
      Object.defineProperty(base, name, desc);
    }
  }
}

function applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {
  var protoInitializers = [];
  var staticInitializers = [];
  var existingProtoNonFields = new Map();
  var existingStaticNonFields = new Map();

  for (var i = 0; i < decInfos.length; i++) {
diff --git a/a.js b/b.js
@@ -388,11 +435,19 @@ function applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInf
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      Object.defineProperty(base, name, desc);
    }
  }
}

function applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {
  var protoInitializers = [];
  var staticInitializers = [];
  var existingProtoNonFields = new Map();
  var existingStaticNonFields = new Map();

  for (var i = 0; i < decInfos.length; i++) {
    var decInfo = decInfos[i];
    if (!Array.isArray(decInfo)) continue;
    var kind = decInfo[1];
    var name = decInfo[2];
    var isPrivate = decInfo.length > 3;
    var isStatic = kind >= 5;
    var base;
    var metadataMap;
    var initializers;

    if (isStatic) {
      base = Class;
      metadataMap = staticMetadataMap;
      kind = kind - 5;
      initializers = staticInitializers;
    } else {
      base = Class.prototype;
      metadataMap = protoMetadataMap;
      initializers = protoInitializers;
    }

    if (kind !== 0 && !isPrivate) {
      var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
diff --git a/a.js b/b.js
@@ -411,73 +466,65 @@ function applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInf
A blob:27dc4e226228a5bd9173b1a08badb6eb03fbd87e
      Object.defineProperty(base, name, desc);
    }
  }
}

function applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {
  var protoInitializers = [];
  var staticInitializers = [];
  var existingProtoNonFields = new Map();
  var existingStaticNonFields = new Map();

  for (var i = 0; i < decInfos.length; i++) {
    var decInfo = decInfos[i];
    if (!Array.isArray(decInfo)) continue;
    var kind = decInfo[1];
    var name = decInfo[2];
    var isPrivate = decInfo.length > 3;
    var isStatic = kind >= 5;
    var base;
    var metadataMap;
    var initializers;

    if (isStatic) {
      base = Class;
      metadataMap = staticMetadataMap;
      kind = kind - 5;
      initializers = staticInitializers;
    } else {
      base = Class.prototype;
      metadataMap = protoMetadataMap;
      initializers = protoInitializers;
    }

    if (kind !== 0 && !isPrivate) {
      var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
      var existingKind = existingNonFields.get(name) || 0;

      if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
        throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
      } else if (!existingKind && kind > 2) {
        existingNonFields.set(name, kind);
      } else {
        existingNonFields.set(name, true);
      }
    }

    applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers);
  }

  if (protoInitializers.length > 0) {
    pushInitializers(ret, protoInitializers);
  }

  if (staticInitializers.length > 0) {
    pushInitializers(ret, staticInitializers);
  }
}

function pushInitializers(ret, initializers) {
  if (initializers.length > 0) {
    initializers = initializers.slice();
    ret.push(function (instance) {
      for (var i = 0; i < initializers.length; i++) {
        initializers[i].call(instance, instance);
      }

      return instance;
    });
  } else {
    ret.push(function (instance) {
      return instance;
    });
  }
}

function applyClassDecs(ret, targetClass, metadataMap, classDecs) {
  var initializers = [];
  var newClass = targetClass;
  var name = targetClass.name;
  var ctx = Object.assign({
    kind: "class",
    name: name,
    addInitializer: createAddInitializerMethod(initializers)
  }, createMetadataMethodsForProperty(metadataMap, 0, name));

  for (var i = classDecs.length - 1; i >= 0; i--) {
    newClass = classDecs[i](newClass, ctx) || newClass;
  }

  ret.push(newClass);

  if (initializers.length > 0) {
    ret.push(function () {
      for (var i = 0; i < initializers.length; i++) {
        initializers[i].call(newClass, newClass);
      }
    });
  } else {
    ret.push(function () {});
  }
}

function applyDecs(targetClass, memberDecs, classDecs) {
  var ret = [];
  var staticMetadataMap = {};

  if (memberDecs) {
    var protoMetadataMap = {};
    applyMemberDecs(ret, targetClass, protoMetadataMap, staticMetadataMap, memberDecs);
    convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap);
  }

  if (classDecs) {
    applyClassDecs(ret, targetClass, staticMetadataMap, classDecs);
  }

  convertMetadataMapToFinal(targetClass, staticMetadataMap);
  return ret;
}
diff --git a/a.js b/b.js
@@ -2,546 +2,480 @@
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class BaseParser {
  constructor() {
    this.sawUnambiguousESM = false;
    this.ambiguousScriptDifferentAst = false;
  }

  hasPlugin(pluginConfig) {
    if (typeof pluginConfig === "string") {
      return this.plugins.has(pluginConfig);
    } else {
      const [pluginName, pluginOptions] = pluginConfig;

      if (!this.hasPlugin(pluginName)) {
        return false;
      }

      const actualOptions = this.plugins.get(pluginName);

      for (const key of Object.keys(pluginOptions)) {
        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
          return false;
        }
      }

      return true;
    }
  }

  getPluginOption(plugin, name) {
    var _this$plugins$get;

    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
  }

}

function setTrailingComments(node, comments) {
  if (node.trailingComments === undefined) {
    node.trailingComments = comments;
  } else {
    node.trailingComments.unshift(...comments);
  }
}

function setLeadingComments(node, comments) {
  if (node.leadingComments === undefined) {
    node.leadingComments = comments;
  } else {
    node.leadingComments.unshift(...comments);
  }
}

function setInnerComments(node, comments) {
  if (node.innerComments === undefined) {
    node.innerComments = comments;
  } else {
    node.innerComments.unshift(...comments);
  }
}

function adjustInnerComments(node, elements, commentWS) {
  let lastElement = null;
  let i = elements.length;

  while (lastElement === null && i > 0) {
    lastElement = elements[--i];
  }

  if (lastElement === null || lastElement.start > commentWS.start) {
    setInnerComments(node, commentWS.comments);
  } else {
    setTrailingComments(lastElement, commentWS.comments);
  }
}

class CommentsParser extends BaseParser {
  addComment(comment) {
    if (this.filename) comment.loc.filename = this.filename;
    this.state.comments.push(comment);
  }

  processComment(node) {
    const {
      commentStack
    } = this.state;
    const commentStackLength = commentStack.length;
    if (commentStackLength === 0) return;
    let i = commentStackLength - 1;
    const lastCommentWS = commentStack[i];

    if (lastCommentWS.start === node.end) {
      lastCommentWS.leadingNode = node;
      i--;
    }

    const {
      start: nodeStart
    } = node;

    for (; i >= 0; i--) {
      const commentWS = commentStack[i];
      const commentEnd = commentWS.end;

      if (commentEnd > nodeStart) {
        commentWS.containingNode = node;
        this.finalizeComment(commentWS);
        commentStack.splice(i, 1);
      } else {
        if (commentEnd === nodeStart) {
          commentWS.trailingNode = node;
        }

        break;
      }
    }
  }

  finalizeComment(commentWS) {
    const {
      comments
    } = commentWS;

    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
      if (commentWS.leadingNode !== null) {
        setTrailingComments(commentWS.leadingNode, comments);
      }

      if (commentWS.trailingNode !== null) {
        setLeadingComments(commentWS.trailingNode, comments);
      }
    } else {
      const {
        containingNode: node,
        start: commentStart
      } = commentWS;

      if (this.input.charCodeAt(commentStart - 1) === 44) {
        switch (node.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            adjustInnerComments(node, node.properties, commentWS);
            break;

          case "CallExpression":
          case "OptionalCallExpression":
            adjustInnerComments(node, node.arguments, commentWS);
            break;

          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            adjustInnerComments(node, node.params, commentWS);
            break;

          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            adjustInnerComments(node, node.elements, commentWS);
            break;

          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            adjustInnerComments(node, node.specifiers, commentWS);
            break;

          default:
            {
              setInnerComments(node, comments);
            }
        }
      } else {
        setInnerComments(node, comments);
      }
    }
  }

  finalizeRemainingComments() {
    const {
      commentStack
    } = this.state;

    for (let i = commentStack.length - 1; i >= 0; i--) {
      this.finalizeComment(commentStack[i]);
    }

    this.state.commentStack = [];
  }

  resetPreviousNodeTrailingComments(node) {
    const {
      commentStack
    } = this.state;
    const {
      length
    } = commentStack;
    if (length === 0) return;
    const commentWS = commentStack[length - 1];

    if (commentWS.leadingNode === node) {
      commentWS.leadingNode = null;
    }
  }

  takeSurroundingComments(node, start, end) {
    const {
      commentStack
    } = this.state;
    const commentStackLength = commentStack.length;
    if (commentStackLength === 0) return;
    let i = commentStackLength - 1;

    for (; i >= 0; i--) {
      const commentWS = commentStack[i];
      const commentEnd = commentWS.end;
      const commentStart = commentWS.start;

      if (commentStart === end) {
        commentWS.leadingNode = node;
      } else if (commentEnd === start) {
        commentWS.trailingNode = node;
      } else if (commentEnd < start) {
        break;
      }
    }
  }

}

const ErrorCodes = Object.freeze({
  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
});

const ErrorMessages = makeErrorTemplates({
  AccessorIsGenerator: "A %0ter cannot be a generator.",
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accesor must not have any formal parameters.",
  BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: "'%0' require an initialization value.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: "Unsyntactic %0.",
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: "`import()` requires exactly %0.",
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: "Expected number in radix %0.",
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
  InvalidIdentifier: "Invalid identifier %0.",
  InvalidLhs: "Invalid left-hand side in %0.",
  InvalidLhsBinding: "Binding invalid left-hand side in %0.",
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: "Unexpected character '%0'.",
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: "Label '%0' is already declared.",
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
  ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
  ModuleExportUndefined: "Export '%0' is not defined.",
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.",
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
  PrivateNameRedeclaration: "Duplicate private name #%0.",
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  StaticPrototype: "Classes may not have static property named prototype.",
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: "Assigning to '%0' in strict mode.",
  StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: "Unexpected keyword '%0'.",
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: "Unexpected reserved word '%0'.",
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: "Unexpected token '%0'.",
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  VarRedeclaration: "Identifier '%0' has already been declared.",
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, ErrorCodes.SyntaxError);
const SourceTypeModuleErrorMessages = makeErrorTemplates({
  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
}, ErrorCodes.SourceTypeModuleError);

function keepReasonCodeCompat(reasonCode, syntaxPlugin) {
  {
    if (syntaxPlugin === "flow" && reasonCode === "PatternIsOptional") {
      return "OptionalBindingPattern";
    }
  }
  return reasonCode;
}

function makeErrorTemplates(messages, code, syntaxPlugin) {
  const templates = {};
  Object.keys(messages).forEach(reasonCode => {
    templates[reasonCode] = Object.freeze({
      code,
      reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin),
      template: messages[reasonCode]
    });
  });
  return Object.freeze(templates);
}
class ParserError extends CommentsParser {
  raise({
    code,
    reasonCode,
    template
  }, origin, ...params) {
    return this.raiseWithData(origin.node ? origin.node.loc.start : origin.at, {
      code,
      reasonCode
    }, template, ...params);
  }

  raiseOverwrite(loc, {
    code,
    template
  }, ...params) {
    const pos = loc.index;
    const message = template.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;

    if (this.options.errorRecovery) {
      const errors = this.state.errors;

      for (let i = errors.length - 1; i >= 0; i--) {
        const error = errors[i];

        if (error.pos === pos) {
          return Object.assign(error, {
            message
          });
        } else if (error.pos < pos) {
          break;
        }
      }
    }

    return this._raise({
      code,
      loc,
      pos
    }, message);
  }

  raiseWithData(loc, data, errorTemplate, ...params) {
    const pos = loc.index;
    const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
    return this._raise(Object.assign({
      loc,
      pos
    }, data), message);
  }

  _raise(errorContext, message) {
    const err = new SyntaxError(message);
    Object.assign(err, errorContext);

    if (this.options.errorRecovery) {
      if (!this.isLookahead) this.state.errors.push(err);
      return err;
    } else {
      throw err;
    }
  }

}

const {
  defineProperty
} = Object;

const toUnenumerable = (object, key) => defineProperty(object, key, {
  enumerable: false,
  value: object[key]
});

function toESTreeLocation(node) {
  toUnenumerable(node.loc.start, "index");
  toUnenumerable(node.loc.end, "index");
  return node;
}

var estree = (superClass => class extends superClass {
  parse() {
    const file = toESTreeLocation(super.parse());

    if (this.options.tokens) {
      file.tokens = file.tokens.map(toESTreeLocation);
    }

    return file;
  }

  parseRegExpLiteral({
    pattern,
    flags
  }) {
    let regex = null;

    try {
      regex = new RegExp(pattern, flags);
    } catch (e) {}

    const node = this.estreeParseLiteral(regex);
    node.regex = {
      pattern,
      flags
    };
    return node;
  }

  parseBigIntLiteral(value) {
    let bigInt;

    try {
      bigInt = BigInt(value);
    } catch (_unused) {
      bigInt = null;
    }

    const node = this.estreeParseLiteral(bigInt);
    node.bigint = String(node.value || value);
    return node;
  }

  parseDecimalLiteral(value) {
    const decimal = null;
diff --git a/a.js b/b.js
@@ -734,6 +668,10 @@ parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return node;
  }

  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);

    if (node) {
      node.kind = "init";
      node.type = "Property";
    }

    return node;
  }

  isAssignable(node, isBinding) {
    if (node != null && this.isObjectProperty(node)) {
      return this.isAssignable(node.value, isBinding);
    }
diff --git a/a.js b/b.js
@@ -762,12 +700,12 @@ toAssignable(node, isLHS = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.isAssignable(node, isBinding);
  }

  toAssignable(node, isLHS = false) {
    if (node != null && this.isObjectProperty(node)) {
      const {
        key,
        value
      } = node;

      if (this.isPrivateName(key)) {
        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
      }

      this.toAssignable(value, isLHS);
      return node;
    }

    return super.toAssignable(node, isLHS);
  }

  toAssignableObjectExpressionProp(prop, ...args) {
    if (prop.kind === "get" || prop.kind === "set") {
      this.raise(ErrorMessages.PatternHasAccessor, {
        node: prop.key
      });
    } else if (prop.method) {
      this.raise(ErrorMessages.PatternHasMethod, {
        node: prop.key
      });
    } else {
      super.toAssignableObjectExpressionProp(prop, ...args);
    }
diff --git a/a.js b/b.js
@@ -1445,37 +1383,6 @@ function getExportedToken(token) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  return token === 57;
}
function tokenIsTemplate(token) {
  return token >= 24 && token <= 25;
}
function getExportedToken(token) {
  return tokenTypes[token];
}
{
  tokenTypes[8].updateContext = context => {
    context.pop();
  };

  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {
    context.push(types.brace);
  };

  tokenTypes[22].updateContext = context => {
    if (context[context.length - 1] === types.template) {
      context.pop();
    } else {
      context.push(types.template);
    }
  };

  tokenTypes[138].updateContext = context => {
    context.push(types.j_expr, types.j_oTag);
  };
}

class Position {
  constructor(line, col, index) {
    this.line = void 0;
    this.column = void 0;
    this.index = void 0;
    this.line = line;
    this.column = col;
    this.index = index;
  }

}
class SourceLocation {
  constructor(start, end) {
    this.start = void 0;
    this.end = void 0;
    this.filename = void 0;
    this.identifierName = void 0;
    this.start = start;
    this.end = end;
  }

}
function createPositionWithColumnOffset(position, columnOffset) {
  const {
    line,
    column,
    index
  } = position;
  return new Position(line, column + columnOffset, index + columnOffset);
}

let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
diff --git a/a.js b/b.js
@@ -1601,222 +1508,233 @@ function canBeReservedWord(word) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

function isIteratorStart(current, next, next2) {
  return current === 64 && next === 64 && isIdentifierStart(next2);
}
const reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function canBeReservedWord(word) {
  return reservedWordLikeSet.has(word);
}

const SCOPE_OTHER = 0b000000000,
      SCOPE_PROGRAM = 0b000000001,
      SCOPE_FUNCTION = 0b000000010,
      SCOPE_ARROW = 0b000000100,
      SCOPE_SIMPLE_CATCH = 0b000001000,
      SCOPE_SUPER = 0b000010000,
      SCOPE_DIRECT_SUPER = 0b000100000,
      SCOPE_CLASS = 0b001000000,
      SCOPE_STATIC_BLOCK = 0b010000000,
      SCOPE_TS_MODULE = 0b100000000,
      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
const BIND_KIND_VALUE = 0b000000000001,
      BIND_KIND_TYPE = 0b000000000010,
      BIND_SCOPE_VAR = 0b000000000100,
      BIND_SCOPE_LEXICAL = 0b000000001000,
      BIND_SCOPE_FUNCTION = 0b000000010000,
      BIND_FLAGS_NONE = 0b000001000000,
      BIND_FLAGS_CLASS = 0b000010000000,
      BIND_FLAGS_TS_ENUM = 0b000100000000,
      BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,
      BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,
      BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;
const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
const CLASS_ELEMENT_FLAG_STATIC = 0b100,
      CLASS_ELEMENT_KIND_GETTER = 0b010,
      CLASS_ELEMENT_KIND_SETTER = 0b001,
      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
      CLASS_ELEMENT_OTHER = 0;

class Scope {
  constructor(flags) {
    this.var = new Set();
    this.lexical = new Set();
    this.functions = new Set();
    this.flags = flags;
  }

}
class ScopeHandler {
  constructor(raise, inModule) {
    this.scopeStack = [];
    this.undefinedExports = new Map();
    this.raise = raise;
    this.inModule = inModule;
  }

  get inFunction() {
    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
  }

  get allowSuper() {
    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
  }

  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
  }

  get inClass() {
    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
  }

  get inClassAndNotInNonArrowFunction() {
    const flags = this.currentThisScopeFlags();
    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
  }

  get inStaticBlock() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const {
        flags
      } = this.scopeStack[i];

      if (flags & SCOPE_STATIC_BLOCK) {
        return true;
      }

      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
        return false;
      }
    }
  }

  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
  }

  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }

  createScope(flags) {
    return new Scope(flags);
  }

  enter(flags) {
    this.scopeStack.push(this.createScope(flags));
  }

  exit() {
    this.scopeStack.pop();
  }

  treatFunctionsAsVarInScope(scope) {
    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
  }

  declareName(name, bindingType, loc) {
    let scope = this.currentScope();

    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
      this.checkRedeclarationInScope(scope, name, bindingType, loc);

      if (bindingType & BIND_SCOPE_FUNCTION) {
        scope.functions.add(name);
      } else {
        scope.lexical.add(name);
      }

      if (bindingType & BIND_SCOPE_LEXICAL) {
        this.maybeExportDefined(scope, name);
      }
    } else if (bindingType & BIND_SCOPE_VAR) {
      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
        scope = this.scopeStack[i];
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        scope.var.add(name);
        this.maybeExportDefined(scope, name);
        if (scope.flags & SCOPE_VAR) break;
      }
    }

    if (this.inModule && scope.flags & SCOPE_PROGRAM) {
      this.undefinedExports.delete(name);
    }
  }

  maybeExportDefined(scope, name) {
    if (this.inModule && scope.flags & SCOPE_PROGRAM) {
      this.undefinedExports.delete(name);
    }
  }

  checkRedeclarationInScope(scope, name, bindingType, loc) {
    if (this.isRedeclaredInScope(scope, name, bindingType)) {
      this.raise(ErrorMessages.VarRedeclaration, {
        at: loc
      }, name);
    }
  }

  isRedeclaredInScope(scope, name, bindingType) {
    if (!(bindingType & BIND_KIND_VALUE)) return false;

    if (bindingType & BIND_SCOPE_LEXICAL) {
      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
    }

    if (bindingType & BIND_SCOPE_FUNCTION) {
      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
    }

    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
  }

  checkLocalExport(id) {
    const {
      name
    } = id;
    const topLevelScope = this.scopeStack[0];

    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
      this.undefinedExports.set(name, id.loc.start);
    }
  }

  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }

  currentVarScopeFlags() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const {
        flags
      } = this.scopeStack[i];

      if (flags & SCOPE_VAR) {
        return flags;
      }
    }
  }

  currentThisScopeFlags() {
    for (let i = this.scopeStack.length - 1;; i--) {
      const {
        flags
      } = this.scopeStack[i];

      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
        return flags;
      }
    }
  }

}

class FlowScope extends Scope {
  constructor(...args) {
    super(...args);
    this.declareFunctions = new Set();
  }

}

class FlowScopeHandler extends ScopeHandler {
  createScope(flags) {
    return new FlowScope(flags);
  }

  declareName(name, bindingType, loc) {
    const scope = this.currentScope();

    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
      this.checkRedeclarationInScope(scope, name, bindingType, loc);
      this.maybeExportDefined(scope, name);
      scope.declareFunctions.add(name);
      return;
    }

    super.declareName(...arguments);
  }

  isRedeclaredInScope(scope, name, bindingType) {
    if (super.isRedeclaredInScope(...arguments)) return true;

    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
    }

    return false;
  }

  checkLocalExport(id) {
    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
      super.checkLocalExport(id);
    }
  }

}
diff --git a/a.js b/b.js
@@ -1947,19 +1865,22 @@ clone(skipArrays) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart, this.pos);
  }

  clone(skipArrays) {
    const state = new State();
    const keys = Object.keys(this);

    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i];
      let val = this[key];

      if (!skipArrays && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }

    return state;
  }

}

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};
const VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);
const forbiddenNumericSeparatorSiblings = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
};
const allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
class Token {
  constructor(state) {
    this.type = state.type;
    this.value = state.value;
diff --git a/a.js b/b.js
@@ -1970,7 +1891,7 @@ constructor(state) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
class Token {
  constructor(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  }

}
class Tokenizer extends ParserError {
  constructor(options, input) {
    super();
    this.isLookahead = void 0;
    this.tokens = [];
diff --git a/a.js b/b.js
@@ -2073,11 +1994,8 @@ setStrict(strict) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return cp;
  }

  setStrict(strict) {
    this.state.strict = strict;

    if (strict) {
      this.state.strictErrors.forEach(({
        message,
        loc
      }) => this.raise(message, {
        at: loc
      }));
      this.state.strictErrors.clear();
    }
  }
diff --git a/a.js b/b.js
@@ -2107,7 +2025,7 @@ skipBlockComment() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }

  skipBlockComment() {
    let startLoc;
    if (!this.isLookahead) startLoc = this.state.curPosition();
    const start = this.state.pos;
    const end = this.input.indexOf("*/", start + 2);

    if (end === -1) {
      throw this.raise(ErrorMessages.UnterminatedComment, {
        at: this.state.curPosition()
      });
    }

diff --git a/a.js b/b.js
@@ -2293,7 +2211,7 @@ readToken_numberSign() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  replaceToken(type) {
    this.state.type = type;
    this.updateContext();
  }

  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return;
    }

    const nextPos = this.state.pos + 1;
    const next = this.codePointAtPos(nextPos);

    if (next >= 48 && next <= 57) {
      throw this.raise(ErrorMessages.UnexpectedDigitAfterHash, {
        at: this.state.curPosition()
      });
    }

diff --git a/a.js b/b.js
@@ -2302,7 +2220,7 @@ readToken_numberSign() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  replaceToken(type) {
    this.state.type = type;
    this.updateContext();
  }

  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return;
    }

    const nextPos = this.state.pos + 1;
    const next = this.codePointAtPos(nextPos);

    if (next >= 48 && next <= 57) {
      throw this.raise(ErrorMessages.UnexpectedDigitAfterHash, {
        at: this.state.curPosition()
      });
    }

    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
      this.expectPlugin("recordAndTuple");

      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
        throw this.raise(next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType, {
          at: this.state.curPosition()
        });
      }

diff --git a/a.js b/b.js
@@ -2408,7 +2326,7 @@ readToken_pipe_amp(code) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.finishOp(type, width);
  }

  readToken_pipe_amp(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(30, 3);
      } else {
        this.finishOp(code === 124 ? 41 : 42, 2);
      }

      return;
    }

    if (code === 124) {
      if (next === 62) {
        this.finishOp(39, 2);
        return;
      }

      if (this.hasPlugin("recordAndTuple") && next === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        }

diff --git a/a.js b/b.js
@@ -2420,7 +2338,7 @@ readToken_pipe_amp(code) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.finishOp(type, width);
  }

  readToken_pipe_amp(code) {
    const next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(30, 3);
      } else {
        this.finishOp(code === 124 ? 41 : 42, 2);
      }

      return;
    }

    if (code === 124) {
      if (next === 62) {
        this.finishOp(39, 2);
        return;
      }

      if (this.hasPlugin("recordAndTuple") && next === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        }

        this.state.pos += 2;
        this.finishToken(9);
        return;
      }

      if (this.hasPlugin("recordAndTuple") && next === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
          throw this.raise(ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        }

diff --git a/a.js b/b.js
@@ -2602,7 +2520,7 @@ getTokenFromCode(code) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      ++this.state.pos;
      this.finishToken(17);
    }
  }

  getTokenFromCode(code) {
    switch (code) {
      case 46:
        this.readToken_dot();
        return;

      case 40:
        ++this.state.pos;
        this.finishToken(10);
        return;

      case 41:
        ++this.state.pos;
        this.finishToken(11);
        return;

      case 59:
        ++this.state.pos;
        this.finishToken(13);
        return;

      case 44:
        ++this.state.pos;
        this.finishToken(12);
        return;

      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }

diff --git a/a.js b/b.js
@@ -2624,7 +2542,7 @@ getTokenFromCode(code) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      ++this.state.pos;
      this.finishToken(17);
    }
  }

  getTokenFromCode(code) {
    switch (code) {
      case 46:
        this.readToken_dot();
        return;

      case 40:
        ++this.state.pos;
        this.finishToken(10);
        return;

      case 41:
        ++this.state.pos;
        this.finishToken(11);
        return;

      case 59:
        ++this.state.pos;
        this.finishToken(13);
        return;

      case 44:
        ++this.state.pos;
        this.finishToken(12);
        return;

      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }

          this.state.pos += 2;
          this.finishToken(2);
        } else {
          ++this.state.pos;
          this.finishToken(0);
        }

        return;

      case 93:
        ++this.state.pos;
        this.finishToken(3);
        return;

      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }

diff --git a/a.js b/b.js
@@ -2729,680 +2647,978 @@ getTokenFromCode(code) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      ++this.state.pos;
      this.finishToken(17);
    }
  }

  getTokenFromCode(code) {
    switch (code) {
      case 46:
        this.readToken_dot();
        return;

      case 40:
        ++this.state.pos;
        this.finishToken(10);
        return;

      case 41:
        ++this.state.pos;
        this.finishToken(11);
        return;

      case 59:
        ++this.state.pos;
        this.finishToken(13);
        return;

      case 44:
        ++this.state.pos;
        this.finishToken(12);
        return;

      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }

          this.state.pos += 2;
          this.finishToken(2);
        } else {
          ++this.state.pos;
          this.finishToken(0);
        }

        return;

      case 93:
        ++this.state.pos;
        this.finishToken(3);
        return;

      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }

          this.state.pos += 2;
          this.finishToken(6);
        } else {
          ++this.state.pos;
          this.finishToken(5);
        }

        return;

      case 125:
        ++this.state.pos;
        this.finishToken(8);
        return;

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          this.finishOp(15, 2);
        } else {
          ++this.state.pos;
          this.finishToken(14);
        }

        return;

      case 63:
        this.readToken_question();
        return;

      case 96:
        this.readTemplateToken();
        return;

      case 48:
        {
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }

          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }

          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }

      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false);
        return;

      case 34:
      case 39:
        this.readString(code);
        return;

      case 47:
        this.readToken_slash();
        return;

      case 37:
      case 42:
        this.readToken_mult_modulo(code);
        return;

      case 124:
      case 38:
        this.readToken_pipe_amp(code);
        return;

      case 94:
        this.readToken_caret();
        return;

      case 43:
      case 45:
        this.readToken_plus_min(code);
        return;

      case 60:
        this.readToken_lt();
        return;

      case 62:
        this.readToken_gt();
        return;

      case 61:
      case 33:
        this.readToken_eq_excl(code);
        return;

      case 126:
        this.finishOp(36, 1);
        return;

      case 64:
        this.readToken_atSign();
        return;

      case 35:
        this.readToken_numberSign();
        return;

      case 92:
        this.readWord();
        return;

      default:
        if (isIdentifierStart(code)) {
          this.readWord(code);
          return;
        }

    }

    throw this.raise(ErrorMessages.InvalidOrUnexpectedToken, {
      at: this.state.curPosition()
    }, String.fromCodePoint(code));
  }

  finishOp(type, size) {
    const str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    this.finishToken(type, str);
  }

  readRegexp() {
    const startLoc = this.state.startLoc;
    const start = this.state.start + 1;
    let escaped, inClass;
    let {
      pos
    } = this.state;

    for (;; ++pos) {
      if (pos >= this.length) {
        throw this.raise(ErrorMessages.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(startLoc, 1)
        });
      }

      const ch = this.input.charCodeAt(pos);

      if (isNewLine(ch)) {
        throw this.raise(ErrorMessages.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(startLoc, 1)
        });
      }

      if (escaped) {
        escaped = false;
      } else {
        if (ch === 91) {
          inClass = true;
        } else if (ch === 93 && inClass) {
          inClass = false;
        } else if (ch === 47 && !inClass) {
          break;
        }

        escaped = ch === 92;
      }
    }

    const content = this.input.slice(start, pos);
    ++pos;
    let mods = "";

    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);

    while (pos < this.length) {
      const cp = this.codePointAtPos(pos);
      const char = String.fromCharCode(cp);

      if (VALID_REGEX_FLAGS.has(cp)) {
        if (cp === 118) {
          this.expectPlugin("regexpUnicodeSets", nextPos());

          if (mods.includes("u")) {
            this.raise(ErrorMessages.IncompatibleRegExpUVFlags, {
              at: nextPos()
            });
          }
        } else if (cp === 117) {
          if (mods.includes("v")) {
            this.raise(ErrorMessages.IncompatibleRegExpUVFlags, {
              at: nextPos()
            });
          }
        }

        if (mods.includes(char)) {
          this.raise(ErrorMessages.DuplicateRegExpFlags, {
            at: nextPos()
          });
        }
      } else if (isIdentifierChar(cp) || cp === 92) {
        this.raise(ErrorMessages.MalformedRegExpFlags, {
          at: nextPos()
        });
      } else {
        break;
      }

      ++pos;
      mods += char;
    }

    this.state.pos = pos;
    this.finishToken(133, {
      pattern: content,
      flags: mods
    });
  }

  readInt(radix, len, forceLen, allowNumSeparator = true) {
    const start = this.state.pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
    let invalid = false;
    let total = 0;

    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = this.input.charCodeAt(this.state.pos);
      let val;

      if (code === 95) {
        const prev = this.input.charCodeAt(this.state.pos - 1);
        const next = this.input.charCodeAt(this.state.pos + 1);

        if (allowedSiblings.indexOf(next) === -1) {
          this.raise(ErrorMessages.UnexpectedNumericSeparator, {
            at: this.state.curPosition()
          });
        } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
          this.raise(ErrorMessages.UnexpectedNumericSeparator, {
            at: this.state.curPosition()
          });
        }

        if (!allowNumSeparator) {
          this.raise(ErrorMessages.NumericSeparatorInEscapeSequence, {
            at: this.state.curPosition()
          });
        }

        ++this.state.pos;
        continue;
      }

      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }

      if (val >= radix) {
        if (this.options.errorRecovery && val <= 9) {
          val = 0;
          this.raise(ErrorMessages.InvalidDigit, {
            at: this.state.curPosition()
          }, radix);
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }

      ++this.state.pos;
      total = total * radix + val;
    }

    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
      return null;
    }

    return total;
  }

  readRadixNumber(radix) {
    const startLoc = this.state.curPosition();
    let isBigInt = false;
    this.state.pos += 2;
    const val = this.readInt(radix);

    if (val == null) {
      this.raise(ErrorMessages.InvalidDigit, {
        at: createPositionWithColumnOffset(startLoc, 2)
      }, radix);
    }

    const next = this.input.charCodeAt(this.state.pos);

    if (next === 110) {
      ++this.state.pos;
      isBigInt = true;
    } else if (next === 109) {
      throw this.raise(ErrorMessages.InvalidDecimal, {
        at: startLoc
      });
    }

    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
      throw this.raise(ErrorMessages.NumberIdentifier, {
        at: this.state.curPosition()
      });
    }

    if (isBigInt) {
      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(131, str);
      return;
    }

    this.finishToken(130, val);
  }

  readNumber(startsWithDot) {
    const start = this.state.pos;
    const startLoc = this.state.curPosition();
    let isFloat = false;
    let isBigInt = false;
    let isDecimal = false;
    let hasExponent = false;
    let isOctal = false;

    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(ErrorMessages.InvalidNumber, {
        at: this.state.curPosition()
      });
    }

    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

    if (hasLeadingZero) {
      const integer = this.input.slice(start, this.state.pos);
      this.recordStrictModeErrors(ErrorMessages.StrictOctalLiteral, startLoc);

      if (!this.state.strict) {
        const underscorePos = integer.indexOf("_");

        if (underscorePos > 0) {
          this.raise(ErrorMessages.ZeroDigitNumericSeparator, {
            at: createPositionWithColumnOffset(startLoc, underscorePos)
          });
        }
      }

      isOctal = hasLeadingZero && !/[89]/.test(integer);
    }

    let next = this.input.charCodeAt(this.state.pos);

    if (next === 46 && !isOctal) {
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }

    if ((next === 69 || next === 101) && !isOctal) {
      next = this.input.charCodeAt(++this.state.pos);

      if (next === 43 || next === 45) {
        ++this.state.pos;
      }

      if (this.readInt(10) === null) {
        this.raise(ErrorMessages.InvalidOrMissingExponent, {
          at: startLoc
        });
      }

      isFloat = true;
      hasExponent = true;
      next = this.input.charCodeAt(this.state.pos);
    }

    if (next === 110) {
      if (isFloat || hasLeadingZero) {
        this.raise(ErrorMessages.InvalidBigIntLiteral, {
          at: startLoc
        });
      }

      ++this.state.pos;
      isBigInt = true;
    }

    if (next === 109) {
      this.expectPlugin("decimal", this.state.curPosition());

      if (hasExponent || hasLeadingZero) {
        this.raise(ErrorMessages.InvalidDecimal, {
          at: startLoc
        });
      }

      ++this.state.pos;
      isDecimal = true;
    }

    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
      throw this.raise(ErrorMessages.NumberIdentifier, {
        at: this.state.curPosition()
      });
    }

    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

    if (isBigInt) {
      this.finishToken(131, str);
      return;
    }

    if (isDecimal) {
      this.finishToken(132, str);
      return;
    }

    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
    this.finishToken(130, val);
  }

  readCodePoint(throwOnInvalid) {
    const ch = this.input.charCodeAt(this.state.pos);
    let code;

    if (ch === 123) {
      ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
      ++this.state.pos;

      if (code !== null && code > 0x10ffff) {
        if (throwOnInvalid) {
          this.raise(ErrorMessages.InvalidCodePoint, {
            at: this.state.curPosition()
          });
        } else {
          return null;
        }
      }
    } else {
      code = this.readHexChar(4, false, throwOnInvalid);
    }

    return code;
  }

  readString(quote) {
    let out = "",
        chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(ErrorMessages.UnterminatedString, {
          at: this.state.startLoc
        });
      }

      const ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;

      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else if (ch === 8232 || ch === 8233) {
        ++this.state.pos;
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
      } else if (isNewLine(ch)) {
        throw this.raise(ErrorMessages.UnterminatedString, {
          at: this.state.startLoc
        });
      } else {
        ++this.state.pos;
      }
    }

    out += this.input.slice(chunkStart, this.state.pos++);
    this.finishToken(129, out);
  }

  readTemplateContinuation() {
    if (!this.match(8)) {
      this.unexpected(null, 8);
    }

    this.state.pos--;
    this.readTemplateToken();
  }

  readTemplateToken() {
    let out = "",
        chunkStart = this.state.pos,
        containsInvalid = false;
    ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(ErrorMessages.UnterminatedTemplate, {
          at: createPositionWithColumnOffset(this.state.startLoc, 1)
        });
      }

      const ch = this.input.charCodeAt(this.state.pos);

      if (ch === 96) {
        ++this.state.pos;
        out += this.input.slice(chunkStart, this.state.pos);
        this.finishToken(24, containsInvalid ? null : out);
        return;
      }

      if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        this.state.pos += 2;
        out += this.input.slice(chunkStart, this.state.pos);
        this.finishToken(25, containsInvalid ? null : out);
        return;
      }

      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos);
        const escaped = this.readEscapedChar(true);

        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }

        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;

        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
            }

          case 10:
            out += "\n";
            break;

          default:
            out += String.fromCharCode(ch);
            break;
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  }

  recordStrictModeErrors(message, loc) {
    if (this.state.strict && !this.state.strictErrors.has(loc.index)) {
      this.raise(message, {
        at: loc
      });
    } else {
      this.state.strictErrors.set(loc.index, {
        loc,
        message
      });
    }
  }

  readEscapedChar(inTemplate) {
    const throwOnInvalid = !inTemplate;
    const ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;

    switch (ch) {
      case 110:
        return "\n";

      case 114:
        return "\r";

      case 120:
        {
          const code = this.readHexChar(2, false, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }

      case 117:
        {
          const code = this.readCodePoint(throwOnInvalid);
          return code === null ? null : String.fromCodePoint(code);
        }

      case 116:
        return "\t";

      case 98:
        return "\b";

      case 118:
        return "\u000b";

      case 102:
        return "\f";

      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
        }

      case 10:
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;

      case 8232:
      case 8233:
        return "";

      case 56:
      case 57:
        if (inTemplate) {
          return null;
        } else {
          this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape, createPositionWithColumnOffset(this.state.curPosition(), -1));
        }

      default:
        if (ch >= 48 && ch <= 55) {
          const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1);
          const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);

          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }

          this.state.pos += octalStr.length - 1;
          const next = this.input.charCodeAt(this.state.pos);

          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return null;
            } else {
              this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape, codePos);
            }
          }

          return String.fromCharCode(octal);
        }

        return String.fromCharCode(ch);
    }
  }

  readHexChar(len, forceLen, throwOnInvalid) {
    const codeLoc = this.state.curPosition();
    const n = this.readInt(16, len, forceLen, false);

    if (n === null) {
      if (throwOnInvalid) {
        this.raise(ErrorMessages.InvalidEscapeSequence, {
          at: codeLoc
        });
      } else {
        this.state.pos = codeLoc.index - 1;
      }
    }

    return n;
  }

  readWord1(firstCode) {
    this.state.containsEsc = false;
    let word = "";
    const start = this.state.pos;
    let chunkStart = this.state.pos;

    if (firstCode !== undefined) {
      this.state.pos += firstCode <= 0xffff ? 1 : 2;
    }

    while (this.state.pos < this.length) {
      const ch = this.codePointAtPos(this.state.pos);

      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        this.state.containsEsc = true;
        word += this.input.slice(chunkStart, this.state.pos);
        const escStart = this.state.curPosition();
        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(ErrorMessages.MissingUnicodeEscape, {
            at: this.state.curPosition()
          });
          chunkStart = this.state.pos - 1;
          continue;
        }

        ++this.state.pos;
        const esc = this.readCodePoint(true);

        if (esc !== null) {
          if (!identifierCheck(esc)) {
            this.raise(ErrorMessages.EscapedCharNotAnIdentifier, {
              at: escStart
            });
          }

          word += String.fromCodePoint(esc);
        }

        chunkStart = this.state.pos;
      } else {
        break;
      }
    }

    return word + this.input.slice(chunkStart, this.state.pos);
  }

  readWord(firstCode) {
    const word = this.readWord1(firstCode);
    const type = keywords$1.get(word);

    if (type !== undefined) {
      this.finishToken(type, tokenLabelName(type));
    } else {
      this.finishToken(128, word);
    }
  }

  checkKeywordEscapes() {
    const {
      type
    } = this.state;

    if (tokenIsKeyword(type) && this.state.containsEsc) {
      this.raise(ErrorMessages.InvalidEscapedReservedWord, {
        at: this.state.startLoc
      }, tokenLabelName(type));
    }
  }

  updateContext(prevType) {}

}

class ClassScope {
  constructor() {
diff --git a/a.js b/b.js
@@ -3414,10 +3630,11 @@ constructor() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  updateContext(prevType) {}

}

class ClassScope {
  constructor() {
    this.privateNames = new Set();
    this.loneAccessors = new Map();
    this.undefinedPrivateNames = new Map();
  }

}
class ClassScopeHandler {
  constructor(raise) {
    this.stack = [];
    this.undefinedPrivateNames = new Map();
    this.raise = raise;
  }

  current() {
    return this.stack[this.stack.length - 1];
diff --git a/a.js b/b.js
@@ -3438,9 +3655,10 @@ exit() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  enter() {
    this.stack.push(new ClassScope());
  }

  exit() {
    const oldClassScope = this.stack.pop();
    const current = this.current();

    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
      if (current) {
        if (!current.undefinedPrivateNames.has(name)) {
          current.undefinedPrivateNames.set(name, loc);
        }
      } else {
        this.raise(ErrorMessages.InvalidPrivateFieldResolution, {
          at: loc
        }, name);
      }
    }
  }

diff --git a/a.js b/b.js
@@ -3469,9 +3687,10 @@ declarePrivateName(name, elementType, loc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        }, name);
      }
    }
  }

  declarePrivateName(name, elementType, loc) {
    const {
      privateNames,
      loneAccessors,
      undefinedPrivateNames
    } = this.current();
    let redefined = privateNames.has(name);

    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
      const accessor = redefined && loneAccessors.get(name);

      if (accessor) {
        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
        redefined = oldKind === newKind || oldStatic !== newStatic;
        if (!redefined) loneAccessors.delete(name);
      } else if (!redefined) {
        loneAccessors.set(name, elementType);
      }
    }

    if (redefined) {
      this.raise(ErrorMessages.PrivateNameRedeclaration, {
        at: loc
      }, name);
    }

    privateNames.add(name);
    undefinedPrivateNames.delete(name);
diff --git a/a.js b/b.js
@@ -3488,9 +3707,10 @@ usePrivateName(name, loc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    privateNames.add(name);
    undefinedPrivateNames.delete(name);
  }

  usePrivateName(name, loc) {
    let classScope;

    for (classScope of this.stack) {
      if (classScope.privateNames.has(name)) return;
    }

    if (classScope) {
      classScope.undefinedPrivateNames.set(name, loc);
    } else {
      this.raise(ErrorMessages.InvalidPrivateFieldResolution, {
        at: loc
      }, name);
    }
  }

}
diff --git a/a.js b/b.js
@@ -3520,30 +3740,31 @@ isCertainlyParameterDeclaration() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  canBeArrowParameterDeclaration() {
    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
  }

  isCertainlyParameterDeclaration() {
    return this.type === kParameterDeclaration;
  }

}

class ArrowHeadParsingScope extends ExpressionScope {
  constructor(type) {
    super(type);
    this.errors = new Map();
  }

  recordDeclarationError(message, loc) {
    this.errors.set(loc.index, {
      message,
      loc
    });
  }

  clearDeclarationError(loc) {
    this.errors.delete(loc.index);
  }

  iterateErrors(iterator) {
    this.errors.forEach(iterator);
  }

}

class ExpressionScopeHandler {
  constructor(raise) {
    this.stack = [new ExpressionScope()];
    this.raise = raise;
  }

  enter(scope) {
    this.stack.push(scope);
diff --git a/a.js b/b.js
@@ -3554,7 +3775,12 @@ exit() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  enter(scope) {
    this.stack.push(scope);
  }

  exit() {
    this.stack.pop();
  }

  recordParameterInitializerError(loc, template) {
    const {
      stack
    } = this;
    let i = stack.length - 1;
diff --git a/a.js b/b.js
@@ -3563,7 +3789,7 @@ recordParameterInitializerError(loc, template) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  exit() {
    this.stack.pop();
  }

  recordParameterInitializerError(loc, template) {
    const {
      stack
    } = this;
    let i = stack.length - 1;
    let scope = stack[i];

    while (!scope.isCertainlyParameterDeclaration()) {
      if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(template, loc);
      } else {
        return;
      }

diff --git a/a.js b/b.js
@@ -3571,29 +3797,32 @@ recordParameterInitializerError(loc, template) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  exit() {
    this.stack.pop();
  }

  recordParameterInitializerError(loc, template) {
    const {
      stack
    } = this;
    let i = stack.length - 1;
    let scope = stack[i];

    while (!scope.isCertainlyParameterDeclaration()) {
      if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(template, loc);
      } else {
        return;
      }

      scope = stack[--i];
    }

    this.raise(template, {
      at: loc
    });
  }

  recordParenthesizedIdentifierError(template, loc) {
    const {
      stack
    } = this;
    const scope = stack[stack.length - 1];

    if (scope.isCertainlyParameterDeclaration()) {
      this.raise(template, {
        at: loc
      });
    } else if (scope.canBeArrowParameterDeclaration()) {
      scope.recordDeclarationError(template, loc);
    } else {
      return;
    }
  }

  recordAsyncArrowParametersError(template, loc) {
    const {
      stack
    } = this;
    let i = stack.length - 1;
diff --git a/a.js b/b.js
@@ -3602,7 +3831,9 @@ recordAsyncArrowParametersError(template, loc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      return;
    }
  }

  recordAsyncArrowParametersError(template, loc) {
    const {
      stack
    } = this;
    let i = stack.length - 1;
    let scope = stack[i];

    while (scope.canBeArrowParameterDeclaration()) {
      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
        scope.recordDeclarationError(template, loc);
      }

      scope = stack[--i];
    }
diff --git a/a.js b/b.js
@@ -3615,18 +3846,15 @@ validateAsPattern() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

      scope = stack[--i];
    }
  }

  validateAsPattern() {
    const {
      stack
    } = this;
    const currentScope = stack[stack.length - 1];
    if (!currentScope.canBeArrowParameterDeclaration()) return;
    currentScope.iterateErrors(({
      message,
      loc
    }) => {
      this.raise(message, {
        at: loc
      });
      let i = stack.length - 2;
      let scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        scope.clearDeclarationError(loc);
        scope = stack[--i];
      }
    });
  }
diff --git a/a.js b/b.js
@@ -3733,10 +3961,10 @@ eatContextual(token) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  isLookaheadContextual(name) {
    const next = this.nextTokenStart();
    return this.isUnparsedContextual(next, name);
  }

  eatContextual(token) {
    if (this.isContextual(token)) {
      this.next();
      return true;
    }

    return false;
  }

  expectContextual(token, template) {
    if (!this.eatContextual(token)) {
      if (template != null) {
        throw this.raise(template, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -3764,7 +3992,7 @@ isLineTerminator() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  hasFollowingLineBreak() {
    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
    return skipWhiteSpaceToLineBreak.test(this.input);
  }

  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }

  semicolon(allowAsi = true) {
    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
    this.raise(ErrorMessages.MissingSemicolon, {
      at: this.state.lastTokEndLoc
    });
  }

diff --git a/a.js b/b.js
@@ -3773,56 +4001,6 @@ expect(type, loc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.raise(ErrorMessages.MissingSemicolon, {
      at: this.state.lastTokEndLoc
    });
  }

  expect(type, loc) {
    this.eat(type) || this.unexpected(loc, type);
  }

  assertNoSpace(message = "Unexpected space.") {
    if (this.state.start > this.state.lastTokEndLoc.index) {
      this.raise({
        code: ErrorCodes.SyntaxError,
        reasonCode: "UnexpectedSpace",
        template: message
      }, {
        at: this.state.lastTokEndLoc
      });
    }
  }

  unexpected(loc, type) {
    throw this.raise({
      code: ErrorCodes.SyntaxError,
      reasonCode: "UnexpectedToken",
      template: type != null ? `Unexpected token, expected "${tokenLabelName(type)}"` : "Unexpected token"
    }, {
      at: loc != null ? loc : this.state.startLoc
    });
  }

  getPluginNamesFromConfigs(pluginConfigs) {
    return pluginConfigs.map(c => {
      if (typeof c === "string") {
        return c;
      } else {
        return c[0];
      }
    });
  }

  expectPlugin(pluginConfig, loc) {
    if (!this.hasPlugin(pluginConfig)) {
      throw this.raiseWithData(loc != null ? loc : this.state.startLoc, {
        missingPlugin: this.getPluginNamesFromConfigs([pluginConfig])
      }, `This experimental syntax requires enabling the parser plugin: ${JSON.stringify(pluginConfig)}.`);
    }

    return true;
  }

  expectOnePlugin(pluginConfigs) {
    if (!pluginConfigs.some(c => this.hasPlugin(c))) {
      throw this.raiseWithData(this.state.startLoc, {
        missingPlugin: this.getPluginNamesFromConfigs(pluginConfigs)
      }, `This experimental syntax requires enabling one of the following parser plugin(s): ${pluginConfigs.map(c => JSON.stringify(c)).join(", ")}.`);
    }
  }

  tryParse(fn, oldState = this.state.clone()) {
    const abortSignal = {
      node: null
    };
diff --git a/a.js b/b.js
@@ -3897,19 +4075,19 @@ checkExpressionErrors(refExpressionErrors, andThrow) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

      throw error;
    }
  }

  checkExpressionErrors(refExpressionErrors, andThrow) {
    if (!refExpressionErrors) return false;
    const {
      shorthandAssignLoc,
      doubleProtoLoc,
      privateKeyLoc,
      optionalParametersLoc
    } = refExpressionErrors;
    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;

    if (!andThrow) {
      return hasErrors;
    }

    if (shorthandAssignLoc != null) {
      this.raise(ErrorMessages.InvalidCoverInitializedName, {
        at: shorthandAssignLoc
      });
    }

    if (doubleProtoLoc != null) {
      this.raise(ErrorMessages.DuplicateProto, {
        at: doubleProtoLoc
      });
    }

    if (privateKeyLoc != null) {
      this.raise(ErrorMessages.UnexpectedPrivateField, {
        at: privateKeyLoc
      });
    }

diff --git a/a.js b/b.js
@@ -3956,13 +4134,13 @@ initializeScopes(inModule = this.options.sourceType === "module") {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isObjectMethod(node) {
    return node.type === "ObjectMethod";
  }

  initializeScopes(inModule = this.options.sourceType === "module") {
    const oldLabels = this.state.labels;
    this.state.labels = [];
    const oldExportedIdentifiers = this.exportedIdentifiers;
    this.exportedIdentifiers = new Set();
    const oldInModule = this.inModule;
    this.inModule = inModule;
    const oldScope = this.scope;
    const ScopeHandler = this.getScopeHandler();
    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
    const oldProdParam = this.prodParam;
    this.prodParam = new ProductionParameterHandler();
    const oldClassScope = this.classScope;
    this.classScope = new ClassScopeHandler(this.raise.bind(this));
    const oldExpressionScope = this.expressionScope;
    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
    return () => {
      this.state.labels = oldLabels;
      this.exportedIdentifiers = oldExportedIdentifiers;
      this.inModule = oldInModule;
diff --git a/a.js b/b.js
@@ -4141,55 +4319,96 @@ resetStartLocationFromNode(node, locationNode) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.end = endLoc.index;
    node.loc.end = endLoc;
    if (this.options.ranges) node.range[1] = endLoc.index;
  }

  resetStartLocationFromNode(node, locationNode) {
    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
  }

}

const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
const FlowErrors = makeErrorTemplates({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: "Cannot overwrite reserved type %0.",
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
  EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
  EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
  EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
  EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
  EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
  EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
  EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
  EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
  EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: "Unexpected reserved type %0.",
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
}, ErrorCodes.SyntaxError, "flow");

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}
diff --git a/a.js b/b.js
@@ -4434,7 +4653,7 @@ flowParseDeclareModule(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
    this.semicolon();
    return this.finishNode(node, "DeclareVariable");
  }

  flowParseDeclareModule(node) {
    this.scope.enter(SCOPE_OTHER);

    if (this.match(129)) {
      node.id = this.parseExprAtom();
    } else {
      node.id = this.parseIdentifier();
    }

    const bodyNode = node.body = this.startNode();
    const body = bodyNode.body = [];
    this.expect(5);

    while (!this.match(8)) {
      let bodyNode = this.startNode();

      if (this.match(83)) {
        this.next();

        if (!this.isContextual(126) && !this.match(87)) {
          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
            at: this.state.lastTokStartLoc
          });
        }

        this.parseImport(bodyNode);
      } else {
        this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
        bodyNode = this.flowParseDeclare(bodyNode, true);
      }

      body.push(bodyNode);
    }

    this.scope.exit();
    this.expect(8);
    this.finishNode(bodyNode, "BlockStatement");
    let kind = null;
    let hasModuleExport = false;
    body.forEach(bodyElement => {
      if (isEsModuleType(bodyElement)) {
        if (kind === "CommonJS") {
          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
            node: bodyElement
          });
        }

        kind = "ES";
diff --git a/a.js b/b.js
@@ -4442,13 +4661,13 @@ flowParseDeclareModule(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
    this.semicolon();
    return this.finishNode(node, "DeclareVariable");
  }

  flowParseDeclareModule(node) {
    this.scope.enter(SCOPE_OTHER);

    if (this.match(129)) {
      node.id = this.parseExprAtom();
    } else {
      node.id = this.parseIdentifier();
    }

    const bodyNode = node.body = this.startNode();
    const body = bodyNode.body = [];
    this.expect(5);

    while (!this.match(8)) {
      let bodyNode = this.startNode();

      if (this.match(83)) {
        this.next();

        if (!this.isContextual(126) && !this.match(87)) {
          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
            at: this.state.lastTokStartLoc
          });
        }

        this.parseImport(bodyNode);
      } else {
        this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
        bodyNode = this.flowParseDeclare(bodyNode, true);
      }

      body.push(bodyNode);
    }

    this.scope.exit();
    this.expect(8);
    this.finishNode(bodyNode, "BlockStatement");
    let kind = null;
    let hasModuleExport = false;
    body.forEach(bodyElement => {
      if (isEsModuleType(bodyElement)) {
        if (kind === "CommonJS") {
          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
            node: bodyElement
          });
        }

        kind = "ES";
      } else if (bodyElement.type === "DeclareModuleExports") {
        if (hasModuleExport) {
          this.raise(FlowErrors.DuplicateDeclareModuleExports, {
            node: bodyElement
          });
        }

        if (kind === "ES") {
          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
            node: bodyElement
          });
        }

        kind = "CommonJS";
diff --git a/a.js b/b.js
@@ -4476,10 +4695,11 @@ flowParseDeclareExportDeclaration(node, insideModule) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    });
    node.kind = kind || "CommonJS";
    return this.finishNode(node, "DeclareModule");
  }

  flowParseDeclareExportDeclaration(node, insideModule) {
    this.expect(82);

    if (this.eat(65)) {
      if (this.match(68) || this.match(80)) {
        node.declaration = this.flowParseDeclare(this.startNode());
      } else {
        node.declaration = this.flowParseType();
        this.semicolon();
      }

      node.default = true;
      return this.finishNode(node, "DeclareExportDeclaration");
    } else {
      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
        const label = this.state.value;
        const suggestion = exportSuggestions[label];
        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
          at: this.state.startLoc
        }, label, suggestion);
      }

      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
        node.declaration = this.flowParseDeclare(this.startNode());
diff --git a/a.js b/b.js
@@ -4605,8 +4825,9 @@ checkNotUnderscore(word) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  flowParseInterface(node) {
    this.flowParseInterfaceish(node);
    return this.finishNode(node, "InterfaceDeclaration");
  }

  checkNotUnderscore(word) {
    if (word === "_") {
      this.raise(FlowErrors.UnexpectedReservedUnderscore, {
        at: this.state.startLoc
      });
    }
  }

  checkReservedType(word, startLoc, declaration) {
    if (!reservedTypes.has(word)) return;
    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
      at: startLoc
    }, word);
  }

  flowParseRestrictedIdentifier(liberal, declaration) {
    this.checkReservedType(this.state.value, this.state.startLoc, declaration);
diff --git a/a.js b/b.js
@@ -5004,7 +5225,7 @@ flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allow
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    this.state.inType = oldInType;
    return out;
  }

  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
    if (this.eat(21)) {
      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);

      if (isInexactToken) {
        if (!allowSpread) {
          this.raise(FlowErrors.InexactInsideNonObject, {
            at: this.state.lastTokStartLoc
          });
        } else if (!allowInexact) {
          this.raise(FlowErrors.InexactInsideExact, {
            at: this.state.lastTokStartLoc
          });
        }

        if (variance) {
          this.raise(FlowErrors.InexactVariance, {
            node: variance
          });
        }

        return null;
diff --git a/a.js b/b.js
@@ -5023,7 +5244,7 @@ flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allow
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    this.state.inType = oldInType;
    return out;
  }

  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
    if (this.eat(21)) {
      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);

      if (isInexactToken) {
        if (!allowSpread) {
          this.raise(FlowErrors.InexactInsideNonObject, {
            at: this.state.lastTokStartLoc
          });
        } else if (!allowInexact) {
          this.raise(FlowErrors.InexactInsideExact, {
            at: this.state.lastTokStartLoc
          });
        }

        if (variance) {
          this.raise(FlowErrors.InexactVariance, {
            node: variance
          });
        }

        return null;
      }

      if (!allowSpread) {
        this.raise(FlowErrors.UnexpectedSpreadType, {
          at: this.state.lastTokStartLoc
        });
      }

      if (protoStartLoc != null) {
        this.unexpected(protoStartLoc);
      }

      if (variance) {
        this.raise(FlowErrors.SpreadVariance, {
          node: variance
        });
      }

      node.argument = this.flowParseType();
diff --git a/a.js b/b.js
@@ -5055,7 +5276,7 @@ flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allow
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    this.state.inType = oldInType;
    return out;
  }

  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
    if (this.eat(21)) {
      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);

      if (isInexactToken) {
        if (!allowSpread) {
          this.raise(FlowErrors.InexactInsideNonObject, {
            at: this.state.lastTokStartLoc
          });
        } else if (!allowInexact) {
          this.raise(FlowErrors.InexactInsideExact, {
            at: this.state.lastTokStartLoc
          });
        }

        if (variance) {
          this.raise(FlowErrors.InexactVariance, {
            node: variance
          });
        }

        return null;
      }

      if (!allowSpread) {
        this.raise(FlowErrors.UnexpectedSpreadType, {
          at: this.state.lastTokStartLoc
        });
      }

      if (protoStartLoc != null) {
        this.unexpected(protoStartLoc);
      }

      if (variance) {
        this.raise(FlowErrors.SpreadVariance, {
          node: variance
        });
      }

      node.argument = this.flowParseType();
      return this.finishNode(node, "ObjectTypeSpreadProperty");
    } else {
      node.key = this.flowParseObjectPropertyKey();
      node.static = isStatic;
      node.proto = protoStartLoc != null;
      node.kind = kind;
      let optional = false;

      if (this.match(47) || this.match(10)) {
        node.method = true;

        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }

        if (variance) {
          this.unexpected(variance.loc.start);
        }

        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

        if (kind === "get" || kind === "set") {
          this.flowCheckGetterSetterParams(node);
        }

        if (!allowSpread && node.key.name === "constructor" && node.value.this) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, {
            node: node.value.this
          });
        }
      } else {
        if (kind !== "init") this.unexpected();
diff --git a/a.js b/b.js
@@ -5081,19 +5302,19 @@ flowCheckGetterSetterParams(property) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      node.optional = optional;
      return this.finishNode(node, "ObjectTypeProperty");
    }
  }

  flowCheckGetterSetterParams(property) {
    const paramCount = property.kind === "get" ? 0 : 1;
    const length = property.value.params.length + (property.value.rest ? 1 : 0);

    if (property.value.this) {
      this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
        node: property.value.this
      });
    }

    if (length !== paramCount) {
      this.raise(property.kind === "get" ? ErrorMessages.BadGetterArity : ErrorMessages.BadSetterArity, {
        node: property
      });
    }

    if (property.kind === "set" && property.value.rest) {
      this.raise(ErrorMessages.BadSetterRestParameter, {
        node: property
      });
    }
  }

diff --git a/a.js b/b.js
@@ -5164,7 +5385,7 @@ flowParseFunctionTypeParam(first) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.expect(3);
    return this.finishNode(node, "TupleTypeAnnotation");
  }

  flowParseFunctionTypeParam(first) {
    let name = null;
    let optional = false;
    let typeAnnotation = null;
    const node = this.startNode();
    const lh = this.lookahead();
    const isThis = this.state.type === 78;

    if (lh.type === 14 || lh.type === 17) {
      if (isThis && !first) {
        this.raise(FlowErrors.ThisParamMustBeFirst, {
          node
        });
      }

      name = this.parseIdentifier(isThis);
diff --git a/a.js b/b.js
@@ -5175,7 +5396,7 @@ flowParseFunctionTypeParam(first) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.expect(3);
    return this.finishNode(node, "TupleTypeAnnotation");
  }

  flowParseFunctionTypeParam(first) {
    let name = null;
    let optional = false;
    let typeAnnotation = null;
    const node = this.startNode();
    const lh = this.lookahead();
    const isThis = this.state.type === 78;

    if (lh.type === 14 || lh.type === 17) {
      if (isThis && !first) {
        this.raise(FlowErrors.ThisParamMustBeFirst, {
          node
        });
      }

      name = this.parseIdentifier(isThis);

      if (this.eat(17)) {
        optional = true;

        if (isThis) {
          this.raise(FlowErrors.ThisParamMayNotBeOptional, {
            node
          });
        }
      }

diff --git a/a.js b/b.js
@@ -5915,7 +6136,7 @@ parseClassMember(classBody, member, state) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (this.match(47)) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
  }

  parseClassMember(classBody, member, state) {
    const {
      startLoc
    } = this.state;

    if (this.isContextual(121)) {
      if (this.parseClassMemberFromModifier(classBody, member)) {
        return;
      }

      member.declare = true;
    }

    super.parseClassMember(classBody, member, state);

    if (member.declare) {
      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
        this.raise(FlowErrors.DeclareClassElement, {
          at: startLoc
        });
      } else if (member.value) {
        this.raise(FlowErrors.DeclareClassFieldInitializer, {
          node: member.value
        });
      }
    }
  }
diff --git a/a.js b/b.js
@@ -5930,9 +6151,10 @@ readIterator() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isIterator(word) {
    return word === "iterator" || word === "asyncIterator";
  }

  readIterator() {
    const word = super.readWord1();
    const fullWord = "@@" + word;

    if (!this.isIterator(word) || !this.state.inType) {
      this.raise(ErrorMessages.InvalidIdentifier, {
        at: this.state.curPosition()
      }, fullWord);
    }

    this.finishToken(128, fullWord);
  }
diff --git a/a.js b/b.js
@@ -5995,7 +6217,7 @@ toReferencedList(exprList, isParenthesizedExpr) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.toAssignableList(exprList, trailingCommaLoc, isLHS);
  }

  toReferencedList(exprList, isParenthesizedExpr) {
    for (let i = 0; i < exprList.length; i++) {
      var _expr$extra;

      const expr = exprList[i];

      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
        this.raise(FlowErrors.TypeCastInPattern, {
          node: expr.typeAnnotation
        });
      }
    }

diff --git a/a.js b/b.js
@@ -6013,10 +6235,8 @@ parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return exprList;
  }

  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);

    if (canBePattern && !this.state.maybeInArrowParameters) {
      this.toReferencedList(node.elements);
    }

    return node;
  }

  checkLVal(expr, ...args) {
    if (expr.type !== "TypeCastExpression") {
      return super.checkLVal(expr, ...args);
    }
  }

  parseClassProperty(node) {
    if (this.match(14)) {
diff --git a/a.js b/b.js
@@ -6065,7 +6285,7 @@ pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDi
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    if (this.match(47)) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

    if (method.params && isConstructor) {
      const params = method.params;

      if (params.length > 0 && this.isThisParam(params[0])) {
        this.raise(FlowErrors.ThisParamBannedInConstructor, {
          node: method
        });
      }
    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
      const params = method.value.params;
diff --git a/a.js b/b.js
@@ -6073,7 +6293,7 @@ pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDi
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    if (this.match(47)) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

    if (method.params && isConstructor) {
      const params = method.params;

      if (params.length > 0 && this.isThisParam(params[0])) {
        this.raise(FlowErrors.ThisParamBannedInConstructor, {
          node: method
        });
      }
    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
      const params = method.value.params;

      if (params.length > 0 && this.isThisParam(params[0])) {
        this.raise(FlowErrors.ThisParamBannedInConstructor, {
          node: method
        });
      }
    }
  }
diff --git a/a.js b/b.js
@@ -6128,11 +6348,11 @@ checkGetterSetterParams(method) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        implemented.push(this.finishNode(node, "ClassImplements"));
      } while (this.eat(12));
    }
  }

  checkGetterSetterParams(method) {
    super.checkGetterSetterParams(method);
    const params = this.getObjectOrClassMethodParams(method);

    if (params.length > 0) {
      const param = params[0];

      if (this.isThisParam(param) && method.kind === "get") {
        this.raise(FlowErrors.GetterMayNotHaveThisParam, {
          node: param
        });
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors.SetterMayNotHaveThisParam, {
          node: param
        });
      }
    }
  }
diff --git a/a.js b/b.js
@@ -6166,13 +6386,13 @@ parseAssignableListItemTypes(param) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (typeParameters) {
      (prop.value || prop).typeParameters = typeParameters;
    }
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(17)) {
      if (param.type !== "Identifier") {
        this.raise(FlowErrors.PatternIsOptional, {
          node: param
        });
      }

      if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamMayNotBeOptional, {
          node: param
        });
      }

      param.optional = true;
diff --git a/a.js b/b.js
@@ -6183,13 +6403,13 @@ parseAssignableListItemTypes(param) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (typeParameters) {
      (prop.value || prop).typeParameters = typeParameters;
    }
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(17)) {
      if (param.type !== "Identifier") {
        this.raise(FlowErrors.PatternIsOptional, {
          node: param
        });
      }

      if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamMayNotBeOptional, {
          node: param
        });
      }

      param.optional = true;
    }

    if (this.match(14)) {
      param.typeAnnotation = this.flowParseTypeAnnotation();
    } else if (this.isThisParam(param)) {
      this.raise(FlowErrors.ThisParamAnnotationRequired, {
        node: param
      });
    }

    if (this.match(29) && this.isThisParam(param)) {
      this.raise(FlowErrors.ThisParamNoDefault, {
        node: param
      });
    }

    this.resetEndLocation(param);
diff --git a/a.js b/b.js
@@ -6202,7 +6422,7 @@ parseMaybeDefault(startPos, startLoc, left) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.resetEndLocation(param);
    return param;
  }

  parseMaybeDefault(startPos, startLoc, left) {
    const node = super.parseMaybeDefault(startPos, startLoc, left);

    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(FlowErrors.TypeBeforeInitializer, {
        node: node.typeAnnotation
      });
    }

    return node;
diff --git a/a.js b/b.js
@@ -6217,10 +6437,9 @@ shouldParseDefaultImport(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return node;
  }

  shouldParseDefaultImport(node) {
    if (!hasTypeImportKind(node)) {
      return super.shouldParseDefaultImport(node);
    }

    return isMaybeDefaultImport(this.state.type);
  }

  parseImportSpecifierLocal(node, specifier, type, contextDescription) {
    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  maybeParseDefaultImportSpecifier(node) {
    node.importKind = "value";
diff --git a/a.js b/b.js
@@ -6284,9 +6503,10 @@ parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTyp
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.maybeParseDefaultImportSpecifier(node);
  }

  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    const firstIdent = specifier.imported;
    let specifierTypeKind = null;

    if (firstIdent.type === "Identifier") {
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }
    }

    let isBinding = false;

    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const as_ident = this.parseIdentifier(true);

      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = as_ident;
        specifier.importKind = specifierTypeKind;
        specifier.local = cloneIdentifier(as_ident);
      } else {
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = this.parseIdentifier();
      }
    } else {
      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
      } else {
        if (importedIsString) {
          throw this.raise(ErrorMessages.ImportBindingIsString, {
            node: specifier
          }, firstIdent.value);
        }

        specifier.imported = firstIdent;
        specifier.importKind = null;
diff --git a/a.js b/b.js
@@ -6305,7 +6525,7 @@ parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTyp
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.maybeParseDefaultImportSpecifier(node);
  }

  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    const firstIdent = specifier.imported;
    let specifierTypeKind = null;

    if (firstIdent.type === "Identifier") {
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }
    }

    let isBinding = false;

    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const as_ident = this.parseIdentifier(true);

      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = as_ident;
        specifier.importKind = specifierTypeKind;
        specifier.local = cloneIdentifier(as_ident);
      } else {
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = this.parseIdentifier();
      }
    } else {
      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
      } else {
        if (importedIsString) {
          throw this.raise(ErrorMessages.ImportBindingIsString, {
            node: specifier
          }, firstIdent.value);
        }

        specifier.imported = firstIdent;
        specifier.importKind = null;
      }

      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        isBinding = true;
        specifier.local = cloneIdentifier(specifier.imported);
      }
    }

    const specifierIsTypeImport = hasTypeImportKind(specifier);

    if (isInTypeOnlyImport && specifierIsTypeImport) {
      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
        node: specifier
      });
    }

    if (isInTypeOnlyImport || specifierIsTypeImport) {
diff --git a/a.js b/b.js
@@ -6317,8 +6537,7 @@ parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTyp
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.maybeParseDefaultImportSpecifier(node);
  }

  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    const firstIdent = specifier.imported;
    let specifierTypeKind = null;

    if (firstIdent.type === "Identifier") {
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }
    }

    let isBinding = false;

    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const as_ident = this.parseIdentifier(true);

      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = as_ident;
        specifier.importKind = specifierTypeKind;
        specifier.local = cloneIdentifier(as_ident);
      } else {
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = this.parseIdentifier();
      }
    } else {
      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
      } else {
        if (importedIsString) {
          throw this.raise(ErrorMessages.ImportBindingIsString, {
            node: specifier
          }, firstIdent.value);
        }

        specifier.imported = firstIdent;
        specifier.importKind = null;
      }

      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        isBinding = true;
        specifier.local = cloneIdentifier(specifier.imported);
      }
    }

    const specifierIsTypeImport = hasTypeImportKind(specifier);

    if (isInTypeOnlyImport && specifierIsTypeImport) {
      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
        node: specifier
      });
    }

    if (isInTypeOnlyImport || specifierIsTypeImport) {
      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
    }

    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
    }

    this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
    return this.finishNode(specifier, "ImportSpecifier");
  }

  parseBindingAtom() {
    switch (this.state.type) {
diff --git a/a.js b/b.js
@@ -6412,7 +6631,7 @@ parseMaybeAssign(refExpressionErrors, afterLeftParse) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }

  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    var _jsx;

    let state = null;
    let jsx;

    if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
      if (!jsx.error) return jsx.node;
      const {
        context
      } = this.state;
      const currentContext = context[context.length - 1];

      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
        context.pop();
      }
    }

    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
      var _jsx2, _jsx3;

      state = state || this.state.clone();
      let typeParameters;
      const arrow = this.tryParse(abort => {
        var _arrowExpression$extr;

        typeParameters = this.flowParseTypeParameterDeclaration();
        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          this.resetStartLocationFromNode(result, typeParameters);
          return result;
        });
        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
        if (expr.type !== "ArrowFunctionExpression") abort();
        expr.typeParameters = typeParameters;
        this.resetStartLocationFromNode(expr, typeParameters);
        return arrowExpression;
      }, state);
      let arrowExpression = null;

      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
        if (!arrow.error && !arrow.aborted) {
          if (arrow.node.async) {
            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
              node: typeParameters
            });
          }

          return arrow.node;
diff --git a/a.js b/b.js
@@ -6435,7 +6654,7 @@ parseMaybeAssign(refExpressionErrors, afterLeftParse) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }

  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    var _jsx;

    let state = null;
    let jsx;

    if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
      if (!jsx.error) return jsx.node;
      const {
        context
      } = this.state;
      const currentContext = context[context.length - 1];

      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
        context.pop();
      }
    }

    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
      var _jsx2, _jsx3;

      state = state || this.state.clone();
      let typeParameters;
      const arrow = this.tryParse(abort => {
        var _arrowExpression$extr;

        typeParameters = this.flowParseTypeParameterDeclaration();
        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          this.resetStartLocationFromNode(result, typeParameters);
          return result;
        });
        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
        if (expr.type !== "ArrowFunctionExpression") abort();
        expr.typeParameters = typeParameters;
        this.resetStartLocationFromNode(expr, typeParameters);
        return arrowExpression;
      }, state);
      let arrowExpression = null;

      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
        if (!arrow.error && !arrow.aborted) {
          if (arrow.node.async) {
            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
              node: typeParameters
            });
          }

          return arrow.node;
        }

        arrowExpression = arrow.node;
      }

      if ((_jsx2 = jsx) != null && _jsx2.node) {
        this.state = jsx.failState;
        return jsx.node;
      }

      if (arrowExpression) {
        this.state = arrow.failState;
        return arrowExpression;
      }

      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
      if (arrow.thrown) throw arrow.error;
      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
        node: typeParameters
      });
    }

    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
diff --git a/a.js b/b.js
@@ -6482,7 +6701,7 @@ checkParams(node, allowDuplicates, isArrowFunction) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      super.setArrowFunctionParameters(node, params);
    }
  }

  checkParams(node, allowDuplicates, isArrowFunction) {
    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      return;
    }

    for (let i = 0; i < node.params.length; i++) {
      if (this.isThisParam(node.params[i]) && i > 0) {
        this.raise(FlowErrors.ThisParamMustBeFirst, {
          node: node.params[i]
        });
      }
    }

diff --git a/a.js b/b.js
@@ -6633,7 +6852,7 @@ skipBlockComment() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return fileNode;
  }

  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment) {
        throw this.raise(FlowErrors.NestedFlowComment, {
          at: this.state.startLoc
        });
      }

      this.hasFlowCommentCompletion();
      this.state.pos += this.skipFlowComment();
      this.state.hasFlowComment = true;
      return;
    }

    if (this.state.hasFlowComment) {
      const end = this.input.indexOf("*-/", this.state.pos + 2);

      if (end === -1) {
        throw this.raise(ErrorMessages.UnterminatedComment, {
          at: this.state.curPosition()
        });
      }

diff --git a/a.js b/b.js
@@ -6677,7 +6896,7 @@ hasFlowCommentCompletion() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return false;
  }

  hasFlowCommentCompletion() {
    const end = this.input.indexOf("*/", this.state.pos);

    if (end === -1) {
      throw this.raise(ErrorMessages.UnterminatedComment, {
        at: this.state.curPosition()
      });
    }
  }
diff --git a/a.js b/b.js
@@ -6688,27 +6907,16 @@ flowEnumErrorBooleanMemberNotInitialized(loc, {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        at: this.state.curPosition()
      });
    }
  }

  flowEnumErrorBooleanMemberNotInitialized(loc, {
    enumName,
    memberName
  }) {
    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
      at: loc
    }, memberName, enumName);
  }

  flowEnumErrorInvalidExplicitType(loc, {
    enumName,
    suppliedType
  }) {
    return this.raise(suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, {
      at: loc
    }, enumName, suppliedType);
  }

  flowEnumErrorInvalidMemberInitializer(loc, {
    enumName,
    explicitType,
    memberName
  }) {
    return this.raise(explicitType === "boolean" || explicitType === "number" || explicitType === "string" ? FlowErrors.EnumInvalidMemberInitializerPrimaryType : explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerUnknownType, {
      at: loc
    }, enumName, memberName, explicitType);
  }

  flowEnumErrorNumberMemberNotInitialized(loc, {
    enumName,
diff --git a/a.js b/b.js
@@ -6716,16 +6924,19 @@ flowEnumErrorNumberMemberNotInitialized(loc, {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    return this.raise(explicitType === "boolean" || explicitType === "number" || explicitType === "string" ? FlowErrors.EnumInvalidMemberInitializerPrimaryType : explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerUnknownType, {
      at: loc
    }, enumName, memberName, explicitType);
  }

  flowEnumErrorNumberMemberNotInitialized(loc, {
    enumName,
    memberName
  }) {
    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
      at: loc
    }, enumName, memberName);
  }

  flowEnumErrorStringMemberInconsistentlyInitailized(node, {
    enumName
  }) {
    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
      node
    }, enumName);
  }

  flowEnumMemberInit() {
    const startLoc = this.state.startLoc;
diff --git a/a.js b/b.js
@@ -6856,14 +7067,19 @@ flowEnumMembers({
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (explicitType !== expectedType) {
      this.flowEnumErrorInvalidMemberInitializer(loc, context);
    }
  }

  flowEnumMembers({
    enumName,
    explicitType
  }) {
    const seenNames = new Set();
    const members = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let hasUnknownMembers = false;

    while (!this.match(8)) {
      if (this.eat(21)) {
        hasUnknownMembers = true;
        break;
      }

      const memberNode = this.startNode();
      const {
        id,
        init
      } = this.flowEnumMemberRaw();
      const memberName = id.name;

      if (memberName === "") {
        continue;
      }

      if (/^[a-z]/.test(memberName)) {
        this.raise(FlowErrors.EnumInvalidMemberName, {
          node: id
        }, memberName, memberName[0].toUpperCase() + memberName.slice(1), enumName);
      }

      if (seenNames.has(memberName)) {
        this.raise(FlowErrors.EnumDuplicateMemberName, {
          node: id
        }, memberName, enumName);
      }

      seenNames.add(memberName);
      const context = {
diff --git a/a.js b/b.js
@@ -6961,30 +7177,29 @@ flowEnumStringMembers(initializedMembers, defaultedMembers, {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      members,
      hasUnknownMembers
    };
  }

  flowEnumStringMembers(initializedMembers, defaultedMembers, {
    enumName
  }) {
    if (initializedMembers.length === 0) {
      return defaultedMembers;
    } else if (defaultedMembers.length === 0) {
      return initializedMembers;
    } else if (defaultedMembers.length > initializedMembers.length) {
      for (const member of initializedMembers) {
        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
          enumName
        });
      }

      return defaultedMembers;
    } else {
      for (const member of defaultedMembers) {
        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
          enumName
        });
      }

      return initializedMembers;
    }
  }

  flowEnumParseExplicitType({
    enumName
  }) {
    if (this.eatContextual(101)) {
      if (!tokenIsIdentifier(this.state.type)) {
        throw this.flowEnumErrorInvalidExplicitType(this.state.startLoc, {
          enumName,
          suppliedType: null
        });
      }

      const {
        value
      } = this.state;
      this.next();

      if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
        this.flowEnumErrorInvalidExplicitType(this.state.startLoc, {
          enumName,
          suppliedType: value
        });
      }

      return value;
    }

    return null;
  }

  flowEnumBody(node, id) {
    const enumName = id.name;
diff --git a/a.js b/b.js
@@ -7075,8 +7290,9 @@ flowEnumBody(node, id) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return null;
  }

  flowEnumBody(node, id) {
    const enumName = id.name;
    const nameLoc = id.loc.start;
    const explicitType = this.flowEnumParseExplicitType({
      enumName
    });
    this.expect(5);
    const {
      members,
      hasUnknownMembers
    } = this.flowEnumMembers({
      enumName,
      explicitType
    });
    node.hasUnknownMembers = hasUnknownMembers;

    switch (explicitType) {
      case "boolean":
        node.explicitType = true;
        node.members = members.booleanMembers;
        this.expect(8);
        return this.finishNode(node, "EnumBooleanBody");

      case "number":
        node.explicitType = true;
        node.members = members.numberMembers;
        this.expect(8);
        return this.finishNode(node, "EnumNumberBody");

      case "string":
        node.explicitType = true;
        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
          enumName
        });
        this.expect(8);
        return this.finishNode(node, "EnumStringBody");

      case "symbol":
        node.members = members.defaultedMembers;
        this.expect(8);
        return this.finishNode(node, "EnumSymbolBody");

      default:
        {
          const empty = () => {
            node.members = [];
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          };

          node.explicitType = false;
          const boolsLen = members.booleanMembers.length;
          const numsLen = members.numberMembers.length;
          const strsLen = members.stringMembers.length;
          const defaultedLen = members.defaultedMembers.length;

          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty();
          } else if (!boolsLen && !numsLen) {
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }

            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }

            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          } else {
            this.raise(FlowErrors.EnumInconsistentMemberValues, {
              at: nameLoc
            }, enumName);
            return empty();
          }
        }
    }
diff --git a/a.js b/b.js
@@ -7108,6 +7324,7 @@ maybeUnwrapTypeCastExpression(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return false;
  }

  maybeUnwrapTypeCastExpression(node) {
    return node.type === "TypeCastExpression" ? node.expression : node;
  }

});

const entities = {
  quot: "\u0022",
  amp: "&",
  apos: "\u0027",
  lt: "<",
diff --git a/a.js b/b.js
@@ -7363,17 +7580,21 @@ maybeUnwrapTypeCastExpression(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return false;
  }

  maybeUnwrapTypeCastExpression(node) {
    return node.type === "TypeCastExpression" ? node.expression : node;
  }

});

const entities = {
  quot: "\u0022",
  amp: "&",
  apos: "\u0027",
  lt: "<",
  gt: ">",
  nbsp: "\u00A0",
  iexcl: "\u00A1",
  cent: "\u00A2",
  pound: "\u00A3",
  curren: "\u00A4",
  yen: "\u00A5",
  brvbar: "\u00A6",
  sect: "\u00A7",
  uml: "\u00A8",
  copy: "\u00A9",
  ordf: "\u00AA",
  laquo: "\u00AB",
  not: "\u00AC",
  shy: "\u00AD",
  reg: "\u00AE",
  macr: "\u00AF",
  deg: "\u00B0",
  plusmn: "\u00B1",
  sup2: "\u00B2",
  sup3: "\u00B3",
  acute: "\u00B4",
  micro: "\u00B5",
  para: "\u00B6",
  middot: "\u00B7",
  cedil: "\u00B8",
  sup1: "\u00B9",
  ordm: "\u00BA",
  raquo: "\u00BB",
  frac14: "\u00BC",
  frac12: "\u00BD",
  frac34: "\u00BE",
  iquest: "\u00BF",
  Agrave: "\u00C0",
  Aacute: "\u00C1",
  Acirc: "\u00C2",
  Atilde: "\u00C3",
  Auml: "\u00C4",
  Aring: "\u00C5",
  AElig: "\u00C6",
  Ccedil: "\u00C7",
  Egrave: "\u00C8",
  Eacute: "\u00C9",
  Ecirc: "\u00CA",
  Euml: "\u00CB",
  Igrave: "\u00CC",
  Iacute: "\u00CD",
  Icirc: "\u00CE",
  Iuml: "\u00CF",
  ETH: "\u00D0",
  Ntilde: "\u00D1",
  Ograve: "\u00D2",
  Oacute: "\u00D3",
  Ocirc: "\u00D4",
  Otilde: "\u00D5",
  Ouml: "\u00D6",
  times: "\u00D7",
  Oslash: "\u00D8",
  Ugrave: "\u00D9",
  Uacute: "\u00DA",
  Ucirc: "\u00DB",
  Uuml: "\u00DC",
  Yacute: "\u00DD",
  THORN: "\u00DE",
  szlig: "\u00DF",
  agrave: "\u00E0",
  aacute: "\u00E1",
  acirc: "\u00E2",
  atilde: "\u00E3",
  auml: "\u00E4",
  aring: "\u00E5",
  aelig: "\u00E6",
  ccedil: "\u00E7",
  egrave: "\u00E8",
  eacute: "\u00E9",
  ecirc: "\u00EA",
  euml: "\u00EB",
  igrave: "\u00EC",
  iacute: "\u00ED",
  icirc: "\u00EE",
  iuml: "\u00EF",
  eth: "\u00F0",
  ntilde: "\u00F1",
  ograve: "\u00F2",
  oacute: "\u00F3",
  ocirc: "\u00F4",
  otilde: "\u00F5",
  ouml: "\u00F6",
  divide: "\u00F7",
  oslash: "\u00F8",
  ugrave: "\u00F9",
  uacute: "\u00FA",
  ucirc: "\u00FB",
  uuml: "\u00FC",
  yacute: "\u00FD",
  thorn: "\u00FE",
  yuml: "\u00FF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;
const JsxErrors = makeErrorTemplates({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
}, ErrorCodes.SyntaxError, "jsx");

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}
diff --git a/a.js b/b.js
@@ -7469,7 +7690,7 @@ jsxReadString(quote) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    ++this.state.curLine;
    this.state.lineStart = this.state.pos;
    return out;
  }

  jsxReadString(quote) {
    let out = "";
    let chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(ErrorMessages.UnterminatedString, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -7495,46 +7716,44 @@ jsxReadString(quote) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    ++this.state.curLine;
    this.state.lineStart = this.state.pos;
    return out;
  }

  jsxReadString(quote) {
    let out = "";
    let chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(ErrorMessages.UnterminatedString, {
          at: this.state.startLoc
        });
      }

      const ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;

      if (ch === 38) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadNewLine(false);
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }

    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(129, out);
  }

  jsxReadEntity() {
    let str = "";
    let count = 0;
    let entity;
    let ch = this.input[this.state.pos];
    const startPos = ++this.state.pos;

    while (this.state.pos < this.length && count++ < 10) {
      ch = this.input[this.state.pos++];

      if (ch === ";") {
        if (str[0] === "#") {
          if (str[1] === "x") {
            str = str.substr(2);

            if (HEX_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);

            if (DECIMAL_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 10));
            }
          }
        } else {
          entity = entities[str];
        }

        break;
      }

      str += ch;
    }

    if (!entity) {
      this.state.pos = startPos;
      return "&";
    }

    return entity;
  }

  jsxReadWord() {
    let ch;
diff --git a/a.js b/b.js
@@ -7605,7 +7824,7 @@ jsxParseAttributeValue() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return node;
  }

  jsxParseAttributeValue() {
    let node;

    switch (this.state.type) {
      case 5:
        node = this.startNode();
        this.setContext(types.brace);
        this.next();
        node = this.jsxParseExpressionContainer(node, types.j_oTag);

        if (node.expression.type === "JSXEmptyExpression") {
          this.raise(JsxErrors.AttributeIsEmpty, {
            node
          });
        }

        return node;
diff --git a/a.js b/b.js
@@ -7752,17 +7971,19 @@ jsxParseElementAt(startPos, startLoc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.name = this.jsxParseElementName();
    this.expect(139);
    return this.finishNode(node, "JSXClosingElement");
  }

  jsxParseElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);
    const children = [];
    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
    let closingElement = null;

    if (!openingElement.selfClosing) {
      contents: for (;;) {
        switch (this.state.type) {
          case 138:
            startPos = this.state.start;
            startLoc = this.state.startLoc;
            this.next();

            if (this.eat(56)) {
              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
              break contents;
            }

            children.push(this.jsxParseElementAt(startPos, startLoc));
            break;

          case 137:
            children.push(this.parseExprAtom());
            break;

          case 5:
            {
              const node = this.startNode();
              this.setContext(types.brace);
              this.next();

              if (this.match(21)) {
                children.push(this.jsxParseSpreadChild(node));
              } else {
                children.push(this.jsxParseExpressionContainer(node, types.j_expr));
              }

              break;
            }

          default:
            throw this.unexpected();
        }
      }

      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
        this.raise(JsxErrors.MissingClosingTagFragment, {
          node: closingElement
        });
      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
        this.raise(JsxErrors.MissingClosingTagElement, {
          node: closingElement
        }, getQualifiedJSXName(openingElement.name));
      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(JsxErrors.MissingClosingTagElement, {
            node: closingElement
          }, getQualifiedJSXName(openingElement.name));
        }
      }
    }

diff --git a/a.js b/b.js
@@ -7957,6 +8178,8 @@ checkLocalExport(id) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.isRedeclaredInScope(...arguments);
  }

  checkLocalExport(id) {
    const topLevelScope = this.scopeStack[0];
    const {
      name
    } = id;

    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
      super.checkLocalExport(id);
    }
  }

}

function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`);
  }
diff --git a/a.js b/b.js
@@ -7971,61 +8194,93 @@ function assert(x) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

const TSErrors = makeErrorTemplates({
  AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
  AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: "'declare' is not allowed in %0ters.",
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
  DuplicateModifier: "Duplicate modifier: '%0'.",
  EmptyHeritageClauseType: "'%0' list cannot be empty.",
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
  InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
}, ErrorCodes.SyntaxError, "typescript");

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
diff --git a/a.js b/b.js
@@ -8106,20 +8361,27 @@ tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  tsNextTokenCanFollowModifier() {
    this.next();
    return this.tsTokenCanFollowModifier();
  }

  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
    if (!tokenIsIdentifier(this.state.type)) {
      return undefined;
    }

    const modifier = this.state.value;

    if (allowedModifiers.indexOf(modifier) !== -1) {
      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
        return undefined;
      }

      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
        return modifier;
      }
    }

    return undefined;
  }

  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
    const enforceOrder = (loc, modifier, before, after) => {
      if (modifier === before && modified[after]) {
        this.raise(TSErrors.InvalidModifiersOrder, {
          at: loc
        }, before, after);
      }
    };

    const incompatible = (loc, modifier, mod1, mod2) => {
      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
        this.raise(TSErrors.IncompatibleModifiers, {
          at: loc
        }, mod1, mod2);
      }
    };

    for (;;) {
diff --git a/a.js b/b.js
@@ -8133,7 +8395,8 @@ tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate,
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return undefined;
  }

  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
    const enforceOrder = (loc, modifier, before, after) => {
      if (modifier === before && modified[after]) {
        this.raise(TSErrors.InvalidModifiersOrder, {
          at: loc
        }, before, after);
      }
    };

    const incompatible = (loc, modifier, mod1, mod2) => {
      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
        this.raise(TSErrors.IncompatibleModifiers, {
          at: loc
        }, mod1, mod2);
      }
    };

    for (;;) {
      const {
        startLoc
      } = this.state;
      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
      if (!modifier) break;

      if (tsIsAccessModifier(modifier)) {
        if (modified.accessibility) {
          this.raise(TSErrors.DuplicateAccessibilityModifier, {
            at: startLoc
          });
        } else {
          enforceOrder(startLoc, modifier, modifier, "override");
          enforceOrder(startLoc, modifier, modifier, "static");
diff --git a/a.js b/b.js
@@ -8144,8 +8407,9 @@ tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate,
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return undefined;
  }

  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
    const enforceOrder = (loc, modifier, before, after) => {
      if (modifier === before && modified[after]) {
        this.raise(TSErrors.InvalidModifiersOrder, {
          at: loc
        }, before, after);
      }
    };

    const incompatible = (loc, modifier, mod1, mod2) => {
      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
        this.raise(TSErrors.IncompatibleModifiers, {
          at: loc
        }, mod1, mod2);
      }
    };

    for (;;) {
      const {
        startLoc
      } = this.state;
      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
      if (!modifier) break;

      if (tsIsAccessModifier(modifier)) {
        if (modified.accessibility) {
          this.raise(TSErrors.DuplicateAccessibilityModifier, {
            at: startLoc
          });
        } else {
          enforceOrder(startLoc, modifier, modifier, "override");
          enforceOrder(startLoc, modifier, modifier, "static");
          enforceOrder(startLoc, modifier, modifier, "readonly");
          modified.accessibility = modifier;
        }
      } else {
        if (Object.hasOwnProperty.call(modified, modifier)) {
          this.raise(TSErrors.DuplicateModifier, {
            at: startLoc
          }, modifier);
        } else {
          enforceOrder(startLoc, modifier, "static", "readonly");
          enforceOrder(startLoc, modifier, "static", "override");
          enforceOrder(startLoc, modifier, "override", "readonly");
diff --git a/a.js b/b.js
@@ -8159,9 +8423,10 @@ tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate,
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return undefined;
  }

  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
    const enforceOrder = (loc, modifier, before, after) => {
      if (modifier === before && modified[after]) {
        this.raise(TSErrors.InvalidModifiersOrder, {
          at: loc
        }, before, after);
      }
    };

    const incompatible = (loc, modifier, mod1, mod2) => {
      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
        this.raise(TSErrors.IncompatibleModifiers, {
          at: loc
        }, mod1, mod2);
      }
    };

    for (;;) {
      const {
        startLoc
      } = this.state;
      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
      if (!modifier) break;

      if (tsIsAccessModifier(modifier)) {
        if (modified.accessibility) {
          this.raise(TSErrors.DuplicateAccessibilityModifier, {
            at: startLoc
          });
        } else {
          enforceOrder(startLoc, modifier, modifier, "override");
          enforceOrder(startLoc, modifier, modifier, "static");
          enforceOrder(startLoc, modifier, modifier, "readonly");
          modified.accessibility = modifier;
        }
      } else {
        if (Object.hasOwnProperty.call(modified, modifier)) {
          this.raise(TSErrors.DuplicateModifier, {
            at: startLoc
          }, modifier);
        } else {
          enforceOrder(startLoc, modifier, "static", "readonly");
          enforceOrder(startLoc, modifier, "static", "override");
          enforceOrder(startLoc, modifier, "override", "readonly");
          enforceOrder(startLoc, modifier, "abstract", "override");
          incompatible(startLoc, modifier, "declare", "override");
          incompatible(startLoc, modifier, "static", "abstract");
        }

        modified[modifier] = true;
      }

      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
        this.raise(errorTemplate, {
          at: startLoc
        }, modifier);
      }
    }
  }

diff --git a/a.js b/b.js
@@ -8275,7 +8540,7 @@ tsParseImportType() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return result;
  }

  tsParseImportType() {
    const node = this.startNode();
    this.expect(83);
    this.expect(10);

    if (!this.match(129)) {
      this.raise(TSErrors.UnsupportedImportTypeArgument, {
        at: this.state.startLoc
      });
    }

    node.argument = this.parseExprAtom();
    this.expect(11);

    if (this.eat(16)) {
      node.qualifier = this.tsParseEntityName(true);
    }

    if (this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
diff --git a/a.js b/b.js
@@ -8285,8 +8550,8 @@ tsParseImportType() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return result;
  }

  tsParseImportType() {
    const node = this.startNode();
    this.expect(83);
    this.expect(10);

    if (!this.match(129)) {
      this.raise(TSErrors.UnsupportedImportTypeArgument, {
        at: this.state.startLoc
      });
    }

    node.argument = this.parseExprAtom();
    this.expect(11);

    if (this.eat(16)) {
      node.qualifier = this.tsParseEntityName(true);
    }

    if (this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSImportType");
  }

  tsParseEntityName(allowReservedWords) {
    let entity = this.parseIdentifier();

    while (this.eat(16)) {
      const node = this.startNodeAtNode(entity);
      node.left = entity;
diff --git a/a.js b/b.js
@@ -8300,7 +8565,7 @@ tsParseEntityName(allowReservedWords) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "TSImportType");
  }

  tsParseEntityName(allowReservedWords) {
    let entity = this.parseIdentifier();

    while (this.eat(16)) {
      const node = this.startNodeAtNode(entity);
      node.left = entity;
      node.right = this.parseIdentifier(allowReservedWords);
      entity = this.finishNode(node, "TSQualifiedName");
    }

    return entity;
  }

  tsParseTypeReference() {
    const node = this.startNode();
    node.typeName = this.tsParseEntityName(false);

    if (!this.hasPrecedingLineBreak() && this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }
diff --git a/a.js b/b.js
@@ -8331,7 +8596,7 @@ tsParseTypeQuery() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const node = this.startNode();
    this.next();
    return this.finishNode(node, "TSThisType");
  }

  tsParseTypeQuery() {
    const node = this.startNode();
    this.expect(87);

    if (this.match(83)) {
      node.exprName = this.tsParseImportType();
    } else {
      node.exprName = this.tsParseEntityName(true);
    }

    return this.finishNode(node, "TSTypeQuery");
  }
diff --git a/a.js b/b.js
@@ -8367,7 +8632,7 @@ tsParseTypeParameters() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (this.match(47)) {
      return this.tsParseTypeParameters();
    }
  }

  tsParseTypeParameters() {
    const node = this.startNode();

    if (this.match(47) || this.match(138)) {
      this.next();
    } else {
      this.unexpected();
    }

    const refTrailingCommaPos = {
      value: -1
    };
    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, refTrailingCommaPos);

    if (node.params.length === 0) {
      this.raise(TSErrors.EmptyTypeParameters, {
        node
      });
    }

    if (refTrailingCommaPos.value !== -1) {
diff --git a/a.js b/b.js
@@ -8379,12 +8644,18 @@ tsParseTypeParameters() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (this.match(47)) {
      return this.tsParseTypeParameters();
    }
  }

  tsParseTypeParameters() {
    const node = this.startNode();

    if (this.match(47) || this.match(138)) {
      this.next();
    } else {
      this.unexpected();
    }

    const refTrailingCommaPos = {
      value: -1
    };
    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, refTrailingCommaPos);

    if (node.params.length === 0) {
      this.raise(TSErrors.EmptyTypeParameters, {
        node
      });
    }

    if (refTrailingCommaPos.value !== -1) {
      this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
    }

    return this.finishNode(node, "TSTypeParameterDeclaration");
  }

  tsTryNextParseConstantContext() {
    if (this.lookahead().type === 75) {
      this.next();
      return this.tsParseTypeReference();
    }

    return null;
  }

  tsFillSignature(returnToken, signature) {
    const returnTokenRequired = returnToken === 19;
diff --git a/a.js b/b.js
@@ -8406,8 +8677,9 @@ tsParseBindingListForSignature() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else if (this.match(returnToken)) {
      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
  }

  tsParseBindingListForSignature() {
    return this.parseBindingList(11, 41).map(pattern => {
      if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
        this.raise(TSErrors.UnsupportedSignatureParameterKind, {
          node: pattern
        }, pattern.type);
      }

      return pattern;
    });
diff --git a/a.js b/b.js
@@ -8461,7 +8733,7 @@ tsParsePropertyOrMethodSignature(node, readonly) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (type) node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }

  tsParsePropertyOrMethodSignature(node, readonly) {
    if (this.eat(17)) node.optional = true;
    const nodeAny = node;

    if (this.match(10) || this.match(47)) {
      if (readonly) {
        this.raise(TSErrors.ReadonlyForMethodSignature, {
          node
        });
      }

      const method = nodeAny;
diff --git a/a.js b/b.js
@@ -8480,7 +8752,7 @@ tsParsePropertyOrMethodSignature(node, readonly) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (type) node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }

  tsParsePropertyOrMethodSignature(node, readonly) {
    if (this.eat(17)) node.optional = true;
    const nodeAny = node;

    if (this.match(10) || this.match(47)) {
      if (readonly) {
        this.raise(TSErrors.ReadonlyForMethodSignature, {
          node
        });
      }

      const method = nodeAny;

      if (method.kind && this.match(47)) {
        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        });
      }

      this.tsFillSignature(14, method);
      this.tsParseTypeMemberSemicolon();
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";

      if (method.kind === "get") {
        if (method[paramsKey].length > 0) {
          this.raise(ErrorMessages.BadGetterArity, {
            at: this.state.curPosition()
          });

          if (this.isThisParam(method[paramsKey][0])) {
diff --git a/a.js b/b.js
@@ -8492,7 +8764,7 @@ tsParsePropertyOrMethodSignature(node, readonly) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (type) node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }

  tsParsePropertyOrMethodSignature(node, readonly) {
    if (this.eat(17)) node.optional = true;
    const nodeAny = node;

    if (this.match(10) || this.match(47)) {
      if (readonly) {
        this.raise(TSErrors.ReadonlyForMethodSignature, {
          node
        });
      }

      const method = nodeAny;

      if (method.kind && this.match(47)) {
        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        });
      }

      this.tsFillSignature(14, method);
      this.tsParseTypeMemberSemicolon();
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";

      if (method.kind === "get") {
        if (method[paramsKey].length > 0) {
          this.raise(ErrorMessages.BadGetterArity, {
            at: this.state.curPosition()
          });

          if (this.isThisParam(method[paramsKey][0])) {
            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            });
          }
        }
      } else if (method.kind === "set") {
        if (method[paramsKey].length !== 1) {
          this.raise(ErrorMessages.BadSetterArity, {
            at: this.state.curPosition()
          });
        } else {
          const firstParameter = method[paramsKey][0];
diff --git a/a.js b/b.js
@@ -8519,7 +8791,7 @@ tsParsePropertyOrMethodSignature(node, readonly) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (type) node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }

  tsParsePropertyOrMethodSignature(node, readonly) {
    if (this.eat(17)) node.optional = true;
    const nodeAny = node;

    if (this.match(10) || this.match(47)) {
      if (readonly) {
        this.raise(TSErrors.ReadonlyForMethodSignature, {
          node
        });
      }

      const method = nodeAny;

      if (method.kind && this.match(47)) {
        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        });
      }

      this.tsFillSignature(14, method);
      this.tsParseTypeMemberSemicolon();
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";

      if (method.kind === "get") {
        if (method[paramsKey].length > 0) {
          this.raise(ErrorMessages.BadGetterArity, {
            at: this.state.curPosition()
          });

          if (this.isThisParam(method[paramsKey][0])) {
            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            });
          }
        }
      } else if (method.kind === "set") {
        if (method[paramsKey].length !== 1) {
          this.raise(ErrorMessages.BadSetterArity, {
            at: this.state.curPosition()
          });
        } else {
          const firstParameter = method[paramsKey][0];

          if (this.isThisParam(firstParameter)) {
            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            });
          }

          if (firstParameter.type === "Identifier" && firstParameter.optional) {
            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
              at: this.state.curPosition()
            });
          }

          if (firstParameter.type === "RestElement") {
            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
              at: this.state.curPosition()
            });
          }
        }

        if (method[returnTypeKey]) {
          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
            node: method[returnTypeKey]
          });
        }
      } else {
        method.kind = "method";
diff --git a/a.js b/b.js
@@ -8556,7 +8828,11 @@ tsParseTypeMember() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(property, "TSPropertySignature");
    }
  }

  tsParseTypeMember() {
    const node = this.startNode();

    if (this.match(10) || this.match(47)) {
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
    }

    if (this.match(77)) {
      const id = this.startNode();
      this.next();

      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
      } else {
        node.key = this.createIdentifier(id, "new");
        return this.tsParsePropertyOrMethodSignature(node, false);
      }
    }

    this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
    const idx = this.tsTryParseIndexSignature(node);

    if (idx) {
      return idx;
diff --git a/a.js b/b.js
@@ -8663,7 +8939,7 @@ tsParseTupleType() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.semicolon();
    this.expect(8);
    return this.finishNode(node, "TSMappedType");
  }

  tsParseTupleType() {
    const node = this.startNode();
    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let seenOptionalElement = false;
    let labeledElements = null;
    node.elementTypes.forEach(elementNode => {
      var _labeledElements;

      let {
        type
      } = elementNode;

      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
        this.raise(TSErrors.OptionalTypeBeforeRequired, {
          node: elementNode
        });
      }

      seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
diff --git a/a.js b/b.js
@@ -8679,7 +8955,7 @@ tsParseTupleType() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.semicolon();
    this.expect(8);
    return this.finishNode(node, "TSMappedType");
  }

  tsParseTupleType() {
    const node = this.startNode();
    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let seenOptionalElement = false;
    let labeledElements = null;
    node.elementTypes.forEach(elementNode => {
      var _labeledElements;

      let {
        type
      } = elementNode;

      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
        this.raise(TSErrors.OptionalTypeBeforeRequired, {
          node: elementNode
        });
      }

      seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

      if (type === "TSRestType") {
        elementNode = elementNode.typeAnnotation;
        type = elementNode.type;
      }

      const isLabeled = type === "TSNamedTupleMember";
      labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

      if (labeledElements !== isLabeled) {
        this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
          node: elementNode
        });
      }
    });
    return this.finishNode(node, "TSTupleType");
diff --git a/a.js b/b.js
@@ -8704,7 +8980,7 @@ tsParseTupleElementType() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      }
    });
    return this.finishNode(node, "TSTupleType");
  }

  tsParseTupleElementType() {
    const {
      start: startPos,
      startLoc
    } = this.state;
    const rest = this.eat(21);
    let type = this.tsParseType();
    const optional = this.eat(17);
    const labeled = this.eat(14);

    if (labeled) {
      const labeledNode = this.startNodeAtNode(type);
      labeledNode.optional = optional;

      if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
        labeledNode.label = type.typeName;
      } else {
        this.raise(TSErrors.InvalidTupleMemberLabel, {
          node: type
        });
        labeledNode.label = type;
      }

diff --git a/a.js b/b.js
@@ -8900,7 +9176,7 @@ tsCheckTypeAnnotationForReadOnly(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "TSTypeOperator");
  }

  tsCheckTypeAnnotationForReadOnly(node) {
    switch (node.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;

      default:
        this.raise(TSErrors.UnexpectedReadonly, {
          node
        });
    }
  }

diff --git a/a.js b/b.js
@@ -8959,37 +9235,32 @@ tsSkipParameterStart() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }

  tsSkipParameterStart() {
    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
      this.next();
      return true;
    }

    if (this.match(5)) {
      let braceStackCounter = 1;
      this.next();

      while (braceStackCounter > 0) {
        if (this.match(5)) {
          ++braceStackCounter;
        } else if (this.match(8)) {
          --braceStackCounter;
        }

        this.next();
      }

      return true;
    }

    if (this.match(0)) {
      let braceStackCounter = 1;
      this.next();

      while (braceStackCounter > 0) {
        if (this.match(0)) {
          ++braceStackCounter;
        } else if (this.match(3)) {
          --braceStackCounter;
        }

        this.next();
      }

      return true;
    }

    return false;
  }
diff --git a/a.js b/b.js
@@ -9100,9 +9371,10 @@ tsParseTypePredicateAsserts() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      this.next();
      return id;
    }
  }

  tsParseTypePredicateAsserts() {
    if (this.state.type !== 106) {
      return false;
    }

    const containsEsc = this.state.containsEsc;
    this.next();

    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
      return false;
    }

    if (containsEsc) {
      this.raise(ErrorMessages.InvalidEscapedReservedWord, {
        at: this.state.lastTokStartLoc
      }, "asserts");
    }

    return true;
  }
diff --git a/a.js b/b.js
@@ -9169,14 +9441,15 @@ tsParseTypeAssertion() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.tsParseUnionTypeOrHigher();
  }

  tsParseTypeAssertion() {
    if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
      this.raise(TSErrors.ReservedTypeAssertion, {
        at: this.state.startLoc
      });
    }

    const node = this.startNode();

    const _const = this.tsTryNextParseConstantContext();

    node.typeAnnotation = _const || this.tsNextThenParseType();
    this.expect(48);
    node.expression = this.parseMaybeUnary();
    return this.finishNode(node, "TSTypeAssertion");
  }

  tsParseHeritageClause(descriptor) {
    const originalStartLoc = this.state.startLoc;
    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

    if (!delimitedList.length) {
      this.raise(TSErrors.EmptyHeritageClauseType, {
        at: originalStartLoc
      }, descriptor);
    }

    return delimitedList;
  }
diff --git a/a.js b/b.js
@@ -9184,7 +9457,7 @@ tsParseHeritageClause(descriptor) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.expect(48);
    node.expression = this.parseMaybeUnary();
    return this.finishNode(node, "TSTypeAssertion");
  }

  tsParseHeritageClause(descriptor) {
    const originalStartLoc = this.state.startLoc;
    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

    if (!delimitedList.length) {
      this.raise(TSErrors.EmptyHeritageClauseType, {
        at: originalStartLoc
      }, descriptor);
    }

    return delimitedList;
  }

  tsParseExpressionWithTypeArguments() {
    const node = this.startNode();
    node.expression = this.tsParseEntityName(false);

    if (this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }
diff --git a/a.js b/b.js
@@ -9193,10 +9466,14 @@ tsParseExpressionWithTypeArguments() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return delimitedList;
  }

  tsParseExpressionWithTypeArguments() {
    const node = this.startNode();
    node.expression = this.tsParseEntityName(false);

    if (this.match(47)) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSExpressionWithTypeArguments");
  }

  tsParseInterfaceDeclaration(node) {
    if (tokenIsIdentifier(this.state.type)) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
    } else {
      node.id = null;
      this.raise(TSErrors.MissingInterfaceName, {
        at: this.state.startLoc
diff --git a/a.js b/b.js
@@ -9218,7 +9495,7 @@ tsParseInterfaceDeclaration(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "TSExpressionWithTypeArguments");
  }

  tsParseInterfaceDeclaration(node) {
    if (tokenIsIdentifier(this.state.type)) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
    } else {
      node.id = null;
      this.raise(TSErrors.MissingInterfaceName, {
        at: this.state.startLoc
      });
    }

    node.typeParameters = this.tsTryParseTypeParameters();

    if (this.eat(81)) {
      node.extends = this.tsParseHeritageClause("extends");
    }

    const body = this.startNode();
    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
    node.body = this.finishNode(body, "TSInterfaceBody");
    return this.finishNode(node, "TSInterfaceDeclaration");
  }

  tsParseTypeAliasDeclaration(node) {
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
    node.typeParameters = this.tsTryParseTypeParameters();
    node.typeAnnotation = this.tsInType(() => {
      this.expect(29);

diff --git a/a.js b/b.js
@@ -9287,10 +9564,12 @@ tsParseEnumMember() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      cb();
      return this.tsParseType();
    });
  }

  tsParseEnumMember() {
    const node = this.startNode();
    node.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);

    if (this.eat(29)) {
      node.initializer = this.parseMaybeAssignAllowIn();
    }

    return this.finishNode(node, "TSEnumMember");
  }

  tsParseEnumDeclaration(node, isConst) {
    if (isConst) node.const = true;
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
    this.expect(5);
    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
    this.expect(8);
    return this.finishNode(node, "TSEnumDeclaration");
diff --git a/a.js b/b.js
@@ -9310,7 +9589,7 @@ tsParseModuleOrNamespaceDeclaration(node, nested = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
    this.scope.exit();
    return this.finishNode(node, "TSModuleBlock");
  }

  tsParseModuleOrNamespaceDeclaration(node, nested = false) {
    node.id = this.parseIdentifier();

    if (!nested) {
      this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
    }

    if (this.eat(16)) {
      const inner = this.startNode();
diff --git a/a.js b/b.js
@@ -9354,13 +9633,13 @@ tsParseAmbientExternalModuleDeclaration(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "TSModuleDeclaration");
  }

  tsParseAmbientExternalModuleDeclaration(node) {
    if (this.isContextual(109)) {
      node.global = true;
      node.id = this.parseIdentifier();
    } else if (this.match(129)) {
      node.id = this.parseExprAtom();
    } else {
      this.unexpected();
    }

    if (this.match(5)) {
      this.scope.enter(SCOPE_TS_MODULE);
      this.prodParam.enter(PARAM);
      node.body = this.tsParseModuleBlock();
      this.prodParam.exit();
      this.scope.exit();
    } else {
      this.semicolon();
    }

    return this.finishNode(node, "TSModuleDeclaration");
  }

  tsParseImportEqualsDeclaration(node, isExport) {
    node.isExport = isExport || false;
    node.id = this.parseIdentifier();
    this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
    this.expect(29);
    const moduleReference = this.tsParseModuleReference();

    if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
      this.raise(TSErrors.ImportAliasHasImportType, {
        node: moduleReference
      });
    }

    node.moduleReference = moduleReference;
diff --git a/a.js b/b.js
@@ -9431,35 +9710,48 @@ tsTryParseDeclare(nany) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      this.state = state;
      return undefined;
    }
  }

  tsTryParseDeclare(nany) {
    if (this.isLineTerminator()) {
      return;
    }

    let starttype = this.state.type;
    let kind;

    if (this.isContextual(99)) {
      starttype = 74;
      kind = "let";
    }

    return this.tsInAmbientContext(() => {
      switch (starttype) {
        case 68:
          nany.declare = true;
          return this.parseFunctionStatement(nany, false, true);

        case 80:
          nany.declare = true;
          return this.parseClass(nany, true, false);

        case 75:
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            this.expect(75);
            this.expectContextual(122);
            return this.tsParseEnumDeclaration(nany, true);
          }

        case 74:
          kind = kind || this.state.value;
          return this.parseVarStatement(nany, kind);

        case 109:
          return this.tsParseAmbientExternalModuleDeclaration(nany);

        default:
          {
            if (tokenIsIdentifier(starttype)) {
              return this.tsParseDeclaration(nany, this.state.value, true);
            }
          }
      }
    });
  }

diff --git a/a.js b/b.js
@@ -9511,21 +9803,6 @@ tsParseDeclaration(node, value, next) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      default:
        return this.tsParseDeclaration(node, expr.name, false);
    }
  }

  tsParseDeclaration(node, value, next) {
    switch (value) {
      case "abstract":
        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
          return this.tsParseAbstractDeclaration(node);
        }

        break;

      case "enum":
        if (next || tokenIsIdentifier(this.state.type)) {
          if (next) this.next();
          return this.tsParseEnumDeclaration(node, false);
        }

        break;

      case "interface":
        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
          return this.tsParseInterfaceDeclaration(node);
        }

        break;

      case "module":
        if (this.tsCheckLineTerminator(next)) {
          if (this.match(129)) {
            return this.tsParseAmbientExternalModuleDeclaration(node);
diff --git a/a.js b/b.js
@@ -9604,7 +9881,7 @@ tsParseTypeArguments() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.tsParseTypeArguments();
  }

  tsParseTypeArguments() {
    const node = this.startNode();
    node.params = this.tsInType(() => this.tsInNoContext(() => {
      this.expect(47);
      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
    }));

    if (node.params.length === 0) {
      this.raise(TSErrors.EmptyTypeArguments, {
        node
      });
    }

    this.expect(48);
diff --git a/a.js b/b.js
@@ -9630,7 +9907,10 @@ parseAssignableListItem(allowModifiers, decorators) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  isExportDefaultSpecifier() {
    if (this.tsIsDeclarationStart()) return false;
    return super.isExportDefaultSpecifier();
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let accessibility;
    let readonly = false;
    let override = false;

    if (allowModifiers !== undefined) {
      const modified = {};
      this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
      accessibility = modified.accessibility;
      override = modified.override;
      readonly = modified.readonly;

diff --git a/a.js b/b.js
@@ -9659,7 +9939,7 @@ parseAssignableListItem(allowModifiers, decorators) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  isExportDefaultSpecifier() {
    if (this.tsIsDeclarationStart()) return false;
    return super.isExportDefaultSpecifier();
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let accessibility;
    let readonly = false;
    let override = false;

    if (allowModifiers !== undefined) {
      const modified = {};
      this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
      accessibility = modified.accessibility;
      override = modified.override;
      readonly = modified.readonly;

      if (allowModifiers === false && (accessibility || readonly || override)) {
        this.raise(TSErrors.UnexpectedParameterModifier, {
          at: startLoc
        });
      }
    }

    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

    if (accessibility || readonly || override) {
      const pp = this.startNodeAt(startPos, startLoc);

      if (decorators.length) {
        pp.decorators = decorators;
      }

      if (accessibility) pp.accessibility = accessibility;
      if (readonly) pp.readonly = readonly;
      if (override) pp.override = override;

      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
        this.raise(TSErrors.UnsupportedParameterPropertyKind, {
          node: pp
        });
      }

      pp.parameter = elt;
diff --git a/a.js b/b.js
@@ -9674,6 +9954,10 @@ parseAssignableListItem(allowModifiers, decorators) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  isExportDefaultSpecifier() {
    if (this.tsIsDeclarationStart()) return false;
    return super.isExportDefaultSpecifier();
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let accessibility;
    let readonly = false;
    let override = false;

    if (allowModifiers !== undefined) {
      const modified = {};
      this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
      accessibility = modified.accessibility;
      override = modified.override;
      readonly = modified.readonly;

      if (allowModifiers === false && (accessibility || readonly || override)) {
        this.raise(TSErrors.UnexpectedParameterModifier, {
          at: startLoc
        });
      }
    }

    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

    if (accessibility || readonly || override) {
      const pp = this.startNodeAt(startPos, startLoc);

      if (decorators.length) {
        pp.decorators = decorators;
      }

      if (accessibility) pp.accessibility = accessibility;
      if (readonly) pp.readonly = readonly;
      if (override) pp.override = override;

      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
        this.raise(TSErrors.UnsupportedParameterPropertyKind, {
          node: pp
        });
      }

      pp.parameter = elt;
      return this.finishNode(pp, "TSParameterProperty");
    }

    if (decorators.length) {
      left.decorators = decorators;
    }

    return elt;
  }

  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(14)) {
      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
    }
diff --git a/a.js b/b.js
@@ -9688,7 +9972,7 @@ parseFunctionBodyAndFinish(node, type, isMethod = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return elt;
  }

  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(14)) {
      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
    }

    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;

    if (bodilessType && !this.match(5) && this.isLineTerminator()) {
      this.finishNode(node, bodilessType);
      return;
    }

    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
      this.raise(TSErrors.DeclareFunctionHasImplementation, {
        node
      });

      if (node.declare) {
        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
diff --git a/a.js b/b.js
@@ -9702,7 +9986,7 @@ parseFunctionBodyAndFinish(node, type, isMethod = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return elt;
  }

  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    if (this.match(14)) {
      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
    }

    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;

    if (bodilessType && !this.match(5) && this.isLineTerminator()) {
      this.finishNode(node, bodilessType);
      return;
    }

    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
      this.raise(TSErrors.DeclareFunctionHasImplementation, {
        node
      });

      if (node.declare) {
        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
        return;
      }
    }

    super.parseFunctionBodyAndFinish(node, type, isMethod);
  }

  registerFunctionStatementId(node) {
    if (!node.body && node.id) {
      this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
    } else {
      super.registerFunctionStatementId(...arguments);
    }
  }
diff --git a/a.js b/b.js
@@ -9712,7 +9996,7 @@ tsCheckForInvalidTypeCasts(items) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      super.registerFunctionStatementId(...arguments);
    }
  }

  tsCheckForInvalidTypeCasts(items) {
    items.forEach(node => {
      if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
        this.raise(TSErrors.UnexpectedTypeAnnotation, {
          node: node.typeAnnotation
        });
      }
    });
  }
diff --git a/a.js b/b.js
@@ -9842,7 +10126,11 @@ parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    super.parseNewArguments(node);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
      const node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.expression = left;

      const _const = this.tsTryNextParseConstantContext();

      if (_const) {
        node.typeAnnotation = _const;
      } else {
        node.typeAnnotation = this.tsNextThenParseType();
      }

      this.finishNode(node, "TSAsExpression");
      this.reScan_lt_gt();
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
    }

    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

  checkDuplicateExports() {}

  parseImport(node) {
diff --git a/a.js b/b.js
@@ -9867,7 +10155,7 @@ parseImport(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

  checkDuplicateExports() {}

  parseImport(node) {
    node.importKind = "value";

    if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
      let ahead = this.lookahead();

      if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
        node.importKind = "type";
        this.next();
        ahead = this.lookahead();
      }

      if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
        return this.tsParseImportEqualsDeclaration(node);
      }
    }

    const importNode = super.parseImport(node);

    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
        node: importNode
      });
    }

    return importNode;
diff --git a/a.js b/b.js
@@ -9923,27 +10211,58 @@ parseExportDefaultExpression() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isAbstractClass() {
    return this.isContextual(120) && this.lookahead().type === 80;
  }

  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const cls = this.startNode();
      this.next();
      cls.abstract = true;
      this.parseClass(cls, true, true);
      return cls;
    }

    if (this.match(125)) {
      const interfaceNode = this.startNode();
      this.next();
      const result = this.tsParseInterfaceDeclaration(interfaceNode);
      if (result) return result;
    }

    return super.parseExportDefaultExpression();
  }

  parseStatementContent(context, topLevel) {
    if (this.state.type === 75) {
      const ahead = this.lookahead();

      if (ahead.type === 122) {
        const node = this.startNode();
        this.next();
        this.expectContextual(122);
        return this.tsParseEnumDeclaration(node, true);
      }
    }

    return super.parseStatementContent(context, topLevel);
  }

  parseAccessModifier() {
diff --git a/a.js b/b.js
@@ -9967,7 +10286,11 @@ tsIsStartOfStaticBlocks() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

      return !!member[modifier];
    });
  }

  tsIsStartOfStaticBlocks() {
    return this.isContextual(104) && this.lookaheadCharCode() === 123;
  }

  parseClassMember(classBody, member, state) {
    const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers(member, modifiers, undefined, undefined, true);

    const callParseClassMemberWithIsStatic = () => {
      if (this.tsIsStartOfStaticBlocks()) {
        this.next();
diff --git a/a.js b/b.js
@@ -10001,25 +10324,26 @@ parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      callParseClassMemberWithIsStatic();
    }
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const idx = this.tsTryParseIndexSignature(member);

    if (idx) {
      classBody.body.push(idx);

      if (member.abstract) {
        this.raise(TSErrors.IndexSignatureHasAbstract, {
          node: member
        });
      }

      if (member.accessibility) {
        this.raise(TSErrors.IndexSignatureHasAccessibility, {
          node: member
        }, member.accessibility);
      }

      if (member.declare) {
        this.raise(TSErrors.IndexSignatureHasDeclare, {
          node: member
        });
      }

      if (member.override) {
        this.raise(TSErrors.IndexSignatureHasOverride, {
          node: member
        });
      }

      return;
diff --git a/a.js b/b.js
@@ -10028,14 +10352,14 @@ parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      callParseClassMemberWithIsStatic();
    }
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const idx = this.tsTryParseIndexSignature(member);

    if (idx) {
      classBody.body.push(idx);

      if (member.abstract) {
        this.raise(TSErrors.IndexSignatureHasAbstract, {
          node: member
        });
      }

      if (member.accessibility) {
        this.raise(TSErrors.IndexSignatureHasAccessibility, {
          node: member
        }, member.accessibility);
      }

      if (member.declare) {
        this.raise(TSErrors.IndexSignatureHasDeclare, {
          node: member
        });
      }

      if (member.override) {
        this.raise(TSErrors.IndexSignatureHasOverride, {
          node: member
        });
      }

      return;
    }

    if (!this.state.inAbstractClass && member.abstract) {
      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
        node: member
      });
    }

    if (member.override) {
      if (!state.hadSuperClass) {
        this.raise(TSErrors.OverrideNotInSubClass, {
          node: member
        });
      }
    }

diff --git a/a.js b/b.js
@@ -10049,13 +10373,13 @@ parsePostMemberNameModifiers(methodOrProp) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parsePostMemberNameModifiers(methodOrProp) {
    const optional = this.eat(17);
    if (optional) methodOrProp.optional = true;

    if (methodOrProp.readonly && this.match(10)) {
      this.raise(TSErrors.ClassMethodHasReadonly, {
        node: methodOrProp
      });
    }

    if (methodOrProp.declare && this.match(10)) {
      this.raise(TSErrors.ClassMethodHasDeclare, {
        node: methodOrProp
      });
    }
  }

diff --git a/a.js b/b.js
@@ -10108,6 +10432,10 @@ parseParenItem(node, startPos, startLoc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    if (result.error) this.state = result.failState;
    return result.node;
  }

  parseParenItem(node, startPos, startLoc) {
    node = super.parseParenItem(node, startPos, startLoc);

    if (this.eat(17)) {
      node.optional = true;
      this.resetEndLocation(node);
    }

    if (this.match(14)) {
      const typeCastNode = this.startNodeAt(startPos, startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TSTypeCastExpression");
    }

    return node;
  }

  parseExportDeclaration(node) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isDeclare = this.eatContextual(121);

diff --git a/a.js b/b.js
@@ -10118,21 +10446,15 @@ parseExportDeclaration(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return node;
  }

  parseExportDeclaration(node) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isDeclare = this.eatContextual(121);

    if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
        at: this.state.startLoc
      });
    }

    let declaration;

    if (tokenIsIdentifier(this.state.type)) {
      declaration = this.tsTryParseExportDeclaration();
    }

    if (!declaration) {
      declaration = super.parseExportDeclaration(node);
    }

    if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
      node.exportKind = "type";
    }

    if (declaration && isDeclare) {
      this.resetStartLocation(declaration, startPos, startLoc);
      declaration.declare = true;
    }

diff --git a/a.js b/b.js
@@ -10173,8 +10495,9 @@ parseClassProperty(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    const type = this.tsTryParseTypeAnnotation();
    if (type) node.typeAnnotation = type;
  }

  parseClassProperty(node) {
    this.parseClassPropertyAnnotation(node);

    if (this.state.isAmbientContext && this.match(29)) {
      this.raise(TSErrors.DeclareClassFieldHasInitializer, {
        at: this.state.startLoc
      });
    }

    if (node.abstract && this.match(29)) {
      const {
        key
      } = node;
      this.raise(TSErrors.AbstractPropertyHasInitializer, {
        at: this.state.startLoc
      }, key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
    }

    return super.parseClassProperty(node);
  }
diff --git a/a.js b/b.js
@@ -10183,14 +10506,15 @@ parseClassProperty(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    const type = this.tsTryParseTypeAnnotation();
    if (type) node.typeAnnotation = type;
  }

  parseClassProperty(node) {
    this.parseClassPropertyAnnotation(node);

    if (this.state.isAmbientContext && this.match(29)) {
      this.raise(TSErrors.DeclareClassFieldHasInitializer, {
        at: this.state.startLoc
      });
    }

    if (node.abstract && this.match(29)) {
      const {
        key
      } = node;
      this.raise(TSErrors.AbstractPropertyHasInitializer, {
        at: this.state.startLoc
      }, key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
    }

    return super.parseClassProperty(node);
  }

  parseClassPrivateProperty(node) {
    if (node.abstract) {
      this.raise(TSErrors.PrivateElementHasAbstract, {
        node
      });
    }

    if (node.accessibility) {
      this.raise(TSErrors.PrivateElementHasAccessibility, {
        node
      }, node.accessibility);
    }

    this.parseClassPropertyAnnotation(node);
    return super.parseClassPrivateProperty(node);
diff --git a/a.js b/b.js
@@ -10202,14 +10526,20 @@ pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDi
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.parseClassPropertyAnnotation(node);
    return super.parseClassPrivateProperty(node);
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    const typeParameters = this.tsTryParseTypeParameters();

    if (typeParameters && isConstructor) {
      this.raise(TSErrors.ConstructorHasTypeParameters, {
        node: typeParameters
      });
    }

    if (method.declare && (method.kind === "get" || method.kind === "set")) {
      this.raise(TSErrors.DeclareAccessor, {
        node: method
      }, method.kind);
    }

    if (typeParameters) method.typeParameters = typeParameters;
    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
diff --git a/a.js b/b.js
@@ -10303,7 +10633,7 @@ parseMaybeAssign(...args) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.parseAsyncArrowFromCallExpression(node, call);
  }

  parseMaybeAssign(...args) {
    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

    let state;
    let jsx;
    let typeCast;

    if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);
      if (!jsx.error) return jsx.node;
      const {
        context
      } = this.state;
      const currentContext = context[context.length - 1];

      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
        context.pop();
      }
    }

    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
      return super.parseMaybeAssign(...args);
    }

    let typeParameters;
    state = state || this.state.clone();
    const arrow = this.tryParse(abort => {
      var _expr$extra, _typeParameters;

      typeParameters = this.tsParseTypeParameters();
      const expr = super.parseMaybeAssign(...args);

diff --git a/a.js b/b.js
@@ -10317,6 +10647,13 @@ parseMaybeAssign(...args) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.parseAsyncArrowFromCallExpression(node, call);
  }

  parseMaybeAssign(...args) {
    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

    let state;
    let jsx;
    let typeCast;

    if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
      state = this.state.clone();
      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);
      if (!jsx.error) return jsx.node;
      const {
        context
      } = this.state;
      const currentContext = context[context.length - 1];

      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
        context.pop();
      }
    }

    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
      return super.parseMaybeAssign(...args);
    }

    let typeParameters;
    state = state || this.state.clone();
    const arrow = this.tryParse(abort => {
      var _expr$extra, _typeParameters;

      typeParameters = this.tsParseTypeParameters();
      const expr = super.parseMaybeAssign(...args);

      if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
        abort();
      }

      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
        this.resetStartLocationFromNode(expr, typeParameters);
      }

      expr.typeParameters = typeParameters;
      return expr;
    }, state);

    if (!arrow.error && !arrow.aborted) {
diff --git a/a.js b/b.js
@@ -10358,7 +10695,7 @@ reportReservedArrowTypeParam(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (arrow.thrown) throw arrow.error;
    if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
  }

  reportReservedArrowTypeParam(node) {
    var _node$extra;

    if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
      this.raise(TSErrors.ReservedArrowTypeParam, {
        node
      });
    }
  }

diff --git a/a.js b/b.js
@@ -10393,7 +10730,7 @@ parseAssignableListItemTypes(param) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return super.parseArrow(node);
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(17)) {
      if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
        this.raise(TSErrors.PatternIsOptional, {
          node: param
        });
      }

      param.optional = true;
diff --git a/a.js b/b.js
@@ -10455,37 +10792,14 @@ toAssignableParenthesizedExpression(node, isLHS) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      default:
        return super.toAssignable(node, isLHS);
    }
  }

  toAssignableParenthesizedExpression(node, isLHS) {
    switch (node.expression.type) {
      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isLHS);
        return node;

      default:
        return super.toAssignable(node, isLHS);
    }
  }

  checkLVal(expr, contextDescription, ...args) {
    var _expr$extra2;

    switch (expr.type) {
      case "TSTypeCastExpression":
        return;

      case "TSParameterProperty":
        this.checkLVal(expr.parameter, "parameter property", ...args);
        return;

      case "TSAsExpression":
      case "TSTypeAssertion":
        if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
          this.raise(ErrorMessages.InvalidLhs, {
            node: expr
          }, contextDescription);
          break;
        }

        this.checkLVal(expr.expression, "parenthesized expression", ...args);
        return;

      case "TSNonNullExpression":
        this.checkLVal(expr.expression, contextDescription, ...args);
        return;

      default:
        super.checkLVal(expr, contextDescription, ...args);
        return;
    }
  }

  parseBindingAtom() {
    switch (this.state.type) {
diff --git a/a.js b/b.js
@@ -10536,7 +10850,7 @@ parseMaybeDefault(...args) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }

  parseMaybeDefault(...args) {
    const node = super.parseMaybeDefault(...args);

    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(TSErrors.TypeAnnotationAfterAssign, {
        node: node.typeAnnotation
      });
    }

    return node;
diff --git a/a.js b/b.js
@@ -10601,7 +10915,7 @@ toAssignableList(exprList) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return type;
  }

  toAssignableList(exprList) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];
      if (!expr) continue;

      switch (expr.type) {
        case "TSTypeCastExpression":
          exprList[i] = this.typeCastToParameter(expr);
          break;

        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!this.state.maybeInArrowParameters) {
            exprList[i] = this.typeCastToParameter(expr);
          } else {
            this.raise(TSErrors.UnexpectedTypeCastInParameter, {
              node: expr
            });
          }

          break;
diff --git a/a.js b/b.js
@@ -10693,9 +11007,8 @@ tsParseAbstractDeclaration(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } finally {
      this.state.inAbstractClass = oldInAbstractClass;
    }
  }

  tsParseAbstractDeclaration(node) {
    if (this.match(80)) {
      node.abstract = true;
      return this.parseClass(node, true, false);
    } else if (this.isContextual(125)) {
      if (!this.hasFollowingLineBreak()) {
        node.abstract = true;
        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
          node
        });
        this.next();
        return this.tsParseInterfaceDeclaration(node);
      }
    } else {
      this.unexpected(null, 80);
diff --git a/a.js b/b.js
@@ -10714,8 +11027,9 @@ parseMethod(...args) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      this.unexpected(null, 80);
    }
  }

  parseMethod(...args) {
    const method = super.parseMethod(...args);

    if (method.abstract) {
      const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;

      if (hasBody) {
        const {
          key
        } = method;
        this.raise(TSErrors.AbstractMethodHasImplementation, {
          node: method
        }, key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
      }
    }

    return method;
diff --git a/a.js b/b.js
@@ -10785,7 +11099,7 @@ parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    specifier.importKind = "value";
    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
  }

  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
    const leftOfAsKey = isImport ? "imported" : "local";
    const rightOfAsKey = isImport ? "local" : "exported";
    let leftOfAs = node[leftOfAsKey];
    let rightOfAs;
    let hasTypeSpecifier = false;
    let canParseAsKeyword = true;
    const loc = leftOfAs.loc.start;

    if (this.isContextual(93)) {
      const firstAs = this.parseIdentifier();

      if (this.isContextual(93)) {
        const secondAs = this.parseIdentifier();

        if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
          rightOfAs = this.parseIdentifier();
          canParseAsKeyword = false;
        } else {
          rightOfAs = secondAs;
          canParseAsKeyword = false;
diff --git a/a.js b/b.js
@@ -10793,14 +11107,14 @@ parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    specifier.importKind = "value";
    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
  }

  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
    const leftOfAsKey = isImport ? "imported" : "local";
    const rightOfAsKey = isImport ? "local" : "exported";
    let leftOfAs = node[leftOfAsKey];
    let rightOfAs;
    let hasTypeSpecifier = false;
    let canParseAsKeyword = true;
    const loc = leftOfAs.loc.start;

    if (this.isContextual(93)) {
      const firstAs = this.parseIdentifier();

      if (this.isContextual(93)) {
        const secondAs = this.parseIdentifier();

        if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
          rightOfAs = this.parseIdentifier();
          canParseAsKeyword = false;
        } else {
          rightOfAs = secondAs;
          canParseAsKeyword = false;
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        canParseAsKeyword = false;
        rightOfAs = this.parseIdentifier();
      } else {
        hasTypeSpecifier = true;
        leftOfAs = firstAs;
      }
    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
      hasTypeSpecifier = true;
      leftOfAs = this.parseIdentifier();
    }

    if (hasTypeSpecifier && isInTypeOnlyImportExport) {
      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
diff --git a/a.js b/b.js
@@ -10823,23 +11137,45 @@ parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    specifier.importKind = "value";
    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
  }

  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
    const leftOfAsKey = isImport ? "imported" : "local";
    const rightOfAsKey = isImport ? "local" : "exported";
    let leftOfAs = node[leftOfAsKey];
    let rightOfAs;
    let hasTypeSpecifier = false;
    let canParseAsKeyword = true;
    const loc = leftOfAs.loc.start;

    if (this.isContextual(93)) {
      const firstAs = this.parseIdentifier();

      if (this.isContextual(93)) {
        const secondAs = this.parseIdentifier();

        if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
          rightOfAs = this.parseIdentifier();
          canParseAsKeyword = false;
        } else {
          rightOfAs = secondAs;
          canParseAsKeyword = false;
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        canParseAsKeyword = false;
        rightOfAs = this.parseIdentifier();
      } else {
        hasTypeSpecifier = true;
        leftOfAs = firstAs;
      }
    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
      hasTypeSpecifier = true;
      leftOfAs = this.parseIdentifier();
    }

    if (hasTypeSpecifier && isInTypeOnlyImportExport) {
      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
        at: loc
      });
    }

    node[leftOfAsKey] = leftOfAs;
    node[rightOfAsKey] = rightOfAs;
    const kindKey = isImport ? "importKind" : "exportKind";
    node[kindKey] = hasTypeSpecifier ? "type" : "value";

    if (canParseAsKeyword && this.eatContextual(93)) {
      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
    }

    if (!node[rightOfAsKey]) {
      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
    }

    if (isImport) {
      this.checkLVal(node[rightOfAsKey], "import specifier", BIND_LEXICAL);
    }
  }

});

const PlaceholderErrors = makeErrorTemplates({
  ClassNameIsRequired: "A class name is required."
}, ErrorCodes.SyntaxError, "placeholders");
var placeholders = (superClass => class extends superClass {
  parsePlaceholder(expectedNode) {
    if (this.match(140)) {
      const node = this.startNode();
      this.next();
      this.assertNoSpace("Unexpected space in placeholder.");
      node.name = super.parseIdentifier(true);
      this.assertNoSpace("Unexpected space in placeholder.");
      this.expect(140);
      return this.finishPlaceholder(node, expectedNode);
    }
  }
diff --git a/a.js b/b.js
@@ -10875,8 +11211,8 @@ parseBindingAtom() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  checkReservedWord(word) {
    if (word !== undefined) super.checkReservedWord(...arguments);
  }

  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
  }

  checkLVal(expr) {
    if (expr.type !== "Placeholder") super.checkLVal(...arguments);
  }

  toAssignable(node) {
    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
diff --git a/a.js b/b.js
@@ -11050,6 +11386,14 @@ parseImportSource() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.source = this.parseImportSource();
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }

  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
  }

});

var v8intrinsic = (superClass => class extends superClass {
  parseV8Intrinsic() {
diff --git a/a.js b/b.js
@@ -11242,6 +11586,8 @@ function getOptions(opts) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true
};
function getOptions(opts) {
  const options = {};

  for (const key of Object.keys(defaultOptions)) {
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

const unwrapParenthesizedExpression = node => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

diff --git a/a.js b/b.js
@@ -11257,15 +11603,17 @@ toAssignable(node, isLHS = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
const unwrapParenthesizedExpression = node => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

class LValParser extends NodeUtils {
  toAssignable(node, isLHS = false) {
    var _node$extra, _node$extra3;

    let parenthesized = undefined;

    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
      parenthesized = unwrapParenthesizedExpression(node);

      if (isLHS) {
        if (parenthesized.type === "Identifier") {
          this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment, node.loc.start);
        } else if (parenthesized.type !== "MemberExpression") {
          this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
            node
          });
        }
      } else {
        this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
          node
        });
      }
    }

diff --git a/a.js b/b.js
@@ -11289,7 +11637,7 @@ toAssignable(node, isLHS = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
const unwrapParenthesizedExpression = node => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

class LValParser extends NodeUtils {
  toAssignable(node, isLHS = false) {
    var _node$extra, _node$extra3;

    let parenthesized = undefined;

    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
      parenthesized = unwrapParenthesizedExpression(node);

      if (isLHS) {
        if (parenthesized.type === "Identifier") {
          this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment, node.loc.start);
        } else if (parenthesized.type !== "MemberExpression") {
          this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
            node
          });
        }
      } else {
        this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
          node
        });
      }
    }

    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
          var _node$extra2;

          const prop = node.properties[i];
          const isLast = i === last;
          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
            this.raise(ErrorMessages.RestTrailingComma, {
              at: node.extra.trailingCommaLoc
            });
          }
        }
diff --git a/a.js b/b.js
@@ -11328,7 +11676,7 @@ toAssignable(node, isLHS = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
const unwrapParenthesizedExpression = node => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

class LValParser extends NodeUtils {
  toAssignable(node, isLHS = false) {
    var _node$extra, _node$extra3;

    let parenthesized = undefined;

    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
      parenthesized = unwrapParenthesizedExpression(node);

      if (isLHS) {
        if (parenthesized.type === "Identifier") {
          this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment, node.loc.start);
        } else if (parenthesized.type !== "MemberExpression") {
          this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
            node
          });
        }
      } else {
        this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
          node
        });
      }
    }

    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
          var _node$extra2;

          const prop = node.properties[i];
          const isLast = i === last;
          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
            this.raise(ErrorMessages.RestTrailingComma, {
              at: node.extra.trailingCommaLoc
            });
          }
        }

        break;

      case "ObjectProperty":
        {
          const {
            key,
            value
          } = node;

          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }

          this.toAssignable(value, isLHS);
          break;
        }

      case "SpreadElement":
        {
          this.checkToRestConversion(node);
          node.type = "RestElement";
          const arg = node.argument;
          this.toAssignable(arg, isLHS);
          break;
        }

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
        break;

      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(ErrorMessages.MissingEqInAssignment, {
            at: node.left.loc.end
          });
        }

diff --git a/a.js b/b.js
@@ -11348,12 +11696,12 @@ toAssignable(node, isLHS = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
const unwrapParenthesizedExpression = node => {
  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};

class LValParser extends NodeUtils {
  toAssignable(node, isLHS = false) {
    var _node$extra, _node$extra3;

    let parenthesized = undefined;

    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
      parenthesized = unwrapParenthesizedExpression(node);

      if (isLHS) {
        if (parenthesized.type === "Identifier") {
          this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment, node.loc.start);
        } else if (parenthesized.type !== "MemberExpression") {
          this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
            node
          });
        }
      } else {
        this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
          node
        });
      }
    }

    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
          var _node$extra2;

          const prop = node.properties[i];
          const isLast = i === last;
          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
            this.raise(ErrorMessages.RestTrailingComma, {
              at: node.extra.trailingCommaLoc
            });
          }
        }

        break;

      case "ObjectProperty":
        {
          const {
            key,
            value
          } = node;

          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }

          this.toAssignable(value, isLHS);
          break;
        }

      case "SpreadElement":
        {
          this.checkToRestConversion(node);
          node.type = "RestElement";
          const arg = node.argument;
          this.toAssignable(arg, isLHS);
          break;
        }

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
        break;

      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(ErrorMessages.MissingEqInAssignment, {
            at: node.left.loc.end
          });
        }

        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isLHS);
        break;

      case "ParenthesizedExpression":
        this.toAssignable(parenthesized, isLHS);
        break;
    }

    return node;
  }

  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    if (prop.type === "ObjectMethod") {
      this.raise(prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod, {
        node: prop.key
      });
    } else if (prop.type === "SpreadElement" && !isLast) {
      this.raise(ErrorMessages.RestTrailingComma, {
        node: prop
      });
    } else {
      this.toAssignable(prop, isLHS);
    }
diff --git a/a.js b/b.js
@@ -11379,7 +11727,7 @@ toAssignableList(exprList, trailingCommaLoc, isLHS) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      this.toAssignable(prop, isLHS);
    }
  }

  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    let end = exprList.length;

    if (end) {
      const last = exprList[end - 1];

      if ((last == null ? void 0 : last.type) === "RestElement") {
        --end;
      } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
        last.type = "RestElement";
        let arg = last.argument;
        this.toAssignable(arg, isLHS);
        arg = unwrapParenthesizedExpression(arg);

        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
          this.unexpected(arg.start);
        }

        if (trailingCommaLoc) {
          this.raise(ErrorMessages.RestTrailingComma, {
            at: trailingCommaLoc
          });
        }

diff --git a/a.js b/b.js
@@ -11395,8 +11743,8 @@ toAssignableList(exprList, trailingCommaLoc, isLHS) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      this.toAssignable(prop, isLHS);
    }
  }

  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    let end = exprList.length;

    if (end) {
      const last = exprList[end - 1];

      if ((last == null ? void 0 : last.type) === "RestElement") {
        --end;
      } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
        last.type = "RestElement";
        let arg = last.argument;
        this.toAssignable(arg, isLHS);
        arg = unwrapParenthesizedExpression(arg);

        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
          this.unexpected(arg.start);
        }

        if (trailingCommaLoc) {
          this.raise(ErrorMessages.RestTrailingComma, {
            at: trailingCommaLoc
          });
        }

        --end;
      }
    }

    for (let i = 0; i < end; i++) {
      const elt = exprList[i];

      if (elt) {
        this.toAssignable(elt, isLHS);

        if (elt.type === "RestElement") {
          this.raise(ErrorMessages.RestTrailingComma, {
            node: elt
          });
        }
      }
    }
diff --git a/a.js b/b.js
@@ -11517,7 +11865,7 @@ parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseIdentifier();
  }

  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
    const elts = [];
    let first = true;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);
      }

      if (allowEmpty && this.match(12)) {
        elts.push(null);
      } else if (this.eat(close)) {
        break;
      } else if (this.match(21)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));

        if (!this.checkCommaAfterRest(closeCharCode)) {
          this.expect(close);
          break;
        }
      } else {
        const decorators = [];

        if (this.match(26) && this.hasPlugin("decorators")) {
          this.raise(ErrorMessages.UnsupportedParameterDecorator, {
            at: this.state.startLoc
          });
        }

diff --git a/a.js b/b.js
@@ -11592,94 +11940,127 @@ parseMaybeDefault(startPos, startLoc, left) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  parseAssignableListItemTypes(param) {
    return param;
  }

  parseMaybeDefault(startPos, startLoc, left) {
    var _startLoc, _startPos, _left;

    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
    left = (_left = left) != null ? _left : this.parseBindingAtom();
    if (!this.eat(29)) return left;
    const node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssignAllowIn();
    return this.finishNode(node, "AssignmentPattern");
  }

  checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {
    switch (expr.type) {
      case "Identifier":
        {
          const {
            name
          } = expr;

          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
            this.raise(bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, {
              node: expr
            }, name);
          }

          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(ErrorMessages.ParamDupe, {
                node: expr
              });
            } else {
              checkClashes.add(name);
            }
          }

          if (disallowLetBinding && name === "let") {
            this.raise(ErrorMessages.LetInLexicalBinding, {
              node: expr
            });
          }

          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(name, bindingType, expr.loc.start);
          }

          break;
        }

      case "MemberExpression":
        if (bindingType !== BIND_NONE) {
          this.raise(ErrorMessages.InvalidPropertyBindingPattern, {
            node: expr
          });
        }

        break;

      case "ObjectPattern":
        for (let prop of expr.properties) {
          if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;
          this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
        }

        break;

      case "ArrayPattern":
        for (const elem of expr.elements) {
          if (elem) {
            this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
          }
        }

        break;

      case "AssignmentPattern":
        this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
        break;

      case "RestElement":
        this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
        break;

      case "ParenthesizedExpression":
        this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
        break;

      default:
        {
          this.raise(bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, {
            node: expr
          }, contextDescription);
        }
    }
  }

  checkToRestConversion(node) {
    if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
      this.raise(ErrorMessages.InvalidRestAssignmentPattern, {
        node: node.argument
      });
    }
  }

diff --git a/a.js b/b.js
@@ -11689,7 +12070,7 @@ checkCommaAfterRest(close) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        node: node.argument
      });
    }
  }

  checkCommaAfterRest(close) {
    if (!this.match(12)) {
      return false;
    }

    this.raise(this.lookaheadCharCode() === close ? ErrorMessages.RestTrailingComma : ErrorMessages.ElementAfterRest, {
      at: this.state.startLoc
    });
    return true;
  }
diff --git a/a.js b/b.js
@@ -11697,7 +12078,6 @@ checkCommaAfterRest(close) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        node: node.argument
      });
    }
  }

  checkCommaAfterRest(close) {
    if (!this.match(12)) {
      return false;
    }

    this.raise(this.lookaheadCharCode() === close ? ErrorMessages.RestTrailingComma : ErrorMessages.ElementAfterRest, {
      at: this.state.startLoc
    });
    return true;
  }

}

const invalidHackPipeBodies = new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
class ExpressionParser extends LValParser {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
      return;
diff --git a/a.js b/b.js
@@ -11709,8 +12089,8 @@ checkProto(prop, isRecord, protoRef, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

}

const invalidHackPipeBodies = new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
class ExpressionParser extends LValParser {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
      return;
    }

    const key = prop.key;
    const name = key.type === "Identifier" ? key.name : key.value;

    if (name === "__proto__") {
      if (isRecord) {
        this.raise(ErrorMessages.RecordNoProto, {
          node: key
        });
        return;
      }

diff --git a/a.js b/b.js
@@ -11721,8 +12101,8 @@ checkProto(prop, isRecord, protoRef, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

}

const invalidHackPipeBodies = new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
class ExpressionParser extends LValParser {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
      return;
    }

    const key = prop.key;
    const name = key.type === "Identifier" ? key.name : key.value;

    if (name === "__proto__") {
      if (isRecord) {
        this.raise(ErrorMessages.RecordNoProto, {
          node: key
        });
        return;
      }

      if (protoRef.used) {
        if (refExpressionErrors) {
          if (refExpressionErrors.doubleProtoLoc === null) {
            refExpressionErrors.doubleProtoLoc = key.loc.start;
          }
        } else {
          this.raise(ErrorMessages.DuplicateProto, {
            node: key
          });
        }
      }

diff --git a/a.js b/b.js
@@ -11860,10 +12240,12 @@ parseMaybeAssign(refExpressionErrors, afterLeftParse) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    var _resultError$loc;

    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
  }

  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;

    if (this.isContextual(105)) {
      if (this.prodParam.hasYield) {
        let left = this.parseYield();

        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }

        return left;
      }
    }

    let ownExpressionErrors;

    if (refExpressionErrors) {
      ownExpressionErrors = false;
    } else {
      refExpressionErrors = new ExpressionErrors();
      ownExpressionErrors = true;
    }

    const {
      type
    } = this.state;

    if (type === 10 || tokenIsIdentifier(type)) {
      this.state.potentialArrowAt = this.state.start;
    }

    let left = this.parseMaybeConditional(refExpressionErrors);

    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }

    if (tokenIsAssignment(this.state.type)) {
      const node = this.startNodeAt(startPos, startLoc);
      const operator = this.state.value;
      node.operator = operator;

      if (this.match(29)) {
        node.left = this.toAssignable(left, true);

        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
          refExpressionErrors.doubleProtoLoc = null;
        }

        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
          refExpressionErrors.shorthandAssignLoc = null;
        }

        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
          this.checkDestructuringPrivate(refExpressionErrors);
          refExpressionErrors.privateKeyLoc = null;
        }
      } else {
        node.left = left;
      }

      this.checkLVal(left, "assignment expression");
      this.next();
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentExpression");
    } else if (ownExpressionErrors) {
      this.checkExpressionErrors(refExpressionErrors, true);
    }

diff --git a/a.js b/b.js
@@ -11919,9 +12301,10 @@ parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseExprOp(expr, startPos, startLoc, -1);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
    if (this.isPrivateName(left)) {
      const value = this.getPrivateNameSV(left);

      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
        this.raise(ErrorMessages.PrivateInExpectedIn, {
          node: left
        }, value);
      }

      this.classScope.usePrivateName(value, left.loc.start);
    }
diff --git a/a.js b/b.js
@@ -11959,7 +12342,7 @@ parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseExprOp(expr, startPos, startLoc, -1);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
    if (this.isPrivateName(left)) {
      const value = this.getPrivateNameSV(left);

      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
        this.raise(ErrorMessages.PrivateInExpectedIn, {
          node: left
        }, value);
      }

      this.classScope.usePrivateName(value, left.loc.start);
    }

    const op = this.state.type;

    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
      let prec = tokenOperatorPrecedence(op);

      if (prec > minPrec) {
        if (op === 39) {
          this.expectPlugin("pipelineOperator");

          if (this.state.inFSharpPipelineDirectBody) {
            return left;
          }

          this.checkPipelineAtInfixOperator(left, leftStartLoc);
        }

        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.left = left;
        node.operator = this.state.value;
        const logical = op === 41 || op === 42;
        const coalesce = op === 40;

        if (coalesce) {
          prec = tokenOperatorPrecedence(42);
        }

        this.next();

        if (op === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }])) {
          if (this.state.type === 96 && this.prodParam.hasAwait) {
            throw this.raise(ErrorMessages.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc
            });
          }
        }
diff --git a/a.js b/b.js
@@ -11970,7 +12353,7 @@ parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseExprOp(expr, startPos, startLoc, -1);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
    if (this.isPrivateName(left)) {
      const value = this.getPrivateNameSV(left);

      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
        this.raise(ErrorMessages.PrivateInExpectedIn, {
          node: left
        }, value);
      }

      this.classScope.usePrivateName(value, left.loc.start);
    }

    const op = this.state.type;

    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
      let prec = tokenOperatorPrecedence(op);

      if (prec > minPrec) {
        if (op === 39) {
          this.expectPlugin("pipelineOperator");

          if (this.state.inFSharpPipelineDirectBody) {
            return left;
          }

          this.checkPipelineAtInfixOperator(left, leftStartLoc);
        }

        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.left = left;
        node.operator = this.state.value;
        const logical = op === 41 || op === 42;
        const coalesce = op === 40;

        if (coalesce) {
          prec = tokenOperatorPrecedence(42);
        }

        this.next();

        if (op === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }])) {
          if (this.state.type === 96 && this.prodParam.hasAwait) {
            throw this.raise(ErrorMessages.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc
            });
          }
        }

        node.right = this.parseExprOpRightExpr(op, prec);
        this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
        const nextOp = this.state.type;

        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
          throw this.raise(ErrorMessages.MixingCoalesceWithLogical, {
            at: this.state.startLoc
          });
        }

diff --git a/a.js b/b.js
@@ -11997,9 +12380,9 @@ parseExprOpRightExpr(op, prec) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return left;
  }

  parseExprOpRightExpr(op, prec) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;

    switch (op) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => {
              return this.parseHackPipeBody();
            });

          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(105)) {
                throw this.raise(ErrorMessages.PipeBodyIsTighter, {
                  at: this.state.startLoc
                }, this.state.value);
              }

              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
            });
diff --git a/a.js b/b.js
@@ -12029,15 +12412,17 @@ parseHackPipeBody() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
  }

  parseHackPipeBody() {
    var _body$extra;

    const {
      startLoc
    } = this.state;
    const body = this.parseMaybeAssign();

    if (invalidHackPipeBodies.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
      this.raise(ErrorMessages.PipeUnparenthesizedBody, {
        at: startLoc
      }, invalidHackPipeBodies.get(body.type));
    }

    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(ErrorMessages.PipeTopicUnused, {
        at: startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -12047,8 +12432,8 @@ parseHackPipeBody() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
  }

  parseHackPipeBody() {
    var _body$extra;

    const {
      startLoc
    } = this.state;
    const body = this.parseMaybeAssign();

    if (invalidHackPipeBodies.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
      this.raise(ErrorMessages.PipeUnparenthesizedBody, {
        at: startLoc
      }, invalidHackPipeBodies.get(body.type));
    }

    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(ErrorMessages.PipeTopicUnused, {
        at: startLoc
      });
    }

    return body;
  }

  checkExponentialAfterUnary(node) {
    if (this.match(57)) {
      this.raise(ErrorMessages.UnexpectedTokenUnaryExponentiation, {
        node: node.argument
      });
    }
  }

diff --git a/a.js b/b.js
@@ -12085,12 +12470,12 @@ parseMaybeUnary(refExpressionErrors, sawUnary) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        node: node.argument
      });
    }
  }

  parseMaybeUnary(refExpressionErrors, sawUnary) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isAwait = this.isContextual(96);

    if (isAwait && this.isAwaitAllowed()) {
      this.next();
      const expr = this.parseAwait(startPos, startLoc);
      if (!sawUnary) this.checkExponentialAfterUnary(expr);
      return expr;
    }

    const update = this.match(34);
    const node = this.startNode();

    if (tokenIsPrefix(this.state.type)) {
      node.operator = this.state.value;
      node.prefix = true;

      if (this.match(72)) {
        this.expectPlugin("throwExpressions");
      }

      const isDelete = this.match(89);
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refExpressionErrors, true);

      if (this.state.strict && isDelete) {
        const arg = node.argument;

        if (arg.type === "Identifier") {
          this.raise(ErrorMessages.StrictDelete, {
            node
          });
        } else if (this.hasPropertyAsPrivateName(arg)) {
          this.raise(ErrorMessages.DeletePrivateField, {
            node
          });
        }
      }

diff --git a/a.js b/b.js
@@ -12110,7 +12495,9 @@ parseMaybeUnary(refExpressionErrors, sawUnary) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        node: node.argument
      });
    }
  }

  parseMaybeUnary(refExpressionErrors, sawUnary) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isAwait = this.isContextual(96);

    if (isAwait && this.isAwaitAllowed()) {
      this.next();
      const expr = this.parseAwait(startPos, startLoc);
      if (!sawUnary) this.checkExponentialAfterUnary(expr);
      return expr;
    }

    const update = this.match(34);
    const node = this.startNode();

    if (tokenIsPrefix(this.state.type)) {
      node.operator = this.state.value;
      node.prefix = true;

      if (this.match(72)) {
        this.expectPlugin("throwExpressions");
      }

      const isDelete = this.match(89);
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refExpressionErrors, true);

      if (this.state.strict && isDelete) {
        const arg = node.argument;

        if (arg.type === "Identifier") {
          this.raise(ErrorMessages.StrictDelete, {
            node
          });
        } else if (this.hasPropertyAsPrivateName(arg)) {
          this.raise(ErrorMessages.DeletePrivateField, {
            node
          });
        }
      }

      if (!update) {
        if (!sawUnary) this.checkExponentialAfterUnary(node);
        return this.finishNode(node, "UnaryExpression");
      }
    }

    const expr = this.parseUpdate(node, update, refExpressionErrors);

    if (isAwait) {
      const {
        type
      } = this.state;
      const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);

      if (startsExpr && !this.isAmbiguousAwait()) {
        this.raiseOverwrite(startLoc, ErrorMessages.AwaitNotInAsyncContext);
        return this.parseAwait(startPos, startLoc);
      }
    }

diff --git a/a.js b/b.js
@@ -12120,8 +12507,10 @@ parseMaybeUnary(refExpressionErrors, sawUnary) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        node: node.argument
      });
    }
  }

  parseMaybeUnary(refExpressionErrors, sawUnary) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isAwait = this.isContextual(96);

    if (isAwait && this.isAwaitAllowed()) {
      this.next();
      const expr = this.parseAwait(startPos, startLoc);
      if (!sawUnary) this.checkExponentialAfterUnary(expr);
      return expr;
    }

    const update = this.match(34);
    const node = this.startNode();

    if (tokenIsPrefix(this.state.type)) {
      node.operator = this.state.value;
      node.prefix = true;

      if (this.match(72)) {
        this.expectPlugin("throwExpressions");
      }

      const isDelete = this.match(89);
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refExpressionErrors, true);

      if (this.state.strict && isDelete) {
        const arg = node.argument;

        if (arg.type === "Identifier") {
          this.raise(ErrorMessages.StrictDelete, {
            node
          });
        } else if (this.hasPropertyAsPrivateName(arg)) {
          this.raise(ErrorMessages.DeletePrivateField, {
            node
          });
        }
      }

      if (!update) {
        if (!sawUnary) this.checkExponentialAfterUnary(node);
        return this.finishNode(node, "UnaryExpression");
      }
    }

    const expr = this.parseUpdate(node, update, refExpressionErrors);

    if (isAwait) {
      const {
        type
      } = this.state;
      const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);

      if (startsExpr && !this.isAmbiguousAwait()) {
        this.raiseOverwrite(startLoc, ErrorMessages.AwaitNotInAsyncContext);
        return this.parseAwait(startPos, startLoc);
      }
    }

    return expr;
  }

  parseUpdate(node, update, refExpressionErrors) {
    if (update) {
      this.checkLVal(node.argument, "prefix operation");
      return this.finishNode(node, "UpdateExpression");
    }

    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
diff --git a/a.js b/b.js
@@ -12134,9 +12523,10 @@ parseUpdate(node, update, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return expr;
  }

  parseUpdate(node, update, refExpressionErrors) {
    if (update) {
      this.checkLVal(node.argument, "prefix operation");
      return this.finishNode(node, "UpdateExpression");
    }

    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let expr = this.parseExprSubscripts(refExpressionErrors);
    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startPos, startLoc);
      node.operator = this.state.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr, "postfix operation");
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }

    return expr;
  }
diff --git a/a.js b/b.js
@@ -12217,7 +12607,7 @@ parseMember(base, startPos, startLoc, state, computed, optional) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        return base;
      }
    }
  }

  parseMember(base, startPos, startLoc, state, computed, optional) {
    const node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.computed = computed;

    if (computed) {
      node.property = this.parseExpression();
      this.expect(3);
    } else if (this.match(134)) {
      if (base.type === "Super") {
        this.raise(ErrorMessages.SuperPrivateField, {
          at: startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -12303,7 +12693,7 @@ parseTaggedTemplateExpression(base, startPos, startLoc, state) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  toReferencedArguments(node, isParenthesizedExpr) {
    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
  }

  parseTaggedTemplateExpression(base, startPos, startLoc, state) {
    const node = this.startNodeAt(startPos, startLoc);
    node.tag = base;
    node.quasi = this.parseTemplate(true);

    if (state.optionalChainMember) {
      this.raise(ErrorMessages.OptionalChainingNoTemplate, {
        at: startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -12326,14 +12716,15 @@ finishCallExpression(node, optional) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  atPossibleAsyncArrow(base) {
    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
  }

  finishCallExpression(node, optional) {
    if (node.callee.type === "Import") {
      if (node.arguments.length === 2) {
        {
          if (!this.hasPlugin("moduleAttributes")) {
            this.expectPlugin("importAssertions");
          }
        }
      }

      if (node.arguments.length === 0 || node.arguments.length > 2) {
        this.raise(ErrorMessages.ImportCallArity, {
          node
        }, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
      } else {
        for (const arg of node.arguments) {
          if (arg.type === "SpreadElement") {
            this.raise(ErrorMessages.ImportCallSpreadArgument, {
              node: arg
            });
          }
        }
      }
diff --git a/a.js b/b.js
@@ -12357,7 +12748,7 @@ parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtr
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
  }

  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
    const elts = [];
    let first = true;
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);

        if (this.match(close)) {
          if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
            this.raise(ErrorMessages.ImportCallArgumentTrailingComma, {
              at: this.state.lastTokStartLoc
            });
          }

diff --git a/a.js b/b.js
@@ -12425,7 +12816,7 @@ parseExprAtom(refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  }

  parseExprAtom(refExpressionErrors) {
    let node;
    const {
      type
    } = this.state;

    switch (type) {
      case 79:
        return this.parseSuper();

      case 83:
        node = this.startNode();
        this.next();

        if (this.match(16)) {
          return this.parseImportMetaProperty(node);
        }

        if (!this.match(10)) {
          this.raise(ErrorMessages.UnsupportedImport, {
            at: this.state.lastTokStartLoc
          });
        }

diff --git a/a.js b/b.js
@@ -12526,17 +12917,18 @@ parseExprAtom(refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  }

  parseExprAtom(refExpressionErrors) {
    let node;
    const {
      type
    } = this.state;

    switch (type) {
      case 79:
        return this.parseSuper();

      case 83:
        node = this.startNode();
        this.next();

        if (this.match(16)) {
          return this.parseImportMetaProperty(node);
        }

        if (!this.match(10)) {
          this.raise(ErrorMessages.UnsupportedImport, {
            at: this.state.lastTokStartLoc
          });
        }

        return this.finishNode(node, "Import");

      case 78:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression");

      case 90:
        {
          return this.parseDo(this.startNode(), false);
        }

      case 56:
      case 31:
        {
          this.readRegexp();
          return this.parseRegExpLiteral(this.state.value);
        }

      case 130:
        return this.parseNumericLiteral(this.state.value);

      case 131:
        return this.parseBigIntLiteral(this.state.value);

      case 132:
        return this.parseDecimalLiteral(this.state.value);

      case 129:
        return this.parseStringLiteral(this.state.value);

      case 84:
        return this.parseNullLiteral();

      case 85:
        return this.parseBooleanLiteral(true);

      case 86:
        return this.parseBooleanLiteral(false);

      case 10:
        {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }

      case 2:
      case 1:
        {
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        }

      case 0:
        {
          return this.parseArrayLike(3, true, false, refExpressionErrors);
        }

      case 6:
      case 7:
        {
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        }

      case 5:
        {
          return this.parseObjectLike(8, false, false, refExpressionErrors);
        }

      case 68:
        return this.parseFunctionOrFunctionSent();

      case 26:
        this.parseDecorators();

      case 80:
        node = this.startNode();
        this.takeDecorators(node);
        return this.parseClass(node, false);

      case 77:
        return this.parseNewOrNewTarget();

      case 25:
      case 24:
        return this.parseTemplate(false);

      case 15:
        {
          node = this.startNode();
          this.next();
          node.object = null;
          const callee = node.callee = this.parseNoCallExpr();

          if (callee.type === "MemberExpression") {
            return this.finishNode(node, "BindExpression");
          } else {
            throw this.raise(ErrorMessages.UnsupportedBind, {
              node: callee
            });
          }
        }

      case 134:
        {
          this.raise(ErrorMessages.PrivateInExpectedIn, {
            at: this.state.startLoc
          }, this.state.value);
          return this.parsePrivateName();
        }

      case 33:
diff --git a/a.js b/b.js
@@ -12653,7 +13045,7 @@ finishTopicReference(node, startLoc, pipeProposal, tokenType) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const tokenType = this.state.type;
    this.next();
    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
  }

  finishTopicReference(node, startLoc, pipeProposal, tokenType) {
    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
      const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";

      if (!this.topicReferenceIsAllowedInCurrentContext()) {
        this.raise(pipeProposal === "smart" ? ErrorMessages.PrimaryTopicNotAllowed : ErrorMessages.PipeTopicUnbound, {
          at: startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -12661,9 +13053,10 @@ finishTopicReference(node, startLoc, pipeProposal, tokenType) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const tokenType = this.state.type;
    this.next();
    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
  }

  finishTopicReference(node, startLoc, pipeProposal, tokenType) {
    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
      const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";

      if (!this.topicReferenceIsAllowedInCurrentContext()) {
        this.raise(pipeProposal === "smart" ? ErrorMessages.PrimaryTopicNotAllowed : ErrorMessages.PipeTopicUnbound, {
          at: startLoc
        });
      }

      this.registerTopicReference();
      return this.finishNode(node, nodeType);
    } else {
      throw this.raise(ErrorMessages.PipeTopicUnconfiguredToken, {
        at: startLoc
      }, tokenLabelName(tokenType));
    }
  }

  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
diff --git a/a.js b/b.js
@@ -12680,7 +13073,7 @@ testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        at: startLoc
      }, tokenLabelName(tokenType));
    }
  }

  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
    switch (pipeProposal) {
      case "hack":
        {
          return this.hasPlugin(["pipelineOperator", {
            topicToken: tokenLabelName(tokenType)
          }]);
        }

      case "smart":
        return tokenType === 27;

      default:
        throw this.raise(ErrorMessages.PipeTopicRequiresHackPipes, {
          at: startLoc
        });
    }
  }
diff --git a/a.js b/b.js
@@ -12692,7 +13085,7 @@ parseAsyncArrowUnaryFunction(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
          at: startLoc
        });
    }
  }

  parseAsyncArrowUnaryFunction(node) {
    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
    const params = [this.parseIdentifier()];
    this.prodParam.exit();

    if (this.hasPrecedingLineBreak()) {
      this.raise(ErrorMessages.LineTerminatorBeforeArrow, {
        at: this.state.curPosition()
      });
    }

diff --git a/a.js b/b.js
@@ -12731,18 +13124,18 @@ parseSuper() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.state.labels = oldLabels;
    return this.finishNode(node, "DoExpression");
  }

  parseSuper() {
    const node = this.startNode();
    this.next();

    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(ErrorMessages.SuperNotAllowed, {
        node
      });
    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(ErrorMessages.UnexpectedSuper, {
        node
      });
    }

    if (!this.match(10) && !this.match(0) && !this.match(16)) {
      this.raise(ErrorMessages.UnsupportedSuper, {
        node
      });
    }

    return this.finishNode(node, "Super");
diff --git a/a.js b/b.js
@@ -12784,9 +13177,11 @@ parseMetaProperty(node, meta, propertyName) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseFunction(node);
  }

  parseMetaProperty(node, meta, propertyName) {
    node.meta = meta;
    const containsEsc = this.state.containsEsc;
    node.property = this.parseIdentifier(true);

    if (node.property.name !== propertyName || containsEsc) {
      this.raise(ErrorMessages.UnsupportedMetaProperty, {
        node: node.property
      }, meta.name, propertyName);
    }

    return this.finishNode(node, "MetaProperty");
  }
diff --git a/a.js b/b.js
@@ -12798,8 +13193,8 @@ parseImportMetaProperty(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "MetaProperty");
  }

  parseImportMetaProperty(node) {
    const id = this.createIdentifier(this.startNodeAtNode(node), "import");
    this.next();

    if (this.isContextual(100)) {
      if (!this.inModule) {
        this.raise(SourceTypeModuleErrorMessages.ImportMetaOutsideModule, {
          node: id
        });
      }

      this.sawUnambiguousESM = true;
diff --git a/a.js b/b.js
@@ -12973,8 +13368,8 @@ parseNewOrNewTarget() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  parseParenItem(node, startPos, startLoc) {
    return node;
  }

  parseNewOrNewTarget() {
    const node = this.startNode();
    this.next();

    if (this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
      this.next();
      const metaProp = this.parseMetaProperty(node, meta, "target");

      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
        this.raise(ErrorMessages.UnexpectedNewTarget, {
          node: metaProp
        });
      }

      return metaProp;
diff --git a/a.js b/b.js
@@ -12988,15 +13383,15 @@ parseNew(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseNew(node);
  }

  parseNew(node) {
    node.callee = this.parseNoCallExpr();

    if (node.callee.type === "Import") {
      this.raise(ErrorMessages.ImportCallNotNewExpression, {
        node: node.callee
      });
    } else if (this.isOptionalChain(node.callee)) {
      this.raise(ErrorMessages.OptionalChainingNoNew, {
        at: this.state.lastTokEndLoc
      });
    } else if (this.eat(18)) {
      this.raise(ErrorMessages.OptionalChainingNoNew, {
        at: this.state.startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -13027,7 +13422,7 @@ parseTemplateElement(isTagged) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      node.arguments = [];
    }
  }

  parseTemplateElement(isTagged) {
    const {
      start,
      startLoc,
      end,
      value
    } = this.state;
    const elemStart = start + 1;
    const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));

    if (value === null) {
      if (!isTagged) {
        this.raise(ErrorMessages.InvalidEscapeSequenceTemplate, {
          at: createPositionWithColumnOffset(startLoc, 2)
        });
      }
    }
diff --git a/a.js b/b.js
@@ -13101,8 +13496,8 @@ parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  parseTemplateSubstitution() {
    return this.parseExpression();
  }

  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
    if (isRecord) {
      this.expectPlugin("recordAndTuple");
    }

    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const propHash = Object.create(null);
    let first = true;
    const node = this.startNode();
    node.properties = [];
    this.next();

    while (!this.match(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(12);

        if (this.match(close)) {
          this.addTrailingCommaExtraToNode(node);
          break;
        }
      }

      let prop;

      if (isPattern) {
        prop = this.parseBindingProperty();
      } else {
        prop = this.parsePropertyDefinition(refExpressionErrors);
        this.checkProto(prop, isRecord, propHash, refExpressionErrors);
      }

      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
        this.raise(ErrorMessages.InvalidRecordProperty, {
          node: prop
        });
      }

      if (prop.shorthand) {
diff --git a/a.js b/b.js
@@ -13140,7 +13535,7 @@ parsePropertyDefinition(refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  maybeAsyncOrAccessorProp(prop) {
    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }

  parsePropertyDefinition(refExpressionErrors) {
    let decorators = [];

    if (this.match(26)) {
      if (this.hasPlugin("decorators")) {
        this.raise(ErrorMessages.UnsupportedPropertyDecorator, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -13195,9 +13590,10 @@ parsePropertyDefinition(refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  maybeAsyncOrAccessorProp(prop) {
    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }

  parsePropertyDefinition(refExpressionErrors) {
    let decorators = [];

    if (this.match(26)) {
      if (this.hasPlugin("decorators")) {
        this.raise(ErrorMessages.UnsupportedPropertyDecorator, {
          at: this.state.startLoc
        });
      }

      while (this.match(26)) {
        decorators.push(this.parseDecorator());
      }
    }

    const prop = this.startNode();
    let isAsync = false;
    let isAccessor = false;
    let startPos;
    let startLoc;

    if (this.match(21)) {
      if (decorators.length) this.unexpected();
      return this.parseSpread();
    }

    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    prop.method = false;

    if (refExpressionErrors) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    let isGenerator = this.eat(55);
    this.parsePropertyNamePrefixOperator(prop);
    const containsEsc = this.state.containsEsc;
    const key = this.parsePropertyName(prop, refExpressionErrors);

    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
      const keyName = key.name;

      if (keyName === "async" && !this.hasPrecedingLineBreak()) {
        isAsync = true;
        this.resetPreviousNodeTrailingComments(key);
        isGenerator = this.eat(55);
        this.parsePropertyName(prop);
      }

      if (keyName === "get" || keyName === "set") {
        isAccessor = true;
        this.resetPreviousNodeTrailingComments(key);
        prop.kind = keyName;

        if (this.match(55)) {
          isGenerator = true;
          this.raise(ErrorMessages.AccessorIsGenerator, {
            at: this.state.curPosition()
          }, keyName);
          this.next();
        }

        this.parsePropertyName(prop);
diff --git a/a.js b/b.js
@@ -13224,14 +13620,14 @@ checkGetterSetterParams(method) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  getObjectOrClassMethodParams(method) {
    return method.params;
  }

  checkGetterSetterParams(method) {
    var _params;

    const paramCount = this.getGetterSetterExpectedParamCount(method);
    const params = this.getObjectOrClassMethodParams(method);

    if (params.length !== paramCount) {
      this.raise(method.kind === "get" ? ErrorMessages.BadGetterArity : ErrorMessages.BadSetterArity, {
        node: method
      });
    }

    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
      this.raise(ErrorMessages.BadSetterRestParameter, {
        node: method
      });
    }
  }

diff --git a/a.js b/b.js
@@ -13272,7 +13668,7 @@ parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      prop.method = true;
      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
    }
  }

  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
    prop.shorthand = false;

    if (this.eat(14)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
      return this.finishNode(prop, "ObjectProperty");
    }

    if (!prop.computed && prop.key.type === "Identifier") {
      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);

      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
      } else if (this.match(29)) {
        const shorthandAssignLoc = this.state.startLoc;

        if (refExpressionErrors != null) {
          if (refExpressionErrors.shorthandAssignLoc === null) {
            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
          }
        } else {
          this.raise(ErrorMessages.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
          });
        }

diff --git a/a.js b/b.js
@@ -13334,7 +13730,7 @@ parsePropertyName(prop, refExpressionErrors) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
    if (!node) this.unexpected();
    return node;
  }

  parsePropertyName(prop, refExpressionErrors) {
    if (this.eat(0)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssignAllowIn();
      this.expect(3);
    } else {
      const {
        type,
        value
      } = this.state;
      let key;

      if (tokenIsKeywordOrIdentifier(type)) {
        key = this.parseIdentifier(true);
      } else {
        switch (type) {
          case 130:
            key = this.parseNumericLiteral(value);
            break;

          case 129:
            key = this.parseStringLiteral(value);
            break;

          case 131:
            key = this.parseBigIntLiteral(value);
            break;

          case 132:
            key = this.parseDecimalLiteral(value);
            break;

          case 134:
            {
              const privateKeyLoc = this.state.startLoc;

              if (refExpressionErrors != null) {
                if (refExpressionErrors.privateKeyLoc === null) {
                  refExpressionErrors.privateKeyLoc = privateKeyLoc;
                }
              } else {
                this.raise(ErrorMessages.UnexpectedPrivateField, {
                  at: privateKeyLoc
                });
              }

diff --git a/a.js b/b.js
@@ -13441,19 +13837,16 @@ parseFunctionBody(node, allowExpression, isMethod = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    this.parseFunctionBody(node, false, isMethod);
    this.finishNode(node, type);
  }

  parseFunctionBody(node, allowExpression, isMethod = false) {
    const isExpression = allowExpression && !this.match(5);
    this.expressionScope.enter(newExpressionScope());

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      this.checkParams(node, false, allowExpression, false);
    } else {
      const oldStrict = this.state.strict;
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
      node.body = this.parseBlock(true, false, hasStrictModeDirective => {
        const nonSimple = !this.isSimpleParamList(node.params);

        if (hasStrictModeDirective && nonSimple) {
          const errorOrigin = (node.kind === "method" || node.kind === "constructor") && !!node.key ? {
            at: node.key.loc.end
          } : {
            node
          };
          this.raise(ErrorMessages.IllegalLanguageModeDirective, errorOrigin);
        }

        const strictModeChanged = !oldStrict && this.state.strict;
        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

        if (this.state.strict && node.id) {
          this.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
        }
      });
      this.prodParam.exit();
      this.state.labels = oldLabels;
diff --git a/a.js b/b.js
@@ -13463,19 +13856,31 @@ parseFunctionBody(node, allowExpression, isMethod = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    this.parseFunctionBody(node, false, isMethod);
    this.finishNode(node, type);
  }

  parseFunctionBody(node, allowExpression, isMethod = false) {
    const isExpression = allowExpression && !this.match(5);
    this.expressionScope.enter(newExpressionScope());

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      this.checkParams(node, false, allowExpression, false);
    } else {
      const oldStrict = this.state.strict;
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
      node.body = this.parseBlock(true, false, hasStrictModeDirective => {
        const nonSimple = !this.isSimpleParamList(node.params);

        if (hasStrictModeDirective && nonSimple) {
          const errorOrigin = (node.kind === "method" || node.kind === "constructor") && !!node.key ? {
            at: node.key.loc.end
          } : {
            node
          };
          this.raise(ErrorMessages.IllegalLanguageModeDirective, errorOrigin);
        }

        const strictModeChanged = !oldStrict && this.state.strict;
        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

        if (this.state.strict && node.id) {
          this.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
        }
      });
      this.prodParam.exit();
      this.state.labels = oldLabels;
    }

    this.expressionScope.exit();
  }

  isSimpleParamList(params) {
    for (let i = 0, len = params.length; i < len; i++) {
      if (params[i].type !== "Identifier") return false;
    }

    return true;
  }

  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    const checkClashes = new Set();

    for (const param of node.params) {
      this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
    }
  }

  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
diff --git a/a.js b/b.js
@@ -13510,9 +13915,10 @@ parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return elts;
  }

  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
    let elt;

    if (this.match(12)) {
      if (!allowEmpty) {
        this.raise(ErrorMessages.UnexpectedToken, {
          at: this.state.curPosition()
        }, ",");
      }

      elt = null;
    } else if (this.match(21)) {
diff --git a/a.js b/b.js
@@ -13524,7 +13930,7 @@ parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return elts;
  }

  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
    let elt;

    if (this.match(12)) {
      if (!allowEmpty) {
        this.raise(ErrorMessages.UnexpectedToken, {
          at: this.state.curPosition()
        }, ",");
      }

      elt = null;
    } else if (this.match(21)) {
      const spreadNodeStartPos = this.state.start;
      const spreadNodeStartLoc = this.state.startLoc;
      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication");

      if (!allowPlaceholder) {
        this.raise(ErrorMessages.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -13589,30 +13995,32 @@ checkReservedWord(word, startLoc, checkKeywords, isBinding) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.next();
    return name;
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    if (word.length > 10) {
      return;
    }

    if (!canBeReservedWord(word)) {
      return;
    }

    if (word === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(ErrorMessages.YieldBindingIdentifier, {
          at: startLoc
        });
        return;
      }
    } else if (word === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(ErrorMessages.AwaitBindingIdentifier, {
          at: startLoc
        });
        return;
      }

      if (this.scope.inStaticBlock) {
        this.raise(ErrorMessages.AwaitBindingIdentifierInStaticBlock, {
          at: startLoc
        });
        return;
      }

      this.expressionScope.recordAsyncArrowParametersError(ErrorMessages.AwaitBindingIdentifier, startLoc);
    } else if (word === "arguments") {
      if (this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(ErrorMessages.ArgumentsInClass, {
          at: startLoc
        });
        return;
      }
diff --git a/a.js b/b.js
@@ -13620,18 +14028,20 @@ checkReservedWord(word, startLoc, checkKeywords, isBinding) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.next();
    return name;
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    if (word.length > 10) {
      return;
    }

    if (!canBeReservedWord(word)) {
      return;
    }

    if (word === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(ErrorMessages.YieldBindingIdentifier, {
          at: startLoc
        });
        return;
      }
    } else if (word === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(ErrorMessages.AwaitBindingIdentifier, {
          at: startLoc
        });
        return;
      }

      if (this.scope.inStaticBlock) {
        this.raise(ErrorMessages.AwaitBindingIdentifierInStaticBlock, {
          at: startLoc
        });
        return;
      }

      this.expressionScope.recordAsyncArrowParametersError(ErrorMessages.AwaitBindingIdentifier, startLoc);
    } else if (word === "arguments") {
      if (this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(ErrorMessages.ArgumentsInClass, {
          at: startLoc
        });
        return;
      }
    }

    if (checkKeywords && isKeyword(word)) {
      this.raise(ErrorMessages.UnexpectedKeyword, {
        at: startLoc
      }, word);
      return;
    }

    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

    if (reservedTest(word, this.inModule)) {
      this.raise(ErrorMessages.UnexpectedReservedWord, {
        at: startLoc
      }, word);
    }
  }

  isAwaitAllowed() {
diff --git a/a.js b/b.js
@@ -13647,11 +14057,13 @@ isAwaitAllowed() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        at: startLoc
      }, word);
    }
  }

  isAwaitAllowed() {
    if (this.prodParam.hasAwait) return true;

    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
      return true;
    }

    return false;
  }

  parseAwait(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);
    this.expressionScope.recordParameterInitializerError(node.loc.start, ErrorMessages.AwaitExpressionFormalParameter);

    if (this.eat(55)) {
      this.raise(ErrorMessages.ObsoleteAwaitStar, {
        node
      });
    }

    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
diff --git a/a.js b/b.js
@@ -13680,7 +14092,9 @@ isAmbiguousAwait() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "AwaitExpression");
  }

  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak()) return true;
    const {
      type
    } = this.state;
    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
  }

  parseYield() {
    const node = this.startNode();
    this.expressionScope.recordParameterInitializerError(node.loc.start, ErrorMessages.YieldInParameter);
    this.next();
    let delegating = false;
    let argument = null;

diff --git a/a.js b/b.js
@@ -13714,7 +14128,7 @@ checkPipelineAtInfixOperator(left, leftStartLoc) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.delegate = delegating;
    node.argument = argument;
    return this.finishNode(node, "YieldExpression");
  }

  checkPipelineAtInfixOperator(left, leftStartLoc) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      if (left.type === "SequenceExpression") {
        this.raise(ErrorMessages.PipelineHeadSequenceExpression, {
          at: leftStartLoc
        });
      }
    }
diff --git a/a.js b/b.js
@@ -13749,13 +14163,13 @@ isSimpleReference(expression) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      bodyNode.expression = childExpr;
      return this.finishNode(bodyNode, "PipelineTopicExpression");
    }
  }

  isSimpleReference(expression) {
    switch (expression.type) {
      case "MemberExpression":
        return !expression.computed && this.isSimpleReference(expression.object);

      case "Identifier":
        return true;

      default:
        return false;
    }
  }

  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
    if (this.match(19)) {
      throw this.raise(ErrorMessages.PipelineBodyNoArrow, {
        at: this.state.startLoc
      });
    }

    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(ErrorMessages.PipelineTopicUnused, {
        at: startLoc
      });
    }
  }
diff --git a/a.js b/b.js
@@ -14032,10 +14446,11 @@ parseProgram(program, end = 135, sourceType = this.options.sourceType) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(file, "File");
  }

  parseProgram(program, end = 135, sourceType = this.options.sourceType) {
    program.sourceType = sourceType;
    program.interpreter = this.parseInterpreterDirective();
    this.parseBlockBody(program, true, true, end);

    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
      for (const [name, loc] of Array.from(this.scope.undefinedExports)) {
        this.raise(ErrorMessages.ModuleExportUndefined, {
          at: loc
        }, name);
      }
    }

    return this.finishNode(program, "Program");
diff --git a/a.js b/b.js
@@ -14144,11 +14559,11 @@ parseStatementContent(context, topLevel) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = 74;
      kind = "let";
    }

    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node, true);

      case 63:
        return this.parseBreakContinueStatement(node, false);

      case 64:
        return this.parseDebuggerStatement(node);

      case 90:
        return this.parseDoStatement(node);

      case 91:
        return this.parseForStatement(node);

      case 68:
        if (this.lookaheadCharCode() === 46) break;

        if (context) {
          if (this.state.strict) {
            this.raise(ErrorMessages.StrictFunction, {
              at: this.state.startLoc
            });
          } else if (context !== "if" && context !== "label") {
            this.raise(ErrorMessages.SloppyFunction, {
              at: this.state.startLoc
            });
          }
        }
diff --git a/a.js b/b.js
@@ -14180,7 +14595,7 @@ parseStatementContent(context, topLevel) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = 74;
      kind = "let";
    }

    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node, true);

      case 63:
        return this.parseBreakContinueStatement(node, false);

      case 64:
        return this.parseDebuggerStatement(node);

      case 90:
        return this.parseDoStatement(node);

      case 91:
        return this.parseForStatement(node);

      case 68:
        if (this.lookaheadCharCode() === 46) break;

        if (context) {
          if (this.state.strict) {
            this.raise(ErrorMessages.StrictFunction, {
              at: this.state.startLoc
            });
          } else if (context !== "if" && context !== "label") {
            this.raise(ErrorMessages.SloppyFunction, {
              at: this.state.startLoc
            });
          }
        }

        return this.parseFunctionStatement(node, false, !context);

      case 80:
        if (context) this.unexpected();
        return this.parseClass(node, true);

      case 69:
        return this.parseIfStatement(node);

      case 70:
        return this.parseReturnStatement(node);

      case 71:
        return this.parseSwitchStatement(node);

      case 72:
        return this.parseThrowStatement(node);

      case 73:
        return this.parseTryStatement(node);

      case 75:
      case 74:
        kind = kind || this.state.value;

        if (context && kind !== "var") {
          this.raise(ErrorMessages.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          });
        }

diff --git a/a.js b/b.js
@@ -14211,7 +14626,7 @@ parseStatementContent(context, topLevel) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = 74;
      kind = "let";
    }

    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node, true);

      case 63:
        return this.parseBreakContinueStatement(node, false);

      case 64:
        return this.parseDebuggerStatement(node);

      case 90:
        return this.parseDoStatement(node);

      case 91:
        return this.parseForStatement(node);

      case 68:
        if (this.lookaheadCharCode() === 46) break;

        if (context) {
          if (this.state.strict) {
            this.raise(ErrorMessages.StrictFunction, {
              at: this.state.startLoc
            });
          } else if (context !== "if" && context !== "label") {
            this.raise(ErrorMessages.SloppyFunction, {
              at: this.state.startLoc
            });
          }
        }

        return this.parseFunctionStatement(node, false, !context);

      case 80:
        if (context) this.unexpected();
        return this.parseClass(node, true);

      case 69:
        return this.parseIfStatement(node);

      case 70:
        return this.parseReturnStatement(node);

      case 71:
        return this.parseSwitchStatement(node);

      case 72:
        return this.parseThrowStatement(node);

      case 73:
        return this.parseTryStatement(node);

      case 75:
      case 74:
        kind = kind || this.state.value;

        if (context && kind !== "var") {
          this.raise(ErrorMessages.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          });
        }

        return this.parseVarStatement(node, kind);

      case 92:
        return this.parseWhileStatement(node);

      case 76:
        return this.parseWithStatement(node);

      case 5:
        return this.parseBlock();

      case 13:
        return this.parseEmptyStatement(node);

      case 83:
        {
          const nextTokenCharCode = this.lookaheadCharCode();

          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }

      case 82:
        {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(ErrorMessages.UnexpectedImportExport, {
              at: this.state.startLoc
            });
          }

diff --git a/a.js b/b.js
@@ -14241,7 +14656,7 @@ parseStatementContent(context, topLevel) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = 74;
      kind = "let";
    }

    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node, true);

      case 63:
        return this.parseBreakContinueStatement(node, false);

      case 64:
        return this.parseDebuggerStatement(node);

      case 90:
        return this.parseDoStatement(node);

      case 91:
        return this.parseForStatement(node);

      case 68:
        if (this.lookaheadCharCode() === 46) break;

        if (context) {
          if (this.state.strict) {
            this.raise(ErrorMessages.StrictFunction, {
              at: this.state.startLoc
            });
          } else if (context !== "if" && context !== "label") {
            this.raise(ErrorMessages.SloppyFunction, {
              at: this.state.startLoc
            });
          }
        }

        return this.parseFunctionStatement(node, false, !context);

      case 80:
        if (context) this.unexpected();
        return this.parseClass(node, true);

      case 69:
        return this.parseIfStatement(node);

      case 70:
        return this.parseReturnStatement(node);

      case 71:
        return this.parseSwitchStatement(node);

      case 72:
        return this.parseThrowStatement(node);

      case 73:
        return this.parseTryStatement(node);

      case 75:
      case 74:
        kind = kind || this.state.value;

        if (context && kind !== "var") {
          this.raise(ErrorMessages.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          });
        }

        return this.parseVarStatement(node, kind);

      case 92:
        return this.parseWhileStatement(node);

      case 76:
        return this.parseWithStatement(node);

      case 5:
        return this.parseBlock();

      case 13:
        return this.parseEmptyStatement(node);

      case 83:
        {
          const nextTokenCharCode = this.lookaheadCharCode();

          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }

      case 82:
        {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(ErrorMessages.UnexpectedImportExport, {
              at: this.state.startLoc
            });
          }

          this.next();
          let result;

          if (starttype === 83) {
            result = this.parseImport(node);

            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node);

            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }

          this.assertModuleNodeAllowed(node);
          return result;
        }

      default:
        {
          if (this.isAsyncFunction()) {
            if (context) {
              this.raise(ErrorMessages.AsyncFunctionInSingleStatementContext, {
                at: this.state.startLoc
              });
            }

diff --git a/a.js b/b.js
@@ -14264,8 +14679,8 @@ parseStatementContent(context, topLevel) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = 74;
      kind = "let";
    }

    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node, true);

      case 63:
        return this.parseBreakContinueStatement(node, false);

      case 64:
        return this.parseDebuggerStatement(node);

      case 90:
        return this.parseDoStatement(node);

      case 91:
        return this.parseForStatement(node);

      case 68:
        if (this.lookaheadCharCode() === 46) break;

        if (context) {
          if (this.state.strict) {
            this.raise(ErrorMessages.StrictFunction, {
              at: this.state.startLoc
            });
          } else if (context !== "if" && context !== "label") {
            this.raise(ErrorMessages.SloppyFunction, {
              at: this.state.startLoc
            });
          }
        }

        return this.parseFunctionStatement(node, false, !context);

      case 80:
        if (context) this.unexpected();
        return this.parseClass(node, true);

      case 69:
        return this.parseIfStatement(node);

      case 70:
        return this.parseReturnStatement(node);

      case 71:
        return this.parseSwitchStatement(node);

      case 72:
        return this.parseThrowStatement(node);

      case 73:
        return this.parseTryStatement(node);

      case 75:
      case 74:
        kind = kind || this.state.value;

        if (context && kind !== "var") {
          this.raise(ErrorMessages.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          });
        }

        return this.parseVarStatement(node, kind);

      case 92:
        return this.parseWhileStatement(node);

      case 76:
        return this.parseWithStatement(node);

      case 5:
        return this.parseBlock();

      case 13:
        return this.parseEmptyStatement(node);

      case 83:
        {
          const nextTokenCharCode = this.lookaheadCharCode();

          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }

      case 82:
        {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(ErrorMessages.UnexpectedImportExport, {
              at: this.state.startLoc
            });
          }

          this.next();
          let result;

          if (starttype === 83) {
            result = this.parseImport(node);

            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node);

            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }

          this.assertModuleNodeAllowed(node);
          return result;
        }

      default:
        {
          if (this.isAsyncFunction()) {
            if (context) {
              this.raise(ErrorMessages.AsyncFunctionInSingleStatementContext, {
                at: this.state.startLoc
              });
            }

            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
        }
    }

    const maybeName = this.state.value;
    const expr = this.parseExpression();

    if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
      return this.parseLabeledStatement(node, maybeName, expr, context);
    } else {
      return this.parseExpressionStatement(node, expr);
    }
  }

  assertModuleNodeAllowed(node) {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raise(SourceTypeModuleErrorMessages.ImportOutsideModule, {
        node
      });
    }
  }

diff --git a/a.js b/b.js
@@ -14298,12 +14713,12 @@ parseDecorators(allowExport) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  canHaveLeadingDecorator() {
    return this.match(80);
  }

  parseDecorators(allowExport) {
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    while (this.match(26)) {
      const decorator = this.parseDecorator();
      currentContextDecorators.push(decorator);
    }

    if (this.match(82)) {
      if (!allowExport) {
        this.unexpected();
      }

      if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.raise(ErrorMessages.DecoratorExportClass, {
          at: this.state.startLoc
        });
      }
    } else if (!this.canHaveLeadingDecorator()) {
      throw this.raise(ErrorMessages.UnexpectedLeadingDecorator, {
        at: this.state.startLoc
      });
    }
  }
diff --git a/a.js b/b.js
@@ -14383,9 +14798,11 @@ verifyBreakContinue(node, isBreak) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

    this.verifyBreakContinue(node, isBreak);
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }

  verifyBreakContinue(node, isBreak) {
    let i;

    for (i = 0; i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i];

      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
        if (node.label && isBreak) break;
      }
    }

    if (i === this.state.labels.length) {
      this.raise(ErrorMessages.IllegalBreakContinue, {
        node
      }, isBreak ? "break" : "continue");
    }
  }

  parseDebuggerStatement(node) {
diff --git a/a.js b/b.js
@@ -14461,14 +14878,14 @@ parseForStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.test = this.parseHeaderExpression();
    this.eat(13);
    return this.finishNode(node, "DoWhileStatement");
  }

  parseForStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    let awaitAt = null;

    if (this.isAwaitAllowed() && this.eatContextual(96)) {
      awaitAt = this.state.lastTokStartLoc;
    }

    this.scope.enter(SCOPE_OTHER);
    this.expect(10);

    if (this.match(13)) {
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, null);
    }

    const startsWithLet = this.isContextual(99);
    const isLet = startsWithLet && this.isLetKeyword();

    if (this.match(74) || this.match(75) || isLet) {
      const init = this.startNode();
      const kind = isLet ? "let" : this.state.value;
      this.next();
      this.parseVar(init, true, kind);
      this.finishNode(init, "VariableDeclaration");

      if ((this.match(58) || this.isContextual(101)) && init.declarations.length === 1) {
        return this.parseForIn(node, init, awaitAt);
      }

      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    const startsWithAsync = this.isContextual(95);
    const refExpressionErrors = new ExpressionErrors();
    const init = this.parseExpression(true, refExpressionErrors);
    const isForOf = this.isContextual(101);

    if (isForOf) {
      if (startsWithLet) {
        this.raise(ErrorMessages.ForOfLet, {
          node: init
        });
      }

      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
        this.raise(ErrorMessages.ForOfAsync, {
          node: init
        });
      }
    }

diff --git a/a.js b/b.js
@@ -14476,8 +14893,12 @@ parseForStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.test = this.parseHeaderExpression();
    this.eat(13);
    return this.finishNode(node, "DoWhileStatement");
  }

  parseForStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    let awaitAt = null;

    if (this.isAwaitAllowed() && this.eatContextual(96)) {
      awaitAt = this.state.lastTokStartLoc;
    }

    this.scope.enter(SCOPE_OTHER);
    this.expect(10);

    if (this.match(13)) {
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, null);
    }

    const startsWithLet = this.isContextual(99);
    const isLet = startsWithLet && this.isLetKeyword();

    if (this.match(74) || this.match(75) || isLet) {
      const init = this.startNode();
      const kind = isLet ? "let" : this.state.value;
      this.next();
      this.parseVar(init, true, kind);
      this.finishNode(init, "VariableDeclaration");

      if ((this.match(58) || this.isContextual(101)) && init.declarations.length === 1) {
        return this.parseForIn(node, init, awaitAt);
      }

      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    const startsWithAsync = this.isContextual(95);
    const refExpressionErrors = new ExpressionErrors();
    const init = this.parseExpression(true, refExpressionErrors);
    const isForOf = this.isContextual(101);

    if (isForOf) {
      if (startsWithLet) {
        this.raise(ErrorMessages.ForOfLet, {
          node: init
        });
      }

      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
        this.raise(ErrorMessages.ForOfAsync, {
          node: init
        });
      }
    }

    if (isForOf || this.match(58)) {
      this.checkDestructuringPrivate(refExpressionErrors);
      this.toAssignable(init, true);
      const description = isForOf ? "for-of statement" : "for-in statement";
      this.checkLVal(init, description);
      return this.parseForIn(node, init, awaitAt);
    } else {
      this.checkExpressionErrors(refExpressionErrors, true);
    }
diff --git a/a.js b/b.js
@@ -14505,7 +14926,7 @@ parseIfStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  parseFunctionStatement(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
  }

  parseIfStatement(node) {
    this.next();
    node.test = this.parseHeaderExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(66) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement");
  }

  parseReturnStatement(node) {
    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
      this.raise(ErrorMessages.IllegalReturn, {
        at: this.state.startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -14543,7 +14964,7 @@ parseSwitchStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "ReturnStatement");
  }

  parseSwitchStatement(node) {
    this.next();
    node.discriminant = this.parseHeaderExpression();
    const cases = node.cases = [];
    this.expect(5);
    this.state.labels.push(switchLabel);
    this.scope.enter(SCOPE_OTHER);
    let cur;

    for (let sawDefault; !this.match(8);) {
      if (this.match(61) || this.match(65)) {
        const isCase = this.match(61);
        if (cur) this.finishNode(cur, "SwitchCase");
        cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();

        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raise(ErrorMessages.MultipleDefaultsInSwitch, {
              at: this.state.lastTokStartLoc
            });
          }

diff --git a/a.js b/b.js
@@ -14573,7 +14994,7 @@ parseThrowStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.next();
    this.state.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  }

  parseThrowStatement(node) {
    this.next();

    if (this.hasPrecedingLineBreak()) {
      this.raise(ErrorMessages.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc
      });
    }

diff --git a/a.js b/b.js
@@ -14587,7 +15008,13 @@ parseCatchClauseParam() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  }

  parseCatchClauseParam() {
    const param = this.parseBindingAtom();
    const simple = param.type === "Identifier";
    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLVal(param, "catch clause", BIND_LEXICAL);
    return param;
  }

  parseTryStatement(node) {
diff --git a/a.js b/b.js
@@ -14617,17 +15044,17 @@ parseTryStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLVal(param, "catch clause", BIND_LEXICAL);
    return param;
  }

  parseTryStatement(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;

    if (this.match(62)) {
      const clause = this.startNode();
      this.next();

      if (this.match(10)) {
        this.expect(10);
        clause.param = this.parseCatchClauseParam();
        this.expect(11);
      } else {
        clause.param = null;
        this.scope.enter(SCOPE_OTHER);
      }

      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
      this.scope.exit();
      node.handler = this.finishNode(clause, "CatchClause");
    }

    node.finalizer = this.eat(67) ? this.parseBlock() : null;

    if (!node.handler && !node.finalizer) {
      this.raise(ErrorMessages.NoCatchOrFinally, {
        node
      });
    }

    return this.finishNode(node, "TryStatement");
  }

  parseVarStatement(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  }

diff --git a/a.js b/b.js
@@ -14643,7 +15070,7 @@ parseWhileStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  }

  parseWhileStatement(node) {
    this.next();
    node.test = this.parseHeaderExpression();
    this.state.labels.push(loopLabel);
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
    this.state.labels.pop();
    return this.finishNode(node, "WhileStatement");
  }

  parseWithStatement(node) {
    if (this.state.strict) {
      this.raise(ErrorMessages.StrictWith, {
        at: this.state.startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -14662,9 +15089,10 @@ parseEmptyStatement(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    node.object = this.parseHeaderExpression();
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
    return this.finishNode(node, "WithStatement");
  }

  parseEmptyStatement(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  }

  parseLabeledStatement(node, maybeName, expr, context) {
    for (const label of this.state.labels) {
      if (label.name === maybeName) {
        this.raise(ErrorMessages.LabelRedeclaration, {
          node: expr
        }, maybeName);
      }
    }

    const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
diff --git a/a.js b/b.js
@@ -14793,15 +15221,19 @@ parseForIn(node, init, awaitAt) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  }

  parseForIn(node, init, awaitAt) {
    const isForIn = this.match(58);
    this.next();

    if (isForIn) {
      if (awaitAt !== null) this.unexpected(awaitAt);
    } else {
      node.await = awaitAt !== null;
    }

    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
      this.raise(ErrorMessages.ForInOfLoopInitializer, {
        node: init
      }, isForIn ? "for-in" : "for-of");
    }

    if (init.type === "AssignmentPattern") {
      this.raise(ErrorMessages.InvalidLhs, {
        node: init
      }, "for-loop");
    }

    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
diff --git a/a.js b/b.js
@@ -14813,31 +15245,27 @@ parseForIn(node, init, awaitAt) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  }

  parseForIn(node, init, awaitAt) {
    const isForIn = this.match(58);
    this.next();

    if (isForIn) {
      if (awaitAt !== null) this.unexpected(awaitAt);
    } else {
      node.await = awaitAt !== null;
    }

    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
      this.raise(ErrorMessages.ForInOfLoopInitializer, {
        node: init
      }, isForIn ? "for-in" : "for-of");
    }

    if (init.type === "AssignmentPattern") {
      this.raise(ErrorMessages.InvalidLhs, {
        node: init
      }, "for-loop");
    }

    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
    this.expect(11);
    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
  }

  parseVar(node, isFor, kind) {
    const declarations = node.declarations = [];
    const isTypescript = this.hasPlugin("typescript");
    node.kind = kind;

    for (;;) {
      const decl = this.startNode();
      this.parseVarId(decl, kind);

      if (this.eat(29)) {
        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
      } else {
        if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
          if (!isTypescript) {
            this.raise(ErrorMessages.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc
            }, "Const declarations");
          }
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
          this.raise(ErrorMessages.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc
          }, "Complex binding patterns");
        }

        decl.init = null;
      }

      declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(12)) break;
diff --git a/a.js b/b.js
@@ -14849,7 +15277,12 @@ parseVar(node, isFor, kind) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.scope.exit();
    this.state.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
  }

  parseVar(node, isFor, kind) {
    const declarations = node.declarations = [];
    const isTypescript = this.hasPlugin("typescript");
    node.kind = kind;

    for (;;) {
      const decl = this.startNode();
      this.parseVarId(decl, kind);

      if (this.eat(29)) {
        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
      } else {
        if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
          if (!isTypescript) {
            this.raise(ErrorMessages.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc
            }, "Const declarations");
          }
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
          this.raise(ErrorMessages.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc
          }, "Complex binding patterns");
        }

        decl.init = null;
      }

      declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(12)) break;
    }

    return node;
  }

  parseVarId(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
  }

  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
    const isStatement = statement & FUNC_STATEMENT;
diff --git a/a.js b/b.js
@@ -14859,7 +15292,7 @@ parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  parseVarId(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
  }

  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
    const isStatement = statement & FUNC_STATEMENT;
    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
    this.initFunction(node, isAsync);

    if (this.match(55) && isHangingStatement) {
      this.raise(ErrorMessages.GeneratorInSingleStatementContext, {
        at: this.state.startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -14947,7 +15380,7 @@ parseClassBody(hadSuperClass, oldStrict) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isNonstaticConstructor(method) {
    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
  }

  parseClassBody(hadSuperClass, oldStrict) {
    this.classScope.enter();
    const state = {
      hadConstructor: false,
      hadSuperClass
    };
    let decorators = [];
    const classBody = this.startNode();
    classBody.body = [];
    this.expect(5);
    this.withSmartMixTopicForbiddingContext(() => {
      while (!this.match(8)) {
        if (this.eat(13)) {
          if (decorators.length > 0) {
            throw this.raise(ErrorMessages.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc
            });
          }

diff --git a/a.js b/b.js
@@ -14971,8 +15404,8 @@ parseClassBody(hadSuperClass, oldStrict) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isNonstaticConstructor(method) {
    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
  }

  parseClassBody(hadSuperClass, oldStrict) {
    this.classScope.enter();
    const state = {
      hadConstructor: false,
      hadSuperClass
    };
    let decorators = [];
    const classBody = this.startNode();
    classBody.body = [];
    this.expect(5);
    this.withSmartMixTopicForbiddingContext(() => {
      while (!this.match(8)) {
        if (this.eat(13)) {
          if (decorators.length > 0) {
            throw this.raise(ErrorMessages.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc
            });
          }

          continue;
        }

        if (this.match(26)) {
          decorators.push(this.parseDecorator());
          continue;
        }

        const member = this.startNode();

        if (decorators.length) {
          member.decorators = decorators;
          this.resetStartLocationFromNode(member, decorators[0]);
          decorators = [];
        }

        this.parseClassMember(classBody, member, state);

        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
          this.raise(ErrorMessages.DecoratorConstructor, {
            node: member
          });
        }
      }
    });
diff --git a/a.js b/b.js
@@ -14981,7 +15414,7 @@ parseClassBody(hadSuperClass, oldStrict) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822

  isNonstaticConstructor(method) {
    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
  }

  parseClassBody(hadSuperClass, oldStrict) {
    this.classScope.enter();
    const state = {
      hadConstructor: false,
      hadSuperClass
    };
    let decorators = [];
    const classBody = this.startNode();
    classBody.body = [];
    this.expect(5);
    this.withSmartMixTopicForbiddingContext(() => {
      while (!this.match(8)) {
        if (this.eat(13)) {
          if (decorators.length > 0) {
            throw this.raise(ErrorMessages.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc
            });
          }

          continue;
        }

        if (this.match(26)) {
          decorators.push(this.parseDecorator());
          continue;
        }

        const member = this.startNode();

        if (decorators.length) {
          member.decorators = decorators;
          this.resetStartLocationFromNode(member, decorators[0]);
          decorators = [];
        }

        this.parseClassMember(classBody, member, state);

        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
          this.raise(ErrorMessages.DecoratorConstructor, {
            node: member
          });
        }
      }
    });
    this.state.strict = oldStrict;
    this.next();

    if (decorators.length) {
      throw this.raise(ErrorMessages.TrailingDecorator, {
        at: this.state.startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -15053,8 +15486,8 @@ parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const accessorProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;
    this.parsePropertyNamePrefixOperator(member);

    if (this.eat(55)) {
      method.kind = "method";
      const isPrivateName = this.match(134);
      this.parseClassElementName(method);

      if (isPrivateName) {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }

      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(ErrorMessages.ConstructorIsGenerator, {
          node: publicMethod.key
        });
      }

      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
diff --git a/a.js b/b.js
@@ -15083,14 +15516,14 @@ parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const accessorProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;
    this.parsePropertyNamePrefixOperator(member);

    if (this.eat(55)) {
      method.kind = "method";
      const isPrivateName = this.match(134);
      this.parseClassElementName(method);

      if (isPrivateName) {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }

      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(ErrorMessages.ConstructorIsGenerator, {
          node: publicMethod.key
        });
      }

      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
      return;
    }

    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
    const isPrivate = this.match(134);
    const key = this.parseClassElementName(member);
    const maybeQuestionTokenStartLoc = this.state.startLoc;
    this.parsePostMemberNameModifiers(publicMember);

    if (this.isClassMethod()) {
      method.kind = "method";

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }

      const isConstructor = this.isNonstaticConstructor(publicMethod);
      let allowsDirectSuper = false;

      if (isConstructor) {
        publicMethod.kind = "constructor";

        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(ErrorMessages.DuplicateConstructor, {
            node: key
          });
        }

        if (isConstructor && this.hasPlugin("typescript") && member.override) {
          this.raise(ErrorMessages.OverrideOnConstructor, {
            node: key
          });
        }

        state.hadConstructor = true;
diff --git a/a.js b/b.js
@@ -15122,8 +15555,8 @@ parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const accessorProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;
    this.parsePropertyNamePrefixOperator(member);

    if (this.eat(55)) {
      method.kind = "method";
      const isPrivateName = this.match(134);
      this.parseClassElementName(method);

      if (isPrivateName) {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }

      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(ErrorMessages.ConstructorIsGenerator, {
          node: publicMethod.key
        });
      }

      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
      return;
    }

    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
    const isPrivate = this.match(134);
    const key = this.parseClassElementName(member);
    const maybeQuestionTokenStartLoc = this.state.startLoc;
    this.parsePostMemberNameModifiers(publicMember);

    if (this.isClassMethod()) {
      method.kind = "method";

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }

      const isConstructor = this.isNonstaticConstructor(publicMethod);
      let allowsDirectSuper = false;

      if (isConstructor) {
        publicMethod.kind = "constructor";

        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(ErrorMessages.DuplicateConstructor, {
            node: key
          });
        }

        if (isConstructor && this.hasPlugin("typescript") && member.override) {
          this.raise(ErrorMessages.OverrideOnConstructor, {
            node: key
          });
        }

        state.hadConstructor = true;
        allowsDirectSuper = state.hadSuperClass;
      }

      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
    } else if (this.isClassProperty()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(key);
      const isGenerator = this.eat(55);

      if (publicMember.optional) {
        this.unexpected(maybeQuestionTokenStartLoc);
      }

      method.kind = "method";
      const isPrivate = this.match(134);
      this.parseClassElementName(method);
      this.parsePostMemberNameModifiers(publicMember);

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(ErrorMessages.ConstructorIsAsync, {
            node: publicMethod.key
          });
        }

        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
diff --git a/a.js b/b.js
@@ -15139,8 +15572,8 @@ parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const accessorProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;
    this.parsePropertyNamePrefixOperator(member);

    if (this.eat(55)) {
      method.kind = "method";
      const isPrivateName = this.match(134);
      this.parseClassElementName(method);

      if (isPrivateName) {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }

      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(ErrorMessages.ConstructorIsGenerator, {
          node: publicMethod.key
        });
      }

      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
      return;
    }

    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
    const isPrivate = this.match(134);
    const key = this.parseClassElementName(member);
    const maybeQuestionTokenStartLoc = this.state.startLoc;
    this.parsePostMemberNameModifiers(publicMember);

    if (this.isClassMethod()) {
      method.kind = "method";

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }

      const isConstructor = this.isNonstaticConstructor(publicMethod);
      let allowsDirectSuper = false;

      if (isConstructor) {
        publicMethod.kind = "constructor";

        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(ErrorMessages.DuplicateConstructor, {
            node: key
          });
        }

        if (isConstructor && this.hasPlugin("typescript") && member.override) {
          this.raise(ErrorMessages.OverrideOnConstructor, {
            node: key
          });
        }

        state.hadConstructor = true;
        allowsDirectSuper = state.hadSuperClass;
      }

      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
    } else if (this.isClassProperty()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(key);
      const isGenerator = this.eat(55);

      if (publicMember.optional) {
        this.unexpected(maybeQuestionTokenStartLoc);
      }

      method.kind = "method";
      const isPrivate = this.match(134);
      this.parseClassElementName(method);
      this.parsePostMemberNameModifiers(publicMember);

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(ErrorMessages.ConstructorIsAsync, {
            node: publicMethod.key
          });
        }

        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
      }
    } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(key);
      method.kind = key.name;
      const isPrivate = this.match(134);
      this.parseClassElementName(publicMethod);

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(ErrorMessages.ConstructorIsAccessor, {
            node: publicMethod.key
          });
        }

        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
diff --git a/a.js b/b.js
@@ -15172,14 +15605,14 @@ parseClassElementName(member) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } else {
      this.unexpected();
    }
  }

  parseClassElementName(member) {
    const {
      type,
      value
    } = this.state;

    if ((type === 128 || type === 129) && member.static && value === "prototype") {
      this.raise(ErrorMessages.StaticPrototype, {
        at: this.state.startLoc
      });
    }

    if (type === 134) {
      if (value === "constructor") {
        this.raise(ErrorMessages.ConstructorClassPrivateField, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -15207,16 +15640,16 @@ parseClassStaticBlock(classBody, member) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.parsePropertyName(member);
  }

  parseClassStaticBlock(classBody, member) {
    var _member$decorators;

    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
    const oldLabels = this.state.labels;
    this.state.labels = [];
    this.prodParam.enter(PARAM);
    const body = member.body = [];
    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
    this.prodParam.exit();
    this.scope.exit();
    this.state.labels = oldLabels;
    classBody.body.push(this.finishNode(member, "StaticBlock"));

    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
      this.raise(ErrorMessages.DecoratorStaticBlock, {
        node: member
      });
    }
  }

  pushClassProperty(classBody, prop) {
    if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
      this.raise(ErrorMessages.ConstructorClassField, {
        node: prop.key
      });
    }

    classBody.body.push(this.parseClassProperty(prop));
diff --git a/a.js b/b.js
@@ -15234,8 +15667,8 @@ pushClassAccessorProperty(classBody, prop, isPrivate) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    const node = this.parseClassPrivateProperty(prop);
    classBody.body.push(node);
    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
  }

  pushClassAccessorProperty(classBody, prop, isPrivate) {
    if (!isPrivate && !prop.computed) {
      const key = prop.key;

      if (key.name === "constructor" || key.value === "constructor") {
        this.raise(ErrorMessages.ConstructorClassField, {
          node: key
        });
      }
    }

diff --git a/a.js b/b.js
@@ -15298,13 +15731,13 @@ parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    this.expressionScope.exit();
    this.prodParam.exit();
    this.scope.exit();
  }

  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
    if (tokenIsIdentifier(this.state.type)) {
      node.id = this.parseIdentifier();

      if (isStatement) {
        this.checkLVal(node.id, "class name", bindingType);
      }
    } else {
      if (optionalId || !isStatement) {
        node.id = null;
      } else {
        throw this.raise(ErrorMessages.MissingClassName, {
          at: this.state.startLoc
        });
      }
    }
diff --git a/a.js b/b.js
@@ -15447,7 +15880,7 @@ parseExportDefaultExpression() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (!this.isContextual(95)) return false;
    const next = this.nextTokenStart();
    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
  }

  parseExportDefaultExpression() {
    const expr = this.startNode();
    const isAsync = this.isAsyncFunction();

    if (this.match(68) || isAsync) {
      this.next();

      if (isAsync) {
        this.next();
      }

      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
    }

    if (this.match(80)) {
      return this.parseClass(expr, true, true);
    }

    if (this.match(26)) {
      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.raise(ErrorMessages.DecoratorBeforeExport, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -15457,7 +15890,7 @@ parseExportDefaultExpression() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    if (!this.isContextual(95)) return false;
    const next = this.nextTokenStart();
    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
  }

  parseExportDefaultExpression() {
    const expr = this.startNode();
    const isAsync = this.isAsyncFunction();

    if (this.match(68) || isAsync) {
      this.next();

      if (isAsync) {
        this.next();
      }

      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
    }

    if (this.match(80)) {
      return this.parseClass(expr, true, true);
    }

    if (this.match(26)) {
      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.raise(ErrorMessages.DecoratorBeforeExport, {
          at: this.state.startLoc
        });
      }

      this.parseDecorators(false);
      return this.parseClass(expr, true, true);
    }

    if (this.match(75) || this.match(74) || this.isLet()) {
      throw this.raise(ErrorMessages.UnsupportedDefaultExport, {
        at: this.state.startLoc
      });
    }

diff --git a/a.js b/b.js
@@ -15536,7 +15969,7 @@ shouldParseExportDeclaration() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    this.semicolon();
  }

  shouldParseExportDeclaration() {
    const {
      type
    } = this.state;

    if (type === 26) {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);

      if (this.hasPlugin("decorators")) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          throw this.raise(ErrorMessages.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        }

diff --git a/a.js b/b.js
@@ -15559,8 +15992,8 @@ checkExport(node, checkNames, isDefault, isFrom) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
  }

  checkExport(node, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default");

        if (this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;

          const declaration = node.declaration;

          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
            this.raise(ErrorMessages.ExportDefaultFromAsIdentifier, {
              node: declaration
            });
          }
        }
      } else if (node.specifiers && node.specifiers.length) {
diff --git a/a.js b/b.js
@@ -15569,8 +16002,8 @@ checkExport(node, checkNames, isDefault, isFrom) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
  }

  checkExport(node, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default");

        if (this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;

          const declaration = node.declaration;

          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
            this.raise(ErrorMessages.ExportDefaultFromAsIdentifier, {
              node: declaration
            });
          }
        }
      } else if (node.specifiers && node.specifiers.length) {
        for (const specifier of node.specifiers) {
          const {
            exported
          } = specifier;
          const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
          this.checkDuplicateExports(specifier, exportedName);

          if (!isFrom && specifier.local) {
            const {
              local
diff --git a/a.js b/b.js
@@ -15578,9 +16011,11 @@ checkExport(node, checkNames, isDefault, isFrom) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
  }

  checkExport(node, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default");

        if (this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;

          const declaration = node.declaration;

          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
            this.raise(ErrorMessages.ExportDefaultFromAsIdentifier, {
              node: declaration
            });
          }
        }
      } else if (node.specifiers && node.specifiers.length) {
        for (const specifier of node.specifiers) {
          const {
            exported
          } = specifier;
          const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
          this.checkDuplicateExports(specifier, exportedName);

          if (!isFrom && specifier.local) {
            const {
              local
            } = specifier;

            if (local.type !== "Identifier") {
              this.raise(ErrorMessages.ExportBindingIsString, {
                node: specifier
              }, local.value, exportedName);
            } else {
              this.checkReservedWord(local.name, local.loc.start, true, false);
              this.scope.checkLocalExport(local);
            }
diff --git a/a.js b/b.js
@@ -15603,8 +16038,8 @@ checkExport(node, checkNames, isDefault, isFrom) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
  }

  checkExport(node, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default");

        if (this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;

          const declaration = node.declaration;

          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
            this.raise(ErrorMessages.ExportDefaultFromAsIdentifier, {
              node: declaration
            });
          }
        }
      } else if (node.specifiers && node.specifiers.length) {
        for (const specifier of node.specifiers) {
          const {
            exported
          } = specifier;
          const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
          this.checkDuplicateExports(specifier, exportedName);

          if (!isFrom && specifier.local) {
            const {
              local
            } = specifier;

            if (local.type !== "Identifier") {
              this.raise(ErrorMessages.ExportBindingIsString, {
                node: specifier
              }, local.value, exportedName);
            } else {
              this.checkReservedWord(local.name, local.loc.start, true, false);
              this.scope.checkLocalExport(local);
            }
          }
        }
      } else if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          const id = node.declaration.id;
          if (!id) throw new Error("Assertion failure");
          this.checkDuplicateExports(node, id.name);
        } else if (node.declaration.type === "VariableDeclaration") {
          for (const declaration of node.declaration.declarations) {
            this.checkDeclaration(declaration.id);
          }
        }
      }
    }

    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    if (currentContextDecorators.length) {
      throw this.raise(ErrorMessages.UnsupportedDecoratorExport, {
        node
      });
    }
  }

diff --git a/a.js b/b.js
@@ -15631,14 +16066,21 @@ checkDeclaration(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
        node
      });
    }
  }

  checkDeclaration(node) {
    if (node.type === "Identifier") {
      this.checkDuplicateExports(node, node.name);
    } else if (node.type === "ObjectPattern") {
      for (const prop of node.properties) {
        this.checkDeclaration(prop);
      }
    } else if (node.type === "ArrayPattern") {
      for (const elem of node.elements) {
        if (elem) {
          this.checkDeclaration(elem);
        }
      }
    } else if (node.type === "ObjectProperty") {
      this.checkDeclaration(node.value);
    } else if (node.type === "RestElement") {
      this.checkDeclaration(node.argument);
    } else if (node.type === "AssignmentPattern") {
      this.checkDeclaration(node.left);
    }
  }

  checkDuplicateExports(node, name) {
    if (this.exportedIdentifiers.has(name)) {
      this.raise(name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, {
        node
      }, name);
    }

    this.exportedIdentifiers.add(name);
  }

  parseExportSpecifiers(isInTypeExport) {
    const nodes = [];
diff --git a/a.js b/b.js
@@ -15682,9 +16124,10 @@ parseModuleExportName() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return this.finishNode(node, "ExportSpecifier");
  }

  parseModuleExportName() {
    if (this.match(129)) {
      const result = this.parseStringLiteral(this.state.value);
      const surrogate = result.value.match(loneSurrogate);

      if (surrogate) {
        this.raise(ErrorMessages.ModuleExportNameHasLoneSurrogate, {
          node: result
        }, surrogate[0].charCodeAt(0).toString(16));
      }

      return result;
    }
diff --git a/a.js b/b.js
@@ -15730,10 +16173,17 @@ shouldParseDefaultImport(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
  parseImportSource() {
    if (!this.match(129)) this.unexpected();
    return this.parseExprAtom();
  }

  shouldParseDefaultImport(node) {
    return tokenIsIdentifier(this.state.type);
  }

  parseImportSpecifierLocal(node, specifier, type, contextDescription) {
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  parseAssertEntries() {
    const attrs = [];
diff --git a/a.js b/b.js
@@ -15749,9 +16199,10 @@ parseAssertEntries() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  parseAssertEntries() {
    const attrs = [];
    const attrNames = new Set();

    do {
      if (this.match(8)) {
        break;
      }

      const node = this.startNode();
      const keyName = this.state.value;

      if (attrNames.has(keyName)) {
        this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc
        }, keyName);
      }

      attrNames.add(keyName);

diff --git a/a.js b/b.js
@@ -15765,7 +16216,7 @@ parseAssertEntries() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  parseAssertEntries() {
    const attrs = [];
    const attrNames = new Set();

    do {
      if (this.match(8)) {
        break;
      }

      const node = this.startNode();
      const keyName = this.state.value;

      if (attrNames.has(keyName)) {
        this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc
        }, keyName);
      }

      attrNames.add(keyName);

      if (this.match(129)) {
        node.key = this.parseStringLiteral(keyName);
      } else {
        node.key = this.parseIdentifier(true);
      }

      this.expect(14);

      if (!this.match(129)) {
        throw this.raise(ErrorMessages.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -15795,22 +16246,23 @@ maybeParseModuleAttributes() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } while (this.eat(12));

    return attrs;
  }

  maybeParseModuleAttributes() {
    if (this.match(76) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin("moduleAttributes");
      this.next();
    } else {
      if (this.hasPlugin("moduleAttributes")) return [];
      return null;
    }

    const attrs = [];
    const attributes = new Set();

    do {
      const node = this.startNode();
      node.key = this.parseIdentifier(true);

      if (node.key.name !== "type") {
        this.raise(ErrorMessages.ModuleAttributeDifferentFromType, {
          node: node.key
        }, node.key.name);
      }

      if (attributes.has(node.key.name)) {
        this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, {
          node: node.key
        }, node.key.name);
      }

      attributes.add(node.key.name);
      this.expect(14);

      if (!this.match(129)) {
        throw this.raise(ErrorMessages.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      }

diff --git a/a.js b/b.js
@@ -15840,7 +16292,7 @@ maybeParseImportAssertions() {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    } while (this.eat(12));

    return attrs;
  }

  maybeParseImportAssertions() {
    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin("importAssertions");
      this.next();
    } else {
      if (this.hasPlugin("importAssertions")) return [];
      return null;
    }

    this.eat(5);
    const attrs = this.parseAssertEntries();
    this.eat(8);
    return attrs;
  }

  maybeParseDefaultImportSpecifier(node) {
    if (this.shouldParseDefaultImport(node)) {
      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
      return true;
    }

    return false;
diff --git a/a.js b/b.js
@@ -15852,7 +16304,7 @@ maybeParseStarImportSpecifier(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return false;
  }

  maybeParseStarImportSpecifier(node) {
    if (this.match(55)) {
      const specifier = this.startNode();
      this.next();
      this.expectContextual(93);
      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
      return true;
    }

    return false;
diff --git a/a.js b/b.js
@@ -15868,7 +16320,7 @@ parseNamedImportSpecifiers(node) {
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
    }

    return false;
  }

  parseNamedImportSpecifiers(node) {
    let first = true;
    this.expect(5);

    while (!this.eat(8)) {
      if (first) {
        first = false;
      } else {
        if (this.eat(14)) {
          throw this.raise(ErrorMessages.DestructureNamedImport, {
            at: this.state.startLoc
          });
        }

diff --git a/a.js b/b.js
@@ -15895,9 +16347,10 @@ parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTyp
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
      node.specifiers.push(importSpecifier);
    }
  }

  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      specifier.local = this.parseIdentifier();
    } else {
      const {
        imported
      } = specifier;

      if (importedIsString) {
        throw this.raise(ErrorMessages.ImportBindingIsString, {
          node: specifier
        }, imported.value);
      }

      this.checkReservedWord(imported.name, specifier.loc.start, true, true);

diff --git a/a.js b/b.js
@@ -15907,8 +16360,7 @@ parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTyp
A blob:b9559112d63e938b7fa6cedec37a5da9c2676822
      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
      node.specifiers.push(importSpecifier);
    }
  }

  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      specifier.local = this.parseIdentifier();
    } else {
      const {
        imported
      } = specifier;

      if (importedIsString) {
        throw this.raise(ErrorMessages.ImportBindingIsString, {
          node: specifier
        }, imported.value);
      }

      this.checkReservedWord(imported.name, specifier.loc.start, true, true);

      if (!specifier.local) {
        specifier.local = cloneIdentifier(imported);
      }
    }

    this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
    return this.finishNode(specifier, "ImportSpecifier");
  }

  isThisParam(param) {
    return param.type === "Identifier" && param.name === "this";
diff --git a/a.js b/b.js
@@ -23,32 +23,6 @@ const stripEncapsulatingBrackets = (container, isArr) => {
A blob:550c97c40b777b98fb541a487fa9292656ba6074
 * Removes initial and ending brackets from `rawType`
 * @param {JsdocTypeLine[]|JsdocTag} container
 * @param {boolean} isArr
 * @returns {void}
 */
const stripEncapsulatingBrackets = (container, isArr) => {
  if (isArr) {
    const firstItem = container[0];
    firstItem.rawType = firstItem.rawType.replace(
      /^\{/u, ''
    );

    const lastItem = container[container.length - 1];
    lastItem.rawType = lastItem.rawType.replace(/\}$/u, '');

    return;
  }
  container.rawType = container.rawType.replace(
    /^\{/u, ''
  ).replace(/\}$/u, '');
};

/**
 * Strips brackets from a tag's `rawType` values and adds `parsedType`
 * @param {JsdocTag} lastTag
 * @param {external:JsdocTypePrattParserMode} mode
 * @returns {void}
 */
const cleanUpLastTag = (lastTag, mode) => {
  // Strip out `}` that encapsulates and is not part of
  //   the type
  stripEncapsulatingBrackets(lastTag);
  if (lastTag.typeLines.length) {
    stripEncapsulatingBrackets(lastTag.typeLines, true);
  }

  // With even a multiline type now in full, add parsing
  let parsedType = null;

  try {
    parsedType = jsdocTypePrattParse(lastTag.rawType, mode);
  } catch (err) {
    // Ignore
  }

  lastTag.parsedType = parsedType;
};

/**
 * @external CommentParserJsdoc
 */

diff --git a/a.js b/b.js
@@ -108,12 +82,46 @@ const cleanUpLastTag = (lastTag, mode) => {
A blob:550c97c40b777b98fb541a487fa9292656ba6074
 * Strips brackets from a tag's `rawType` values and adds `parsedType`
 * @param {JsdocTag} lastTag
 * @param {external:JsdocTypePrattParserMode} mode
 * @returns {void}
 */
const cleanUpLastTag = (lastTag, mode) => {
  // Strip out `}` that encapsulates and is not part of
  //   the type
  stripEncapsulatingBrackets(lastTag);
  if (lastTag.typeLines.length) {
    stripEncapsulatingBrackets(lastTag.typeLines, true);
  }

  // With even a multiline type now in full, add parsing
  let parsedType = null;

  try {
    parsedType = jsdocTypePrattParse(lastTag.rawType, mode);
  } catch (err) {
    // Ignore
  }

  lastTag.parsedType = parsedType;
};

/**
 * @external CommentParserJsdoc
 */

/**
 * @external JsdocTypePrattParserMode
 */

/**
 * @typedef {{
 *   delimiter: string,
 *   postDelimiter: string,
 *   rawType: string,
 *   start: string,
 *   type: "JsdocTypeLine"
 * }} JsdocTypeLine
 */

/**
 * @typedef {{
 *   delimiter: string,
 *   description: string,
 *   postDelimiter: string,
 *   start: string,
 *   type: "JsdocDescriptionLine"
 * }} JsdocDescriptionLine
 */

/**
 * @typedef {{
 *   delimiter: string,
 *   description: string,
 *   postDelimiter: string,
 *   start: string,
 *   tag: string,
 *   end: string,
 *   type: string,
 *   descriptionLines: JsdocDescriptionLine[],
 *   rawType: string,
 *   type: "JsdocTag",
 *   typeLines: JsdocTypeLine[]
 * }} JsdocTag
 */

/**
 * @typedef {{
 *   delimiter: string,
 *   description: string,
 *   descriptionLines: JsdocDescriptionLine[],
 *   end: string,
 *   postDelimiter: string,
 *   lineEnd: string,
 *   type: "JsdocBlock",
 *   lastDescriptionLine: Integer,
 *   tags: JsdocTag[]
 * }} JsdocBlock
 */

/**
 *
 * @param {external:CommentParserJsdoc} jsdoc
 * @param {external:JsdocTypePrattParserMode} mode
 * @returns {JsdocBlock}
 */
const commentParserToESTree = (jsdoc, mode) => {
  const {source} = jsdoc;

  const {tokens: {
    delimiter: delimiterRoot,
diff --git a/a.js b/b.js
@@ -163,7 +171,7 @@ const commentParserToESTree = (jsdoc, mode) => {
A blob:550c97c40b777b98fb541a487fa9292656ba6074
 *
 * @param {external:CommentParserJsdoc} jsdoc
 * @param {external:JsdocTypePrattParserMode} mode
 * @returns {JsdocBlock}
 */
const commentParserToESTree = (jsdoc, mode) => {
  const {source} = jsdoc;

  const {tokens: {
    delimiter: delimiterRoot,
    lineEnd: lineEndRoot,
    postDelimiter: postDelimiterRoot,
    end: endRoot,
    description: descriptionRoot
  }} = source[0];

  const endLine = source.length - 1;
  const ast = {
    delimiter: delimiterRoot,
    description: descriptionRoot,

    descriptionLines: [],

    // `end` will be overwritten if there are other entries
    end: endRoot,
    endLine,
    postDelimiter: postDelimiterRoot,
    lineEnd: lineEndRoot,

    type: 'JsdocBlock'
  };

  const tags = [];
  let lastDescriptionLine;
  let lastTag = null;

  source.forEach((info, idx) => {
    const {tokens} = info;
    const {
      delimiter,
      description,
      postDelimiter,
      start,
      tag,
      end,
      type: rawType
    } = tokens;

    if (tag || end) {
      if (lastDescriptionLine === undefined) {
        lastDescriptionLine = idx;
      }

      // Clean-up with last tag before end or new tag
      if (lastTag) {
        cleanUpLastTag(lastTag, mode);
      }

      // Stop the iteration when we reach the end
      // but only when there is no tag earlier in the line
diff --git a/a.js b/b.js
@@ -264,7 +272,7 @@ const commentParserToESTree = (jsdoc, mode) => {
A blob:550c97c40b777b98fb541a487fa9292656ba6074
 *
 * @param {external:CommentParserJsdoc} jsdoc
 * @param {external:JsdocTypePrattParserMode} mode
 * @returns {JsdocBlock}
 */
const commentParserToESTree = (jsdoc, mode) => {
  const {source} = jsdoc;

  const {tokens: {
    delimiter: delimiterRoot,
    lineEnd: lineEndRoot,
    postDelimiter: postDelimiterRoot,
    end: endRoot,
    description: descriptionRoot
  }} = source[0];

  const endLine = source.length - 1;
  const ast = {
    delimiter: delimiterRoot,
    description: descriptionRoot,

    descriptionLines: [],

    // `end` will be overwritten if there are other entries
    end: endRoot,
    endLine,
    postDelimiter: postDelimiterRoot,
    lineEnd: lineEndRoot,

    type: 'JsdocBlock'
  };

  const tags = [];
  let lastDescriptionLine;
  let lastTag = null;

  source.forEach((info, idx) => {
    const {tokens} = info;
    const {
      delimiter,
      description,
      postDelimiter,
      start,
      tag,
      end,
      type: rawType
    } = tokens;

    if (tag || end) {
      if (lastDescriptionLine === undefined) {
        lastDescriptionLine = idx;
      }

      // Clean-up with last tag before end or new tag
      if (lastTag) {
        cleanUpLastTag(lastTag, mode);
      }

      // Stop the iteration when we reach the end
      // but only when there is no tag earlier in the line
      // to still process
      if (end && !tag) {
        ast.end = end;

        return;
      }

      const {
        end: ed,
        delimiter: de,
        postDelimiter: pd,
        ...tkns
      } = tokens;

      if (!tokens.name) {
        let i = 0;
        while (source[idx + i]) {
          const {tokens: {
            name,
            postName
          }} = source[idx + i];
          if (name) {
            tkns.name = name;
            tkns.postName = postName;
            break;
          }
          i++;
        }
      }

      const tagObj = {
        ...tkns,
        postDelimiter: lastDescriptionLine ? pd : '',
        delimiter: lastDescriptionLine ? de : '',
        descriptionLines: [],
        rawType: '',
        type: 'JsdocTag',
        typeLines: []
      };
      tagObj.tag = tagObj.tag.replace(/^@/u, '');

      lastTag = tagObj;

      tags.push(tagObj);
    }

    if (rawType) {
      // Will strip rawType brackets after this tag
      lastTag.typeLines.push(
        lastTag.typeLines.length
          ? {
            delimiter,
            postDelimiter,
            rawType,
            start,
            type: 'JsdocTypeLine'
          }
          : {
            delimiter: '',
            postDelimiter: '',
            rawType,
            start: '',
            type: 'JsdocTypeLine'
          }
      );
      lastTag.rawType += lastTag.rawType ? '\n' + rawType : rawType;
    }

    if (description) {
      const holder = lastTag || ast;
      holder.descriptionLines.push(
        holder.descriptionLines.length
          ? {
            delimiter,
            description,
            postDelimiter,
            start,
            type: 'JsdocDescriptionLine'
          }
          : {
            delimiter: '',
            description,
            postDelimiter: '',
            start: '',
            type: 'JsdocDescriptionLine'
          }
      );
      holder.description += holder.description
        ? '\n' + description
        : description;
    }

    // Clean-up where last line itself has tag content
    if (end && tag) {
      ast.end = end;

      cleanUpLastTag(lastTag, mode);
    }
  });

  ast.lastDescriptionLine = lastDescriptionLine;
diff --git a/a.js b/b.js
@@ -233,7 +233,7 @@ const findJSDocComment = (astNode, sourceCode, settings) => {
A blob:7f10773a00731ac3c97b76b8e9b3c036b28b1cc7
 * @param {{maxLines: Integer, minLines: Integer}} settings
 * @returns {Token|null} The Block comment token containing the JSDoc comment
 *    for the given node or null if not found.
 * @private
 */
const findJSDocComment = (astNode, sourceCode, settings) => {
  const {minLines, maxLines} = settings;
  let currentNode = astNode;
  let tokenBefore = null;

  while (currentNode) {
    const decorator = getDecorator(currentNode);
    if (decorator) {
      currentNode = decorator;
    }
    tokenBefore = sourceCode.getTokenBefore(
      currentNode, {includeComments: true}
    );
    if (
      tokenBefore && tokenBefore.type === 'Punctuator' &&
      tokenBefore.value === '('
    ) {
      [tokenBefore] = sourceCode.getTokensBefore(currentNode, {
        count: 2,
        includeComments: true
      });
    }
    if (!tokenBefore || !isCommentToken(tokenBefore)) {
      return null;
    }
    if (tokenBefore.type === 'Line') {
      currentNode = tokenBefore;
      continue;
    }
    break;
  }

  if (
    tokenBefore.type === 'Block' &&
    tokenBefore.value.charAt(0) === '*' &&
    currentNode.loc.start.line - tokenBefore.loc.end.line >= minLines &&
    currentNode.loc.start.line - tokenBefore.loc.end.line <= maxLines
  ) {
    return tokenBefore;
diff --git a/a.js b/b.js
@@ -1,15 +1,9 @@
A blob:dd146b8835879c71c2986469bc6d693b390fb6f1
/* eslint-disable prefer-named-capture-group -- Temporary */
import {
  parse as commentParser,
  tokenizers,
  util
} from 'comment-parser';

const {
  seedBlock,
  seedTokens
} = util;

const {
  name: nameTokenizer,
  tag: tagTokenizer,
  type: typeTokenizer,
diff --git a/a.js b/b.js
@@ -94,7 +88,7 @@ tagTokenizer(),
A blob:dd146b8835879c71c2986469bc6d693b390fb6f1
  noNames = defaultNoNames
} = {}) => {
  // trim
  return [
    // Tag
    tagTokenizer(),

    // Type
    (spec) => {
      if (noTypes.includes(spec.tag)) {
        return spec;
      }

      return typeTokenizer()(spec);
    },

    // Name
    (spec) => {
      if (spec.tag === 'template') {
        // const preWS = spec.postTag;
        const remainder = spec.source[0].tokens.description;

        const pos = remainder.search(/(?<![\s,])\s/u);

        const name = pos === -1 ? remainder : remainder.slice(0, pos);
        const extra = remainder.slice(pos);
        let postName = '', description = '', lineEnd = '';
        if (pos > -1) {
          [, postName, description, lineEnd] = extra.match(/(\s*)([^\r]*)(\r)?/u);
        }

        spec.name = name;
        spec.optional = false;
        const {tokens} = spec.source[0];
        tokens.name = name;
        tokens.postName = postName;
        tokens.description = description;
        tokens.lineEnd = lineEnd || '';

        return spec;
      }

      if (noNames.includes(spec.tag) || hasSeeWithLink(spec)) {
        return spec;
      }

      return nameTokenizer()(spec);
    },

    // Description
    (spec) => {
      return descriptionTokenizer('preserve')(spec);
    }
  ];
};

/**
 *
 * @param {PlainObject} commentNode
 * @param {string} [indent=""] Whitespace
 * @returns {PlainObject}
 */
diff --git a/a.js b/b.js
@@ -104,23 +98,7 @@ const parseComment = (commentNode, indent = '') => {
A blob:dd146b8835879c71c2986469bc6d693b390fb6f1
 *
 * @param {PlainObject} commentNode
 * @param {string} [indent=""] Whitespace
 * @returns {PlainObject}
 */
const parseComment = (commentNode, indent = '') => {
  // Preserve JSDoc block start/end indentation.
  return commentParser(`/*${commentNode.value}*/`, {
    // @see https://github.com/yavorskiy/comment-parser/issues/21
    tokenizers: getTokenizers()
  })[0] || seedBlock({
    source: [
      {
        number: 0,
        tokens: seedTokens({
          delimiter: '/**'
        })
      },
      {
        number: 1,
        tokens: seedTokens({
          end: '*/',
          start: indent + ' '
        })
      }
    ]
  });
};

export {getTokenizers, parseComment};

diff --git a/a.js b/b.js
@@ -149,7 +149,7 @@
A blob:a42c00baa33d4c12084acae103fd92331919c5f4
                    break;
            }
            return spec;
        };
    }

    /**
     * Splits the `@prefix` from remaining `Spec.lines[].token.descrioption` into the `tag` token,
     * and populates `spec.tag`
     */
    function tagTokenizer() {
        return (spec) => {
diff --git a/a.js b/b.js
@@ -388,15 +388,12 @@
A blob:a42c00baa33d4c12084acae103fd92331919c5f4
    ], } = {}) {
        if (startLine < 0 || startLine % 1 > 0)
            throw new Error('Invalid startLine');
        const parseSource = getParser$2({ startLine, markers });
        const parseBlock = getParser$3({ fence });
        const parseSpec = getParser$1({ tokenizers });
        const joinDescription = getJoiner(spacing);
        const notEmpty = (line) => line.tokens.description.trim() != '';
        return function (source) {
            const blocks = [];
            for (const line of splitLines(source)) {
                const lines = parseSource(line);
                if (lines === null)
                    continue;
                if (lines.find(notEmpty) === undefined)
                    continue;
                const sections = parseBlock(lines);
                const specs = sections.slice(1).map(parseSpec);
                blocks.push({
                    description: joinDescription(sections[0], markers),
diff --git a/a.js b/b.js
@@ -19,15 +19,12 @@ tokenizeDescription(spacing),
A blob:01e17686692f47fd422c03425372d51b64a6cbc2
import tokenizeDescription, { getJoiner as getDescriptionJoiner, } from './tokenizers/description.js';
export default function getParser({ startLine = 0, fence = '```', spacing = 'compact', markers = Markers, tokenizers = [
    tokenizeTag(),
    tokenizeType(spacing),
    tokenizeName(),
    tokenizeDescription(spacing),
], } = {}) {
    if (startLine < 0 || startLine % 1 > 0)
        throw new Error('Invalid startLine');
    const parseSource = sourceParser({ startLine, markers });
    const parseBlock = blockParser({ fence });
    const parseSpec = specParser({ tokenizers });
    const joinDescription = getDescriptionJoiner(spacing);
    const notEmpty = (line) => line.tokens.description.trim() != '';
    return function (source) {
        const blocks = [];
        for (const line of splitLines(source)) {
            const lines = parseSource(line);
            if (lines === null)
                continue;
            if (lines.find(notEmpty) === undefined)
                continue;
            const sections = parseBlock(lines);
            const specs = sections.slice(1).map(parseSpec);
            blocks.push({
                description: joinDescription(sections[0], markers),
diff --git a/a.js b/b.js
@@ -1,5 +1,5 @@
A blob:4696b00dab08a0aee3f87addc8136e2a76338c35
/**
 * Splits the `@prefix` from remaining `Spec.lines[].token.descrioption` into the `tag` token,
 * and populates `spec.tag`
 */
export default function tagTokenizer() {
    return (spec) => {
diff --git a/a.js b/b.js
@@ -179,7 +179,7 @@ function setup(env) {
A blob:6d571d2844dd950db81c8e07cabbfc9048c59658
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
diff --git a/a.js b/b.js
@@ -1432,7 +1432,6 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"15.0.0-alpha.2",
		"15.0.0-nightly.20210706",
		"15.0.0-nightly.20210707",
		"15.0.0-nightly.20210708",
		"15.0.0-nightly.20210709",
		"15.0.0-nightly.20210712",
		"15.0.0-nightly.20210713",
		"15.0.0-nightly.20210714",
		"15.0.0-nightly.20210715",
		"15.0.0-nightly.20210716",
		"15.0.0-nightly.20210719",
		"15.0.0-nightly.20210720",
diff --git a/a.js b/b.js
@@ -1458,23 +1457,32 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
	],
	"93.0.4577.51": [
		"14.0.0-beta.24",
		"14.0.0-beta.25"
	],
	"92.0.4475.0": [
		"14.0.0-nightly.20210426",
		"14.0.0-nightly.20210427"
	],
	"92.0.4488.0": [
		"14.0.0-nightly.20210430",
		"14.0.0-nightly.20210503"
	],
	"92.0.4496.0": [
		"14.0.0-nightly.20210505"
	],
	"92.0.4498.0": [
		"14.0.0-nightly.20210506"
	],
	"92.0.4499.0": [
		"14.0.0-nightly.20210507",
		"14.0.0-nightly.20210510",
		"14.0.0-nightly.20210511",
		"14.0.0-nightly.20210512",
		"14.0.0-nightly.20210513"
	],
	"92.0.4505.0": [
		"14.0.0-nightly.20210514",
diff --git a/a.js b/b.js
@@ -1500,7 +1508,8 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"14.2.0",
		"14.2.1",
		"14.2.2",
		"14.2.3",
		"14.2.4",
		"14.2.5",
		"14.2.6",
		"14.2.7"
	],
	"94.0.4584.0": [
		"15.0.0-alpha.3",
		"15.0.0-alpha.4",
diff --git a/a.js b/b.js
@@ -1560,7 +1569,6 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
	],
	"93.0.4550.0": [
		"15.0.0-nightly.20210623",
		"15.0.0-nightly.20210624"
	],
	"93.0.4552.0": [
		"15.0.0-nightly.20210625",
		"15.0.0-nightly.20210628",
		"15.0.0-nightly.20210629"
	],
	"93.0.4558.0": [
		"15.0.0-nightly.20210630",
diff --git a/a.js b/b.js
@@ -1590,7 +1598,8 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"15.3.2",
		"15.3.3",
		"15.3.4",
		"15.3.5",
		"15.3.6",
		"15.3.7",
		"15.4.0",
		"15.4.1"
	],
	"95.0.4629.0": [
		"16.0.0-alpha.1",
		"16.0.0-alpha.2",
diff --git a/a.js b/b.js
@@ -1612,18 +1621,12 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"16.0.0-nightly.20210909",
		"16.0.0-nightly.20210910",
		"16.0.0-nightly.20210913",
		"16.0.0-nightly.20210914",
		"16.0.0-nightly.20210915",
		"16.0.0-nightly.20210916",
		"16.0.0-nightly.20210917",
		"16.0.0-nightly.20210920",
		"16.0.0-nightly.20210921",
		"16.0.0-nightly.20210922",
		"17.0.0-nightly.20210923",
		"17.0.0-nightly.20210924",
		"17.0.0-nightly.20210927",
		"17.0.0-nightly.20210928",
		"17.0.0-nightly.20210929",
		"17.0.0-nightly.20210930",
		"17.0.0-nightly.20211001",
		"17.0.0-nightly.20211004",
		"17.0.0-nightly.20211005"
	],
	"96.0.4647.0": [
		"16.0.0-alpha.8",
		"16.0.0-alpha.9",
diff --git a/a.js b/b.js
@@ -1660,7 +1663,6 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"16.0.0-beta.8",
		"16.0.0-beta.9"
	],
	"95.0.4612.5": [
		"16.0.0-nightly.20210824",
		"16.0.0-nightly.20210825",
		"16.0.0-nightly.20210826",
		"16.0.0-nightly.20210827",
		"16.0.0-nightly.20210830",
		"16.0.0-nightly.20210831",
		"16.0.0-nightly.20210901"
	],
diff --git a/a.js b/b.js
@@ -1683,7 +1685,8 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"16.0.6",
		"16.0.7",
		"16.0.8"
	],
	"96.0.4664.174": [
		"16.0.9",
		"16.0.10",
		"16.1.0"
	],
	"96.0.4664.4": [
		"17.0.0-alpha.1",
		"17.0.0-alpha.2",
diff --git a/a.js b/b.js
@@ -1773,7 +1776,8 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"17.0.1"
	],
	"98.0.4758.102": [
		"17.1.0"
	],
	"98.0.4758.109": [
		"17.1.1",
		"17.1.2"
	],
	"99.0.4767.0": [
		"18.0.0-alpha.1",
		"18.0.0-alpha.2",
diff --git a/a.js b/b.js
@@ -1805,9 +1809,25 @@
A blob:bfefaebe3dbe5c32291c67d463d330824aca3ae0
		"19.0.0-nightly.20220207",
		"19.0.0-nightly.20220208",
		"19.0.0-nightly.20220209"
	],
	"100.0.4894.0": [
		"18.0.0-beta.1",
		"18.0.0-beta.2",
		"19.0.0-nightly.20220308",
		"19.0.0-nightly.20220309",
		"19.0.0-nightly.20220310",
		"19.0.0-nightly.20220311"
	]
};
diff --git a/a.js b/b.js
@@ -1054,6 +1054,7 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"14.2.1": "93.0.4577.82",
	"14.2.2": "93.0.4577.82",
	"14.2.3": "93.0.4577.82",
	"14.2.4": "93.0.4577.82",
	"14.2.5": "93.0.4577.82",
	"14.2.6": "93.0.4577.82",
	"14.2.7": "93.0.4577.82",
	"15.0.0-alpha.1": "93.0.4566.0",
	"15.0.0-alpha.2": "93.0.4566.0",
	"15.0.0-alpha.3": "94.0.4584.0",
	"15.0.0-alpha.4": "94.0.4584.0",
diff --git a/a.js b/b.js
@@ -1092,7 +1093,6 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"15.0.0-nightly.20210617": "93.0.4539.0",
	"15.0.0-nightly.20210618": "93.0.4539.0",
	"15.0.0-nightly.20210621": "93.0.4539.0",
	"15.0.0-nightly.20210622": "93.0.4539.0",
	"15.0.0-nightly.20210623": "93.0.4550.0",
	"15.0.0-nightly.20210624": "93.0.4550.0",
	"15.0.0-nightly.20210625": "93.0.4552.0",
	"15.0.0-nightly.20210628": "93.0.4552.0",
	"15.0.0-nightly.20210629": "93.0.4552.0",
	"15.0.0-nightly.20210630": "93.0.4558.0",
	"15.0.0-nightly.20210701": "93.0.4558.0",
	"15.0.0-nightly.20210702": "93.0.4558.0",
diff --git a/a.js b/b.js
@@ -1104,7 +1104,6 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"15.0.0-nightly.20210705": "93.0.4558.0",
	"15.0.0-nightly.20210706": "93.0.4566.0",
	"15.0.0-nightly.20210707": "93.0.4566.0",
	"15.0.0-nightly.20210708": "93.0.4566.0",
	"15.0.0-nightly.20210709": "93.0.4566.0",
	"15.0.0-nightly.20210712": "93.0.4566.0",
	"15.0.0-nightly.20210713": "93.0.4566.0",
	"15.0.0-nightly.20210714": "93.0.4566.0",
	"15.0.0-nightly.20210715": "93.0.4566.0",
	"15.0.0-nightly.20210716": "93.0.4566.0",
	"15.0.0-nightly.20210719": "93.0.4566.0",
	"15.0.0-nightly.20210720": "93.0.4566.0",
diff --git a/a.js b/b.js
@@ -1125,6 +1124,7 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"15.3.3": "94.0.4606.81",
	"15.3.4": "94.0.4606.81",
	"15.3.5": "94.0.4606.81",
	"15.3.6": "94.0.4606.81",
	"15.3.7": "94.0.4606.81",
	"15.4.0": "94.0.4606.81",
	"15.4.1": "94.0.4606.81",
	"16.0.0-alpha.1": "95.0.4629.0",
	"16.0.0-alpha.2": "95.0.4629.0",
	"16.0.0-alpha.3": "95.0.4629.0",
	"16.0.0-alpha.4": "95.0.4629.0",
diff --git a/a.js b/b.js
@@ -1169,7 +1169,6 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"16.0.0-nightly.20210818": "94.0.4590.2",
	"16.0.0-nightly.20210819": "94.0.4590.2",
	"16.0.0-nightly.20210820": "94.0.4590.2",
	"16.0.0-nightly.20210823": "94.0.4590.2",
	"16.0.0-nightly.20210824": "95.0.4612.5",
	"16.0.0-nightly.20210825": "95.0.4612.5",
	"16.0.0-nightly.20210826": "95.0.4612.5",
	"16.0.0-nightly.20210827": "95.0.4612.5",
	"16.0.0-nightly.20210830": "95.0.4612.5",
	"16.0.0-nightly.20210831": "95.0.4612.5",
	"16.0.0-nightly.20210901": "95.0.4612.5",
	"16.0.0-nightly.20210902": "95.0.4629.0",
diff --git a/a.js b/b.js
@@ -1185,7 +1184,6 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"16.0.0-nightly.20210909": "95.0.4629.0",
	"16.0.0-nightly.20210910": "95.0.4629.0",
	"16.0.0-nightly.20210913": "95.0.4629.0",
	"16.0.0-nightly.20210914": "95.0.4629.0",
	"16.0.0-nightly.20210915": "95.0.4629.0",
	"16.0.0-nightly.20210916": "95.0.4629.0",
	"16.0.0-nightly.20210917": "95.0.4629.0",
	"16.0.0-nightly.20210920": "95.0.4629.0",
	"16.0.0-nightly.20210921": "95.0.4629.0",
	"16.0.0-nightly.20210922": "95.0.4629.0",
	"16.0.0": "96.0.4664.45",
	"16.0.1": "96.0.4664.45",
diff --git a/a.js b/b.js
@@ -1200,6 +1198,7 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"16.0.5": "96.0.4664.55",
	"16.0.6": "96.0.4664.110",
	"16.0.7": "96.0.4664.110",
	"16.0.8": "96.0.4664.110",
	"16.0.9": "96.0.4664.174",
	"16.0.10": "96.0.4664.174",
	"16.1.0": "96.0.4664.174",
	"17.0.0-alpha.1": "96.0.4664.4",
	"17.0.0-alpha.2": "96.0.4664.4",
	"17.0.0-alpha.3": "96.0.4664.4",
	"17.0.0-alpha.4": "98.0.4706.0",
diff --git a/a.js b/b.js
@@ -1219,11 +1218,6 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"17.0.0-beta.7": "98.0.4758.11",
	"17.0.0-beta.8": "98.0.4758.11",
	"17.0.0-beta.9": "98.0.4758.11",
	"17.0.0-nightly.20210923": "95.0.4629.0",
	"17.0.0-nightly.20210924": "95.0.4629.0",
	"17.0.0-nightly.20210927": "95.0.4629.0",
	"17.0.0-nightly.20210928": "95.0.4629.0",
	"17.0.0-nightly.20210929": "95.0.4629.0",
	"17.0.0-nightly.20210930": "95.0.4629.0",
	"17.0.0-nightly.20211001": "95.0.4629.0",
	"17.0.0-nightly.20211004": "95.0.4629.0",
	"17.0.0-nightly.20211005": "95.0.4629.0",
	"17.0.0-nightly.20211006": "96.0.4647.0",
	"17.0.0-nightly.20211007": "96.0.4647.0",
	"17.0.0-nightly.20211008": "96.0.4647.0",
	"17.0.0-nightly.20211011": "96.0.4647.0",
diff --git a/a.js b/b.js
@@ -1260,6 +1254,7 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"17.0.0-nightly.20211116": "96.0.4664.4",
	"17.0.0-nightly.20211117": "96.0.4664.4",
	"17.0.0": "98.0.4758.74",
	"17.0.1": "98.0.4758.82",
	"17.1.0": "98.0.4758.102",
	"17.1.1": "98.0.4758.109",
	"17.1.2": "98.0.4758.109",
	"18.0.0-alpha.1": "99.0.4767.0",
	"18.0.0-alpha.2": "99.0.4767.0",
	"18.0.0-alpha.3": "99.0.4767.0",
	"18.0.0-alpha.4": "99.0.4767.0",
diff --git a/a.js b/b.js
@@ -1267,6 +1262,10 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"18.0.0-alpha.1": "99.0.4767.0",
	"18.0.0-alpha.2": "99.0.4767.0",
	"18.0.0-alpha.3": "99.0.4767.0",
	"18.0.0-alpha.4": "99.0.4767.0",
	"18.0.0-alpha.5": "99.0.4767.0",
	"18.0.0-beta.1": "100.0.4894.0",
	"18.0.0-beta.2": "100.0.4894.0",
	"18.0.0-nightly.20211118": "96.0.4664.4",
	"18.0.0-nightly.20211119": "96.0.4664.4",
	"18.0.0-nightly.20211122": "96.0.4664.4",
	"18.0.0-nightly.20211123": "96.0.4664.4",
diff --git a/a.js b/b.js
@@ -1325,5 +1324,15 @@
A blob:5369e370f0afd6c0fdd1d5966c94e9bf2b399cd1
	"19.0.0-nightly.20220204": "99.0.4767.0",
	"19.0.0-nightly.20220207": "99.0.4767.0",
	"19.0.0-nightly.20220208": "99.0.4767.0",
	"19.0.0-nightly.20220209": "99.0.4767.0",
	"19.0.0-nightly.20220308": "100.0.4894.0",
	"19.0.0-nightly.20220309": "100.0.4894.0",
	"19.0.0-nightly.20220310": "100.0.4894.0",
	"19.0.0-nightly.20220311": "100.0.4894.0"
};
diff --git a/a.js b/b.js
@@ -84,5 +84,6 @@
A blob:3e0ce3f54375987032e53233a4d9474671501746
	"15.2": "94",
	"15.3": "94",
	"15.4": "94",
	"16.0": "96",
	"16.1": "96",
	"17.0": "98",
	"17.1": "98",
	"18.0": "100"
};
diff --git a/a.js b/b.js
@@ -490,7 +490,7 @@ const getExportAncestor = function (nde) {
A blob:510d20dda97d67c16d24a3c534d5af31172ee900
};

const exportTypes = new Set(['ExportNamedDeclaration', 'ExportDefaultDeclaration']);
const ignorableNestedTypes = new Set(['FunctionDeclaration', 'ArrowFunctionExpression', 'FunctionExpression']);

const getExportAncestor = function (nde) {
  let node = nde;
  let idx = 0;
  const ignorableIfDeep = ignorableNestedTypes.has(nde === null || nde === void 0 ? void 0 : nde.type);

  while (node) {
    // Ignore functions nested more deeply than say `export default function () {}`
    if (idx >= 2 && ignorableIfDeep) {
      break;
    }

    if (exportTypes.has(node.type)) {
      return node;
    }

    node = node.parent;
    idx++;
  }

  return false;
};

const canBeExportedByAncestorType = new Set(['TSPropertySignature', 'TSMethodSignature', 'ClassProperty', 'PropertyDefinition', 'Method']);
const canExportChildrenType = new Set(['TSInterfaceBody', 'TSInterfaceDeclaration', 'ClassDeclaration', 'ClassBody', 'ClassDefinition', 'ClassExpression', 'Program']);

const isExportByAncestor = function (nde) {
  if (!canBeExportedByAncestorType.has(nde.type)) {
    return false;
diff --git a/a.js b/b.js
@@ -20,7 +20,6 @@ get: function () {
A blob:f480e32f9a44cdaec7912f60d63861163d7e8043
});
exports.default = iterateJsdoc;
exports.getSettings = void 0;
Object.defineProperty(exports, "parseComment", {
  enumerable: true,
  get: function () {
    return _jsdoccomment.parseComment;
  }
});

var _jsdoccomment = require("@es-joy/jsdoccomment");

var _commentParser = require("comment-parser");

var _jsdocUtils = _interopRequireDefault(require("./jsdocUtils"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable jsdoc/valid-types */
const {
  rewireSpecs,
  seedTokens
} = _commentParser.util;
diff --git a/a.js b/b.js
@@ -256,7 +255,13 @@ report(msg, handler ? fixer => {
A blob:f480e32f9a44cdaec7912f60d63861163d7e8043
  utils.stringify = (tagBlock, specRewire) => {
    return (0, _commentParser.stringify)(specRewire ? rewireSpecs(tagBlock) : tagBlock);
  };

  utils.reportJSDoc = (msg, tag, handler, specRewire, data) => {
    report(msg, handler ? fixer => {
      handler();
      const replacement = utils.stringify(jsdoc, specRewire);
      return fixer.replaceText(jsdocNode, replacement);
    } : null, tag, data);
  };

  utils.getRegexFromString = (str, requiredFlags) => {
    return _jsdocUtils.default.getRegexFromString(str, requiredFlags);
  };

  utils.getTagDescription = tg => {
    const descriptions = [];
    tg.source.some(({
      tokens: {
        end,
        lineEnd,
        postDelimiter,
        tag,
        postTag,
        name,
        type,
        description
      }
    }) => {
      const desc = (tag && postTag || !tag && !name && !type && postDelimiter || '' // Remove space
      ).slice(1) + (description || '') + (lineEnd || '');

      if (end) {
        if (desc) {
          descriptions.push(desc);
        }

        return true;
      }

      descriptions.push(desc);
      return false;
    });
    return descriptions.join('\n');
  };

  utils.getDescription = () => {
    const descriptions = [];
    let lastDescriptionLine = 0;
    jsdoc.source.some(({
      tokens: {
        description,
        tag,
        end
      }
    }, idx) => {
      if (idx && (tag || end)) {
        lastDescriptionLine = idx - 1;
        return true;
      }

      if (idx || description) {
        descriptions.push(description || (descriptions.length ? '' : '\n'));
      }

      return false;
    });
    return {
      description: descriptions.join('\n'),
      lastDescriptionLine
    };
  };

  utils.changeTag = (tag, ...tokens) => {
    for (const [idx, src] of tag.source.entries()) {
      src.tokens = { ...src.tokens,
        ...tokens[idx]
      };
    }
  };

  utils.setTag = (tag, tokens) => {
    tag.source = [{
      // Or tag.source[0].number?
      number: tag.line,
      tokens: seedTokens({
        delimiter: '*',
        postDelimiter: ' ',
        start: indent + ' ',
        tag: '@' + tag.tag,
        ...tokens
      })
    }];
  };

  utils.removeTag = idx => {
    return utils.removeTagItem(idx);
  };

  utils.removeTagItem = (tagIndex, tagSourceOffset = 0) => {
    const {
      source: tagSource
    } = jsdoc.tags[tagIndex];
    let lastIndex;
    const firstNumber = jsdoc.source[0].number;
    tagSource.some(({
      number
    }, tagIdx) => {
      const sourceIndex = jsdoc.source.findIndex(({
        number: srcNumber,
        tokens: {
          end
        }
      }) => {
        return number === srcNumber && !end;
      }); // istanbul ignore else

      if (sourceIndex > -1) {
        let spliceCount = 1;
        tagSource.slice(tagIdx + 1).some(({
          tokens: {
            tag,
            end
          }
        }) => {
          if (!tag && !end) {
            spliceCount++;
            return false;
          }

          return true;
        });
        jsdoc.source.splice(sourceIndex + tagSourceOffset, spliceCount - tagSourceOffset);
        tagSource.splice(tagIdx + tagSourceOffset, spliceCount - tagSourceOffset);
        lastIndex = sourceIndex;
        return true;
      } // istanbul ignore next


      return false;
    });

    for (const [idx, src] of jsdoc.source.slice(lastIndex).entries()) {
      src.number = firstNumber + lastIndex + idx;
    } // Todo: Once rewiring of tags may be fixed in comment-parser to reflect missing tags,
    //         this step should be added here (so that, e.g., if accessing `jsdoc.tags`,
    //         such as to add a new tag, the correct information will be available)

  };

  utils.addTag = (targetTagName, number = (() => {
    var _jsdoc$tags$source$0$, _jsdoc$tags, _jsdoc$tags$source$;

    return (_jsdoc$tags$source$0$ = (_jsdoc$tags = jsdoc.tags[jsdoc.tags.length - 1]) === null || _jsdoc$tags === void 0 ? void 0 : (_jsdoc$tags$source$ = _jsdoc$tags.source[0]) === null || _jsdoc$tags$source$ === void 0 ? void 0 : _jsdoc$tags$source$.number) !== null && _jsdoc$tags$source$0$ !== void 0 ? _jsdoc$tags$source$0$ : 0;
  })() + 1, tokens = {}) => {
    jsdoc.source.splice(number, 0, {
      number,
      source: '',
diff --git a/a.js b/b.js
@@ -857,7 +862,7 @@ const getIndentAndJSDoc = function (lines, jsdocNode) {
A blob:f480e32f9a44cdaec7912f60d63861163d7e8043
    state,
    utils
  });
};

const getIndentAndJSDoc = function (lines, jsdocNode) {
  const sourceLine = lines[jsdocNode.loc.start.line - 1];
  const indnt = sourceLine.charAt(0).repeat(jsdocNode.loc.start.column);
  const jsdc = (0, _jsdoccomment.parseComment)(jsdocNode, indnt);
  return [indnt, jsdc];
};
/**
 * Create an eslint rule that iterates over all JSDocs, regardless of whether
 * they are attached to a function-like node.
 *
 * @param {JsdocVisitor} iterator
 * @param {{meta: any}} ruleConfig
 * @param contexts
 * @param {boolean} additiveContexts
 */


const iterateAllJsdocs = (iterator, ruleConfig, contexts, additiveContexts) => {
  const trackedJsdocs = [];
  let handler;
  let settings;

  const callIterator = (context, node, jsdocNodes, state, lastCall) => {
diff --git a/a.js b/b.js
@@ -949,7 +954,7 @@ create(context) {
A blob:f480e32f9a44cdaec7912f60d63861163d7e8043
      });
    }
  };

  return {
    create(context) {
      const sourceCode = context.getSourceCode();
      settings = getSettings(context);

      if (!settings) {
        return {};
      }

      if (contexts) {
        handler = (0, _jsdoccomment.commentHandler)(settings);
      }

      const state = {};
      return {
        '*:not(Program)'(node) {
          const reducedNode = (0, _jsdoccomment.getReducedASTNode)(node, sourceCode);

          if (node !== reducedNode) {
            return;
          }

          const commentNode = (0, _jsdoccomment.getJSDocComment)(sourceCode, node, settings);

          if (trackedJsdocs.includes(commentNode)) {
            return;
          }

          if (!commentNode) {
diff --git a/a.js b/b.js
@@ -964,14 +969,14 @@ create(context) {
A blob:f480e32f9a44cdaec7912f60d63861163d7e8043
      });
    }
  };

  return {
    create(context) {
      const sourceCode = context.getSourceCode();
      settings = getSettings(context);

      if (!settings) {
        return {};
      }

      if (contexts) {
        handler = (0, _jsdoccomment.commentHandler)(settings);
      }

      const state = {};
      return {
        '*:not(Program)'(node) {
          const reducedNode = (0, _jsdoccomment.getReducedASTNode)(node, sourceCode);

          if (node !== reducedNode) {
            return;
          }

          const commentNode = (0, _jsdoccomment.getJSDocComment)(sourceCode, node, settings);

          if (trackedJsdocs.includes(commentNode)) {
            return;
          }

          if (!commentNode) {
            if (ruleConfig.nonComment) {
              ruleConfig.nonComment({
                node,
                state
              });
            }

            return;
          }

          trackedJsdocs.push(commentNode);
          callIterator(context, node, [commentNode], state);
        },

        'Program:exit'() {
          const allComments = sourceCode.getAllComments();
          const untrackedJSdoc = allComments.filter(node => {
            return !trackedJsdocs.includes(node);
          });
          callIterator(context, null, untrackedJSdoc, state, true);
        }

diff --git a/a.js b/b.js
@@ -12,8 +12,20 @@
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef
var _jsdoccomment = require("@es-joy/jsdoccomment");

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
diff --git a/a.js b/b.js
@@ -35,7 +47,7 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
diff --git a/a.js b/b.js
@@ -48,7 +60,7 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
diff --git a/a.js b/b.js
@@ -73,11 +85,21 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  settings,
  context
}) => {
  const jsdocTagsWithPossibleType = utils.filterTags(tag => {
    return utils.tagMightHaveTypePosition(tag.tag);
  });
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;
  const {
    noDefaults,
    unifyParentAndChildTypeChecks,
    exemptTagContexts = []
  } = context.options[0] || {};

  const getPreferredTypeInfo = (_type, nodeName, parentNode, property) => {
    let hasMatchingPreferredType;
    let isGenericMatch;
    let typeName = nodeName;

    if (Object.keys(preferredTypes).length) {
      const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';

diff --git a/a.js b/b.js
@@ -91,7 +113,7 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  settings,
  context
}) => {
  const jsdocTagsWithPossibleType = utils.filterTags(tag => {
    return utils.tagMightHaveTypePosition(tag.tag);
  });
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;
  const {
    noDefaults,
    unifyParentAndChildTypeChecks,
    exemptTagContexts = []
  } = context.options[0] || {};

  const getPreferredTypeInfo = (_type, nodeName, parentNode, property) => {
    let hasMatchingPreferredType;
    let isGenericMatch;
    let typeName = nodeName;

    if (Object.keys(preferredTypes).length) {
      const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';

      if (unifyParentAndChildTypeChecks || isNameOfGeneric) {
        var _parentNode$meta, _parentNode$meta2;

        const brackets = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta = parentNode.meta) === null || _parentNode$meta === void 0 ? void 0 : _parentNode$meta.brackets;
        const dot = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta2 = parentNode.meta) === null || _parentNode$meta2 === void 0 ? void 0 : _parentNode$meta2.dot;

        if (brackets === 'angle') {
          const checkPostFixes = dot ? ['.', '.<>'] : ['<>'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName + checkPostFix]) !== undefined) {
              typeName += checkPostFix;
              return true;
            }

diff --git a/a.js b/b.js
@@ -113,7 +135,7 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  settings,
  context
}) => {
  const jsdocTagsWithPossibleType = utils.filterTags(tag => {
    return utils.tagMightHaveTypePosition(tag.tag);
  });
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;
  const {
    noDefaults,
    unifyParentAndChildTypeChecks,
    exemptTagContexts = []
  } = context.options[0] || {};

  const getPreferredTypeInfo = (_type, nodeName, parentNode, property) => {
    let hasMatchingPreferredType;
    let isGenericMatch;
    let typeName = nodeName;

    if (Object.keys(preferredTypes).length) {
      const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';

      if (unifyParentAndChildTypeChecks || isNameOfGeneric) {
        var _parentNode$meta, _parentNode$meta2;

        const brackets = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta = parentNode.meta) === null || _parentNode$meta === void 0 ? void 0 : _parentNode$meta.brackets;
        const dot = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta2 = parentNode.meta) === null || _parentNode$meta2 === void 0 ? void 0 : _parentNode$meta2.dot;

        if (brackets === 'angle') {
          const checkPostFixes = dot ? ['.', '.<>'] : ['<>'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName + checkPostFix]) !== undefined) {
              typeName += checkPostFix;
              return true;
            }

            return false;
          });
        }

        if (!isGenericMatch && property) {
          const checkPostFixes = dot ? ['.', '.<>'] : [brackets === 'angle' ? '<>' : '[]'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[checkPostFix]) !== undefined) {
              typeName = checkPostFix;
              return true;
            }

            return false;
          });
        }
      }

      const directNameMatch = (preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName]) !== undefined && !Object.values(preferredTypes).includes(nodeName);
      const unifiedSyntaxParentMatch = property && directNameMatch && unifyParentAndChildTypeChecks;
      isGenericMatch = isGenericMatch || unifiedSyntaxParentMatch;
      hasMatchingPreferredType = isGenericMatch || directNameMatch && !property;
    }
diff --git a/a.js b/b.js
@@ -121,6 +143,95 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  settings,
  context
}) => {
  const jsdocTagsWithPossibleType = utils.filterTags(tag => {
    return utils.tagMightHaveTypePosition(tag.tag);
  });
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;
  const {
    noDefaults,
    unifyParentAndChildTypeChecks,
    exemptTagContexts = []
  } = context.options[0] || {};

  const getPreferredTypeInfo = (_type, nodeName, parentNode, property) => {
    let hasMatchingPreferredType;
    let isGenericMatch;
    let typeName = nodeName;

    if (Object.keys(preferredTypes).length) {
      const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';

      if (unifyParentAndChildTypeChecks || isNameOfGeneric) {
        var _parentNode$meta, _parentNode$meta2;

        const brackets = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta = parentNode.meta) === null || _parentNode$meta === void 0 ? void 0 : _parentNode$meta.brackets;
        const dot = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta2 = parentNode.meta) === null || _parentNode$meta2 === void 0 ? void 0 : _parentNode$meta2.dot;

        if (brackets === 'angle') {
          const checkPostFixes = dot ? ['.', '.<>'] : ['<>'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName + checkPostFix]) !== undefined) {
              typeName += checkPostFix;
              return true;
            }

            return false;
          });
        }

        if (!isGenericMatch && property) {
          const checkPostFixes = dot ? ['.', '.<>'] : [brackets === 'angle' ? '<>' : '[]'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[checkPostFix]) !== undefined) {
              typeName = checkPostFix;
              return true;
            }

            return false;
          });
        }
      }

      const directNameMatch = (preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName]) !== undefined && !Object.values(preferredTypes).includes(nodeName);
      const unifiedSyntaxParentMatch = property && directNameMatch && unifyParentAndChildTypeChecks;
      isGenericMatch = isGenericMatch || unifiedSyntaxParentMatch;
      hasMatchingPreferredType = isGenericMatch || directNameMatch && !property;
    }

    return [hasMatchingPreferredType, typeName, isGenericMatch];
  };

  for (const jsdocTag of jsdocTagsWithPossibleType) {
    const invalidTypes = [];
    let typeAst;
diff --git a/a.js b/b.js
@@ -132,8 +243,7 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  settings,
  context
}) => {
  const jsdocTagsWithPossibleType = utils.filterTags(tag => {
    return utils.tagMightHaveTypePosition(tag.tag);
  });
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;
  const {
    noDefaults,
    unifyParentAndChildTypeChecks,
    exemptTagContexts = []
  } = context.options[0] || {};

  const getPreferredTypeInfo = (_type, nodeName, parentNode, property) => {
    let hasMatchingPreferredType;
    let isGenericMatch;
    let typeName = nodeName;

    if (Object.keys(preferredTypes).length) {
      const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';

      if (unifyParentAndChildTypeChecks || isNameOfGeneric) {
        var _parentNode$meta, _parentNode$meta2;

        const brackets = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta = parentNode.meta) === null || _parentNode$meta === void 0 ? void 0 : _parentNode$meta.brackets;
        const dot = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta2 = parentNode.meta) === null || _parentNode$meta2 === void 0 ? void 0 : _parentNode$meta2.dot;

        if (brackets === 'angle') {
          const checkPostFixes = dot ? ['.', '.<>'] : ['<>'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName + checkPostFix]) !== undefined) {
              typeName += checkPostFix;
              return true;
            }

            return false;
          });
        }

        if (!isGenericMatch && property) {
          const checkPostFixes = dot ? ['.', '.<>'] : [brackets === 'angle' ? '<>' : '[]'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[checkPostFix]) !== undefined) {
              typeName = checkPostFix;
              return true;
            }

            return false;
          });
        }
      }

      const directNameMatch = (preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName]) !== undefined && !Object.values(preferredTypes).includes(nodeName);
      const unifiedSyntaxParentMatch = property && directNameMatch && unifyParentAndChildTypeChecks;
      isGenericMatch = isGenericMatch || unifiedSyntaxParentMatch;
      hasMatchingPreferredType = isGenericMatch || directNameMatch && !property;
    }

    return [hasMatchingPreferredType, typeName, isGenericMatch];
  };

  for (const jsdocTag of jsdocTagsWithPossibleType) {
    const invalidTypes = [];
    let typeAst;

    try {
      typeAst = mode === 'permissive' ? (0, _jsdoccomment.tryParse)(jsdocTag.type) : (0, _jsdoccomment.parse)(jsdocTag.type, mode);
    } catch {
      continue;
    }

    const tagName = jsdocTag.tag; // eslint-disable-next-line complexity -- To refactor

    (0, _jsdoccomment.traverse)(typeAst, (node, parentNode, property) => {
      const {
        type,
        value
diff --git a/a.js b/b.js
@@ -144,64 +254,15 @@ const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode
A blob:8e6995f77a3b24b55139bfb125710de4bd4183ef

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'bigint', 'string', 'symbol', 'object', 'Array', 'Function', 'Date', 'RegExp'];

const adjustNames = (type, preferred, isGenericMatch, nodeName, node, parentNode) => {
  let ret = preferred;

  if (isGenericMatch) {
    if (preferred === '[]') {
      parentNode.meta.brackets = 'square';
      parentNode.meta.dot = false;
      ret = 'Array';
    } else {
      const dotBracketEnd = preferred.match(/\.(?:<>)?$/u);

      if (dotBracketEnd) {
        parentNode.meta.brackets = 'angle';
        parentNode.meta.dot = true;
        ret = preferred.slice(0, -dotBracketEnd[0].length);
      } else {
        const bracketEnd = preferred.endsWith('<>');

        if (bracketEnd) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
          ret = preferred.slice(0, -2);
        } else if (parentNode.meta.brackets === 'square' && (nodeName === '[]' || nodeName === 'Array')) {
          parentNode.meta.brackets = 'angle';
          parentNode.meta.dot = false;
        }
      }
    }
  } else if (type === 'JsdocTypeAny') {
    node.type = 'JsdocTypeName';
  }

  node.value = ret.replace(/(?:\.|<>|\.<>|\[\])$/u, ''); // For bare pseudo-types like `<>`

  if (!ret) {
    node.value = nodeName;
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  settings,
  context
}) => {
  const jsdocTagsWithPossibleType = utils.filterTags(tag => {
    return utils.tagMightHaveTypePosition(tag.tag);
  });
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;
  const {
    noDefaults,
    unifyParentAndChildTypeChecks,
    exemptTagContexts = []
  } = context.options[0] || {};

  const getPreferredTypeInfo = (_type, nodeName, parentNode, property) => {
    let hasMatchingPreferredType;
    let isGenericMatch;
    let typeName = nodeName;

    if (Object.keys(preferredTypes).length) {
      const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';

      if (unifyParentAndChildTypeChecks || isNameOfGeneric) {
        var _parentNode$meta, _parentNode$meta2;

        const brackets = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta = parentNode.meta) === null || _parentNode$meta === void 0 ? void 0 : _parentNode$meta.brackets;
        const dot = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$meta2 = parentNode.meta) === null || _parentNode$meta2 === void 0 ? void 0 : _parentNode$meta2.dot;

        if (brackets === 'angle') {
          const checkPostFixes = dot ? ['.', '.<>'] : ['<>'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName + checkPostFix]) !== undefined) {
              typeName += checkPostFix;
              return true;
            }

            return false;
          });
        }

        if (!isGenericMatch && property) {
          const checkPostFixes = dot ? ['.', '.<>'] : [brackets === 'angle' ? '<>' : '[]'];
          isGenericMatch = checkPostFixes.some(checkPostFix => {
            if ((preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[checkPostFix]) !== undefined) {
              typeName = checkPostFix;
              return true;
            }

            return false;
          });
        }
      }

      const directNameMatch = (preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[nodeName]) !== undefined && !Object.values(preferredTypes).includes(nodeName);
      const unifiedSyntaxParentMatch = property && directNameMatch && unifyParentAndChildTypeChecks;
      isGenericMatch = isGenericMatch || unifiedSyntaxParentMatch;
      hasMatchingPreferredType = isGenericMatch || directNameMatch && !property;
    }

    return [hasMatchingPreferredType, typeName, isGenericMatch];
  };

  for (const jsdocTag of jsdocTagsWithPossibleType) {
    const invalidTypes = [];
    let typeAst;

    try {
      typeAst = mode === 'permissive' ? (0, _jsdoccomment.tryParse)(jsdocTag.type) : (0, _jsdoccomment.parse)(jsdocTag.type, mode);
    } catch {
      continue;
    }

    const tagName = jsdocTag.tag; // eslint-disable-next-line complexity -- To refactor

    (0, _jsdoccomment.traverse)(typeAst, (node, parentNode, property) => {
      const {
        type,
        value
      } = node;

      if (!['JsdocTypeName', 'JsdocTypeAny'].includes(type)) {
        return;
      }

      let nodeName = type === 'JsdocTypeAny' ? '*' : value;
      const [hasMatchingPreferredType, typeName, isGenericMatch] = getPreferredTypeInfo(type, nodeName, parentNode, property);
      let preferred;
      let types;

      if (hasMatchingPreferredType) {
        const preferredSetting = preferredTypes[typeName];
        nodeName = typeName === '[]' ? typeName : nodeName;

        if (!preferredSetting) {
          invalidTypes.push([nodeName]);
        } else if (typeof preferredSetting === 'string') {
          preferred = preferredSetting;
          invalidTypes.push([nodeName, preferred]);
        } else if (typeof preferredSetting === 'object') {
          preferred = preferredSetting === null || preferredSetting === void 0 ? void 0 : preferredSetting.replacement;
          invalidTypes.push([nodeName, preferred, preferredSetting === null || preferredSetting === void 0 ? void 0 : preferredSetting.message]);
        } else {
          utils.reportSettings('Invalid `settings.jsdoc.preferredTypes`. Values must be falsy, a string, or an object.');
          return;
        }
      } else if (Object.entries(structuredTags).some(([tag, {
        type: typs
      }]) => {
        types = typs;
        return tag === tagName && Array.isArray(types) && !types.includes(nodeName);
      })) {
        invalidTypes.push([nodeName, types]);
      } else if (!noDefaults && type === 'JsdocTypeName') {
        for (const strictNativeType of strictNativeTypes) {
          if ( // Todo: Avoid typescript condition if moving to default typescript
          strictNativeType === 'object' && mode === 'typescript' && ( // This is not set to remap with exact type match (e.g.,
          //   `object: 'Object'`), so can ignore (including if circular)
          !(preferredTypes !== null && preferredTypes !== void 0 && preferredTypes[nodeName]) || // Although present on `preferredTypes` for remapping, this is a
          //   parent object without a parent match (and not
          //   `unifyParentAndChildTypeChecks`) and we don't want
          //   `object<>` given TypeScript issue https://github.com/microsoft/TypeScript/issues/20555
          parentNode !== null && parentNode !== void 0 && parentNode.elements.length && (parentNode === null || parentNode === void 0 ? void 0 : parentNode.left.type) === 'JsdocTypeName' && (parentNode === null || parentNode === void 0 ? void 0 : parentNode.left.value) === 'Object')) {
            continue;
          }

          if (strictNativeType !== nodeName && strictNativeType.toLowerCase() === nodeName.toLowerCase() && ( // Don't report if user has own map for a strict native type
          !preferredTypes || (preferredTypes === null || preferredTypes === void 0 ? void 0 : preferredTypes[strictNativeType]) === undefined)) {
            preferred = strictNativeType;
            invalidTypes.push([nodeName, preferred]);
            break;
          }
        }
      } // For fixer


      if (preferred) {
        adjustNames(type, preferred, isGenericMatch, nodeName, node, parentNode);
      }
    });

    if (invalidTypes.length) {
      const fixedType = (0, _jsdoccomment.stringify)(typeAst);

      const fix = fixer => {
        return fixer.replaceText(jsdocNode, sourceCode.getText(jsdocNode).replace(`{${jsdocTag.type}}`, `{${fixedType}}`));
      };
diff --git a/a.js b/b.js
@@ -11,7 +11,7 @@
A blob:0659b3486acf1a3bef4cb362d8650d2a934afd71

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// If supporting Node >= 10, we could loosen the default to this for the
//   initial letter: \\p{Upper}
const matchDescriptionDefault = '^[A-Z`\\d_][\\s\\S]*[.?!`]\\s*$';

const stringOrDefault = (value, userDefault) => {
  return typeof value === 'string' ? value : userDefault || matchDescriptionDefault;
};
diff --git a/a.js b/b.js
@@ -71,7 +71,7 @@ const stripPseudoTypes = str => {
A blob:4395ab683c7945468b952ec4ffaf0412a8210d2b

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const extraTypes = ['null', 'undefined', 'void', 'string', 'boolean', 'object', 'function', 'symbol', 'number', 'bigint', 'NaN', 'Infinity', 'any', '*', 'never', 'unknown', 'const', 'this', 'true', 'false', 'Array', 'Object', 'RegExp', 'Date', 'Function'];

const stripPseudoTypes = str => {
  return str && str.replace(/(?:\.|<>|\.<>|\[\])$/u, '');
};

var _default = (0, _iterateJsdoc.default)(({
  context,
  node,
  report,
  settings,
  sourceCode,
  utils
}) => {
  var _globalScope$childSco;

  const {
    scopeManager
  } = sourceCode;
  const {
    globalScope
  } = scopeManager;
  const {
    definedTypes = []
  } = context.options[0] || {};
  let definedPreferredTypes = [];
  const {
    preferredTypes,
    structuredTags,
    mode
  } = settings;

  if (Object.keys(preferredTypes).length) {
    definedPreferredTypes = Object.values(preferredTypes).map(preferredType => {
      if (typeof preferredType === 'string') {
        // May become an empty string but will be filtered out below
        return stripPseudoTypes(preferredType);
      }

      if (!preferredType) {
        return undefined;
      }

      if (typeof preferredType !== 'object') {
        utils.reportSettings('Invalid `settings.jsdoc.preferredTypes`. Values must be falsy, a string, or an object.');
      }

      return stripPseudoTypes(preferredType.replacement);
    }).filter(preferredType => {
      return preferredType;
    });
  }

  const typedefDeclarations = context.getAllComments().filter(comment => {
    return comment.value.startsWith('*');
  }).map(commentNode => {
    return (0, _iterateJsdoc.parseComment)(commentNode, '');
  }).flatMap(doc => {
    return doc.tags.filter(({
diff --git a/a.js b/b.js
@@ -63,7 +63,7 @@ const capitalize = str => {
A blob:5f72084c9b84ecb83b74408bc49a00efd7b93c59

const isTable = str => {
  return str.charAt() === '|';
};

const capitalize = str => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

const validateDescription = (description, reportOrig, jsdocNode, abbreviationsRegex, sourceCode, tag, newlineBeforeCapsAssumesBadSentenceEnd) => {
  if (!description) {
    return false;
  }

  const paragraphs = extractParagraphs(description);
diff --git a/a.js b/b.js
@@ -1174,6 +1174,10 @@
A blob:d4e8e47e1202f95faebeb2f83c1b84de5e3df819
                        }
                        else if (parser.consume(';')) {
                            separator = 'semicolon';
                        }
                        else {
                            break;
                        }
                    }
                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here
                    if (!parser.consume('}')) {
                        throw new Error('Unterminated record type. Missing \'}\'');
diff --git a/a.js b/b.js
@@ -2,37 +2,17 @@
A blob:de852f15e47bc28599a45109e37f52d64687f3fc
#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const minimist = require('minimist')
const pkg = require('../package.json')
const JSON5 = require('./')

const argv = minimist(process.argv.slice(2), {
    alias: {
        'convert': 'c',
        'space': 's',
        'validate': 'v',
        'out-file': 'o',
        'version': 'V',
        'help': 'h',
    },
    boolean: [
        'convert',
        'validate',
        'version',
        'help',
    ],
    string: [
        'space',
        'out-file',
    ],
})

if (argv.version) {
    version()
} else if (argv.help) {
    usage()
} else {
    const inFilename = argv._[0]

    let readStream
    if (inFilename) {
        readStream = fs.createReadStream(inFilename)
diff --git a/a.js b/b.js
@@ -65,7 +45,7 @@ usage()
A blob:de852f15e47bc28599a45109e37f52d64687f3fc
})

if (argv.version) {
    version()
} else if (argv.help) {
    usage()
} else {
    const inFilename = argv._[0]

    let readStream
    if (inFilename) {
        readStream = fs.createReadStream(inFilename)
    } else {
        readStream = process.stdin
    }

    let json5 = ''
    readStream.on('data', data => {
        json5 += data
    })

    readStream.on('end', () => {
        let space
        if (argv.space === 't' || argv.space === 'tab') {
            space = '\t'
        } else {
            space = Number(argv.space)
        }

        let value
        try {
            value = JSON5.parse(json5)
            if (!argv.validate) {
                const json = JSON.stringify(value, null, space)

                let writeStream

                // --convert is for backward compatibility with v0.5.1. If
                // specified with <file> and not --out-file, then a file with
                // the same name but with a .json extension will be written.
                if (argv.convert && inFilename && !argv.o) {
                    const parsedFilename = path.parse(inFilename)
                    const outFilename = path.format(
                        Object.assign(
                            parsedFilename,
diff --git a/a.js b/b.js
@@ -75,8 +55,8 @@ usage()
A blob:de852f15e47bc28599a45109e37f52d64687f3fc
})

if (argv.version) {
    version()
} else if (argv.help) {
    usage()
} else {
    const inFilename = argv._[0]

    let readStream
    if (inFilename) {
        readStream = fs.createReadStream(inFilename)
    } else {
        readStream = process.stdin
    }

    let json5 = ''
    readStream.on('data', data => {
        json5 += data
    })

    readStream.on('end', () => {
        let space
        if (argv.space === 't' || argv.space === 'tab') {
            space = '\t'
        } else {
            space = Number(argv.space)
        }

        let value
        try {
            value = JSON5.parse(json5)
            if (!argv.validate) {
                const json = JSON.stringify(value, null, space)

                let writeStream

                // --convert is for backward compatibility with v0.5.1. If
                // specified with <file> and not --out-file, then a file with
                // the same name but with a .json extension will be written.
                if (argv.convert && inFilename && !argv.o) {
                    const parsedFilename = path.parse(inFilename)
                    const outFilename = path.format(
                        Object.assign(
                            parsedFilename,
                            {base: path.basename(parsedFilename.base, parsedFilename.ext) + '.json'}
                        )
                    )

                    writeStream = fs.createWriteStream(outFilename)
                } else if (argv.o) {
                    writeStream = fs.createWriteStream(argv.o)
                } else {
                    writeStream = process.stdout
                }

diff --git a/a.js b/b.js
@@ -90,6 +70,66 @@ usage()
A blob:de852f15e47bc28599a45109e37f52d64687f3fc
})

if (argv.version) {
    version()
} else if (argv.help) {
    usage()
} else {
    const inFilename = argv._[0]

    let readStream
    if (inFilename) {
        readStream = fs.createReadStream(inFilename)
    } else {
        readStream = process.stdin
    }

    let json5 = ''
    readStream.on('data', data => {
        json5 += data
    })

    readStream.on('end', () => {
        let space
        if (argv.space === 't' || argv.space === 'tab') {
            space = '\t'
        } else {
            space = Number(argv.space)
        }

        let value
        try {
            value = JSON5.parse(json5)
            if (!argv.validate) {
                const json = JSON.stringify(value, null, space)

                let writeStream

                // --convert is for backward compatibility with v0.5.1. If
                // specified with <file> and not --out-file, then a file with
                // the same name but with a .json extension will be written.
                if (argv.convert && inFilename && !argv.o) {
                    const parsedFilename = path.parse(inFilename)
                    const outFilename = path.format(
                        Object.assign(
                            parsedFilename,
                            {base: path.basename(parsedFilename.base, parsedFilename.ext) + '.json'}
                        )
                    )

                    writeStream = fs.createWriteStream(outFilename)
                } else if (argv.o) {
                    writeStream = fs.createWriteStream(argv.o)
                } else {
                    writeStream = process.stdout
                }

                writeStream.write(json)
            }
        } catch (err) {
            console.error(err.message)
            process.exit(1)
        }
    })
}

function version () {
    console.log(pkg.version)
}

diff --git a/a.js b/b.js
@@ -98,7 +98,7 @@
A blob:29fece552567a956bb2459b393283221d41bbc20
/**
 * Spawns a new Node.js process + fork.
 * @param {string|URL} modulePath
 * @param {string[]} [args]
 * @param {{
 *   cwd?: string;
 *   detached?: boolean;
 *   env?: Object;
 *   execPath?: string;
 *   execArgv?: string[];
 *   gid?: number;
 *   serialization?: string;
diff --git a/a.js b/b.js
@@ -199,7 +199,7 @@ function normalizeExecArgs(command, options, callback) {
A blob:29fece552567a956bb2459b393283221d41bbc20
  process.on('removeListener', function onRemoveListener(name) {
    if (name === 'message' || name === 'disconnect') control.unrefCounted();
  });
}

function normalizeExecArgs(command, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = undefined;
  }

  // Make a shallow copy so we don't clobber the user's options object.
  options = { ...options };
  options.shell = typeof options.shell === 'string' ? options.shell : true;

  return {
    file: command,
    options: options,
    callback: callback
  };
}

/**
 * Spawns a shell executing the given command.
 * @param {string} command
 * @param {{
 *   cmd?: string;
 *   env?: Object;
 *   encoding?: string;
 *   shell?: string;
 *   signal?: AbortSignal;
 *   timeout?: number;
diff --git a/a.js b/b.js
@@ -253,7 +253,7 @@ ObjectDefineProperty(exec, promisify.custom, {
A blob:29fece552567a956bb2459b393283221d41bbc20

    return promise;
  };
};

ObjectDefineProperty(exec, promisify.custom, {
  enumerable: false,
  value: customPromiseExecFunction(exec)
});

/**
 * Spawns the specified file as a shell.
 * @param {string} file
 * @param {string[]} [args]
 * @param {{
 *   cwd?: string;
 *   env?: Object;
 *   encoding?: string;
 *   timeout?: number;
 *   maxBuffer?: number;
 *   killSignal?: string | number;
diff --git a/a.js b/b.js
@@ -662,7 +662,7 @@ function abortChildProcess(child, killSignal) {
A blob:29fece552567a956bb2459b393283221d41bbc20
    windowsHide: !!options.windowsHide,
    windowsVerbatimArguments: !!windowsVerbatimArguments,
  };
}

function abortChildProcess(child, killSignal) {
  if (!child)
    return;
  try {
    if (child.kill(killSignal)) {
      child.emit('error', new AbortError());
    }
  } catch (err) {
    child.emit('error', err);
  }
}

/**
 * Spawns a new process using the given `file`.
 * @param {string} file
 * @param {string[]} [args]
 * @param {{
 *   cwd?: string;
 *   env?: Object;
 *   argv0?: string;
 *   stdio?: Array | string;
 *   detached?: boolean;
 *   uid?: number;
diff --git a/a.js b/b.js
@@ -735,7 +735,7 @@ function spawn(file, args, options) {
A blob:29fece552567a956bb2459b393283221d41bbc20
 *   timeout?: number;
 *   killSignal?: string | number;
 *   }} [options]
 * @returns {ChildProcess}
 */
function spawn(file, args, options) {
  options = normalizeSpawnArguments(file, args, options);
  validateTimeout(options.timeout);
  validateAbortSignal(options.signal, 'options.signal');
  const killSignal = sanitizeKillSignal(options.killSignal);
  const child = new ChildProcess();

  debug('spawn', options);
  child.spawn(options);

  if (options.timeout > 0) {
    let timeoutId = setTimeout(() => {
      if (timeoutId) {
        try {
          child.kill(killSignal);
        } catch (err) {
          child.emit('error', err);
        }
        timeoutId = null;
      }
    }, options.timeout);

    child.once('exit', () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    });
  }

  if (options.signal) {
    const signal = options.signal;
    if (signal.aborted) {
      process.nextTick(onAbortListener);
    } else {
      signal.addEventListener('abort', onAbortListener, { once: true });
      child.once('exit',
                 () => signal.removeEventListener('abort', onAbortListener));
    }

    function onAbortListener() {
      abortChildProcess(child, killSignal);
    }
  }

  return child;
}

/**
 * Spawns a new process synchronously using the given `file`.
 * @param {string} file
 * @param {string[]} [args]
 * @param {{
 *   cwd?: string;
 *   input?: string | Buffer | TypedArray | DataView;
 *   argv0?: string;
 *   stdio?: string | Array;
 *   env?: Object;
 *   uid?: number;
 *   gid?: number;
 *   timeout?: number;
 *   killSignal?: string | number;
diff --git a/a.js b/b.js
@@ -827,7 +827,7 @@ function checkExecSyncError(ret, args, cmd) {
A blob:29fece552567a956bb2459b393283221d41bbc20

  return child_process.spawnSync(options);
}


function checkExecSyncError(ret, args, cmd) {
  let err;
  if (ret.error) {
    err = ret.error;
    ObjectAssign(err, ret);
  } else if (ret.status !== 0) {
    let msg = 'Command failed: ';
    msg += cmd || ArrayPrototypeJoin(args, ' ');
    if (ret.stderr && ret.stderr.length > 0)
      msg += `\n${ret.stderr.toString()}`;
    err = genericNodeError(msg, ret);
  }
  return err;
}

/**
 * Spawns a file as a shell synchronously.
 * @param {string} command
 * @param {string[]} [args]
 * @param {{
 *   cwd?: string;
 *   input?: string | Buffer | TypedArray | DataView;
 *   stdio?: string | Array;
 *   env?: Object;
 *   uid?: number;
 *   gid?: number;
 *   timeout?: number;
 *   killSignal?: string | number;
diff --git a/a.js b/b.js
@@ -864,7 +864,7 @@ function execFileSync(command, args, options) {
A blob:29fece552567a956bb2459b393283221d41bbc20
 *   windowsHide?: boolean;
 *   shell?: boolean | string;
 *   }} [options]
 * @returns {Buffer | string}
 */
function execFileSync(command, args, options) {
  options = normalizeSpawnArguments(command, args, options);

  const inheritStderr = !options.stdio;
  const ret = spawnSync(options.file,
                        ArrayPrototypeSlice(options.args, 1), options);

  if (inheritStderr && ret.stderr)
    process.stderr.write(ret.stderr);

  const err = checkExecSyncError(ret, options.args, undefined);

  if (err)
    throw err;

  return ret.stdout;
}

/**
 * Spawns a shell executing the given `command` synchronously.
 * @param {string} command
 * @param {{
 *   cwd?: string;
 *   input?: string | Buffer | TypedArray | DataView;
 *   stdio?: string | Array;
 *   env?: Object;
 *   shell?: string;
 *   uid?: number;
 *   gid?: number;
 *   timeout?: number;
diff --git a/a.js b/b.js
@@ -2876,7 +2876,7 @@ function lazyLoadStreams() {
A blob:611eaaa90c6c9c1f0afb5243011b5a261e18f15c
  dest = pathModule.toNamespacedPath(getValidatedPath(dest, 'dest'));
  lazyLoadCp();
  cpSyncFn(src, dest, options);
}

function lazyLoadStreams() {
  if (!ReadStream) {
    ({ ReadStream, WriteStream } = require('internal/fs/streams'));
    FileReadStream = ReadStream;
    FileWriteStream = WriteStream;
  }
}

/**
 * Creates a readable stream with a default `highWaterMark`
 * of 64 kb.
 * @param {string | Buffer | URL} path
 * @param {string | {
 *   flags?: string;
 *   encoding?: string;
 *   fd?: number | FileHandle;
 *   mode?: number;
 *   autoClose?: boolean;
 *   emitClose?: boolean;
 *   start: number;
 *   end?: number;
 *   highWaterMark?: number;
 *   fs?: Object | null;
 *   }} [options]
 * @returns {ReadStream}
 */
function createReadStream(path, options) {
diff --git a/a.js b/b.js
@@ -2896,7 +2896,7 @@ function createReadStream(path, options) {
A blob:611eaaa90c6c9c1f0afb5243011b5a261e18f15c
 *   highWaterMark?: number;
 *   fs?: Object | null;
 *   }} [options]
 * @returns {ReadStream}
 */
function createReadStream(path, options) {
  lazyLoadStreams();
  return new ReadStream(path, options);
}

/**
 * Creates a write stream.
 * @param {string | Buffer | URL} path
 * @param {string | {
 *   flags?: string;
 *   encoding?: string;
 *   fd?: number | FileHandle;
 *   mode?: number;
 *   autoClose?: boolean;
 *   emitClose?: boolean;
 *   start: number;
 *   fs?: Object | null;
 *   }} [options]
 * @returns {WriteStream}
 */
function createWriteStream(path, options) {
diff --git a/a.js b/b.js
@@ -362,7 +362,7 @@ function request(...args) {
A blob:7a9a4243aaae144896550ef6bbc4b3540e539367
/**
 * Makes a request to a secure web server.
 * @param {...any} args
 * @returns {ClientRequest}
 */
function request(...args) {
  let options = {};

  if (typeof args[0] === 'string') {
    const urlStr = ArrayPrototypeShift(args);
    options = urlToHttpOptions(new URL(urlStr));
  } else if (args[0] && args[0][searchParamsSymbol] &&
             args[0][searchParamsSymbol][searchParamsSymbol]) {
    // url.URL instance
    options = urlToHttpOptions(ArrayPrototypeShift(args));
  }

  if (args[0] && typeof args[0] !== 'function') {
    ObjectAssign(options, ArrayPrototypeShift(args));
  }

  options._defaultAgent = module.exports.globalAgent;
  ArrayPrototypeUnshift(args, options);

  return ReflectConstruct(ClientRequest, args);
}

/**
 * Makes a GET request to a secure web server.
 * @param {string | URL} input
 * @param {{
 *   agent?: Agent | boolean;
 *   auth?: string;
 *   createConnection?: Function;
 *   defaultPort?: number;
 *   family?: number;
 *   headers?: Object;
 *   hints?: number;
 *   host?: string;
 *   hostname?: string;
 *   insecureHTTPParser?: boolean;
diff --git a/a.js b/b.js
@@ -96,10 +96,9 @@
A blob:b8b0f5b54fc91c98a37ba7d6d990b502314c02e7
  if (common.hasFipsCrypto && test.iv.length < 24) {
    common.printSkipMessage('IV len < 12 bytes unsupported in FIPS mode');
    continue;
  }

  const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);
  const isOCB = /^aes-(128|192|256)-ocb$/.test(test.algo);
  const isChacha20Poly1305 = test.algo === 'chacha20-poly1305';

  let options;
  if (isCCM || isOCB || isChacha20Poly1305)
    options = { authTagLength: test.tag.length / 2 };

  const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';

diff --git a/a.js b/b.js
@@ -659,8 +658,7 @@
A blob:b8b0f5b54fc91c98a37ba7d6d990b502314c02e7
  check(17);

  function check(ivLength) {
    const prefix = ivLength - valid.iv.length / 2;
    assert.throws(() => crypto.createCipheriv(
      valid.algo,
      Buffer.from(valid.key, 'hex'),
      Buffer.from(H(prefix) + valid.iv, 'hex'),
      { authTagLength: valid.tag.length / 2 }
    ), errMessages.length, `iv length ${ivLength} was not rejected`);

    function H(length) { return '00'.repeat(length); }
  }
diff --git a/a.js b/b.js
@@ -745,3 +743,46 @@
A blob:b8b0f5b54fc91c98a37ba7d6d990b502314c02e7
          code: 'ERR_CRYPTO_INVALID_AUTH_TAG',
          message: `Invalid authentication tag length: ${authTagLength}`
        });
      }
    }
  }
}

diff --git a/a.js b/b.js
@@ -159,7 +159,7 @@ function startListening(socket) {
A blob:221afcf5bb0c84a4d46ac509c571c630df9ace70
function createSocket(type, listener) {
  return new Socket(type, listener);
}


function startListening(socket) {
  const state = socket[kStateSymbol];

  state.handle.onmessage = onMessage;
  // Todo: handle errors
  state.handle.recvStart();
  state.receiving = true;
  state.bindState = BIND_STATE_BOUND;

diff --git a/a.js b/b.js
@@ -923,6 +923,12 @@ function onMessage(nread, handle, buf, rinfo) {
A blob:221afcf5bb0c84a4d46ac509c571c630df9ace70
  state.handle.recvStop();
  state.receiving = false;
}


function onMessage(nread, handle, buf, rinfo) {
  const self = handle[owner_symbol];
  if (nread < 0) {
    return self.emit('error', errnoException(nread, 'recvmsg'));
  }
  rinfo.size = buf.length; // compatibility
  self.emit('message', buf, rinfo);
}


Socket.prototype.ref = function() {
  const handle = this[kStateSymbol].handle;

  if (handle)
diff --git a/a.js b/b.js
@@ -24,6 +24,8 @@
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
} = primordials;

const {
  constants: {
    NODE_PERFORMANCE_ENTRY_TYPE_GC,
    NODE_PERFORMANCE_ENTRY_TYPE_HTTP2,
    NODE_PERFORMANCE_ENTRY_TYPE_HTTP,
  },
  installGarbageCollectionTracking,
  observerCounts,
  removeGarbageCollectionTracking,
diff --git a/a.js b/b.js
@@ -61,13 +63,9 @@
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238

const {
  setImmediate,
} = require('timers');

const { inspect } = require('util');

const kBuffer = Symbol('kBuffer');
const kCallback = Symbol('kCallback');
const kDispatch = Symbol('kDispatch');
const kEntryTypes = Symbol('kEntryTypes');
const kMaybeBuffer = Symbol('kMaybeBuffer');
const kDeprecatedFields = Symbol('kDeprecatedFields');
const kType = Symbol('kType');

const kDeprecationMessage =
  'Custom PerformanceEntry accessors are deprecated. ' +
  'Please use the detail property.';
diff --git a/a.js b/b.js
@@ -79,12 +77,14 @@
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238

const kTypeSingle = 0;
const kTypeMultiple = 1;

let gcTrackingInstalled = false;

const kSupportedEntryTypes = ObjectFreeze([
  'function',
  'gc',
  'http',
  'http2',
  'mark',
  'measure',
]);

// Performance timeline entry Buffers
let markEntryBuffer = [];
diff --git a/a.js b/b.js
@@ -118,6 +118,8 @@ function getObserverType(type) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    for (const pending of pendings)
      pending[kDispatch]();
  });
}

function getObserverType(type) {
  switch (type) {
    case 'gc': return NODE_PERFORMANCE_ENTRY_TYPE_GC;
    case 'http2': return NODE_PERFORMANCE_ENTRY_TYPE_HTTP2;
    case 'http': return NODE_PERFORMANCE_ENTRY_TYPE_HTTP;
  }
}

function maybeDecrementObserverCounts(entryTypes) {
diff --git a/a.js b/b.js
@@ -151,20 +153,22 @@ function maybeIncrementObserverCount(type) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
      }
    }
  }
}

function maybeIncrementObserverCount(type) {
  const observerType = getObserverType(type);

  if (observerType !== undefined) {
    observerCounts[observerType]++;
    if (!gcTrackingInstalled &&
        observerType === NODE_PERFORMANCE_ENTRY_TYPE_GC) {
      installGarbageCollectionTracking();
      gcTrackingInstalled = true;
    }
  }
}

class PerformanceObserverEntryList {
  constructor(entries) {
    this[kBuffer] = ArrayPrototypeSort(entries, (first, second) => {
      return first.startTime - second.startTime;
    });
  }

  getEntries() {
    return ArrayPrototypeSlice(this[kBuffer]);
  }

  getEntriesByType(type) {
    type = `${type}`;
    return ArrayPrototypeFilter(
      this[kBuffer],
      (entry) => entry.entryType === type);
  }

  getEntriesByName(name, type) {
diff --git a/a.js b/b.js
@@ -172,11 +176,11 @@ getEntriesByName(name, type) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    return ArrayPrototypeFilter(
      this[kBuffer],
      (entry) => entry.entryType === type);
  }

  getEntriesByName(name, type) {
    name = `${name}`;
    if (type != null /** not nullish */) {
      return ArrayPrototypeFilter(
        this[kBuffer],
        (entry) => entry.name === name && entry.entryType === type);
    }
    return ArrayPrototypeFilter(
      this[kBuffer],
      (entry) => entry.name === name);
  }

  [kInspect](depth, options) {
diff --git a/a.js b/b.js
@@ -188,20 +192,19 @@ getEntriesByName(name, type) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    return ArrayPrototypeFilter(
      this[kBuffer],
      (entry) => entry.entryType === type);
  }

  getEntriesByName(name, type) {
    name = `${name}`;
    if (type != null /** not nullish */) {
      return ArrayPrototypeFilter(
        this[kBuffer],
        (entry) => entry.name === name && entry.entryType === type);
    }
    return ArrayPrototypeFilter(
      this[kBuffer],
      (entry) => entry.name === name);
  }

  [kInspect](depth, options) {
    if (depth < 0) return this;

    const opts = {
      ...options,
      depth: options.depth == null ? null : options.depth - 1
    };

    return `PerformanceObserverEntryList ${inspect(this[kBuffer], opts)}`;
  }
}

class PerformanceObserver {
  constructor(callback) {
    // TODO(joyeecheung): V8 snapshot does not support instance member
    // initializers for now:
    // https://bugs.chromium.org/p/v8/issues/detail?id=10704
    this[kBuffer] = [];
    this[kEntryTypes] = new SafeSet();
    this[kType] = undefined;
    validateFunction(callback, 'callback');
    this[kCallback] = callback;
  }

  observe(options = {}) {
    validateObject(options, 'options');
diff --git a/a.js b/b.js
@@ -219,10 +222,10 @@ observe(options = {}) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    this[kType] = undefined;
    validateFunction(callback, 'callback');
    this[kCallback] = callback;
  }

  observe(options = {}) {
    validateObject(options, 'options');
    const {
      entryTypes,
      type,
      buffered,
    } = { ...options };
    if (entryTypes === undefined && type === undefined)
      throw new ERR_MISSING_ARGS('options.entryTypes', 'options.type');
    if (entryTypes != null && type != null)
      throw new ERR_INVALID_ARG_VALUE('options.entryTypes',
                                      entryTypes,
                                      'options.entryTypes can not set with ' +
                                      'options.type together');

    switch (this[kType]) {
      case undefined:
        if (entryTypes !== undefined) this[kType] = kTypeMultiple;
        if (type !== undefined) this[kType] = kTypeSingle;
        break;
      case kTypeSingle:
        if (entryTypes !== undefined)
          throw lazyDOMException(
diff --git a/a.js b/b.js
@@ -238,53 +241,53 @@ observe(options = {}) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    this[kType] = undefined;
    validateFunction(callback, 'callback');
    this[kCallback] = callback;
  }

  observe(options = {}) {
    validateObject(options, 'options');
    const {
      entryTypes,
      type,
      buffered,
    } = { ...options };
    if (entryTypes === undefined && type === undefined)
      throw new ERR_MISSING_ARGS('options.entryTypes', 'options.type');
    if (entryTypes != null && type != null)
      throw new ERR_INVALID_ARG_VALUE('options.entryTypes',
                                      entryTypes,
                                      'options.entryTypes can not set with ' +
                                      'options.type together');

    switch (this[kType]) {
      case undefined:
        if (entryTypes !== undefined) this[kType] = kTypeMultiple;
        if (type !== undefined) this[kType] = kTypeSingle;
        break;
      case kTypeSingle:
        if (entryTypes !== undefined)
          throw lazyDOMException(
            'PerformanceObserver can not change to multiple observations',
            'InvalidModificationError');
        break;
      case kTypeMultiple:
        if (type !== undefined)
          throw lazyDOMException(
            'PerformanceObserver can not change to single observation',
            'InvalidModificationError');
        break;
    }

    if (this[kType] === kTypeMultiple) {
      if (!ArrayIsArray(entryTypes)) {
        throw new ERR_INVALID_ARG_TYPE(
          'options.entryTypes',
          'string[]',
          entryTypes);
      }
      maybeDecrementObserverCounts(this[kEntryTypes]);
      this[kEntryTypes].clear();
      for (let n = 0; n < entryTypes.length; n++) {
        if (ArrayPrototypeIncludes(kSupportedEntryTypes, entryTypes[n])) {
          this[kEntryTypes].add(entryTypes[n]);
          maybeIncrementObserverCount(entryTypes[n]);
        }
      }
    } else {
      if (!ArrayPrototypeIncludes(kSupportedEntryTypes, type))
        return;
      this[kEntryTypes].add(type);
      maybeIncrementObserverCount(type);
      if (buffered) {
        const entries = filterBufferMapByNameAndType(undefined, type);
        ArrayPrototypePushApply(this[kBuffer], entries);
        kPending.add(this);
        if (kPending.size)
          queuePending();
      }
    }

    if (this[kEntryTypes].size)
      kObservers.add(this);
    else
      this.disconnect();
  }

  disconnect() {
    maybeDecrementObserverCounts(this[kEntryTypes]);
    kObservers.delete(this);
    kPending.delete(this);
    this[kBuffer] = [];
    this[kEntryTypes].clear();
    this[kType] = undefined;
  }

  takeRecords() {
    const list = this[kBuffer];
    this[kBuffer] = [];
    return list;
  }

  static get supportedEntryTypes() {
diff --git a/a.js b/b.js
@@ -293,17 +296,17 @@ static get supportedEntryTypes() {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    const list = this[kBuffer];
    this[kBuffer] = [];
    return list;
  }

  static get supportedEntryTypes() {
    return kSupportedEntryTypes;
  }

  [kMaybeBuffer](entry) {
    if (!this[kEntryTypes].has(entry.entryType))
      return;
    ArrayPrototypePush(this[kBuffer], entry);
    kPending.add(this);
    if (kPending.size)
      queuePending();
  }

  [kDispatch]() {
    this[kCallback](new PerformanceObserverEntryList(this.takeRecords()),
                    this);
  }

  [kInspect](depth, options) {
    if (depth < 0) return this;
diff --git a/a.js b/b.js
@@ -317,8 +320,8 @@ static get supportedEntryTypes() {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
    const list = this[kBuffer];
    this[kBuffer] = [];
    return list;
  }

  static get supportedEntryTypes() {
    return kSupportedEntryTypes;
  }

  [kMaybeBuffer](entry) {
    if (!this[kEntryTypes].has(entry.entryType))
      return;
    ArrayPrototypePush(this[kBuffer], entry);
    kPending.add(this);
    if (kPending.size)
      queuePending();
  }

  [kDispatch]() {
    this[kCallback](new PerformanceObserverEntryList(this.takeRecords()),
                    this);
  }

  [kInspect](depth, options) {
    if (depth < 0) return this;

    const opts = {
      ...options,
      depth: options.depth == null ? null : options.depth - 1
    };

    return `PerformanceObserver ${inspect({
      connected: kObservers.has(this),
      pending: kPending.has(this),
      entryTypes: ArrayFrom(this[kEntryTypes]),
      buffer: this[kBuffer],
    }, opts)}`;
  }
}

diff --git a/a.js b/b.js
@@ -443,6 +446,32 @@ function hasObserver(type) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
  enqueue(entry);
}

setupObservers(observerCallback);

function hasObserver(type) {
  const observerType = getObserverType(type);
  return observerCounts[observerType] > 0;
}

module.exports = {
  PerformanceObserver,
  PerformanceObserverEntryList,
  enqueue,
diff --git a/a.js b/b.js
@@ -450,4 +479,6 @@ function hasObserver(type) {
A blob:2f9506ed28e3ebe7e806fab819c67293d6a35238
  enqueue(entry);
}

setupObservers(observerCallback);

function hasObserver(type) {
  const observerType = getObserverType(type);
  return observerCounts[observerType] > 0;
}

module.exports = {
  PerformanceObserver,
  PerformanceObserverEntryList,
  enqueue,
  hasObserver,
  clearEntriesFromBuffer,
  filterBufferMapByNameAndType,
};

diff --git a/a.js b/b.js
@@ -63,16 +63,7 @@
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
const kNewListener = Symbol('kNewListener');
const kRemoveListener = Symbol('kRemoveListener');
const kIsNodeStyleListener = Symbol('kIsNodeStyleListener');
const kTrustEvent = Symbol('kTrustEvent');

const { now } = require('internal/perf/utils');

// TODO(joyeecheung): V8 snapshot does not support instance member
// initializers for now:
// https://bugs.chromium.org/p/v8/issues/detail?id=10704
const kType = Symbol('type');
const kDefaultPrevented = Symbol('defaultPrevented');
const kCancelable = Symbol('cancelable');
const kTimestamp = Symbol('timestamp');
const kBubbles = Symbol('bubbles');
const kComposed = Symbol('composed');
const kPropagationStopped = Symbol('propagationStopped');

const isTrustedSet = new SafeWeakSet();
const isTrusted = ObjectGetOwnPropertyDescriptor({
  get isTrusted() {
diff --git a/a.js b/b.js
@@ -86,6 +77,13 @@ function isEvent(value) {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  get isTrusted() {
    return isTrustedSet.has(this);
  }
}, 'isTrusted').get;

function isEvent(value) {
  return typeof value?.[kType] === 'string';
}

class Event {
  /**
   * @param {string} type
   * @param {{
   *   bubbles?: boolean,
diff --git a/a.js b/b.js
@@ -101,13 +99,11 @@ validateObject(options, 'options', {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
   * }} [options]
   */
  constructor(type, options = null) {
    if (arguments.length === 0)
      throw new ERR_MISSING_ARGS('type');
    validateObject(options, 'options', {
      allowArray: true, allowFunction: true, nullable: true,
    });
    const { cancelable, bubbles, composed } = { ...options };
    this[kCancelable] = !!cancelable;
    this[kBubbles] = !!bubbles;
    this[kComposed] = !!composed;
    this[kType] = `${type}`;
    this[kDefaultPrevented] = false;
    this[kTimestamp] = now();
    this[kPropagationStopped] = false;
    if (options?.[kTrustEvent]) {
      isTrustedSet.add(this);
    }

diff --git a/a.js b/b.js
@@ -135,9 +131,9 @@ ObjectDefineProperty(this, 'isTrusted', {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
    if (options?.[kTrustEvent]) {
      isTrustedSet.add(this);
    }

    // isTrusted is special (LegacyUnforgeable)
    ObjectDefineProperty(this, 'isTrusted', {
      get: isTrusted,
      enumerable: true,
      configurable: false
    });
    this[kTarget] = null;
    this[kIsBeingDispatched] = false;
  }

  [customInspectSymbol](depth, options) {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    const name = this.constructor.name;
    if (depth < 0)
      return name;

    const opts = ObjectAssign({}, options, {
      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth
    });

    return `${name} ${inspect({
      type: this[kType],
      defaultPrevented: this[kDefaultPrevented],
      cancelable: this[kCancelable],
      timeStamp: this[kTimestamp],
    }, opts)}`;
  }

  stopImmediatePropagation() {
diff --git a/a.js b/b.js
@@ -150,7 +146,7 @@ stopImmediatePropagation() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
      cancelable: this[kCancelable],
      timeStamp: this[kTimestamp],
    }, opts)}`;
  }

  stopImmediatePropagation() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    this[kStop] = true;
  }

  preventDefault() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    this[kDefaultPrevented] = true;
  }

  /**
   * @type {EventTarget}
diff --git a/a.js b/b.js
@@ -195,7 +191,7 @@ get type() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {string}
   */
  get type() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kType];
  }

  /**
   * @type {boolean}
   */
  get cancelable() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kCancelable];
  }

  /**
   * @type {boolean}
diff --git a/a.js b/b.js
@@ -204,7 +200,7 @@ get cancelable() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {boolean}
   */
  get cancelable() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kCancelable];
  }

  /**
   * @type {boolean}
   */
  get defaultPrevented() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kCancelable] && this[kDefaultPrevented];
  }

  /**
   * @type {number}
diff --git a/a.js b/b.js
@@ -213,7 +209,7 @@ get defaultPrevented() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {boolean}
   */
  get defaultPrevented() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kCancelable] && this[kDefaultPrevented];
  }

  /**
   * @type {number}
   */
  get timeStamp() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kTimestamp];
  }


  // The following are non-op and unused properties/methods from Web API Event.
diff --git a/a.js b/b.js
@@ -244,7 +240,7 @@ get returnValue() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {boolean}
   */
  get returnValue() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return !this.defaultPrevented;
  }

  /**
   * @type {boolean}
   */
  get bubbles() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kBubbles];
  }

  /**
   * @type {boolean}
diff --git a/a.js b/b.js
@@ -253,7 +249,7 @@ get bubbles() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {boolean}
   */
  get bubbles() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kBubbles];
  }

  /**
   * @type {boolean}
   */
  get composed() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kComposed];
  }

  /**
   * @type {number}
diff --git a/a.js b/b.js
@@ -271,7 +267,7 @@ get eventPhase() {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {number}
   */
  get eventPhase() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;
  }

  /**
   * @type {boolean}
   */
  get cancelBubble() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kPropagationStopped];
  }

  /**
   * @type {boolean}
diff --git a/a.js b/b.js
@@ -288,7 +284,7 @@ set cancelBubble(value) {
A blob:7c539db2eb3c2aa1d8138b7f37f91a6e81228700
  }

  /**
   * @type {boolean}
   */
  set cancelBubble(value) {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    if (value) {
      this.stopPropagation();
    }
  }

  stopPropagation() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    this[kPropagationStopped] = true;
  }

  static NONE = 0;
  static CAPTURING_PHASE = 1;
diff --git a/a.js b/b.js
@@ -291,9 +291,8 @@ function abortSignal(signal, reason) {
A blob:e0c0d63899972cde982ade31a4796ceeee84d9bb
  signal[kAborted] = aborted;
  signal[kReason] = reason;
  return lazyMakeTransferable(signal);
}

function abortSignal(signal, reason) {
  if (signal[kAborted]) return;
  signal[kAborted] = true;
  signal[kReason] = reason;
  const event = new Event('abort', {
    [kTrustEvent]: true
  });
  signal.dispatchEvent(event);
}

// TODO(joyeecheung): V8 snapshot does not support instance member
// initializers for now:
// https://bugs.chromium.org/p/v8/issues/detail?id=10704
const kSignal = Symbol('signal');

function validateAbortController(obj) {
  if (obj?.[kSignal] === undefined)
diff --git a/a.js b/b.js
@@ -44,6 +44,7 @@
A blob:d6869ef6334496a5186f8819752bc21c15706604
'use strict';

// This file is compiled as if it's wrapped in a function with arguments
// passed by node::RunBootstrapping()
/* global process, getLinkedBinding, getInternalBinding, primordials */

const {
  ArrayPrototypeMap,
  ArrayPrototypePush,
  ArrayPrototypeSlice,
  Error,
diff --git a/a.js b/b.js
@@ -119,6 +120,11 @@ ObjectDefineProperty(process, 'moduleLoadList', {
A blob:d6869ef6334496a5186f8819752bc21c15706604
  TypeError,
} = primordials;

// Set up process.moduleLoadList.
const moduleLoadList = [];
ObjectDefineProperty(process, 'moduleLoadList', {
  value: moduleLoadList,
  configurable: true,
  enumerable: true,
  writable: false
});


// internalBindingAllowlist contains the name of internalBinding modules
// that are allowed for access via process.binding()... This is used
// to provide a transition path for modules that are being moved over to
// internalBinding.
const internalBindingAllowlist = new SafeSet([
  'async_wrap',
  'buffer',
  'cares_wrap',
  'config',
  'constants',
  'contextify',
  'crypto',
  'fs',
  'fs_event_wrap',
  'http_parser',
  'icu',
  'inspector',
  'js_stream',
  'natives',
  'os',
  'pipe_wrap',
  'process_wrap',
  'signal_wrap',
  'spawn_sync',
  'stream_wrap',
  'tcp_wrap',
  'tls_wrap',
  'tty_wrap',
  'udp_wrap',
  'url',
  'util',
  'uv',
  'v8',
  'zlib',
]);

const runtimeDeprecatedList = new SafeSet([
  'async_wrap',
  'crypto',
  'http_parser',
  'signal_wrap',
  'url',
  'v8',
]);

const legacyWrapperList = new SafeSet([
  'util',
]);

// Set up process.binding() and process._linkedBinding().
{
  const bindingObj = ObjectCreate(null);

diff --git a/a.js b/b.js
@@ -242,6 +248,16 @@ static canBeRequiredByUsers(id) {
A blob:d6869ef6334496a5186f8819752bc21c15706604

  static exists(id) {
    return NativeModule.map.has(id);
  }

  static canBeRequiredByUsers(id) {
    const mod = NativeModule.map.get(id);
    return mod && mod.canBeRequiredByUsers;
  }

  // Used by user-land module loaders to compile and load builtins.
  compileForPublicLoader() {
    if (!this.canBeRequiredByUsers) {
      // No code because this is an assertion against bugs
diff --git a/a.js b/b.js
@@ -182,7 +182,8 @@ function Module(id = '', parent) {
A blob:9e4229af9faaf8694fdd107bb1b14744fe91e5d3
  if (children && !(scan && ArrayPrototypeIncludes(children, child)))
    ArrayPrototypePush(children, child);
}

const moduleParentCache = new SafeWeakMap();
function Module(id = '', parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  moduleParentCache.set(this, parent);
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}

const builtinModules = [];
for (const { 0: id, 1: mod } of NativeModule.map) {
  if (mod.canBeRequiredByUsers) {
    ArrayPrototypePush(builtinModules, id);
  }
}

diff --git a/a.js b/b.js
@@ -802,7 +803,13 @@ Module._load = function(request, parent, isMain) {
A blob:9e4229af9faaf8694fdd107bb1b14744fe91e5d3
// 2. If the module is native: call
//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.
// 3. Otherwise, create a new module for the file and save it to the cache.
//    Then have it load  the file contents before returning its exports
//    object.
Module._load = function(request, parent, isMain) {
  let relResolveCacheIdentifier;
  if (parent) {
    debug('Module._load REQUEST %s parent: %s', request, parent.id);
    // Fast path for (lazy loaded) modules in the same directory. The indirect
    // caching is required to allow cache invalidation without changing the old
    // cache key names.
    relResolveCacheIdentifier = `${parent.path}\x00${request}`;
    const filename = relativeResolveCache[relResolveCacheIdentifier];
    if (filename !== undefined) {
      const cachedModule = Module._cache[filename];
      if (cachedModule !== undefined) {
        updateChildren(parent, cachedModule, true);
        if (!cachedModule.loaded)
          return getExportsForCircularRequire(cachedModule);
        return cachedModule.exports;
      }
      delete relativeResolveCache[relResolveCacheIdentifier];
    }
  }

  const filename = Module._resolveFilename(request, parent, isMain);
  if (StringPrototypeStartsWith(filename, 'node:')) {
    // Slice 'node:' prefix
    const id = StringPrototypeSlice(filename, 5);

    const module = loadNativeModule(id, request);
    if (!module?.canBeRequiredByUsers) {
      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);
    }

    return module.exports;
  }

  const cachedModule = Module._cache[filename];
  if (cachedModule !== undefined) {
    updateChildren(parent, cachedModule, true);
    if (!cachedModule.loaded) {
      const parseCachedModule = cjsParseCache.get(cachedModule);
      if (!parseCachedModule || parseCachedModule.loaded)
        return getExportsForCircularRequire(cachedModule);
      parseCachedModule.loaded = true;
    } else {
      return cachedModule.exports;
    }
  }

  const mod = loadNativeModule(filename, request);
  if (mod?.canBeRequiredByUsers) return mod.exports;

  // Don't call updateChildren(), Module constructor already does.
  const module = cachedModule || new Module(filename, parent);

diff --git a/a.js b/b.js
@@ -57,6 +57,7 @@ require('internal/process/policy') :
A blob:59d3bc1723e074d99240be7c688406ce22176f8f
  Stats,
} = require('fs');
const { getOptionValue } = require('internal/options');
// Do not eagerly grab .manifest, it may be in TDZ
const policy = getOptionValue('--experimental-policy') ?
  require('internal/process/policy') :
  null;
const { sep, relative, resolve } = require('path');
const preserveSymlinks = getOptionValue('--preserve-symlinks');
const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');
const experimentalNetworkImports =
  getOptionValue('--experimental-network-imports');
const typeFlag = getOptionValue('--input-type');
const { URL, pathToFileURL, fileURLToPath } = require('internal/url');
const {
  ERR_INPUT_TYPE_NOT_ALLOWED,
  ERR_INVALID_ARG_VALUE,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MANIFEST_DEPENDENCY_MISSING,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_UNSUPPORTED_ESM_URL_SCHEME,
} = require('internal/errors').codes;
const { Module: CJSModule } = require('internal/modules/cjs/loader');

diff --git a/a.js b/b.js
@@ -363,7 +364,6 @@ function resolveDirectoryEntry(search) {
A blob:59d3bc1723e074d99240be7c688406ce22176f8f

/**
 * @param {URL} search
 * @returns {URL | undefined}
 */
function resolveDirectoryEntry(search) {
  const dirPath = fileURLToPath(search);
  const pkgJsonPath = resolve(dirPath, 'package.json');
  if (fileExists(pkgJsonPath)) {
    const pkgJson = packageJsonReader.read(pkgJsonPath);
    if (pkgJson.containsKeys) {
      const { main } = JSONParse(pkgJson.string);
      if (main != null) {
        const mainUrl = pathToFileURL(resolve(dirPath, main));
        return resolveExtensionsWithTryExactName(mainUrl);
      }
    }
  }
  return resolveExtensions(new URL('index', search));
}

const encodedSepRegEx = /%2F|%5C/i;
let experimentalSpecifierResolutionWarned = false;
/**
 * @param {URL} resolved
 * @param {string | URL | undefined} base
 * @param {boolean} preserveSymlinks
diff --git a/a.js b/b.js
@@ -378,13 +378,6 @@ function finalizeResolution(resolved, base, preserveSymlinks) {
A blob:59d3bc1723e074d99240be7c688406ce22176f8f
 * @param {URL} resolved
 * @param {string | URL | undefined} base
 * @param {boolean} preserveSymlinks
 * @returns {URL | undefined}
 */
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname, 'must not include encoded "/" or "\\" characters',
      fileURLToPath(base));

  let path = fileURLToPath(resolved);
  if (getOptionValue('--experimental-specifier-resolution') === 'node') {
    if (!experimentalSpecifierResolutionWarned) {
      process.emitWarning(
        'The Node.js specifier resolution flag is experimental. It could change or be removed at any time.',
        'ExperimentalWarning');
      experimentalSpecifierResolutionWarned = true;
    }

    let file = resolveExtensionsWithTryExactName(resolved);

    // Directory
    if (file === undefined) {
diff --git a/a.js b/b.js
@@ -860,8 +853,13 @@ function parsePackageName(specifier, base) {
A blob:59d3bc1723e074d99240be7c688406ce22176f8f
/**
 * @param {string} specifier
 * @param {string | URL | undefined} base
 * @returns {{ packageName: string, packageSubpath: string, isScoped: boolean }}
 */
function parsePackageName(specifier, base) {
  let separatorIndex = StringPrototypeIndexOf(specifier, '/');
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === '@') {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = StringPrototypeIndexOf(
        specifier, '/', separatorIndex + 1);
    }
  }

  const packageName = separatorIndex === -1 ?
    specifier : StringPrototypeSlice(specifier, 0, separatorIndex);

  // Package name cannot have leading . and cannot have percent-encoding or
  // \\ separators.
  if (RegExpPrototypeExec(invalidPackageNameRegEx, packageName) !== null)
    validPackageName = false;

  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier, 'is not a valid package name', fileURLToPath(base));
  }

  const packageSubpath = '.' + (separatorIndex === -1 ? '' :
    StringPrototypeSlice(specifier, separatorIndex));

  return { packageName, packageSubpath, isScoped };
}

/**
 * @param {string} specifier
 * @param {string | URL | undefined} base
 * @param {Set<string>} conditions
 * @returns {resolved: URL, format? : string}
 */
function packageResolve(specifier, base, conditions) {
  if (NativeModule.canBeRequiredByUsers(specifier))
    return new URL('node:' + specifier);

  const { packageName, packageSubpath, isScoped } =
    parsePackageName(specifier, base);

diff --git a/a.js b/b.js
@@ -100,6 +100,7 @@
A blob:eb9152d9ce02661a0aa19eb8283af66642b591c1
  StringPrototypeTrimLeft,
  Symbol,
  SyntaxError,
  SyntaxErrorPrototype,
  globalThis,
} = primordials;

const {
  makeRequireFunction,
  addBuiltinLibsToObject
} = require('internal/modules/cjs/helpers');
diff --git a/a.js b/b.js
@@ -129,6 +130,10 @@
A blob:eb9152d9ce02661a0aa19eb8283af66642b591c1
const CJSModule = require('internal/modules/cjs/loader').Module;
let _builtinLibs = ArrayPrototypeFilter(
  CJSModule.builtinModules,
  (e) => !StringPrototypeStartsWith(e, '_'),
);
const nodeSchemeBuiltinLibs = ArrayPrototypeMap(
  _builtinLibs, (lib) => `node:${lib}`);
const domain = require('domain');
let debug = require('internal/util/debuglog').debuglog('repl', (fn) => {
  debug = fn;
});
diff --git a/a.js b/b.js
@@ -16,7 +16,7 @@
A blob:1b151e269dcfaf1035ad861b8ed86bea2061582d
} = require('internal/test/binding');
const {
  getCacheUsage,
  moduleCategories: { canBeRequired, cannotBeRequired }
} = internalBinding('native_module');

for (const key of canBeRequired) {
  require(key);
}

// The computation has to be delayed until we have done loading modules
const {
diff --git a/a.js b/b.js
@@ -53,14 +53,18 @@ assert(modules.includes(newModule) &&
A blob:1968caa5accf5446cc105de3f241000380c4dcb4
  const newModule = 'foobar';
  assert(!builtinModules.includes(newModule));
  repl.builtinModules.push(newModule);
  testMe.complete('import(\'', common.mustCall((_, [modules]) => {
    assert.strictEqual(data[0].length + 1, modules.length);
    assert(modules.includes(newModule) &&
      !modules.includes(`node:${newModule}`));
  }));
}));

testMe.complete("import\t( 'n", common.mustCall((error, data) => {
  assert.strictEqual(error, null);
  assert.strictEqual(data.length, 2);
  assert.strictEqual(data[1], 'n');
  const completions = data[0];
  // import(...) completions include `node:` URL modules:
  publicModules.forEach((lib, index) =>
    assert.strictEqual(completions[index], `node:${lib}`));
  assert.strictEqual(completions[publicModules.length], '');
  // There is only one Node.js module that starts with n:
  assert.strictEqual(completions[publicModules.length + 1], 'net');
  assert.strictEqual(completions[publicModules.length + 2], '');
  // It's possible to pick up non-core modules too
  completions.slice(publicModules.length + 3).forEach((completion) => {
    assert.match(completion, /^n/);
  });
}));

diff --git a/a.js b/b.js
@@ -261,14 +261,18 @@ assert(
A blob:270fb768b030cf0aa8bda44cd7919b04cd7e882c
  const newModule = 'foobar';
  assert(!builtinModules.includes(newModule));
  repl.builtinModules.push(newModule);
  testMe.complete('require(\'', common.mustCall((_, [modules]) => {
    assert.strictEqual(data[0].length + 1, modules.length);
    assert(modules.includes(newModule));
  }));
}));

testMe.complete("require\t( 'n", common.mustCall(function(error, data) {
  assert.strictEqual(error, null);
  assert.strictEqual(data.length, 2);
  assert.strictEqual(data[1], 'n');
  // require(...) completions include `node:`-prefixed modules:
  publicModules.forEach((lib, index) =>
    assert.strictEqual(data[0][index], `node:${lib}`));
  assert.strictEqual(data[0][publicModules.length], '');
  // There is only one Node.js module that starts with n:
  assert.strictEqual(data[0][publicModules.length + 1], 'net');
  assert.strictEqual(data[0][publicModules.length + 2], '');
  // It's possible to pick up non-core modules too
  data[0].slice(publicModules.length + 3).forEach((completion) => {
    assert.match(completion, /^n/);
  });
}));

diff --git a/a.js b/b.js
@@ -1544,6 +1544,18 @@ E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT',
A blob:dce159b94cc19836850edab9d81d5352231f864d
E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);
E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);
E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);
E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);
E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT',
  'stream.unshift() after end event', Error);
E('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode', Error);
E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);
E('ERR_SYNTHETIC', 'JavaScript Callstack', Error);
E('ERR_SYSTEM_ERROR', 'A system error occurred', SystemError);
E('ERR_TLS_CERT_ALTNAME_FORMAT', 'Invalid subject alternative name string',
  SyntaxError);
E('ERR_TLS_CERT_ALTNAME_INVALID', function(reason, host, cert) {
  this.reason = reason;
diff --git a/a.js b/b.js
@@ -326,14 +326,10 @@ function promiseInitHookWithDestroyTracking(promise, parent) {
A blob:f15fe5cc99b5c4782fb4c718d116abc0b0cd4aae
  const asyncId = promise[async_id_symbol];
  const triggerAsyncId = promise[trigger_async_id_symbol];
  emitInitScript(asyncId, 'PROMISE', triggerAsyncId, promise);
}

function promiseInitHookWithDestroyTracking(promise, parent) {
  promiseInitHook(promise, parent);
  destroyTracking(promise, parent);
}

const destroyedSymbol = Symbol('destroyed');

function destroyTracking(promise, parent) {
  trackPromise(promise, parent);
  const asyncId = promise[async_id_symbol];
  const destroyed = { destroyed: false };
  promise[destroyedSymbol] = destroyed;
  registerDestroyHook(promise, asyncId, destroyed);
}

function promiseBeforeHook(promise) {
  trackPromise(promise);
diff --git a/a.js b/b.js
@@ -96,10 +96,9 @@
A blob:3749895769ffc9947143aee9aeb126628262bc84
  if (common.hasFipsCrypto && test.iv.length < 24) {
    common.printSkipMessage('IV len < 12 bytes unsupported in FIPS mode');
    continue;
  }

  const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);
  const isOCB = /^aes-(128|192|256)-ocb$/.test(test.algo);
  const isChacha20Poly1305 = test.algo === 'chacha20-poly1305';

  let options;
  if (isCCM || isOCB || isChacha20Poly1305)
    options = { authTagLength: test.tag.length / 2 };

  const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';

diff --git a/a.js b/b.js
@@ -659,8 +658,7 @@
A blob:3749895769ffc9947143aee9aeb126628262bc84
  check(17);

  function check(ivLength) {
    const prefix = ivLength - valid.iv.length / 2;
    assert.throws(() => crypto.createCipheriv(
      valid.algo,
      Buffer.from(valid.key, 'hex'),
      Buffer.from(H(prefix) + valid.iv, 'hex'),
      { authTagLength: valid.tag.length / 2 }
    ), errMessages.length, `iv length ${ivLength} was not rejected`);

    function H(length) { return '00'.repeat(length); }
  }
diff --git a/a.js b/b.js
@@ -701,3 +699,90 @@
A blob:3749895769ffc9947143aee9aeb126628262bc84
      crypto.createCipheriv('chacha20-poly1305', key, iv, { authTagLength });
    }, {
      code: 'ERR_CRYPTO_INVALID_AUTH_TAG',
      message: errMessages.authTagLength
    });
  }
}

diff --git a/a.js b/b.js
@@ -44,7 +44,7 @@
A blob:21c5af6cfe3e5eef64fc2d4dcc63c55b1d79ad51
const TEST_CASES = require(fixtures.path('aead-vectors.js'));

const errMessages = {
  auth: / auth/,
  state: / state/,
  FIPS: /not supported in FIPS mode/,
  length: /Invalid initialization vector/,
  authTagLength: /Invalid authentication tag/
};

const ciphers = crypto.getCiphers();

diff --git a/a.js b/b.js
@@ -96,10 +96,9 @@
A blob:21c5af6cfe3e5eef64fc2d4dcc63c55b1d79ad51
  if (common.hasFipsCrypto && test.iv.length < 24) {
    common.printSkipMessage('IV len < 12 bytes unsupported in FIPS mode');
    continue;
  }

  const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);
  const isOCB = /^aes-(128|192|256)-ocb$/.test(test.algo);
  const isChacha20Poly1305 = test.algo === 'chacha20-poly1305';

  let options;
  if (isCCM || isOCB || isChacha20Poly1305)
    options = { authTagLength: test.tag.length / 2 };

  const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';

diff --git a/a.js b/b.js
@@ -659,8 +658,7 @@
A blob:21c5af6cfe3e5eef64fc2d4dcc63c55b1d79ad51
  check(17);

  function check(ivLength) {
    const prefix = ivLength - valid.iv.length / 2;
    assert.throws(() => crypto.createCipheriv(
      valid.algo,
      Buffer.from(valid.key, 'hex'),
      Buffer.from(H(prefix) + valid.iv, 'hex'),
      { authTagLength: valid.tag.length / 2 }
    ), errMessages.length, `iv length ${ivLength} was not rejected`);

    function H(length) { return '00'.repeat(length); }
  }
diff --git a/a.js b/b.js
@@ -687,3 +685,104 @@
A blob:21c5af6cfe3e5eef64fc2d4dcc63c55b1d79ad51
    }, common.hasOpenSSL3 ? {
      code: 'ERR_OSSL_TAG_NOT_SET'
    } : {
      message: /Unsupported state/
    });
  }
}

